const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./DefaultLayout-D9cihayI.js","./CContainer-CopZpwLe.js","./DefaultLayout-CUaJ4U48.css","./Register-Dpam4VvG.js","./CRow-Bb3xtpYK.js","./CCardBody-CanmQiUv.js","./Page404-Bjcm-ULf.js","./cil-magnifying-glass-DQABYMt8.js","./Page500-bTRzm0I-.js"])))=>i.map(i=>d[i]);
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
function _mergeNamespaces(n2, m2) {
  for (var i = 0; i < m2.length; i++) {
    const e2 = m2[i];
    if (typeof e2 !== "string" && !Array.isArray(e2)) {
      for (const k2 in e2) {
        if (k2 !== "default" && !(k2 in n2)) {
          const d2 = Object.getOwnPropertyDescriptor(e2, k2);
          if (d2) {
            Object.defineProperty(n2, k2, d2.get ? d2 : {
              enumerable: true,
              get: () => e2[k2]
            });
          }
        }
      }
    }
  }
  return Object.freeze(Object.defineProperty(n2, Symbol.toStringTag, { value: "Module" }));
}
(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link2 of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link2);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node2 of mutation.addedNodes) {
        if (node2.tagName === "LINK" && node2.rel === "modulepreload")
          processPreload(node2);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(link2) {
    const fetchOpts = {};
    if (link2.integrity) fetchOpts.integrity = link2.integrity;
    if (link2.referrerPolicy) fetchOpts.referrerPolicy = link2.referrerPolicy;
    if (link2.crossOrigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (link2.crossOrigin === "anonymous") fetchOpts.credentials = "omit";
    else fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link2) {
    if (link2.ep)
      return;
    link2.ep = true;
    const fetchOpts = getFetchOpts(link2);
    fetch(link2.href, fetchOpts);
  }
})();
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs$2(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function getAugmentedNamespace(n2) {
  if (n2.__esModule) return n2;
  var f2 = n2.default;
  if (typeof f2 == "function") {
    var a = function a2() {
      if (this instanceof a2) {
        return Reflect.construct(f2, arguments, this.constructor);
      }
      return f2.apply(this, arguments);
    };
    a.prototype = f2.prototype;
  } else a = {};
  Object.defineProperty(a, "__esModule", { value: true });
  Object.keys(n2).forEach(function(k2) {
    var d2 = Object.getOwnPropertyDescriptor(n2, k2);
    Object.defineProperty(a, k2, d2.get ? d2 : {
      enumerable: true,
      get: function() {
        return n2[k2];
      }
    });
  });
  return a;
}
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production_min = {};
var react = { exports: {} };
var react_production_min = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var l$2 = Symbol.for("react.element"), n$2 = Symbol.for("react.portal"), p$3 = Symbol.for("react.fragment"), q$2 = Symbol.for("react.strict_mode"), r$2 = Symbol.for("react.profiler"), t$1 = Symbol.for("react.provider"), u = Symbol.for("react.context"), v$2 = Symbol.for("react.forward_ref"), w$1 = Symbol.for("react.suspense"), x$1 = Symbol.for("react.memo"), y$1 = Symbol.for("react.lazy"), z$2 = Symbol.iterator;
function A$2(a) {
  if (null === a || "object" !== typeof a) return null;
  a = z$2 && a[z$2] || a["@@iterator"];
  return "function" === typeof a ? a : null;
}
var B$1 = { isMounted: function() {
  return false;
}, enqueueForceUpdate: function() {
}, enqueueReplaceState: function() {
}, enqueueSetState: function() {
} }, C$1 = Object.assign, D$1 = {};
function E$3(a, b2, e2) {
  this.props = a;
  this.context = b2;
  this.refs = D$1;
  this.updater = e2 || B$1;
}
E$3.prototype.isReactComponent = {};
E$3.prototype.setState = function(a, b2) {
  if ("object" !== typeof a && "function" !== typeof a && null != a) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
  this.updater.enqueueSetState(this, a, b2, "setState");
};
E$3.prototype.forceUpdate = function(a) {
  this.updater.enqueueForceUpdate(this, a, "forceUpdate");
};
function F() {
}
F.prototype = E$3.prototype;
function G$1(a, b2, e2) {
  this.props = a;
  this.context = b2;
  this.refs = D$1;
  this.updater = e2 || B$1;
}
var H$1 = G$1.prototype = new F();
H$1.constructor = G$1;
C$1(H$1, E$3.prototype);
H$1.isPureReactComponent = true;
var I$1 = Array.isArray, J = Object.prototype.hasOwnProperty, K$1 = { current: null }, L$1 = { key: true, ref: true, __self: true, __source: true };
function M$1(a, b2, e2) {
  var d2, c2 = {}, k2 = null, h2 = null;
  if (null != b2) for (d2 in void 0 !== b2.ref && (h2 = b2.ref), void 0 !== b2.key && (k2 = "" + b2.key), b2) J.call(b2, d2) && !L$1.hasOwnProperty(d2) && (c2[d2] = b2[d2]);
  var g2 = arguments.length - 2;
  if (1 === g2) c2.children = e2;
  else if (1 < g2) {
    for (var f2 = Array(g2), m2 = 0; m2 < g2; m2++) f2[m2] = arguments[m2 + 2];
    c2.children = f2;
  }
  if (a && a.defaultProps) for (d2 in g2 = a.defaultProps, g2) void 0 === c2[d2] && (c2[d2] = g2[d2]);
  return { $$typeof: l$2, type: a, key: k2, ref: h2, props: c2, _owner: K$1.current };
}
function N$1(a, b2) {
  return { $$typeof: l$2, type: a.type, key: b2, ref: a.ref, props: a.props, _owner: a._owner };
}
function O$1(a) {
  return "object" === typeof a && null !== a && a.$$typeof === l$2;
}
function escape(a) {
  var b2 = { "=": "=0", ":": "=2" };
  return "$" + a.replace(/[=:]/g, function(a2) {
    return b2[a2];
  });
}
var P$1 = /\/+/g;
function Q$1(a, b2) {
  return "object" === typeof a && null !== a && null != a.key ? escape("" + a.key) : b2.toString(36);
}
function R$1(a, b2, e2, d2, c2) {
  var k2 = typeof a;
  if ("undefined" === k2 || "boolean" === k2) a = null;
  var h2 = false;
  if (null === a) h2 = true;
  else switch (k2) {
    case "string":
    case "number":
      h2 = true;
      break;
    case "object":
      switch (a.$$typeof) {
        case l$2:
        case n$2:
          h2 = true;
      }
  }
  if (h2) return h2 = a, c2 = c2(h2), a = "" === d2 ? "." + Q$1(h2, 0) : d2, I$1(c2) ? (e2 = "", null != a && (e2 = a.replace(P$1, "$&/") + "/"), R$1(c2, b2, e2, "", function(a2) {
    return a2;
  })) : null != c2 && (O$1(c2) && (c2 = N$1(c2, e2 + (!c2.key || h2 && h2.key === c2.key ? "" : ("" + c2.key).replace(P$1, "$&/") + "/") + a)), b2.push(c2)), 1;
  h2 = 0;
  d2 = "" === d2 ? "." : d2 + ":";
  if (I$1(a)) for (var g2 = 0; g2 < a.length; g2++) {
    k2 = a[g2];
    var f2 = d2 + Q$1(k2, g2);
    h2 += R$1(k2, b2, e2, f2, c2);
  }
  else if (f2 = A$2(a), "function" === typeof f2) for (a = f2.call(a), g2 = 0; !(k2 = a.next()).done; ) k2 = k2.value, f2 = d2 + Q$1(k2, g2++), h2 += R$1(k2, b2, e2, f2, c2);
  else if ("object" === k2) throw b2 = String(a), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b2 ? "object with keys {" + Object.keys(a).join(", ") + "}" : b2) + "). If you meant to render a collection of children, use an array instead.");
  return h2;
}
function S$1(a, b2, e2) {
  if (null == a) return a;
  var d2 = [], c2 = 0;
  R$1(a, d2, "", "", function(a2) {
    return b2.call(e2, a2, c2++);
  });
  return d2;
}
function T$1(a) {
  if (-1 === a._status) {
    var b2 = a._result;
    b2 = b2();
    b2.then(function(b3) {
      if (0 === a._status || -1 === a._status) a._status = 1, a._result = b3;
    }, function(b3) {
      if (0 === a._status || -1 === a._status) a._status = 2, a._result = b3;
    });
    -1 === a._status && (a._status = 0, a._result = b2);
  }
  if (1 === a._status) return a._result.default;
  throw a._result;
}
var U$1 = { current: null }, V$1 = { transition: null }, W$1 = { ReactCurrentDispatcher: U$1, ReactCurrentBatchConfig: V$1, ReactCurrentOwner: K$1 };
function X$1() {
  throw Error("act(...) is not supported in production builds of React.");
}
react_production_min.Children = { map: S$1, forEach: function(a, b2, e2) {
  S$1(a, function() {
    b2.apply(this, arguments);
  }, e2);
}, count: function(a) {
  var b2 = 0;
  S$1(a, function() {
    b2++;
  });
  return b2;
}, toArray: function(a) {
  return S$1(a, function(a2) {
    return a2;
  }) || [];
}, only: function(a) {
  if (!O$1(a)) throw Error("React.Children.only expected to receive a single React element child.");
  return a;
} };
react_production_min.Component = E$3;
react_production_min.Fragment = p$3;
react_production_min.Profiler = r$2;
react_production_min.PureComponent = G$1;
react_production_min.StrictMode = q$2;
react_production_min.Suspense = w$1;
react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W$1;
react_production_min.act = X$1;
react_production_min.cloneElement = function(a, b2, e2) {
  if (null === a || void 0 === a) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a + ".");
  var d2 = C$1({}, a.props), c2 = a.key, k2 = a.ref, h2 = a._owner;
  if (null != b2) {
    void 0 !== b2.ref && (k2 = b2.ref, h2 = K$1.current);
    void 0 !== b2.key && (c2 = "" + b2.key);
    if (a.type && a.type.defaultProps) var g2 = a.type.defaultProps;
    for (f2 in b2) J.call(b2, f2) && !L$1.hasOwnProperty(f2) && (d2[f2] = void 0 === b2[f2] && void 0 !== g2 ? g2[f2] : b2[f2]);
  }
  var f2 = arguments.length - 2;
  if (1 === f2) d2.children = e2;
  else if (1 < f2) {
    g2 = Array(f2);
    for (var m2 = 0; m2 < f2; m2++) g2[m2] = arguments[m2 + 2];
    d2.children = g2;
  }
  return { $$typeof: l$2, type: a.type, key: c2, ref: k2, props: d2, _owner: h2 };
};
react_production_min.createContext = function(a) {
  a = { $$typeof: u, _currentValue: a, _currentValue2: a, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
  a.Provider = { $$typeof: t$1, _context: a };
  return a.Consumer = a;
};
react_production_min.createElement = M$1;
react_production_min.createFactory = function(a) {
  var b2 = M$1.bind(null, a);
  b2.type = a;
  return b2;
};
react_production_min.createRef = function() {
  return { current: null };
};
react_production_min.forwardRef = function(a) {
  return { $$typeof: v$2, render: a };
};
react_production_min.isValidElement = O$1;
react_production_min.lazy = function(a) {
  return { $$typeof: y$1, _payload: { _status: -1, _result: a }, _init: T$1 };
};
react_production_min.memo = function(a, b2) {
  return { $$typeof: x$1, type: a, compare: void 0 === b2 ? null : b2 };
};
react_production_min.startTransition = function(a) {
  var b2 = V$1.transition;
  V$1.transition = {};
  try {
    a();
  } finally {
    V$1.transition = b2;
  }
};
react_production_min.unstable_act = X$1;
react_production_min.useCallback = function(a, b2) {
  return U$1.current.useCallback(a, b2);
};
react_production_min.useContext = function(a) {
  return U$1.current.useContext(a);
};
react_production_min.useDebugValue = function() {
};
react_production_min.useDeferredValue = function(a) {
  return U$1.current.useDeferredValue(a);
};
react_production_min.useEffect = function(a, b2) {
  return U$1.current.useEffect(a, b2);
};
react_production_min.useId = function() {
  return U$1.current.useId();
};
react_production_min.useImperativeHandle = function(a, b2, e2) {
  return U$1.current.useImperativeHandle(a, b2, e2);
};
react_production_min.useInsertionEffect = function(a, b2) {
  return U$1.current.useInsertionEffect(a, b2);
};
react_production_min.useLayoutEffect = function(a, b2) {
  return U$1.current.useLayoutEffect(a, b2);
};
react_production_min.useMemo = function(a, b2) {
  return U$1.current.useMemo(a, b2);
};
react_production_min.useReducer = function(a, b2, e2) {
  return U$1.current.useReducer(a, b2, e2);
};
react_production_min.useRef = function(a) {
  return U$1.current.useRef(a);
};
react_production_min.useState = function(a) {
  return U$1.current.useState(a);
};
react_production_min.useSyncExternalStore = function(a, b2, e2) {
  return U$1.current.useSyncExternalStore(a, b2, e2);
};
react_production_min.useTransition = function() {
  return U$1.current.useTransition();
};
react_production_min.version = "18.3.1";
{
  react.exports = react_production_min;
}
var reactExports = react.exports;
const React$1 = /* @__PURE__ */ getDefaultExportFromCjs$2(reactExports);
const React$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: React$1
}, [reactExports]);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var f$1 = reactExports, k$1 = Symbol.for("react.element"), l$1 = Symbol.for("react.fragment"), m$2 = Object.prototype.hasOwnProperty, n$1 = f$1.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p$2 = { key: true, ref: true, __self: true, __source: true };
function q$1(c2, a, g2) {
  var b2, d2 = {}, e2 = null, h2 = null;
  void 0 !== g2 && (e2 = "" + g2);
  void 0 !== a.key && (e2 = "" + a.key);
  void 0 !== a.ref && (h2 = a.ref);
  for (b2 in a) m$2.call(a, b2) && !p$2.hasOwnProperty(b2) && (d2[b2] = a[b2]);
  if (c2 && c2.defaultProps) for (b2 in a = c2.defaultProps, a) void 0 === d2[b2] && (d2[b2] = a[b2]);
  return { $$typeof: k$1, type: c2, key: e2, ref: h2, props: d2, _owner: n$1.current };
}
reactJsxRuntime_production_min.Fragment = l$1;
reactJsxRuntime_production_min.jsx = q$1;
reactJsxRuntime_production_min.jsxs = q$1;
{
  jsxRuntime.exports = reactJsxRuntime_production_min;
}
var jsxRuntimeExports = jsxRuntime.exports;
var reactDom = { exports: {} };
var reactDom_production_min = {};
var scheduler = { exports: {} };
var scheduler_production_min = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(exports) {
  function f2(a, b2) {
    var c2 = a.length;
    a.push(b2);
    a: for (; 0 < c2; ) {
      var d2 = c2 - 1 >>> 1, e2 = a[d2];
      if (0 < g2(e2, b2)) a[d2] = b2, a[c2] = e2, c2 = d2;
      else break a;
    }
  }
  function h2(a) {
    return 0 === a.length ? null : a[0];
  }
  function k2(a) {
    if (0 === a.length) return null;
    var b2 = a[0], c2 = a.pop();
    if (c2 !== b2) {
      a[0] = c2;
      a: for (var d2 = 0, e2 = a.length, w2 = e2 >>> 1; d2 < w2; ) {
        var m2 = 2 * (d2 + 1) - 1, C2 = a[m2], n2 = m2 + 1, x2 = a[n2];
        if (0 > g2(C2, c2)) n2 < e2 && 0 > g2(x2, C2) ? (a[d2] = x2, a[n2] = c2, d2 = n2) : (a[d2] = C2, a[m2] = c2, d2 = m2);
        else if (n2 < e2 && 0 > g2(x2, c2)) a[d2] = x2, a[n2] = c2, d2 = n2;
        else break a;
      }
    }
    return b2;
  }
  function g2(a, b2) {
    var c2 = a.sortIndex - b2.sortIndex;
    return 0 !== c2 ? c2 : a.id - b2.id;
  }
  if ("object" === typeof performance && "function" === typeof performance.now) {
    var l2 = performance;
    exports.unstable_now = function() {
      return l2.now();
    };
  } else {
    var p2 = Date, q2 = p2.now();
    exports.unstable_now = function() {
      return p2.now() - q2;
    };
  }
  var r2 = [], t2 = [], u2 = 1, v2 = null, y2 = 3, z2 = false, A2 = false, B2 = false, D2 = "function" === typeof setTimeout ? setTimeout : null, E2 = "function" === typeof clearTimeout ? clearTimeout : null, F2 = "undefined" !== typeof setImmediate ? setImmediate : null;
  "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function G2(a) {
    for (var b2 = h2(t2); null !== b2; ) {
      if (null === b2.callback) k2(t2);
      else if (b2.startTime <= a) k2(t2), b2.sortIndex = b2.expirationTime, f2(r2, b2);
      else break;
      b2 = h2(t2);
    }
  }
  function H2(a) {
    B2 = false;
    G2(a);
    if (!A2) if (null !== h2(r2)) A2 = true, I2(J2);
    else {
      var b2 = h2(t2);
      null !== b2 && K2(H2, b2.startTime - a);
    }
  }
  function J2(a, b2) {
    A2 = false;
    B2 && (B2 = false, E2(L2), L2 = -1);
    z2 = true;
    var c2 = y2;
    try {
      G2(b2);
      for (v2 = h2(r2); null !== v2 && (!(v2.expirationTime > b2) || a && !M2()); ) {
        var d2 = v2.callback;
        if ("function" === typeof d2) {
          v2.callback = null;
          y2 = v2.priorityLevel;
          var e2 = d2(v2.expirationTime <= b2);
          b2 = exports.unstable_now();
          "function" === typeof e2 ? v2.callback = e2 : v2 === h2(r2) && k2(r2);
          G2(b2);
        } else k2(r2);
        v2 = h2(r2);
      }
      if (null !== v2) var w2 = true;
      else {
        var m2 = h2(t2);
        null !== m2 && K2(H2, m2.startTime - b2);
        w2 = false;
      }
      return w2;
    } finally {
      v2 = null, y2 = c2, z2 = false;
    }
  }
  var N2 = false, O2 = null, L2 = -1, P2 = 5, Q2 = -1;
  function M2() {
    return exports.unstable_now() - Q2 < P2 ? false : true;
  }
  function R2() {
    if (null !== O2) {
      var a = exports.unstable_now();
      Q2 = a;
      var b2 = true;
      try {
        b2 = O2(true, a);
      } finally {
        b2 ? S2() : (N2 = false, O2 = null);
      }
    } else N2 = false;
  }
  var S2;
  if ("function" === typeof F2) S2 = function() {
    F2(R2);
  };
  else if ("undefined" !== typeof MessageChannel) {
    var T2 = new MessageChannel(), U2 = T2.port2;
    T2.port1.onmessage = R2;
    S2 = function() {
      U2.postMessage(null);
    };
  } else S2 = function() {
    D2(R2, 0);
  };
  function I2(a) {
    O2 = a;
    N2 || (N2 = true, S2());
  }
  function K2(a, b2) {
    L2 = D2(function() {
      a(exports.unstable_now());
    }, b2);
  }
  exports.unstable_IdlePriority = 5;
  exports.unstable_ImmediatePriority = 1;
  exports.unstable_LowPriority = 4;
  exports.unstable_NormalPriority = 3;
  exports.unstable_Profiling = null;
  exports.unstable_UserBlockingPriority = 2;
  exports.unstable_cancelCallback = function(a) {
    a.callback = null;
  };
  exports.unstable_continueExecution = function() {
    A2 || z2 || (A2 = true, I2(J2));
  };
  exports.unstable_forceFrameRate = function(a) {
    0 > a || 125 < a ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P2 = 0 < a ? Math.floor(1e3 / a) : 5;
  };
  exports.unstable_getCurrentPriorityLevel = function() {
    return y2;
  };
  exports.unstable_getFirstCallbackNode = function() {
    return h2(r2);
  };
  exports.unstable_next = function(a) {
    switch (y2) {
      case 1:
      case 2:
      case 3:
        var b2 = 3;
        break;
      default:
        b2 = y2;
    }
    var c2 = y2;
    y2 = b2;
    try {
      return a();
    } finally {
      y2 = c2;
    }
  };
  exports.unstable_pauseExecution = function() {
  };
  exports.unstable_requestPaint = function() {
  };
  exports.unstable_runWithPriority = function(a, b2) {
    switch (a) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        a = 3;
    }
    var c2 = y2;
    y2 = a;
    try {
      return b2();
    } finally {
      y2 = c2;
    }
  };
  exports.unstable_scheduleCallback = function(a, b2, c2) {
    var d2 = exports.unstable_now();
    "object" === typeof c2 && null !== c2 ? (c2 = c2.delay, c2 = "number" === typeof c2 && 0 < c2 ? d2 + c2 : d2) : c2 = d2;
    switch (a) {
      case 1:
        var e2 = -1;
        break;
      case 2:
        e2 = 250;
        break;
      case 5:
        e2 = 1073741823;
        break;
      case 4:
        e2 = 1e4;
        break;
      default:
        e2 = 5e3;
    }
    e2 = c2 + e2;
    a = { id: u2++, callback: b2, priorityLevel: a, startTime: c2, expirationTime: e2, sortIndex: -1 };
    c2 > d2 ? (a.sortIndex = c2, f2(t2, a), null === h2(r2) && a === h2(t2) && (B2 ? (E2(L2), L2 = -1) : B2 = true, K2(H2, c2 - d2))) : (a.sortIndex = e2, f2(r2, a), A2 || z2 || (A2 = true, I2(J2)));
    return a;
  };
  exports.unstable_shouldYield = M2;
  exports.unstable_wrapCallback = function(a) {
    var b2 = y2;
    return function() {
      var c2 = y2;
      y2 = b2;
      try {
        return a.apply(this, arguments);
      } finally {
        y2 = c2;
      }
    };
  };
})(scheduler_production_min);
{
  scheduler.exports = scheduler_production_min;
}
var schedulerExports = scheduler.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var aa = reactExports, ca = schedulerExports;
function p$1(a) {
  for (var b2 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c2 = 1; c2 < arguments.length; c2++) b2 += "&args[]=" + encodeURIComponent(arguments[c2]);
  return "Minified React error #" + a + "; visit " + b2 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
var da = /* @__PURE__ */ new Set(), ea = {};
function fa(a, b2) {
  ha(a, b2);
  ha(a + "Capture", b2);
}
function ha(a, b2) {
  ea[a] = b2;
  for (a = 0; a < b2.length; a++) da.add(b2[a]);
}
var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ja = Object.prototype.hasOwnProperty, ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la = {}, ma = {};
function oa(a) {
  if (ja.call(ma, a)) return true;
  if (ja.call(la, a)) return false;
  if (ka.test(a)) return ma[a] = true;
  la[a] = true;
  return false;
}
function pa(a, b2, c2, d2) {
  if (null !== c2 && 0 === c2.type) return false;
  switch (typeof b2) {
    case "function":
    case "symbol":
      return true;
    case "boolean":
      if (d2) return false;
      if (null !== c2) return !c2.acceptsBooleans;
      a = a.toLowerCase().slice(0, 5);
      return "data-" !== a && "aria-" !== a;
    default:
      return false;
  }
}
function qa(a, b2, c2, d2) {
  if (null === b2 || "undefined" === typeof b2 || pa(a, b2, c2, d2)) return true;
  if (d2) return false;
  if (null !== c2) switch (c2.type) {
    case 3:
      return !b2;
    case 4:
      return false === b2;
    case 5:
      return isNaN(b2);
    case 6:
      return isNaN(b2) || 1 > b2;
  }
  return false;
}
function v$1(a, b2, c2, d2, e2, f2, g2) {
  this.acceptsBooleans = 2 === b2 || 3 === b2 || 4 === b2;
  this.attributeName = d2;
  this.attributeNamespace = e2;
  this.mustUseProperty = c2;
  this.propertyName = a;
  this.type = b2;
  this.sanitizeURL = f2;
  this.removeEmptyString = g2;
}
var z$1 = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a) {
  z$1[a] = new v$1(a, 0, false, a, null, false, false);
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a) {
  var b2 = a[0];
  z$1[b2] = new v$1(b2, 1, false, a[1], null, false, false);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a) {
  z$1[a] = new v$1(a, 2, false, a.toLowerCase(), null, false, false);
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a) {
  z$1[a] = new v$1(a, 2, false, a, null, false, false);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a) {
  z$1[a] = new v$1(a, 3, false, a.toLowerCase(), null, false, false);
});
["checked", "multiple", "muted", "selected"].forEach(function(a) {
  z$1[a] = new v$1(a, 3, true, a, null, false, false);
});
["capture", "download"].forEach(function(a) {
  z$1[a] = new v$1(a, 4, false, a, null, false, false);
});
["cols", "rows", "size", "span"].forEach(function(a) {
  z$1[a] = new v$1(a, 6, false, a, null, false, false);
});
["rowSpan", "start"].forEach(function(a) {
  z$1[a] = new v$1(a, 5, false, a.toLowerCase(), null, false, false);
});
var ra = /[\-:]([a-z])/g;
function sa(a) {
  return a[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a) {
  var b2 = a.replace(
    ra,
    sa
  );
  z$1[b2] = new v$1(b2, 1, false, a, null, false, false);
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a) {
  var b2 = a.replace(ra, sa);
  z$1[b2] = new v$1(b2, 1, false, a, "http://www.w3.org/1999/xlink", false, false);
});
["xml:base", "xml:lang", "xml:space"].forEach(function(a) {
  var b2 = a.replace(ra, sa);
  z$1[b2] = new v$1(b2, 1, false, a, "http://www.w3.org/XML/1998/namespace", false, false);
});
["tabIndex", "crossOrigin"].forEach(function(a) {
  z$1[a] = new v$1(a, 1, false, a.toLowerCase(), null, false, false);
});
z$1.xlinkHref = new v$1("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
["src", "href", "action", "formAction"].forEach(function(a) {
  z$1[a] = new v$1(a, 1, false, a.toLowerCase(), null, true, true);
});
function ta(a, b2, c2, d2) {
  var e2 = z$1.hasOwnProperty(b2) ? z$1[b2] : null;
  if (null !== e2 ? 0 !== e2.type : d2 || !(2 < b2.length) || "o" !== b2[0] && "O" !== b2[0] || "n" !== b2[1] && "N" !== b2[1]) qa(b2, c2, e2, d2) && (c2 = null), d2 || null === e2 ? oa(b2) && (null === c2 ? a.removeAttribute(b2) : a.setAttribute(b2, "" + c2)) : e2.mustUseProperty ? a[e2.propertyName] = null === c2 ? 3 === e2.type ? false : "" : c2 : (b2 = e2.attributeName, d2 = e2.attributeNamespace, null === c2 ? a.removeAttribute(b2) : (e2 = e2.type, c2 = 3 === e2 || 4 === e2 && true === c2 ? "" : "" + c2, d2 ? a.setAttributeNS(d2, b2, c2) : a.setAttribute(b2, c2)));
}
var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va = Symbol.for("react.element"), wa = Symbol.for("react.portal"), ya = Symbol.for("react.fragment"), za = Symbol.for("react.strict_mode"), Aa = Symbol.for("react.profiler"), Ba = Symbol.for("react.provider"), Ca = Symbol.for("react.context"), Da = Symbol.for("react.forward_ref"), Ea = Symbol.for("react.suspense"), Fa = Symbol.for("react.suspense_list"), Ga = Symbol.for("react.memo"), Ha = Symbol.for("react.lazy");
var Ia = Symbol.for("react.offscreen");
var Ja = Symbol.iterator;
function Ka(a) {
  if (null === a || "object" !== typeof a) return null;
  a = Ja && a[Ja] || a["@@iterator"];
  return "function" === typeof a ? a : null;
}
var A$1 = Object.assign, La;
function Ma(a) {
  if (void 0 === La) try {
    throw Error();
  } catch (c2) {
    var b2 = c2.stack.trim().match(/\n( *(at )?)/);
    La = b2 && b2[1] || "";
  }
  return "\n" + La + a;
}
var Na = false;
function Oa(a, b2) {
  if (!a || Na) return "";
  Na = true;
  var c2 = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (b2) if (b2 = function() {
      throw Error();
    }, Object.defineProperty(b2.prototype, "props", { set: function() {
      throw Error();
    } }), "object" === typeof Reflect && Reflect.construct) {
      try {
        Reflect.construct(b2, []);
      } catch (l2) {
        var d2 = l2;
      }
      Reflect.construct(a, [], b2);
    } else {
      try {
        b2.call();
      } catch (l2) {
        d2 = l2;
      }
      a.call(b2.prototype);
    }
    else {
      try {
        throw Error();
      } catch (l2) {
        d2 = l2;
      }
      a();
    }
  } catch (l2) {
    if (l2 && d2 && "string" === typeof l2.stack) {
      for (var e2 = l2.stack.split("\n"), f2 = d2.stack.split("\n"), g2 = e2.length - 1, h2 = f2.length - 1; 1 <= g2 && 0 <= h2 && e2[g2] !== f2[h2]; ) h2--;
      for (; 1 <= g2 && 0 <= h2; g2--, h2--) if (e2[g2] !== f2[h2]) {
        if (1 !== g2 || 1 !== h2) {
          do
            if (g2--, h2--, 0 > h2 || e2[g2] !== f2[h2]) {
              var k2 = "\n" + e2[g2].replace(" at new ", " at ");
              a.displayName && k2.includes("<anonymous>") && (k2 = k2.replace("<anonymous>", a.displayName));
              return k2;
            }
          while (1 <= g2 && 0 <= h2);
        }
        break;
      }
    }
  } finally {
    Na = false, Error.prepareStackTrace = c2;
  }
  return (a = a ? a.displayName || a.name : "") ? Ma(a) : "";
}
function Pa(a) {
  switch (a.tag) {
    case 5:
      return Ma(a.type);
    case 16:
      return Ma("Lazy");
    case 13:
      return Ma("Suspense");
    case 19:
      return Ma("SuspenseList");
    case 0:
    case 2:
    case 15:
      return a = Oa(a.type, false), a;
    case 11:
      return a = Oa(a.type.render, false), a;
    case 1:
      return a = Oa(a.type, true), a;
    default:
      return "";
  }
}
function Qa(a) {
  if (null == a) return null;
  if ("function" === typeof a) return a.displayName || a.name || null;
  if ("string" === typeof a) return a;
  switch (a) {
    case ya:
      return "Fragment";
    case wa:
      return "Portal";
    case Aa:
      return "Profiler";
    case za:
      return "StrictMode";
    case Ea:
      return "Suspense";
    case Fa:
      return "SuspenseList";
  }
  if ("object" === typeof a) switch (a.$$typeof) {
    case Ca:
      return (a.displayName || "Context") + ".Consumer";
    case Ba:
      return (a._context.displayName || "Context") + ".Provider";
    case Da:
      var b2 = a.render;
      a = a.displayName;
      a || (a = b2.displayName || b2.name || "", a = "" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
      return a;
    case Ga:
      return b2 = a.displayName || null, null !== b2 ? b2 : Qa(a.type) || "Memo";
    case Ha:
      b2 = a._payload;
      a = a._init;
      try {
        return Qa(a(b2));
      } catch (c2) {
      }
  }
  return null;
}
function Ra(a) {
  var b2 = a.type;
  switch (a.tag) {
    case 24:
      return "Cache";
    case 9:
      return (b2.displayName || "Context") + ".Consumer";
    case 10:
      return (b2._context.displayName || "Context") + ".Provider";
    case 18:
      return "DehydratedFragment";
    case 11:
      return a = b2.render, a = a.displayName || a.name || "", b2.displayName || ("" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
    case 7:
      return "Fragment";
    case 5:
      return b2;
    case 4:
      return "Portal";
    case 3:
      return "Root";
    case 6:
      return "Text";
    case 16:
      return Qa(b2);
    case 8:
      return b2 === za ? "StrictMode" : "Mode";
    case 22:
      return "Offscreen";
    case 12:
      return "Profiler";
    case 21:
      return "Scope";
    case 13:
      return "Suspense";
    case 19:
      return "SuspenseList";
    case 25:
      return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if ("function" === typeof b2) return b2.displayName || b2.name || null;
      if ("string" === typeof b2) return b2;
  }
  return null;
}
function Sa(a) {
  switch (typeof a) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return a;
    case "object":
      return a;
    default:
      return "";
  }
}
function Ta(a) {
  var b2 = a.type;
  return (a = a.nodeName) && "input" === a.toLowerCase() && ("checkbox" === b2 || "radio" === b2);
}
function Ua(a) {
  var b2 = Ta(a) ? "checked" : "value", c2 = Object.getOwnPropertyDescriptor(a.constructor.prototype, b2), d2 = "" + a[b2];
  if (!a.hasOwnProperty(b2) && "undefined" !== typeof c2 && "function" === typeof c2.get && "function" === typeof c2.set) {
    var e2 = c2.get, f2 = c2.set;
    Object.defineProperty(a, b2, { configurable: true, get: function() {
      return e2.call(this);
    }, set: function(a2) {
      d2 = "" + a2;
      f2.call(this, a2);
    } });
    Object.defineProperty(a, b2, { enumerable: c2.enumerable });
    return { getValue: function() {
      return d2;
    }, setValue: function(a2) {
      d2 = "" + a2;
    }, stopTracking: function() {
      a._valueTracker = null;
      delete a[b2];
    } };
  }
}
function Va(a) {
  a._valueTracker || (a._valueTracker = Ua(a));
}
function Wa(a) {
  if (!a) return false;
  var b2 = a._valueTracker;
  if (!b2) return true;
  var c2 = b2.getValue();
  var d2 = "";
  a && (d2 = Ta(a) ? a.checked ? "true" : "false" : a.value);
  a = d2;
  return a !== c2 ? (b2.setValue(a), true) : false;
}
function Xa(a) {
  a = a || ("undefined" !== typeof document ? document : void 0);
  if ("undefined" === typeof a) return null;
  try {
    return a.activeElement || a.body;
  } catch (b2) {
    return a.body;
  }
}
function Ya(a, b2) {
  var c2 = b2.checked;
  return A$1({}, b2, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c2 ? c2 : a._wrapperState.initialChecked });
}
function Za(a, b2) {
  var c2 = null == b2.defaultValue ? "" : b2.defaultValue, d2 = null != b2.checked ? b2.checked : b2.defaultChecked;
  c2 = Sa(null != b2.value ? b2.value : c2);
  a._wrapperState = { initialChecked: d2, initialValue: c2, controlled: "checkbox" === b2.type || "radio" === b2.type ? null != b2.checked : null != b2.value };
}
function ab(a, b2) {
  b2 = b2.checked;
  null != b2 && ta(a, "checked", b2, false);
}
function bb(a, b2) {
  ab(a, b2);
  var c2 = Sa(b2.value), d2 = b2.type;
  if (null != c2) if ("number" === d2) {
    if (0 === c2 && "" === a.value || a.value != c2) a.value = "" + c2;
  } else a.value !== "" + c2 && (a.value = "" + c2);
  else if ("submit" === d2 || "reset" === d2) {
    a.removeAttribute("value");
    return;
  }
  b2.hasOwnProperty("value") ? cb(a, b2.type, c2) : b2.hasOwnProperty("defaultValue") && cb(a, b2.type, Sa(b2.defaultValue));
  null == b2.checked && null != b2.defaultChecked && (a.defaultChecked = !!b2.defaultChecked);
}
function db(a, b2, c2) {
  if (b2.hasOwnProperty("value") || b2.hasOwnProperty("defaultValue")) {
    var d2 = b2.type;
    if (!("submit" !== d2 && "reset" !== d2 || void 0 !== b2.value && null !== b2.value)) return;
    b2 = "" + a._wrapperState.initialValue;
    c2 || b2 === a.value || (a.value = b2);
    a.defaultValue = b2;
  }
  c2 = a.name;
  "" !== c2 && (a.name = "");
  a.defaultChecked = !!a._wrapperState.initialChecked;
  "" !== c2 && (a.name = c2);
}
function cb(a, b2, c2) {
  if ("number" !== b2 || Xa(a.ownerDocument) !== a) null == c2 ? a.defaultValue = "" + a._wrapperState.initialValue : a.defaultValue !== "" + c2 && (a.defaultValue = "" + c2);
}
var eb = Array.isArray;
function fb(a, b2, c2, d2) {
  a = a.options;
  if (b2) {
    b2 = {};
    for (var e2 = 0; e2 < c2.length; e2++) b2["$" + c2[e2]] = true;
    for (c2 = 0; c2 < a.length; c2++) e2 = b2.hasOwnProperty("$" + a[c2].value), a[c2].selected !== e2 && (a[c2].selected = e2), e2 && d2 && (a[c2].defaultSelected = true);
  } else {
    c2 = "" + Sa(c2);
    b2 = null;
    for (e2 = 0; e2 < a.length; e2++) {
      if (a[e2].value === c2) {
        a[e2].selected = true;
        d2 && (a[e2].defaultSelected = true);
        return;
      }
      null !== b2 || a[e2].disabled || (b2 = a[e2]);
    }
    null !== b2 && (b2.selected = true);
  }
}
function gb(a, b2) {
  if (null != b2.dangerouslySetInnerHTML) throw Error(p$1(91));
  return A$1({}, b2, { value: void 0, defaultValue: void 0, children: "" + a._wrapperState.initialValue });
}
function hb(a, b2) {
  var c2 = b2.value;
  if (null == c2) {
    c2 = b2.children;
    b2 = b2.defaultValue;
    if (null != c2) {
      if (null != b2) throw Error(p$1(92));
      if (eb(c2)) {
        if (1 < c2.length) throw Error(p$1(93));
        c2 = c2[0];
      }
      b2 = c2;
    }
    null == b2 && (b2 = "");
    c2 = b2;
  }
  a._wrapperState = { initialValue: Sa(c2) };
}
function ib(a, b2) {
  var c2 = Sa(b2.value), d2 = Sa(b2.defaultValue);
  null != c2 && (c2 = "" + c2, c2 !== a.value && (a.value = c2), null == b2.defaultValue && a.defaultValue !== c2 && (a.defaultValue = c2));
  null != d2 && (a.defaultValue = "" + d2);
}
function jb(a) {
  var b2 = a.textContent;
  b2 === a._wrapperState.initialValue && "" !== b2 && null !== b2 && (a.value = b2);
}
function kb(a) {
  switch (a) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function lb(a, b2) {
  return null == a || "http://www.w3.org/1999/xhtml" === a ? kb(b2) : "http://www.w3.org/2000/svg" === a && "foreignObject" === b2 ? "http://www.w3.org/1999/xhtml" : a;
}
var mb, nb = function(a) {
  return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b2, c2, d2, e2) {
    MSApp.execUnsafeLocalFunction(function() {
      return a(b2, c2, d2, e2);
    });
  } : a;
}(function(a, b2) {
  if ("http://www.w3.org/2000/svg" !== a.namespaceURI || "innerHTML" in a) a.innerHTML = b2;
  else {
    mb = mb || document.createElement("div");
    mb.innerHTML = "<svg>" + b2.valueOf().toString() + "</svg>";
    for (b2 = mb.firstChild; a.firstChild; ) a.removeChild(a.firstChild);
    for (; b2.firstChild; ) a.appendChild(b2.firstChild);
  }
});
function ob(a, b2) {
  if (b2) {
    var c2 = a.firstChild;
    if (c2 && c2 === a.lastChild && 3 === c2.nodeType) {
      c2.nodeValue = b2;
      return;
    }
  }
  a.textContent = b2;
}
var pb = {
  animationIterationCount: true,
  aspectRatio: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridArea: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
}, qb = ["Webkit", "ms", "Moz", "O"];
Object.keys(pb).forEach(function(a) {
  qb.forEach(function(b2) {
    b2 = b2 + a.charAt(0).toUpperCase() + a.substring(1);
    pb[b2] = pb[a];
  });
});
function rb(a, b2, c2) {
  return null == b2 || "boolean" === typeof b2 || "" === b2 ? "" : c2 || "number" !== typeof b2 || 0 === b2 || pb.hasOwnProperty(a) && pb[a] ? ("" + b2).trim() : b2 + "px";
}
function sb(a, b2) {
  a = a.style;
  for (var c2 in b2) if (b2.hasOwnProperty(c2)) {
    var d2 = 0 === c2.indexOf("--"), e2 = rb(c2, b2[c2], d2);
    "float" === c2 && (c2 = "cssFloat");
    d2 ? a.setProperty(c2, e2) : a[c2] = e2;
  }
}
var tb = A$1({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
function ub(a, b2) {
  if (b2) {
    if (tb[a] && (null != b2.children || null != b2.dangerouslySetInnerHTML)) throw Error(p$1(137, a));
    if (null != b2.dangerouslySetInnerHTML) {
      if (null != b2.children) throw Error(p$1(60));
      if ("object" !== typeof b2.dangerouslySetInnerHTML || !("__html" in b2.dangerouslySetInnerHTML)) throw Error(p$1(61));
    }
    if (null != b2.style && "object" !== typeof b2.style) throw Error(p$1(62));
  }
}
function vb(a, b2) {
  if (-1 === a.indexOf("-")) return "string" === typeof b2.is;
  switch (a) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return false;
    default:
      return true;
  }
}
var wb = null;
function xb(a) {
  a = a.target || a.srcElement || window;
  a.correspondingUseElement && (a = a.correspondingUseElement);
  return 3 === a.nodeType ? a.parentNode : a;
}
var yb = null, zb = null, Ab = null;
function Bb(a) {
  if (a = Cb(a)) {
    if ("function" !== typeof yb) throw Error(p$1(280));
    var b2 = a.stateNode;
    b2 && (b2 = Db(b2), yb(a.stateNode, a.type, b2));
  }
}
function Eb(a) {
  zb ? Ab ? Ab.push(a) : Ab = [a] : zb = a;
}
function Fb() {
  if (zb) {
    var a = zb, b2 = Ab;
    Ab = zb = null;
    Bb(a);
    if (b2) for (a = 0; a < b2.length; a++) Bb(b2[a]);
  }
}
function Gb(a, b2) {
  return a(b2);
}
function Hb() {
}
var Ib = false;
function Jb(a, b2, c2) {
  if (Ib) return a(b2, c2);
  Ib = true;
  try {
    return Gb(a, b2, c2);
  } finally {
    if (Ib = false, null !== zb || null !== Ab) Hb(), Fb();
  }
}
function Kb(a, b2) {
  var c2 = a.stateNode;
  if (null === c2) return null;
  var d2 = Db(c2);
  if (null === d2) return null;
  c2 = d2[b2];
  a: switch (b2) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
      (d2 = !d2.disabled) || (a = a.type, d2 = !("button" === a || "input" === a || "select" === a || "textarea" === a));
      a = !d2;
      break a;
    default:
      a = false;
  }
  if (a) return null;
  if (c2 && "function" !== typeof c2) throw Error(p$1(231, b2, typeof c2));
  return c2;
}
var Lb = false;
if (ia) try {
  var Mb = {};
  Object.defineProperty(Mb, "passive", { get: function() {
    Lb = true;
  } });
  window.addEventListener("test", Mb, Mb);
  window.removeEventListener("test", Mb, Mb);
} catch (a) {
  Lb = false;
}
function Nb(a, b2, c2, d2, e2, f2, g2, h2, k2) {
  var l2 = Array.prototype.slice.call(arguments, 3);
  try {
    b2.apply(c2, l2);
  } catch (m2) {
    this.onError(m2);
  }
}
var Ob = false, Pb = null, Qb = false, Rb = null, Sb = { onError: function(a) {
  Ob = true;
  Pb = a;
} };
function Tb(a, b2, c2, d2, e2, f2, g2, h2, k2) {
  Ob = false;
  Pb = null;
  Nb.apply(Sb, arguments);
}
function Ub(a, b2, c2, d2, e2, f2, g2, h2, k2) {
  Tb.apply(this, arguments);
  if (Ob) {
    if (Ob) {
      var l2 = Pb;
      Ob = false;
      Pb = null;
    } else throw Error(p$1(198));
    Qb || (Qb = true, Rb = l2);
  }
}
function Vb(a) {
  var b2 = a, c2 = a;
  if (a.alternate) for (; b2.return; ) b2 = b2.return;
  else {
    a = b2;
    do
      b2 = a, 0 !== (b2.flags & 4098) && (c2 = b2.return), a = b2.return;
    while (a);
  }
  return 3 === b2.tag ? c2 : null;
}
function Wb(a) {
  if (13 === a.tag) {
    var b2 = a.memoizedState;
    null === b2 && (a = a.alternate, null !== a && (b2 = a.memoizedState));
    if (null !== b2) return b2.dehydrated;
  }
  return null;
}
function Xb(a) {
  if (Vb(a) !== a) throw Error(p$1(188));
}
function Yb(a) {
  var b2 = a.alternate;
  if (!b2) {
    b2 = Vb(a);
    if (null === b2) throw Error(p$1(188));
    return b2 !== a ? null : a;
  }
  for (var c2 = a, d2 = b2; ; ) {
    var e2 = c2.return;
    if (null === e2) break;
    var f2 = e2.alternate;
    if (null === f2) {
      d2 = e2.return;
      if (null !== d2) {
        c2 = d2;
        continue;
      }
      break;
    }
    if (e2.child === f2.child) {
      for (f2 = e2.child; f2; ) {
        if (f2 === c2) return Xb(e2), a;
        if (f2 === d2) return Xb(e2), b2;
        f2 = f2.sibling;
      }
      throw Error(p$1(188));
    }
    if (c2.return !== d2.return) c2 = e2, d2 = f2;
    else {
      for (var g2 = false, h2 = e2.child; h2; ) {
        if (h2 === c2) {
          g2 = true;
          c2 = e2;
          d2 = f2;
          break;
        }
        if (h2 === d2) {
          g2 = true;
          d2 = e2;
          c2 = f2;
          break;
        }
        h2 = h2.sibling;
      }
      if (!g2) {
        for (h2 = f2.child; h2; ) {
          if (h2 === c2) {
            g2 = true;
            c2 = f2;
            d2 = e2;
            break;
          }
          if (h2 === d2) {
            g2 = true;
            d2 = f2;
            c2 = e2;
            break;
          }
          h2 = h2.sibling;
        }
        if (!g2) throw Error(p$1(189));
      }
    }
    if (c2.alternate !== d2) throw Error(p$1(190));
  }
  if (3 !== c2.tag) throw Error(p$1(188));
  return c2.stateNode.current === c2 ? a : b2;
}
function Zb(a) {
  a = Yb(a);
  return null !== a ? $b(a) : null;
}
function $b(a) {
  if (5 === a.tag || 6 === a.tag) return a;
  for (a = a.child; null !== a; ) {
    var b2 = $b(a);
    if (null !== b2) return b2;
    a = a.sibling;
  }
  return null;
}
var ac = ca.unstable_scheduleCallback, bc = ca.unstable_cancelCallback, cc = ca.unstable_shouldYield, dc = ca.unstable_requestPaint, B = ca.unstable_now, ec = ca.unstable_getCurrentPriorityLevel, fc = ca.unstable_ImmediatePriority, gc = ca.unstable_UserBlockingPriority, hc = ca.unstable_NormalPriority, ic = ca.unstable_LowPriority, jc = ca.unstable_IdlePriority, kc = null, lc = null;
function mc(a) {
  if (lc && "function" === typeof lc.onCommitFiberRoot) try {
    lc.onCommitFiberRoot(kc, a, void 0, 128 === (a.current.flags & 128));
  } catch (b2) {
  }
}
var oc = Math.clz32 ? Math.clz32 : nc, pc = Math.log, qc = Math.LN2;
function nc(a) {
  a >>>= 0;
  return 0 === a ? 32 : 31 - (pc(a) / qc | 0) | 0;
}
var rc = 64, sc = 4194304;
function tc(a) {
  switch (a & -a) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return a & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return a & 130023424;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 1073741824;
    default:
      return a;
  }
}
function uc(a, b2) {
  var c2 = a.pendingLanes;
  if (0 === c2) return 0;
  var d2 = 0, e2 = a.suspendedLanes, f2 = a.pingedLanes, g2 = c2 & 268435455;
  if (0 !== g2) {
    var h2 = g2 & ~e2;
    0 !== h2 ? d2 = tc(h2) : (f2 &= g2, 0 !== f2 && (d2 = tc(f2)));
  } else g2 = c2 & ~e2, 0 !== g2 ? d2 = tc(g2) : 0 !== f2 && (d2 = tc(f2));
  if (0 === d2) return 0;
  if (0 !== b2 && b2 !== d2 && 0 === (b2 & e2) && (e2 = d2 & -d2, f2 = b2 & -b2, e2 >= f2 || 16 === e2 && 0 !== (f2 & 4194240))) return b2;
  0 !== (d2 & 4) && (d2 |= c2 & 16);
  b2 = a.entangledLanes;
  if (0 !== b2) for (a = a.entanglements, b2 &= d2; 0 < b2; ) c2 = 31 - oc(b2), e2 = 1 << c2, d2 |= a[c2], b2 &= ~e2;
  return d2;
}
function vc(a, b2) {
  switch (a) {
    case 1:
    case 2:
    case 4:
      return b2 + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return b2 + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function wc(a, b2) {
  for (var c2 = a.suspendedLanes, d2 = a.pingedLanes, e2 = a.expirationTimes, f2 = a.pendingLanes; 0 < f2; ) {
    var g2 = 31 - oc(f2), h2 = 1 << g2, k2 = e2[g2];
    if (-1 === k2) {
      if (0 === (h2 & c2) || 0 !== (h2 & d2)) e2[g2] = vc(h2, b2);
    } else k2 <= b2 && (a.expiredLanes |= h2);
    f2 &= ~h2;
  }
}
function xc(a) {
  a = a.pendingLanes & -1073741825;
  return 0 !== a ? a : a & 1073741824 ? 1073741824 : 0;
}
function yc() {
  var a = rc;
  rc <<= 1;
  0 === (rc & 4194240) && (rc = 64);
  return a;
}
function zc(a) {
  for (var b2 = [], c2 = 0; 31 > c2; c2++) b2.push(a);
  return b2;
}
function Ac(a, b2, c2) {
  a.pendingLanes |= b2;
  536870912 !== b2 && (a.suspendedLanes = 0, a.pingedLanes = 0);
  a = a.eventTimes;
  b2 = 31 - oc(b2);
  a[b2] = c2;
}
function Bc(a, b2) {
  var c2 = a.pendingLanes & ~b2;
  a.pendingLanes = b2;
  a.suspendedLanes = 0;
  a.pingedLanes = 0;
  a.expiredLanes &= b2;
  a.mutableReadLanes &= b2;
  a.entangledLanes &= b2;
  b2 = a.entanglements;
  var d2 = a.eventTimes;
  for (a = a.expirationTimes; 0 < c2; ) {
    var e2 = 31 - oc(c2), f2 = 1 << e2;
    b2[e2] = 0;
    d2[e2] = -1;
    a[e2] = -1;
    c2 &= ~f2;
  }
}
function Cc(a, b2) {
  var c2 = a.entangledLanes |= b2;
  for (a = a.entanglements; c2; ) {
    var d2 = 31 - oc(c2), e2 = 1 << d2;
    e2 & b2 | a[d2] & b2 && (a[d2] |= b2);
    c2 &= ~e2;
  }
}
var C = 0;
function Dc(a) {
  a &= -a;
  return 1 < a ? 4 < a ? 0 !== (a & 268435455) ? 16 : 536870912 : 4 : 1;
}
var Ec, Fc, Gc, Hc, Ic, Jc = false, Kc = [], Lc = null, Mc = null, Nc = null, Oc = /* @__PURE__ */ new Map(), Pc = /* @__PURE__ */ new Map(), Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function Sc(a, b2) {
  switch (a) {
    case "focusin":
    case "focusout":
      Lc = null;
      break;
    case "dragenter":
    case "dragleave":
      Mc = null;
      break;
    case "mouseover":
    case "mouseout":
      Nc = null;
      break;
    case "pointerover":
    case "pointerout":
      Oc.delete(b2.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      Pc.delete(b2.pointerId);
  }
}
function Tc(a, b2, c2, d2, e2, f2) {
  if (null === a || a.nativeEvent !== f2) return a = { blockedOn: b2, domEventName: c2, eventSystemFlags: d2, nativeEvent: f2, targetContainers: [e2] }, null !== b2 && (b2 = Cb(b2), null !== b2 && Fc(b2)), a;
  a.eventSystemFlags |= d2;
  b2 = a.targetContainers;
  null !== e2 && -1 === b2.indexOf(e2) && b2.push(e2);
  return a;
}
function Uc(a, b2, c2, d2, e2) {
  switch (b2) {
    case "focusin":
      return Lc = Tc(Lc, a, b2, c2, d2, e2), true;
    case "dragenter":
      return Mc = Tc(Mc, a, b2, c2, d2, e2), true;
    case "mouseover":
      return Nc = Tc(Nc, a, b2, c2, d2, e2), true;
    case "pointerover":
      var f2 = e2.pointerId;
      Oc.set(f2, Tc(Oc.get(f2) || null, a, b2, c2, d2, e2));
      return true;
    case "gotpointercapture":
      return f2 = e2.pointerId, Pc.set(f2, Tc(Pc.get(f2) || null, a, b2, c2, d2, e2)), true;
  }
  return false;
}
function Vc(a) {
  var b2 = Wc(a.target);
  if (null !== b2) {
    var c2 = Vb(b2);
    if (null !== c2) {
      if (b2 = c2.tag, 13 === b2) {
        if (b2 = Wb(c2), null !== b2) {
          a.blockedOn = b2;
          Ic(a.priority, function() {
            Gc(c2);
          });
          return;
        }
      } else if (3 === b2 && c2.stateNode.current.memoizedState.isDehydrated) {
        a.blockedOn = 3 === c2.tag ? c2.stateNode.containerInfo : null;
        return;
      }
    }
  }
  a.blockedOn = null;
}
function Xc(a) {
  if (null !== a.blockedOn) return false;
  for (var b2 = a.targetContainers; 0 < b2.length; ) {
    var c2 = Yc(a.domEventName, a.eventSystemFlags, b2[0], a.nativeEvent);
    if (null === c2) {
      c2 = a.nativeEvent;
      var d2 = new c2.constructor(c2.type, c2);
      wb = d2;
      c2.target.dispatchEvent(d2);
      wb = null;
    } else return b2 = Cb(c2), null !== b2 && Fc(b2), a.blockedOn = c2, false;
    b2.shift();
  }
  return true;
}
function Zc(a, b2, c2) {
  Xc(a) && c2.delete(b2);
}
function $c() {
  Jc = false;
  null !== Lc && Xc(Lc) && (Lc = null);
  null !== Mc && Xc(Mc) && (Mc = null);
  null !== Nc && Xc(Nc) && (Nc = null);
  Oc.forEach(Zc);
  Pc.forEach(Zc);
}
function ad(a, b2) {
  a.blockedOn === b2 && (a.blockedOn = null, Jc || (Jc = true, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
}
function bd(a) {
  function b2(b3) {
    return ad(b3, a);
  }
  if (0 < Kc.length) {
    ad(Kc[0], a);
    for (var c2 = 1; c2 < Kc.length; c2++) {
      var d2 = Kc[c2];
      d2.blockedOn === a && (d2.blockedOn = null);
    }
  }
  null !== Lc && ad(Lc, a);
  null !== Mc && ad(Mc, a);
  null !== Nc && ad(Nc, a);
  Oc.forEach(b2);
  Pc.forEach(b2);
  for (c2 = 0; c2 < Qc.length; c2++) d2 = Qc[c2], d2.blockedOn === a && (d2.blockedOn = null);
  for (; 0 < Qc.length && (c2 = Qc[0], null === c2.blockedOn); ) Vc(c2), null === c2.blockedOn && Qc.shift();
}
var cd = ua.ReactCurrentBatchConfig, dd = true;
function ed(a, b2, c2, d2) {
  var e2 = C, f2 = cd.transition;
  cd.transition = null;
  try {
    C = 1, fd(a, b2, c2, d2);
  } finally {
    C = e2, cd.transition = f2;
  }
}
function gd(a, b2, c2, d2) {
  var e2 = C, f2 = cd.transition;
  cd.transition = null;
  try {
    C = 4, fd(a, b2, c2, d2);
  } finally {
    C = e2, cd.transition = f2;
  }
}
function fd(a, b2, c2, d2) {
  if (dd) {
    var e2 = Yc(a, b2, c2, d2);
    if (null === e2) hd(a, b2, d2, id$3, c2), Sc(a, d2);
    else if (Uc(e2, a, b2, c2, d2)) d2.stopPropagation();
    else if (Sc(a, d2), b2 & 4 && -1 < Rc.indexOf(a)) {
      for (; null !== e2; ) {
        var f2 = Cb(e2);
        null !== f2 && Ec(f2);
        f2 = Yc(a, b2, c2, d2);
        null === f2 && hd(a, b2, d2, id$3, c2);
        if (f2 === e2) break;
        e2 = f2;
      }
      null !== e2 && d2.stopPropagation();
    } else hd(a, b2, d2, null, c2);
  }
}
var id$3 = null;
function Yc(a, b2, c2, d2) {
  id$3 = null;
  a = xb(d2);
  a = Wc(a);
  if (null !== a) if (b2 = Vb(a), null === b2) a = null;
  else if (c2 = b2.tag, 13 === c2) {
    a = Wb(b2);
    if (null !== a) return a;
    a = null;
  } else if (3 === c2) {
    if (b2.stateNode.current.memoizedState.isDehydrated) return 3 === b2.tag ? b2.stateNode.containerInfo : null;
    a = null;
  } else b2 !== a && (a = null);
  id$3 = a;
  return null;
}
function jd(a) {
  switch (a) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;
    case "message":
      switch (ec()) {
        case fc:
          return 1;
        case gc:
          return 4;
        case hc:
        case ic:
          return 16;
        case jc:
          return 536870912;
        default:
          return 16;
      }
    default:
      return 16;
  }
}
var kd = null, ld = null, md = null;
function nd() {
  if (md) return md;
  var a, b2 = ld, c2 = b2.length, d2, e2 = "value" in kd ? kd.value : kd.textContent, f2 = e2.length;
  for (a = 0; a < c2 && b2[a] === e2[a]; a++) ;
  var g2 = c2 - a;
  for (d2 = 1; d2 <= g2 && b2[c2 - d2] === e2[f2 - d2]; d2++) ;
  return md = e2.slice(a, 1 < d2 ? 1 - d2 : void 0);
}
function od(a) {
  var b2 = a.keyCode;
  "charCode" in a ? (a = a.charCode, 0 === a && 13 === b2 && (a = 13)) : a = b2;
  10 === a && (a = 13);
  return 32 <= a || 13 === a ? a : 0;
}
function pd() {
  return true;
}
function qd() {
  return false;
}
function rd(a) {
  function b2(b3, d2, e2, f2, g2) {
    this._reactName = b3;
    this._targetInst = e2;
    this.type = d2;
    this.nativeEvent = f2;
    this.target = g2;
    this.currentTarget = null;
    for (var c2 in a) a.hasOwnProperty(c2) && (b3 = a[c2], this[c2] = b3 ? b3(f2) : f2[c2]);
    this.isDefaultPrevented = (null != f2.defaultPrevented ? f2.defaultPrevented : false === f2.returnValue) ? pd : qd;
    this.isPropagationStopped = qd;
    return this;
  }
  A$1(b2.prototype, { preventDefault: function() {
    this.defaultPrevented = true;
    var a2 = this.nativeEvent;
    a2 && (a2.preventDefault ? a2.preventDefault() : "unknown" !== typeof a2.returnValue && (a2.returnValue = false), this.isDefaultPrevented = pd);
  }, stopPropagation: function() {
    var a2 = this.nativeEvent;
    a2 && (a2.stopPropagation ? a2.stopPropagation() : "unknown" !== typeof a2.cancelBubble && (a2.cancelBubble = true), this.isPropagationStopped = pd);
  }, persist: function() {
  }, isPersistent: pd });
  return b2;
}
var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a) {
  return a.timeStamp || Date.now();
}, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = A$1({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = A$1({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a) {
  return void 0 === a.relatedTarget ? a.fromElement === a.srcElement ? a.toElement : a.fromElement : a.relatedTarget;
}, movementX: function(a) {
  if ("movementX" in a) return a.movementX;
  a !== yd && (yd && "mousemove" === a.type ? (wd = a.screenX - yd.screenX, xd = a.screenY - yd.screenY) : xd = wd = 0, yd = a);
  return wd;
}, movementY: function(a) {
  return "movementY" in a ? a.movementY : xd;
} }), Bd = rd(Ad), Cd = A$1({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = A$1({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = A$1({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = A$1({}, sd, { clipboardData: function(a) {
  return "clipboardData" in a ? a.clipboardData : window.clipboardData;
} }), Jd = rd(Id), Kd = A$1({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
  Esc: "Escape",
  Spacebar: " ",
  Left: "ArrowLeft",
  Up: "ArrowUp",
  Right: "ArrowRight",
  Down: "ArrowDown",
  Del: "Delete",
  Win: "OS",
  Menu: "ContextMenu",
  Apps: "ContextMenu",
  Scroll: "ScrollLock",
  MozPrintableKey: "Unidentified"
}, Nd = {
  8: "Backspace",
  9: "Tab",
  12: "Clear",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  19: "Pause",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  45: "Insert",
  46: "Delete",
  112: "F1",
  113: "F2",
  114: "F3",
  115: "F4",
  116: "F5",
  117: "F6",
  118: "F7",
  119: "F8",
  120: "F9",
  121: "F10",
  122: "F11",
  123: "F12",
  144: "NumLock",
  145: "ScrollLock",
  224: "Meta"
}, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
function Pd(a) {
  var b2 = this.nativeEvent;
  return b2.getModifierState ? b2.getModifierState(a) : (a = Od[a]) ? !!b2[a] : false;
}
function zd() {
  return Pd;
}
var Qd = A$1({}, ud, { key: function(a) {
  if (a.key) {
    var b2 = Md[a.key] || a.key;
    if ("Unidentified" !== b2) return b2;
  }
  return "keypress" === a.type ? (a = od(a), 13 === a ? "Enter" : String.fromCharCode(a)) : "keydown" === a.type || "keyup" === a.type ? Nd[a.keyCode] || "Unidentified" : "";
}, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a) {
  return "keypress" === a.type ? od(a) : 0;
}, keyCode: function(a) {
  return "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
}, which: function(a) {
  return "keypress" === a.type ? od(a) : "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
} }), Rd = rd(Qd), Sd = A$1({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = A$1({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = A$1({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = A$1({}, Ad, {
  deltaX: function(a) {
    return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
  },
  deltaY: function(a) {
    return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
  },
  deltaZ: 0,
  deltaMode: 0
}), Zd = rd(Yd), $d = [9, 13, 27, 32], ae = ia && "CompositionEvent" in window, be = null;
ia && "documentMode" in document && (be = document.documentMode);
var ce = ia && "TextEvent" in window && !be, de = ia && (!ae || be && 8 < be && 11 >= be), ee = String.fromCharCode(32), fe = false;
function ge(a, b2) {
  switch (a) {
    case "keyup":
      return -1 !== $d.indexOf(b2.keyCode);
    case "keydown":
      return 229 !== b2.keyCode;
    case "keypress":
    case "mousedown":
    case "focusout":
      return true;
    default:
      return false;
  }
}
function he(a) {
  a = a.detail;
  return "object" === typeof a && "data" in a ? a.data : null;
}
var ie = false;
function je(a, b2) {
  switch (a) {
    case "compositionend":
      return he(b2);
    case "keypress":
      if (32 !== b2.which) return null;
      fe = true;
      return ee;
    case "textInput":
      return a = b2.data, a === ee && fe ? null : a;
    default:
      return null;
  }
}
function ke(a, b2) {
  if (ie) return "compositionend" === a || !ae && ge(a, b2) ? (a = nd(), md = ld = kd = null, ie = false, a) : null;
  switch (a) {
    case "paste":
      return null;
    case "keypress":
      if (!(b2.ctrlKey || b2.altKey || b2.metaKey) || b2.ctrlKey && b2.altKey) {
        if (b2.char && 1 < b2.char.length) return b2.char;
        if (b2.which) return String.fromCharCode(b2.which);
      }
      return null;
    case "compositionend":
      return de && "ko" !== b2.locale ? null : b2.data;
    default:
      return null;
  }
}
var le = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
function me(a) {
  var b2 = a && a.nodeName && a.nodeName.toLowerCase();
  return "input" === b2 ? !!le[a.type] : "textarea" === b2 ? true : false;
}
function ne(a, b2, c2, d2) {
  Eb(d2);
  b2 = oe(b2, "onChange");
  0 < b2.length && (c2 = new td("onChange", "change", null, c2, d2), a.push({ event: c2, listeners: b2 }));
}
var pe = null, qe = null;
function re(a) {
  se(a, 0);
}
function te(a) {
  var b2 = ue(a);
  if (Wa(b2)) return a;
}
function ve(a, b2) {
  if ("change" === a) return b2;
}
var we = false;
if (ia) {
  var xe;
  if (ia) {
    var ye = "oninput" in document;
    if (!ye) {
      var ze = document.createElement("div");
      ze.setAttribute("oninput", "return;");
      ye = "function" === typeof ze.oninput;
    }
    xe = ye;
  } else xe = false;
  we = xe && (!document.documentMode || 9 < document.documentMode);
}
function Ae() {
  pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
}
function Be(a) {
  if ("value" === a.propertyName && te(qe)) {
    var b2 = [];
    ne(b2, qe, a, xb(a));
    Jb(re, b2);
  }
}
function Ce(a, b2, c2) {
  "focusin" === a ? (Ae(), pe = b2, qe = c2, pe.attachEvent("onpropertychange", Be)) : "focusout" === a && Ae();
}
function De(a) {
  if ("selectionchange" === a || "keyup" === a || "keydown" === a) return te(qe);
}
function Ee(a, b2) {
  if ("click" === a) return te(b2);
}
function Fe(a, b2) {
  if ("input" === a || "change" === a) return te(b2);
}
function Ge(a, b2) {
  return a === b2 && (0 !== a || 1 / a === 1 / b2) || a !== a && b2 !== b2;
}
var He = "function" === typeof Object.is ? Object.is : Ge;
function Ie(a, b2) {
  if (He(a, b2)) return true;
  if ("object" !== typeof a || null === a || "object" !== typeof b2 || null === b2) return false;
  var c2 = Object.keys(a), d2 = Object.keys(b2);
  if (c2.length !== d2.length) return false;
  for (d2 = 0; d2 < c2.length; d2++) {
    var e2 = c2[d2];
    if (!ja.call(b2, e2) || !He(a[e2], b2[e2])) return false;
  }
  return true;
}
function Je(a) {
  for (; a && a.firstChild; ) a = a.firstChild;
  return a;
}
function Ke(a, b2) {
  var c2 = Je(a);
  a = 0;
  for (var d2; c2; ) {
    if (3 === c2.nodeType) {
      d2 = a + c2.textContent.length;
      if (a <= b2 && d2 >= b2) return { node: c2, offset: b2 - a };
      a = d2;
    }
    a: {
      for (; c2; ) {
        if (c2.nextSibling) {
          c2 = c2.nextSibling;
          break a;
        }
        c2 = c2.parentNode;
      }
      c2 = void 0;
    }
    c2 = Je(c2);
  }
}
function Le(a, b2) {
  return a && b2 ? a === b2 ? true : a && 3 === a.nodeType ? false : b2 && 3 === b2.nodeType ? Le(a, b2.parentNode) : "contains" in a ? a.contains(b2) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(b2) & 16) : false : false;
}
function Me() {
  for (var a = window, b2 = Xa(); b2 instanceof a.HTMLIFrameElement; ) {
    try {
      var c2 = "string" === typeof b2.contentWindow.location.href;
    } catch (d2) {
      c2 = false;
    }
    if (c2) a = b2.contentWindow;
    else break;
    b2 = Xa(a.document);
  }
  return b2;
}
function Ne(a) {
  var b2 = a && a.nodeName && a.nodeName.toLowerCase();
  return b2 && ("input" === b2 && ("text" === a.type || "search" === a.type || "tel" === a.type || "url" === a.type || "password" === a.type) || "textarea" === b2 || "true" === a.contentEditable);
}
function Oe(a) {
  var b2 = Me(), c2 = a.focusedElem, d2 = a.selectionRange;
  if (b2 !== c2 && c2 && c2.ownerDocument && Le(c2.ownerDocument.documentElement, c2)) {
    if (null !== d2 && Ne(c2)) {
      if (b2 = d2.start, a = d2.end, void 0 === a && (a = b2), "selectionStart" in c2) c2.selectionStart = b2, c2.selectionEnd = Math.min(a, c2.value.length);
      else if (a = (b2 = c2.ownerDocument || document) && b2.defaultView || window, a.getSelection) {
        a = a.getSelection();
        var e2 = c2.textContent.length, f2 = Math.min(d2.start, e2);
        d2 = void 0 === d2.end ? f2 : Math.min(d2.end, e2);
        !a.extend && f2 > d2 && (e2 = d2, d2 = f2, f2 = e2);
        e2 = Ke(c2, f2);
        var g2 = Ke(
          c2,
          d2
        );
        e2 && g2 && (1 !== a.rangeCount || a.anchorNode !== e2.node || a.anchorOffset !== e2.offset || a.focusNode !== g2.node || a.focusOffset !== g2.offset) && (b2 = b2.createRange(), b2.setStart(e2.node, e2.offset), a.removeAllRanges(), f2 > d2 ? (a.addRange(b2), a.extend(g2.node, g2.offset)) : (b2.setEnd(g2.node, g2.offset), a.addRange(b2)));
      }
    }
    b2 = [];
    for (a = c2; a = a.parentNode; ) 1 === a.nodeType && b2.push({ element: a, left: a.scrollLeft, top: a.scrollTop });
    "function" === typeof c2.focus && c2.focus();
    for (c2 = 0; c2 < b2.length; c2++) a = b2[c2], a.element.scrollLeft = a.left, a.element.scrollTop = a.top;
  }
}
var Pe = ia && "documentMode" in document && 11 >= document.documentMode, Qe = null, Re = null, Se = null, Te = false;
function Ue(a, b2, c2) {
  var d2 = c2.window === c2 ? c2.document : 9 === c2.nodeType ? c2 : c2.ownerDocument;
  Te || null == Qe || Qe !== Xa(d2) || (d2 = Qe, "selectionStart" in d2 && Ne(d2) ? d2 = { start: d2.selectionStart, end: d2.selectionEnd } : (d2 = (d2.ownerDocument && d2.ownerDocument.defaultView || window).getSelection(), d2 = { anchorNode: d2.anchorNode, anchorOffset: d2.anchorOffset, focusNode: d2.focusNode, focusOffset: d2.focusOffset }), Se && Ie(Se, d2) || (Se = d2, d2 = oe(Re, "onSelect"), 0 < d2.length && (b2 = new td("onSelect", "select", null, b2, c2), a.push({ event: b2, listeners: d2 }), b2.target = Qe)));
}
function Ve(a, b2) {
  var c2 = {};
  c2[a.toLowerCase()] = b2.toLowerCase();
  c2["Webkit" + a] = "webkit" + b2;
  c2["Moz" + a] = "moz" + b2;
  return c2;
}
var We = { animationend: Ve("Animation", "AnimationEnd"), animationiteration: Ve("Animation", "AnimationIteration"), animationstart: Ve("Animation", "AnimationStart"), transitionend: Ve("Transition", "TransitionEnd") }, Xe = {}, Ye = {};
ia && (Ye = document.createElement("div").style, "AnimationEvent" in window || (delete We.animationend.animation, delete We.animationiteration.animation, delete We.animationstart.animation), "TransitionEvent" in window || delete We.transitionend.transition);
function Ze(a) {
  if (Xe[a]) return Xe[a];
  if (!We[a]) return a;
  var b2 = We[a], c2;
  for (c2 in b2) if (b2.hasOwnProperty(c2) && c2 in Ye) return Xe[a] = b2[c2];
  return a;
}
var $e = Ze("animationend"), af = Ze("animationiteration"), bf = Ze("animationstart"), cf = Ze("transitionend"), df = /* @__PURE__ */ new Map(), ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function ff(a, b2) {
  df.set(a, b2);
  fa(b2, [a]);
}
for (var gf = 0; gf < ef.length; gf++) {
  var hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
  ff(jf, "on" + kf);
}
ff($e, "onAnimationEnd");
ff(af, "onAnimationIteration");
ff(bf, "onAnimationStart");
ff("dblclick", "onDoubleClick");
ff("focusin", "onFocus");
ff("focusout", "onBlur");
ff(cf, "onTransitionEnd");
ha("onMouseEnter", ["mouseout", "mouseover"]);
ha("onMouseLeave", ["mouseout", "mouseover"]);
ha("onPointerEnter", ["pointerout", "pointerover"]);
ha("onPointerLeave", ["pointerout", "pointerover"]);
fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
function nf(a, b2, c2) {
  var d2 = a.type || "unknown-event";
  a.currentTarget = c2;
  Ub(d2, b2, void 0, a);
  a.currentTarget = null;
}
function se(a, b2) {
  b2 = 0 !== (b2 & 4);
  for (var c2 = 0; c2 < a.length; c2++) {
    var d2 = a[c2], e2 = d2.event;
    d2 = d2.listeners;
    a: {
      var f2 = void 0;
      if (b2) for (var g2 = d2.length - 1; 0 <= g2; g2--) {
        var h2 = d2[g2], k2 = h2.instance, l2 = h2.currentTarget;
        h2 = h2.listener;
        if (k2 !== f2 && e2.isPropagationStopped()) break a;
        nf(e2, h2, l2);
        f2 = k2;
      }
      else for (g2 = 0; g2 < d2.length; g2++) {
        h2 = d2[g2];
        k2 = h2.instance;
        l2 = h2.currentTarget;
        h2 = h2.listener;
        if (k2 !== f2 && e2.isPropagationStopped()) break a;
        nf(e2, h2, l2);
        f2 = k2;
      }
    }
  }
  if (Qb) throw a = Rb, Qb = false, Rb = null, a;
}
function D(a, b2) {
  var c2 = b2[of];
  void 0 === c2 && (c2 = b2[of] = /* @__PURE__ */ new Set());
  var d2 = a + "__bubble";
  c2.has(d2) || (pf(b2, a, 2, false), c2.add(d2));
}
function qf(a, b2, c2) {
  var d2 = 0;
  b2 && (d2 |= 4);
  pf(c2, a, d2, b2);
}
var rf = "_reactListening" + Math.random().toString(36).slice(2);
function sf(a) {
  if (!a[rf]) {
    a[rf] = true;
    da.forEach(function(b3) {
      "selectionchange" !== b3 && (mf.has(b3) || qf(b3, false, a), qf(b3, true, a));
    });
    var b2 = 9 === a.nodeType ? a : a.ownerDocument;
    null === b2 || b2[rf] || (b2[rf] = true, qf("selectionchange", false, b2));
  }
}
function pf(a, b2, c2, d2) {
  switch (jd(b2)) {
    case 1:
      var e2 = ed;
      break;
    case 4:
      e2 = gd;
      break;
    default:
      e2 = fd;
  }
  c2 = e2.bind(null, b2, c2, a);
  e2 = void 0;
  !Lb || "touchstart" !== b2 && "touchmove" !== b2 && "wheel" !== b2 || (e2 = true);
  d2 ? void 0 !== e2 ? a.addEventListener(b2, c2, { capture: true, passive: e2 }) : a.addEventListener(b2, c2, true) : void 0 !== e2 ? a.addEventListener(b2, c2, { passive: e2 }) : a.addEventListener(b2, c2, false);
}
function hd(a, b2, c2, d2, e2) {
  var f2 = d2;
  if (0 === (b2 & 1) && 0 === (b2 & 2) && null !== d2) a: for (; ; ) {
    if (null === d2) return;
    var g2 = d2.tag;
    if (3 === g2 || 4 === g2) {
      var h2 = d2.stateNode.containerInfo;
      if (h2 === e2 || 8 === h2.nodeType && h2.parentNode === e2) break;
      if (4 === g2) for (g2 = d2.return; null !== g2; ) {
        var k2 = g2.tag;
        if (3 === k2 || 4 === k2) {
          if (k2 = g2.stateNode.containerInfo, k2 === e2 || 8 === k2.nodeType && k2.parentNode === e2) return;
        }
        g2 = g2.return;
      }
      for (; null !== h2; ) {
        g2 = Wc(h2);
        if (null === g2) return;
        k2 = g2.tag;
        if (5 === k2 || 6 === k2) {
          d2 = f2 = g2;
          continue a;
        }
        h2 = h2.parentNode;
      }
    }
    d2 = d2.return;
  }
  Jb(function() {
    var d3 = f2, e3 = xb(c2), g3 = [];
    a: {
      var h3 = df.get(a);
      if (void 0 !== h3) {
        var k3 = td, n2 = a;
        switch (a) {
          case "keypress":
            if (0 === od(c2)) break a;
          case "keydown":
          case "keyup":
            k3 = Rd;
            break;
          case "focusin":
            n2 = "focus";
            k3 = Fd;
            break;
          case "focusout":
            n2 = "blur";
            k3 = Fd;
            break;
          case "beforeblur":
          case "afterblur":
            k3 = Fd;
            break;
          case "click":
            if (2 === c2.button) break a;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            k3 = Bd;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            k3 = Dd;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            k3 = Vd;
            break;
          case $e:
          case af:
          case bf:
            k3 = Hd;
            break;
          case cf:
            k3 = Xd;
            break;
          case "scroll":
            k3 = vd;
            break;
          case "wheel":
            k3 = Zd;
            break;
          case "copy":
          case "cut":
          case "paste":
            k3 = Jd;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            k3 = Td;
        }
        var t2 = 0 !== (b2 & 4), J2 = !t2 && "scroll" === a, x2 = t2 ? null !== h3 ? h3 + "Capture" : null : h3;
        t2 = [];
        for (var w2 = d3, u2; null !== w2; ) {
          u2 = w2;
          var F2 = u2.stateNode;
          5 === u2.tag && null !== F2 && (u2 = F2, null !== x2 && (F2 = Kb(w2, x2), null != F2 && t2.push(tf(w2, F2, u2))));
          if (J2) break;
          w2 = w2.return;
        }
        0 < t2.length && (h3 = new k3(h3, n2, null, c2, e3), g3.push({ event: h3, listeners: t2 }));
      }
    }
    if (0 === (b2 & 7)) {
      a: {
        h3 = "mouseover" === a || "pointerover" === a;
        k3 = "mouseout" === a || "pointerout" === a;
        if (h3 && c2 !== wb && (n2 = c2.relatedTarget || c2.fromElement) && (Wc(n2) || n2[uf])) break a;
        if (k3 || h3) {
          h3 = e3.window === e3 ? e3 : (h3 = e3.ownerDocument) ? h3.defaultView || h3.parentWindow : window;
          if (k3) {
            if (n2 = c2.relatedTarget || c2.toElement, k3 = d3, n2 = n2 ? Wc(n2) : null, null !== n2 && (J2 = Vb(n2), n2 !== J2 || 5 !== n2.tag && 6 !== n2.tag)) n2 = null;
          } else k3 = null, n2 = d3;
          if (k3 !== n2) {
            t2 = Bd;
            F2 = "onMouseLeave";
            x2 = "onMouseEnter";
            w2 = "mouse";
            if ("pointerout" === a || "pointerover" === a) t2 = Td, F2 = "onPointerLeave", x2 = "onPointerEnter", w2 = "pointer";
            J2 = null == k3 ? h3 : ue(k3);
            u2 = null == n2 ? h3 : ue(n2);
            h3 = new t2(F2, w2 + "leave", k3, c2, e3);
            h3.target = J2;
            h3.relatedTarget = u2;
            F2 = null;
            Wc(e3) === d3 && (t2 = new t2(x2, w2 + "enter", n2, c2, e3), t2.target = u2, t2.relatedTarget = J2, F2 = t2);
            J2 = F2;
            if (k3 && n2) b: {
              t2 = k3;
              x2 = n2;
              w2 = 0;
              for (u2 = t2; u2; u2 = vf(u2)) w2++;
              u2 = 0;
              for (F2 = x2; F2; F2 = vf(F2)) u2++;
              for (; 0 < w2 - u2; ) t2 = vf(t2), w2--;
              for (; 0 < u2 - w2; ) x2 = vf(x2), u2--;
              for (; w2--; ) {
                if (t2 === x2 || null !== x2 && t2 === x2.alternate) break b;
                t2 = vf(t2);
                x2 = vf(x2);
              }
              t2 = null;
            }
            else t2 = null;
            null !== k3 && wf(g3, h3, k3, t2, false);
            null !== n2 && null !== J2 && wf(g3, J2, n2, t2, true);
          }
        }
      }
      a: {
        h3 = d3 ? ue(d3) : window;
        k3 = h3.nodeName && h3.nodeName.toLowerCase();
        if ("select" === k3 || "input" === k3 && "file" === h3.type) var na = ve;
        else if (me(h3)) if (we) na = Fe;
        else {
          na = De;
          var xa = Ce;
        }
        else (k3 = h3.nodeName) && "input" === k3.toLowerCase() && ("checkbox" === h3.type || "radio" === h3.type) && (na = Ee);
        if (na && (na = na(a, d3))) {
          ne(g3, na, c2, e3);
          break a;
        }
        xa && xa(a, h3, d3);
        "focusout" === a && (xa = h3._wrapperState) && xa.controlled && "number" === h3.type && cb(h3, "number", h3.value);
      }
      xa = d3 ? ue(d3) : window;
      switch (a) {
        case "focusin":
          if (me(xa) || "true" === xa.contentEditable) Qe = xa, Re = d3, Se = null;
          break;
        case "focusout":
          Se = Re = Qe = null;
          break;
        case "mousedown":
          Te = true;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          Te = false;
          Ue(g3, c2, e3);
          break;
        case "selectionchange":
          if (Pe) break;
        case "keydown":
        case "keyup":
          Ue(g3, c2, e3);
      }
      var $a;
      if (ae) b: {
        switch (a) {
          case "compositionstart":
            var ba = "onCompositionStart";
            break b;
          case "compositionend":
            ba = "onCompositionEnd";
            break b;
          case "compositionupdate":
            ba = "onCompositionUpdate";
            break b;
        }
        ba = void 0;
      }
      else ie ? ge(a, c2) && (ba = "onCompositionEnd") : "keydown" === a && 229 === c2.keyCode && (ba = "onCompositionStart");
      ba && (de && "ko" !== c2.locale && (ie || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie && ($a = nd()) : (kd = e3, ld = "value" in kd ? kd.value : kd.textContent, ie = true)), xa = oe(d3, ba), 0 < xa.length && (ba = new Ld(ba, a, null, c2, e3), g3.push({ event: ba, listeners: xa }), $a ? ba.data = $a : ($a = he(c2), null !== $a && (ba.data = $a))));
      if ($a = ce ? je(a, c2) : ke(a, c2)) d3 = oe(d3, "onBeforeInput"), 0 < d3.length && (e3 = new Ld("onBeforeInput", "beforeinput", null, c2, e3), g3.push({ event: e3, listeners: d3 }), e3.data = $a);
    }
    se(g3, b2);
  });
}
function tf(a, b2, c2) {
  return { instance: a, listener: b2, currentTarget: c2 };
}
function oe(a, b2) {
  for (var c2 = b2 + "Capture", d2 = []; null !== a; ) {
    var e2 = a, f2 = e2.stateNode;
    5 === e2.tag && null !== f2 && (e2 = f2, f2 = Kb(a, c2), null != f2 && d2.unshift(tf(a, f2, e2)), f2 = Kb(a, b2), null != f2 && d2.push(tf(a, f2, e2)));
    a = a.return;
  }
  return d2;
}
function vf(a) {
  if (null === a) return null;
  do
    a = a.return;
  while (a && 5 !== a.tag);
  return a ? a : null;
}
function wf(a, b2, c2, d2, e2) {
  for (var f2 = b2._reactName, g2 = []; null !== c2 && c2 !== d2; ) {
    var h2 = c2, k2 = h2.alternate, l2 = h2.stateNode;
    if (null !== k2 && k2 === d2) break;
    5 === h2.tag && null !== l2 && (h2 = l2, e2 ? (k2 = Kb(c2, f2), null != k2 && g2.unshift(tf(c2, k2, h2))) : e2 || (k2 = Kb(c2, f2), null != k2 && g2.push(tf(c2, k2, h2))));
    c2 = c2.return;
  }
  0 !== g2.length && a.push({ event: b2, listeners: g2 });
}
var xf = /\r\n?/g, yf = /\u0000|\uFFFD/g;
function zf(a) {
  return ("string" === typeof a ? a : "" + a).replace(xf, "\n").replace(yf, "");
}
function Af(a, b2, c2) {
  b2 = zf(b2);
  if (zf(a) !== b2 && c2) throw Error(p$1(425));
}
function Bf() {
}
var Cf = null, Df = null;
function Ef(a, b2) {
  return "textarea" === a || "noscript" === a || "string" === typeof b2.children || "number" === typeof b2.children || "object" === typeof b2.dangerouslySetInnerHTML && null !== b2.dangerouslySetInnerHTML && null != b2.dangerouslySetInnerHTML.__html;
}
var Ff = "function" === typeof setTimeout ? setTimeout : void 0, Gf = "function" === typeof clearTimeout ? clearTimeout : void 0, Hf = "function" === typeof Promise ? Promise : void 0, Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a) {
  return Hf.resolve(null).then(a).catch(If);
} : Ff;
function If(a) {
  setTimeout(function() {
    throw a;
  });
}
function Kf(a, b2) {
  var c2 = b2, d2 = 0;
  do {
    var e2 = c2.nextSibling;
    a.removeChild(c2);
    if (e2 && 8 === e2.nodeType) if (c2 = e2.data, "/$" === c2) {
      if (0 === d2) {
        a.removeChild(e2);
        bd(b2);
        return;
      }
      d2--;
    } else "$" !== c2 && "$?" !== c2 && "$!" !== c2 || d2++;
    c2 = e2;
  } while (c2);
  bd(b2);
}
function Lf(a) {
  for (; null != a; a = a.nextSibling) {
    var b2 = a.nodeType;
    if (1 === b2 || 3 === b2) break;
    if (8 === b2) {
      b2 = a.data;
      if ("$" === b2 || "$!" === b2 || "$?" === b2) break;
      if ("/$" === b2) return null;
    }
  }
  return a;
}
function Mf(a) {
  a = a.previousSibling;
  for (var b2 = 0; a; ) {
    if (8 === a.nodeType) {
      var c2 = a.data;
      if ("$" === c2 || "$!" === c2 || "$?" === c2) {
        if (0 === b2) return a;
        b2--;
      } else "/$" === c2 && b2++;
    }
    a = a.previousSibling;
  }
  return null;
}
var Nf = Math.random().toString(36).slice(2), Of = "__reactFiber$" + Nf, Pf = "__reactProps$" + Nf, uf = "__reactContainer$" + Nf, of = "__reactEvents$" + Nf, Qf = "__reactListeners$" + Nf, Rf = "__reactHandles$" + Nf;
function Wc(a) {
  var b2 = a[Of];
  if (b2) return b2;
  for (var c2 = a.parentNode; c2; ) {
    if (b2 = c2[uf] || c2[Of]) {
      c2 = b2.alternate;
      if (null !== b2.child || null !== c2 && null !== c2.child) for (a = Mf(a); null !== a; ) {
        if (c2 = a[Of]) return c2;
        a = Mf(a);
      }
      return b2;
    }
    a = c2;
    c2 = a.parentNode;
  }
  return null;
}
function Cb(a) {
  a = a[Of] || a[uf];
  return !a || 5 !== a.tag && 6 !== a.tag && 13 !== a.tag && 3 !== a.tag ? null : a;
}
function ue(a) {
  if (5 === a.tag || 6 === a.tag) return a.stateNode;
  throw Error(p$1(33));
}
function Db(a) {
  return a[Pf] || null;
}
var Sf = [], Tf = -1;
function Uf(a) {
  return { current: a };
}
function E$2(a) {
  0 > Tf || (a.current = Sf[Tf], Sf[Tf] = null, Tf--);
}
function G(a, b2) {
  Tf++;
  Sf[Tf] = a.current;
  a.current = b2;
}
var Vf = {}, H = Uf(Vf), Wf = Uf(false), Xf = Vf;
function Yf(a, b2) {
  var c2 = a.type.contextTypes;
  if (!c2) return Vf;
  var d2 = a.stateNode;
  if (d2 && d2.__reactInternalMemoizedUnmaskedChildContext === b2) return d2.__reactInternalMemoizedMaskedChildContext;
  var e2 = {}, f2;
  for (f2 in c2) e2[f2] = b2[f2];
  d2 && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b2, a.__reactInternalMemoizedMaskedChildContext = e2);
  return e2;
}
function Zf(a) {
  a = a.childContextTypes;
  return null !== a && void 0 !== a;
}
function $f() {
  E$2(Wf);
  E$2(H);
}
function ag(a, b2, c2) {
  if (H.current !== Vf) throw Error(p$1(168));
  G(H, b2);
  G(Wf, c2);
}
function bg(a, b2, c2) {
  var d2 = a.stateNode;
  b2 = b2.childContextTypes;
  if ("function" !== typeof d2.getChildContext) return c2;
  d2 = d2.getChildContext();
  for (var e2 in d2) if (!(e2 in b2)) throw Error(p$1(108, Ra(a) || "Unknown", e2));
  return A$1({}, c2, d2);
}
function cg(a) {
  a = (a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext || Vf;
  Xf = H.current;
  G(H, a);
  G(Wf, Wf.current);
  return true;
}
function dg(a, b2, c2) {
  var d2 = a.stateNode;
  if (!d2) throw Error(p$1(169));
  c2 ? (a = bg(a, b2, Xf), d2.__reactInternalMemoizedMergedChildContext = a, E$2(Wf), E$2(H), G(H, a)) : E$2(Wf);
  G(Wf, c2);
}
var eg = null, fg = false, gg = false;
function hg(a) {
  null === eg ? eg = [a] : eg.push(a);
}
function ig(a) {
  fg = true;
  hg(a);
}
function jg() {
  if (!gg && null !== eg) {
    gg = true;
    var a = 0, b2 = C;
    try {
      var c2 = eg;
      for (C = 1; a < c2.length; a++) {
        var d2 = c2[a];
        do
          d2 = d2(true);
        while (null !== d2);
      }
      eg = null;
      fg = false;
    } catch (e2) {
      throw null !== eg && (eg = eg.slice(a + 1)), ac(fc, jg), e2;
    } finally {
      C = b2, gg = false;
    }
  }
  return null;
}
var kg = [], lg = 0, mg = null, ng = 0, og = [], pg = 0, qg = null, rg = 1, sg = "";
function tg(a, b2) {
  kg[lg++] = ng;
  kg[lg++] = mg;
  mg = a;
  ng = b2;
}
function ug(a, b2, c2) {
  og[pg++] = rg;
  og[pg++] = sg;
  og[pg++] = qg;
  qg = a;
  var d2 = rg;
  a = sg;
  var e2 = 32 - oc(d2) - 1;
  d2 &= ~(1 << e2);
  c2 += 1;
  var f2 = 32 - oc(b2) + e2;
  if (30 < f2) {
    var g2 = e2 - e2 % 5;
    f2 = (d2 & (1 << g2) - 1).toString(32);
    d2 >>= g2;
    e2 -= g2;
    rg = 1 << 32 - oc(b2) + e2 | c2 << e2 | d2;
    sg = f2 + a;
  } else rg = 1 << f2 | c2 << e2 | d2, sg = a;
}
function vg(a) {
  null !== a.return && (tg(a, 1), ug(a, 1, 0));
}
function wg(a) {
  for (; a === mg; ) mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
  for (; a === qg; ) qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
}
var xg = null, yg = null, I = false, zg = null;
function Ag(a, b2) {
  var c2 = Bg(5, null, null, 0);
  c2.elementType = "DELETED";
  c2.stateNode = b2;
  c2.return = a;
  b2 = a.deletions;
  null === b2 ? (a.deletions = [c2], a.flags |= 16) : b2.push(c2);
}
function Cg(a, b2) {
  switch (a.tag) {
    case 5:
      var c2 = a.type;
      b2 = 1 !== b2.nodeType || c2.toLowerCase() !== b2.nodeName.toLowerCase() ? null : b2;
      return null !== b2 ? (a.stateNode = b2, xg = a, yg = Lf(b2.firstChild), true) : false;
    case 6:
      return b2 = "" === a.pendingProps || 3 !== b2.nodeType ? null : b2, null !== b2 ? (a.stateNode = b2, xg = a, yg = null, true) : false;
    case 13:
      return b2 = 8 !== b2.nodeType ? null : b2, null !== b2 ? (c2 = null !== qg ? { id: rg, overflow: sg } : null, a.memoizedState = { dehydrated: b2, treeContext: c2, retryLane: 1073741824 }, c2 = Bg(18, null, null, 0), c2.stateNode = b2, c2.return = a, a.child = c2, xg = a, yg = null, true) : false;
    default:
      return false;
  }
}
function Dg(a) {
  return 0 !== (a.mode & 1) && 0 === (a.flags & 128);
}
function Eg(a) {
  if (I) {
    var b2 = yg;
    if (b2) {
      var c2 = b2;
      if (!Cg(a, b2)) {
        if (Dg(a)) throw Error(p$1(418));
        b2 = Lf(c2.nextSibling);
        var d2 = xg;
        b2 && Cg(a, b2) ? Ag(d2, c2) : (a.flags = a.flags & -4097 | 2, I = false, xg = a);
      }
    } else {
      if (Dg(a)) throw Error(p$1(418));
      a.flags = a.flags & -4097 | 2;
      I = false;
      xg = a;
    }
  }
}
function Fg(a) {
  for (a = a.return; null !== a && 5 !== a.tag && 3 !== a.tag && 13 !== a.tag; ) a = a.return;
  xg = a;
}
function Gg(a) {
  if (a !== xg) return false;
  if (!I) return Fg(a), I = true, false;
  var b2;
  (b2 = 3 !== a.tag) && !(b2 = 5 !== a.tag) && (b2 = a.type, b2 = "head" !== b2 && "body" !== b2 && !Ef(a.type, a.memoizedProps));
  if (b2 && (b2 = yg)) {
    if (Dg(a)) throw Hg(), Error(p$1(418));
    for (; b2; ) Ag(a, b2), b2 = Lf(b2.nextSibling);
  }
  Fg(a);
  if (13 === a.tag) {
    a = a.memoizedState;
    a = null !== a ? a.dehydrated : null;
    if (!a) throw Error(p$1(317));
    a: {
      a = a.nextSibling;
      for (b2 = 0; a; ) {
        if (8 === a.nodeType) {
          var c2 = a.data;
          if ("/$" === c2) {
            if (0 === b2) {
              yg = Lf(a.nextSibling);
              break a;
            }
            b2--;
          } else "$" !== c2 && "$!" !== c2 && "$?" !== c2 || b2++;
        }
        a = a.nextSibling;
      }
      yg = null;
    }
  } else yg = xg ? Lf(a.stateNode.nextSibling) : null;
  return true;
}
function Hg() {
  for (var a = yg; a; ) a = Lf(a.nextSibling);
}
function Ig() {
  yg = xg = null;
  I = false;
}
function Jg(a) {
  null === zg ? zg = [a] : zg.push(a);
}
var Kg = ua.ReactCurrentBatchConfig;
function Lg(a, b2, c2) {
  a = c2.ref;
  if (null !== a && "function" !== typeof a && "object" !== typeof a) {
    if (c2._owner) {
      c2 = c2._owner;
      if (c2) {
        if (1 !== c2.tag) throw Error(p$1(309));
        var d2 = c2.stateNode;
      }
      if (!d2) throw Error(p$1(147, a));
      var e2 = d2, f2 = "" + a;
      if (null !== b2 && null !== b2.ref && "function" === typeof b2.ref && b2.ref._stringRef === f2) return b2.ref;
      b2 = function(a2) {
        var b3 = e2.refs;
        null === a2 ? delete b3[f2] : b3[f2] = a2;
      };
      b2._stringRef = f2;
      return b2;
    }
    if ("string" !== typeof a) throw Error(p$1(284));
    if (!c2._owner) throw Error(p$1(290, a));
  }
  return a;
}
function Mg(a, b2) {
  a = Object.prototype.toString.call(b2);
  throw Error(p$1(31, "[object Object]" === a ? "object with keys {" + Object.keys(b2).join(", ") + "}" : a));
}
function Ng(a) {
  var b2 = a._init;
  return b2(a._payload);
}
function Og(a) {
  function b2(b3, c3) {
    if (a) {
      var d3 = b3.deletions;
      null === d3 ? (b3.deletions = [c3], b3.flags |= 16) : d3.push(c3);
    }
  }
  function c2(c3, d3) {
    if (!a) return null;
    for (; null !== d3; ) b2(c3, d3), d3 = d3.sibling;
    return null;
  }
  function d2(a2, b3) {
    for (a2 = /* @__PURE__ */ new Map(); null !== b3; ) null !== b3.key ? a2.set(b3.key, b3) : a2.set(b3.index, b3), b3 = b3.sibling;
    return a2;
  }
  function e2(a2, b3) {
    a2 = Pg(a2, b3);
    a2.index = 0;
    a2.sibling = null;
    return a2;
  }
  function f2(b3, c3, d3) {
    b3.index = d3;
    if (!a) return b3.flags |= 1048576, c3;
    d3 = b3.alternate;
    if (null !== d3) return d3 = d3.index, d3 < c3 ? (b3.flags |= 2, c3) : d3;
    b3.flags |= 2;
    return c3;
  }
  function g2(b3) {
    a && null === b3.alternate && (b3.flags |= 2);
    return b3;
  }
  function h2(a2, b3, c3, d3) {
    if (null === b3 || 6 !== b3.tag) return b3 = Qg(c3, a2.mode, d3), b3.return = a2, b3;
    b3 = e2(b3, c3);
    b3.return = a2;
    return b3;
  }
  function k2(a2, b3, c3, d3) {
    var f3 = c3.type;
    if (f3 === ya) return m2(a2, b3, c3.props.children, d3, c3.key);
    if (null !== b3 && (b3.elementType === f3 || "object" === typeof f3 && null !== f3 && f3.$$typeof === Ha && Ng(f3) === b3.type)) return d3 = e2(b3, c3.props), d3.ref = Lg(a2, b3, c3), d3.return = a2, d3;
    d3 = Rg(c3.type, c3.key, c3.props, null, a2.mode, d3);
    d3.ref = Lg(a2, b3, c3);
    d3.return = a2;
    return d3;
  }
  function l2(a2, b3, c3, d3) {
    if (null === b3 || 4 !== b3.tag || b3.stateNode.containerInfo !== c3.containerInfo || b3.stateNode.implementation !== c3.implementation) return b3 = Sg(c3, a2.mode, d3), b3.return = a2, b3;
    b3 = e2(b3, c3.children || []);
    b3.return = a2;
    return b3;
  }
  function m2(a2, b3, c3, d3, f3) {
    if (null === b3 || 7 !== b3.tag) return b3 = Tg(c3, a2.mode, d3, f3), b3.return = a2, b3;
    b3 = e2(b3, c3);
    b3.return = a2;
    return b3;
  }
  function q2(a2, b3, c3) {
    if ("string" === typeof b3 && "" !== b3 || "number" === typeof b3) return b3 = Qg("" + b3, a2.mode, c3), b3.return = a2, b3;
    if ("object" === typeof b3 && null !== b3) {
      switch (b3.$$typeof) {
        case va:
          return c3 = Rg(b3.type, b3.key, b3.props, null, a2.mode, c3), c3.ref = Lg(a2, null, b3), c3.return = a2, c3;
        case wa:
          return b3 = Sg(b3, a2.mode, c3), b3.return = a2, b3;
        case Ha:
          var d3 = b3._init;
          return q2(a2, d3(b3._payload), c3);
      }
      if (eb(b3) || Ka(b3)) return b3 = Tg(b3, a2.mode, c3, null), b3.return = a2, b3;
      Mg(a2, b3);
    }
    return null;
  }
  function r2(a2, b3, c3, d3) {
    var e3 = null !== b3 ? b3.key : null;
    if ("string" === typeof c3 && "" !== c3 || "number" === typeof c3) return null !== e3 ? null : h2(a2, b3, "" + c3, d3);
    if ("object" === typeof c3 && null !== c3) {
      switch (c3.$$typeof) {
        case va:
          return c3.key === e3 ? k2(a2, b3, c3, d3) : null;
        case wa:
          return c3.key === e3 ? l2(a2, b3, c3, d3) : null;
        case Ha:
          return e3 = c3._init, r2(
            a2,
            b3,
            e3(c3._payload),
            d3
          );
      }
      if (eb(c3) || Ka(c3)) return null !== e3 ? null : m2(a2, b3, c3, d3, null);
      Mg(a2, c3);
    }
    return null;
  }
  function y2(a2, b3, c3, d3, e3) {
    if ("string" === typeof d3 && "" !== d3 || "number" === typeof d3) return a2 = a2.get(c3) || null, h2(b3, a2, "" + d3, e3);
    if ("object" === typeof d3 && null !== d3) {
      switch (d3.$$typeof) {
        case va:
          return a2 = a2.get(null === d3.key ? c3 : d3.key) || null, k2(b3, a2, d3, e3);
        case wa:
          return a2 = a2.get(null === d3.key ? c3 : d3.key) || null, l2(b3, a2, d3, e3);
        case Ha:
          var f3 = d3._init;
          return y2(a2, b3, c3, f3(d3._payload), e3);
      }
      if (eb(d3) || Ka(d3)) return a2 = a2.get(c3) || null, m2(b3, a2, d3, e3, null);
      Mg(b3, d3);
    }
    return null;
  }
  function n2(e3, g3, h3, k3) {
    for (var l3 = null, m3 = null, u2 = g3, w2 = g3 = 0, x2 = null; null !== u2 && w2 < h3.length; w2++) {
      u2.index > w2 ? (x2 = u2, u2 = null) : x2 = u2.sibling;
      var n3 = r2(e3, u2, h3[w2], k3);
      if (null === n3) {
        null === u2 && (u2 = x2);
        break;
      }
      a && u2 && null === n3.alternate && b2(e3, u2);
      g3 = f2(n3, g3, w2);
      null === m3 ? l3 = n3 : m3.sibling = n3;
      m3 = n3;
      u2 = x2;
    }
    if (w2 === h3.length) return c2(e3, u2), I && tg(e3, w2), l3;
    if (null === u2) {
      for (; w2 < h3.length; w2++) u2 = q2(e3, h3[w2], k3), null !== u2 && (g3 = f2(u2, g3, w2), null === m3 ? l3 = u2 : m3.sibling = u2, m3 = u2);
      I && tg(e3, w2);
      return l3;
    }
    for (u2 = d2(e3, u2); w2 < h3.length; w2++) x2 = y2(u2, e3, w2, h3[w2], k3), null !== x2 && (a && null !== x2.alternate && u2.delete(null === x2.key ? w2 : x2.key), g3 = f2(x2, g3, w2), null === m3 ? l3 = x2 : m3.sibling = x2, m3 = x2);
    a && u2.forEach(function(a2) {
      return b2(e3, a2);
    });
    I && tg(e3, w2);
    return l3;
  }
  function t2(e3, g3, h3, k3) {
    var l3 = Ka(h3);
    if ("function" !== typeof l3) throw Error(p$1(150));
    h3 = l3.call(h3);
    if (null == h3) throw Error(p$1(151));
    for (var u2 = l3 = null, m3 = g3, w2 = g3 = 0, x2 = null, n3 = h3.next(); null !== m3 && !n3.done; w2++, n3 = h3.next()) {
      m3.index > w2 ? (x2 = m3, m3 = null) : x2 = m3.sibling;
      var t3 = r2(e3, m3, n3.value, k3);
      if (null === t3) {
        null === m3 && (m3 = x2);
        break;
      }
      a && m3 && null === t3.alternate && b2(e3, m3);
      g3 = f2(t3, g3, w2);
      null === u2 ? l3 = t3 : u2.sibling = t3;
      u2 = t3;
      m3 = x2;
    }
    if (n3.done) return c2(
      e3,
      m3
    ), I && tg(e3, w2), l3;
    if (null === m3) {
      for (; !n3.done; w2++, n3 = h3.next()) n3 = q2(e3, n3.value, k3), null !== n3 && (g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
      I && tg(e3, w2);
      return l3;
    }
    for (m3 = d2(e3, m3); !n3.done; w2++, n3 = h3.next()) n3 = y2(m3, e3, w2, n3.value, k3), null !== n3 && (a && null !== n3.alternate && m3.delete(null === n3.key ? w2 : n3.key), g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
    a && m3.forEach(function(a2) {
      return b2(e3, a2);
    });
    I && tg(e3, w2);
    return l3;
  }
  function J2(a2, d3, f3, h3) {
    "object" === typeof f3 && null !== f3 && f3.type === ya && null === f3.key && (f3 = f3.props.children);
    if ("object" === typeof f3 && null !== f3) {
      switch (f3.$$typeof) {
        case va:
          a: {
            for (var k3 = f3.key, l3 = d3; null !== l3; ) {
              if (l3.key === k3) {
                k3 = f3.type;
                if (k3 === ya) {
                  if (7 === l3.tag) {
                    c2(a2, l3.sibling);
                    d3 = e2(l3, f3.props.children);
                    d3.return = a2;
                    a2 = d3;
                    break a;
                  }
                } else if (l3.elementType === k3 || "object" === typeof k3 && null !== k3 && k3.$$typeof === Ha && Ng(k3) === l3.type) {
                  c2(a2, l3.sibling);
                  d3 = e2(l3, f3.props);
                  d3.ref = Lg(a2, l3, f3);
                  d3.return = a2;
                  a2 = d3;
                  break a;
                }
                c2(a2, l3);
                break;
              } else b2(a2, l3);
              l3 = l3.sibling;
            }
            f3.type === ya ? (d3 = Tg(f3.props.children, a2.mode, h3, f3.key), d3.return = a2, a2 = d3) : (h3 = Rg(f3.type, f3.key, f3.props, null, a2.mode, h3), h3.ref = Lg(a2, d3, f3), h3.return = a2, a2 = h3);
          }
          return g2(a2);
        case wa:
          a: {
            for (l3 = f3.key; null !== d3; ) {
              if (d3.key === l3) if (4 === d3.tag && d3.stateNode.containerInfo === f3.containerInfo && d3.stateNode.implementation === f3.implementation) {
                c2(a2, d3.sibling);
                d3 = e2(d3, f3.children || []);
                d3.return = a2;
                a2 = d3;
                break a;
              } else {
                c2(a2, d3);
                break;
              }
              else b2(a2, d3);
              d3 = d3.sibling;
            }
            d3 = Sg(f3, a2.mode, h3);
            d3.return = a2;
            a2 = d3;
          }
          return g2(a2);
        case Ha:
          return l3 = f3._init, J2(a2, d3, l3(f3._payload), h3);
      }
      if (eb(f3)) return n2(a2, d3, f3, h3);
      if (Ka(f3)) return t2(a2, d3, f3, h3);
      Mg(a2, f3);
    }
    return "string" === typeof f3 && "" !== f3 || "number" === typeof f3 ? (f3 = "" + f3, null !== d3 && 6 === d3.tag ? (c2(a2, d3.sibling), d3 = e2(d3, f3), d3.return = a2, a2 = d3) : (c2(a2, d3), d3 = Qg(f3, a2.mode, h3), d3.return = a2, a2 = d3), g2(a2)) : c2(a2, d3);
  }
  return J2;
}
var Ug = Og(true), Vg = Og(false), Wg = Uf(null), Xg = null, Yg = null, Zg = null;
function $g() {
  Zg = Yg = Xg = null;
}
function ah(a) {
  var b2 = Wg.current;
  E$2(Wg);
  a._currentValue = b2;
}
function bh(a, b2, c2) {
  for (; null !== a; ) {
    var d2 = a.alternate;
    (a.childLanes & b2) !== b2 ? (a.childLanes |= b2, null !== d2 && (d2.childLanes |= b2)) : null !== d2 && (d2.childLanes & b2) !== b2 && (d2.childLanes |= b2);
    if (a === c2) break;
    a = a.return;
  }
}
function ch(a, b2) {
  Xg = a;
  Zg = Yg = null;
  a = a.dependencies;
  null !== a && null !== a.firstContext && (0 !== (a.lanes & b2) && (dh = true), a.firstContext = null);
}
function eh(a) {
  var b2 = a._currentValue;
  if (Zg !== a) if (a = { context: a, memoizedValue: b2, next: null }, null === Yg) {
    if (null === Xg) throw Error(p$1(308));
    Yg = a;
    Xg.dependencies = { lanes: 0, firstContext: a };
  } else Yg = Yg.next = a;
  return b2;
}
var fh = null;
function gh(a) {
  null === fh ? fh = [a] : fh.push(a);
}
function hh(a, b2, c2, d2) {
  var e2 = b2.interleaved;
  null === e2 ? (c2.next = c2, gh(b2)) : (c2.next = e2.next, e2.next = c2);
  b2.interleaved = c2;
  return ih(a, d2);
}
function ih(a, b2) {
  a.lanes |= b2;
  var c2 = a.alternate;
  null !== c2 && (c2.lanes |= b2);
  c2 = a;
  for (a = a.return; null !== a; ) a.childLanes |= b2, c2 = a.alternate, null !== c2 && (c2.childLanes |= b2), c2 = a, a = a.return;
  return 3 === c2.tag ? c2.stateNode : null;
}
var jh = false;
function kh(a) {
  a.updateQueue = { baseState: a.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
}
function lh(a, b2) {
  a = a.updateQueue;
  b2.updateQueue === a && (b2.updateQueue = { baseState: a.baseState, firstBaseUpdate: a.firstBaseUpdate, lastBaseUpdate: a.lastBaseUpdate, shared: a.shared, effects: a.effects });
}
function mh(a, b2) {
  return { eventTime: a, lane: b2, tag: 0, payload: null, callback: null, next: null };
}
function nh(a, b2, c2) {
  var d2 = a.updateQueue;
  if (null === d2) return null;
  d2 = d2.shared;
  if (0 !== (K & 2)) {
    var e2 = d2.pending;
    null === e2 ? b2.next = b2 : (b2.next = e2.next, e2.next = b2);
    d2.pending = b2;
    return ih(a, c2);
  }
  e2 = d2.interleaved;
  null === e2 ? (b2.next = b2, gh(d2)) : (b2.next = e2.next, e2.next = b2);
  d2.interleaved = b2;
  return ih(a, c2);
}
function oh(a, b2, c2) {
  b2 = b2.updateQueue;
  if (null !== b2 && (b2 = b2.shared, 0 !== (c2 & 4194240))) {
    var d2 = b2.lanes;
    d2 &= a.pendingLanes;
    c2 |= d2;
    b2.lanes = c2;
    Cc(a, c2);
  }
}
function ph(a, b2) {
  var c2 = a.updateQueue, d2 = a.alternate;
  if (null !== d2 && (d2 = d2.updateQueue, c2 === d2)) {
    var e2 = null, f2 = null;
    c2 = c2.firstBaseUpdate;
    if (null !== c2) {
      do {
        var g2 = { eventTime: c2.eventTime, lane: c2.lane, tag: c2.tag, payload: c2.payload, callback: c2.callback, next: null };
        null === f2 ? e2 = f2 = g2 : f2 = f2.next = g2;
        c2 = c2.next;
      } while (null !== c2);
      null === f2 ? e2 = f2 = b2 : f2 = f2.next = b2;
    } else e2 = f2 = b2;
    c2 = { baseState: d2.baseState, firstBaseUpdate: e2, lastBaseUpdate: f2, shared: d2.shared, effects: d2.effects };
    a.updateQueue = c2;
    return;
  }
  a = c2.lastBaseUpdate;
  null === a ? c2.firstBaseUpdate = b2 : a.next = b2;
  c2.lastBaseUpdate = b2;
}
function qh(a, b2, c2, d2) {
  var e2 = a.updateQueue;
  jh = false;
  var f2 = e2.firstBaseUpdate, g2 = e2.lastBaseUpdate, h2 = e2.shared.pending;
  if (null !== h2) {
    e2.shared.pending = null;
    var k2 = h2, l2 = k2.next;
    k2.next = null;
    null === g2 ? f2 = l2 : g2.next = l2;
    g2 = k2;
    var m2 = a.alternate;
    null !== m2 && (m2 = m2.updateQueue, h2 = m2.lastBaseUpdate, h2 !== g2 && (null === h2 ? m2.firstBaseUpdate = l2 : h2.next = l2, m2.lastBaseUpdate = k2));
  }
  if (null !== f2) {
    var q2 = e2.baseState;
    g2 = 0;
    m2 = l2 = k2 = null;
    h2 = f2;
    do {
      var r2 = h2.lane, y2 = h2.eventTime;
      if ((d2 & r2) === r2) {
        null !== m2 && (m2 = m2.next = {
          eventTime: y2,
          lane: 0,
          tag: h2.tag,
          payload: h2.payload,
          callback: h2.callback,
          next: null
        });
        a: {
          var n2 = a, t2 = h2;
          r2 = b2;
          y2 = c2;
          switch (t2.tag) {
            case 1:
              n2 = t2.payload;
              if ("function" === typeof n2) {
                q2 = n2.call(y2, q2, r2);
                break a;
              }
              q2 = n2;
              break a;
            case 3:
              n2.flags = n2.flags & -65537 | 128;
            case 0:
              n2 = t2.payload;
              r2 = "function" === typeof n2 ? n2.call(y2, q2, r2) : n2;
              if (null === r2 || void 0 === r2) break a;
              q2 = A$1({}, q2, r2);
              break a;
            case 2:
              jh = true;
          }
        }
        null !== h2.callback && 0 !== h2.lane && (a.flags |= 64, r2 = e2.effects, null === r2 ? e2.effects = [h2] : r2.push(h2));
      } else y2 = { eventTime: y2, lane: r2, tag: h2.tag, payload: h2.payload, callback: h2.callback, next: null }, null === m2 ? (l2 = m2 = y2, k2 = q2) : m2 = m2.next = y2, g2 |= r2;
      h2 = h2.next;
      if (null === h2) if (h2 = e2.shared.pending, null === h2) break;
      else r2 = h2, h2 = r2.next, r2.next = null, e2.lastBaseUpdate = r2, e2.shared.pending = null;
    } while (1);
    null === m2 && (k2 = q2);
    e2.baseState = k2;
    e2.firstBaseUpdate = l2;
    e2.lastBaseUpdate = m2;
    b2 = e2.shared.interleaved;
    if (null !== b2) {
      e2 = b2;
      do
        g2 |= e2.lane, e2 = e2.next;
      while (e2 !== b2);
    } else null === f2 && (e2.shared.lanes = 0);
    rh |= g2;
    a.lanes = g2;
    a.memoizedState = q2;
  }
}
function sh(a, b2, c2) {
  a = b2.effects;
  b2.effects = null;
  if (null !== a) for (b2 = 0; b2 < a.length; b2++) {
    var d2 = a[b2], e2 = d2.callback;
    if (null !== e2) {
      d2.callback = null;
      d2 = c2;
      if ("function" !== typeof e2) throw Error(p$1(191, e2));
      e2.call(d2);
    }
  }
}
var th = {}, uh = Uf(th), vh = Uf(th), wh = Uf(th);
function xh(a) {
  if (a === th) throw Error(p$1(174));
  return a;
}
function yh(a, b2) {
  G(wh, b2);
  G(vh, a);
  G(uh, th);
  a = b2.nodeType;
  switch (a) {
    case 9:
    case 11:
      b2 = (b2 = b2.documentElement) ? b2.namespaceURI : lb(null, "");
      break;
    default:
      a = 8 === a ? b2.parentNode : b2, b2 = a.namespaceURI || null, a = a.tagName, b2 = lb(b2, a);
  }
  E$2(uh);
  G(uh, b2);
}
function zh() {
  E$2(uh);
  E$2(vh);
  E$2(wh);
}
function Ah(a) {
  xh(wh.current);
  var b2 = xh(uh.current);
  var c2 = lb(b2, a.type);
  b2 !== c2 && (G(vh, a), G(uh, c2));
}
function Bh(a) {
  vh.current === a && (E$2(uh), E$2(vh));
}
var L = Uf(0);
function Ch(a) {
  for (var b2 = a; null !== b2; ) {
    if (13 === b2.tag) {
      var c2 = b2.memoizedState;
      if (null !== c2 && (c2 = c2.dehydrated, null === c2 || "$?" === c2.data || "$!" === c2.data)) return b2;
    } else if (19 === b2.tag && void 0 !== b2.memoizedProps.revealOrder) {
      if (0 !== (b2.flags & 128)) return b2;
    } else if (null !== b2.child) {
      b2.child.return = b2;
      b2 = b2.child;
      continue;
    }
    if (b2 === a) break;
    for (; null === b2.sibling; ) {
      if (null === b2.return || b2.return === a) return null;
      b2 = b2.return;
    }
    b2.sibling.return = b2.return;
    b2 = b2.sibling;
  }
  return null;
}
var Dh = [];
function Eh() {
  for (var a = 0; a < Dh.length; a++) Dh[a]._workInProgressVersionPrimary = null;
  Dh.length = 0;
}
var Fh = ua.ReactCurrentDispatcher, Gh = ua.ReactCurrentBatchConfig, Hh = 0, M = null, N = null, O = null, Ih = false, Jh = false, Kh = 0, Lh = 0;
function P() {
  throw Error(p$1(321));
}
function Mh(a, b2) {
  if (null === b2) return false;
  for (var c2 = 0; c2 < b2.length && c2 < a.length; c2++) if (!He(a[c2], b2[c2])) return false;
  return true;
}
function Nh(a, b2, c2, d2, e2, f2) {
  Hh = f2;
  M = b2;
  b2.memoizedState = null;
  b2.updateQueue = null;
  b2.lanes = 0;
  Fh.current = null === a || null === a.memoizedState ? Oh : Ph;
  a = c2(d2, e2);
  if (Jh) {
    f2 = 0;
    do {
      Jh = false;
      Kh = 0;
      if (25 <= f2) throw Error(p$1(301));
      f2 += 1;
      O = N = null;
      b2.updateQueue = null;
      Fh.current = Qh;
      a = c2(d2, e2);
    } while (Jh);
  }
  Fh.current = Rh;
  b2 = null !== N && null !== N.next;
  Hh = 0;
  O = N = M = null;
  Ih = false;
  if (b2) throw Error(p$1(300));
  return a;
}
function Sh() {
  var a = 0 !== Kh;
  Kh = 0;
  return a;
}
function Th() {
  var a = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
  null === O ? M.memoizedState = O = a : O = O.next = a;
  return O;
}
function Uh() {
  if (null === N) {
    var a = M.alternate;
    a = null !== a ? a.memoizedState : null;
  } else a = N.next;
  var b2 = null === O ? M.memoizedState : O.next;
  if (null !== b2) O = b2, N = a;
  else {
    if (null === a) throw Error(p$1(310));
    N = a;
    a = { memoizedState: N.memoizedState, baseState: N.baseState, baseQueue: N.baseQueue, queue: N.queue, next: null };
    null === O ? M.memoizedState = O = a : O = O.next = a;
  }
  return O;
}
function Vh(a, b2) {
  return "function" === typeof b2 ? b2(a) : b2;
}
function Wh(a) {
  var b2 = Uh(), c2 = b2.queue;
  if (null === c2) throw Error(p$1(311));
  c2.lastRenderedReducer = a;
  var d2 = N, e2 = d2.baseQueue, f2 = c2.pending;
  if (null !== f2) {
    if (null !== e2) {
      var g2 = e2.next;
      e2.next = f2.next;
      f2.next = g2;
    }
    d2.baseQueue = e2 = f2;
    c2.pending = null;
  }
  if (null !== e2) {
    f2 = e2.next;
    d2 = d2.baseState;
    var h2 = g2 = null, k2 = null, l2 = f2;
    do {
      var m2 = l2.lane;
      if ((Hh & m2) === m2) null !== k2 && (k2 = k2.next = { lane: 0, action: l2.action, hasEagerState: l2.hasEagerState, eagerState: l2.eagerState, next: null }), d2 = l2.hasEagerState ? l2.eagerState : a(d2, l2.action);
      else {
        var q2 = {
          lane: m2,
          action: l2.action,
          hasEagerState: l2.hasEagerState,
          eagerState: l2.eagerState,
          next: null
        };
        null === k2 ? (h2 = k2 = q2, g2 = d2) : k2 = k2.next = q2;
        M.lanes |= m2;
        rh |= m2;
      }
      l2 = l2.next;
    } while (null !== l2 && l2 !== f2);
    null === k2 ? g2 = d2 : k2.next = h2;
    He(d2, b2.memoizedState) || (dh = true);
    b2.memoizedState = d2;
    b2.baseState = g2;
    b2.baseQueue = k2;
    c2.lastRenderedState = d2;
  }
  a = c2.interleaved;
  if (null !== a) {
    e2 = a;
    do
      f2 = e2.lane, M.lanes |= f2, rh |= f2, e2 = e2.next;
    while (e2 !== a);
  } else null === e2 && (c2.lanes = 0);
  return [b2.memoizedState, c2.dispatch];
}
function Xh(a) {
  var b2 = Uh(), c2 = b2.queue;
  if (null === c2) throw Error(p$1(311));
  c2.lastRenderedReducer = a;
  var d2 = c2.dispatch, e2 = c2.pending, f2 = b2.memoizedState;
  if (null !== e2) {
    c2.pending = null;
    var g2 = e2 = e2.next;
    do
      f2 = a(f2, g2.action), g2 = g2.next;
    while (g2 !== e2);
    He(f2, b2.memoizedState) || (dh = true);
    b2.memoizedState = f2;
    null === b2.baseQueue && (b2.baseState = f2);
    c2.lastRenderedState = f2;
  }
  return [f2, d2];
}
function Yh() {
}
function Zh(a, b2) {
  var c2 = M, d2 = Uh(), e2 = b2(), f2 = !He(d2.memoizedState, e2);
  f2 && (d2.memoizedState = e2, dh = true);
  d2 = d2.queue;
  $h(ai.bind(null, c2, d2, a), [a]);
  if (d2.getSnapshot !== b2 || f2 || null !== O && O.memoizedState.tag & 1) {
    c2.flags |= 2048;
    bi(9, ci.bind(null, c2, d2, e2, b2), void 0, null);
    if (null === Q) throw Error(p$1(349));
    0 !== (Hh & 30) || di(c2, b2, e2);
  }
  return e2;
}
function di(a, b2, c2) {
  a.flags |= 16384;
  a = { getSnapshot: b2, value: c2 };
  b2 = M.updateQueue;
  null === b2 ? (b2 = { lastEffect: null, stores: null }, M.updateQueue = b2, b2.stores = [a]) : (c2 = b2.stores, null === c2 ? b2.stores = [a] : c2.push(a));
}
function ci(a, b2, c2, d2) {
  b2.value = c2;
  b2.getSnapshot = d2;
  ei(b2) && fi(a);
}
function ai(a, b2, c2) {
  return c2(function() {
    ei(b2) && fi(a);
  });
}
function ei(a) {
  var b2 = a.getSnapshot;
  a = a.value;
  try {
    var c2 = b2();
    return !He(a, c2);
  } catch (d2) {
    return true;
  }
}
function fi(a) {
  var b2 = ih(a, 1);
  null !== b2 && gi(b2, a, 1, -1);
}
function hi$1(a) {
  var b2 = Th();
  "function" === typeof a && (a = a());
  b2.memoizedState = b2.baseState = a;
  a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Vh, lastRenderedState: a };
  b2.queue = a;
  a = a.dispatch = ii.bind(null, M, a);
  return [b2.memoizedState, a];
}
function bi(a, b2, c2, d2) {
  a = { tag: a, create: b2, destroy: c2, deps: d2, next: null };
  b2 = M.updateQueue;
  null === b2 ? (b2 = { lastEffect: null, stores: null }, M.updateQueue = b2, b2.lastEffect = a.next = a) : (c2 = b2.lastEffect, null === c2 ? b2.lastEffect = a.next = a : (d2 = c2.next, c2.next = a, a.next = d2, b2.lastEffect = a));
  return a;
}
function ji() {
  return Uh().memoizedState;
}
function ki(a, b2, c2, d2) {
  var e2 = Th();
  M.flags |= a;
  e2.memoizedState = bi(1 | b2, c2, void 0, void 0 === d2 ? null : d2);
}
function li(a, b2, c2, d2) {
  var e2 = Uh();
  d2 = void 0 === d2 ? null : d2;
  var f2 = void 0;
  if (null !== N) {
    var g2 = N.memoizedState;
    f2 = g2.destroy;
    if (null !== d2 && Mh(d2, g2.deps)) {
      e2.memoizedState = bi(b2, c2, f2, d2);
      return;
    }
  }
  M.flags |= a;
  e2.memoizedState = bi(1 | b2, c2, f2, d2);
}
function mi(a, b2) {
  return ki(8390656, 8, a, b2);
}
function $h(a, b2) {
  return li(2048, 8, a, b2);
}
function ni(a, b2) {
  return li(4, 2, a, b2);
}
function oi(a, b2) {
  return li(4, 4, a, b2);
}
function pi(a, b2) {
  if ("function" === typeof b2) return a = a(), b2(a), function() {
    b2(null);
  };
  if (null !== b2 && void 0 !== b2) return a = a(), b2.current = a, function() {
    b2.current = null;
  };
}
function qi(a, b2, c2) {
  c2 = null !== c2 && void 0 !== c2 ? c2.concat([a]) : null;
  return li(4, 4, pi.bind(null, b2, a), c2);
}
function ri() {
}
function si(a, b2) {
  var c2 = Uh();
  b2 = void 0 === b2 ? null : b2;
  var d2 = c2.memoizedState;
  if (null !== d2 && null !== b2 && Mh(b2, d2[1])) return d2[0];
  c2.memoizedState = [a, b2];
  return a;
}
function ti(a, b2) {
  var c2 = Uh();
  b2 = void 0 === b2 ? null : b2;
  var d2 = c2.memoizedState;
  if (null !== d2 && null !== b2 && Mh(b2, d2[1])) return d2[0];
  a = a();
  c2.memoizedState = [a, b2];
  return a;
}
function ui(a, b2, c2) {
  if (0 === (Hh & 21)) return a.baseState && (a.baseState = false, dh = true), a.memoizedState = c2;
  He(c2, b2) || (c2 = yc(), M.lanes |= c2, rh |= c2, a.baseState = true);
  return b2;
}
function vi(a, b2) {
  var c2 = C;
  C = 0 !== c2 && 4 > c2 ? c2 : 4;
  a(true);
  var d2 = Gh.transition;
  Gh.transition = {};
  try {
    a(false), b2();
  } finally {
    C = c2, Gh.transition = d2;
  }
}
function wi() {
  return Uh().memoizedState;
}
function xi(a, b2, c2) {
  var d2 = yi(a);
  c2 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
  if (zi(a)) Ai(b2, c2);
  else if (c2 = hh(a, b2, c2, d2), null !== c2) {
    var e2 = R();
    gi(c2, a, d2, e2);
    Bi(c2, b2, d2);
  }
}
function ii(a, b2, c2) {
  var d2 = yi(a), e2 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
  if (zi(a)) Ai(b2, e2);
  else {
    var f2 = a.alternate;
    if (0 === a.lanes && (null === f2 || 0 === f2.lanes) && (f2 = b2.lastRenderedReducer, null !== f2)) try {
      var g2 = b2.lastRenderedState, h2 = f2(g2, c2);
      e2.hasEagerState = true;
      e2.eagerState = h2;
      if (He(h2, g2)) {
        var k2 = b2.interleaved;
        null === k2 ? (e2.next = e2, gh(b2)) : (e2.next = k2.next, k2.next = e2);
        b2.interleaved = e2;
        return;
      }
    } catch (l2) {
    } finally {
    }
    c2 = hh(a, b2, e2, d2);
    null !== c2 && (e2 = R(), gi(c2, a, d2, e2), Bi(c2, b2, d2));
  }
}
function zi(a) {
  var b2 = a.alternate;
  return a === M || null !== b2 && b2 === M;
}
function Ai(a, b2) {
  Jh = Ih = true;
  var c2 = a.pending;
  null === c2 ? b2.next = b2 : (b2.next = c2.next, c2.next = b2);
  a.pending = b2;
}
function Bi(a, b2, c2) {
  if (0 !== (c2 & 4194240)) {
    var d2 = b2.lanes;
    d2 &= a.pendingLanes;
    c2 |= d2;
    b2.lanes = c2;
    Cc(a, c2);
  }
}
var Rh = { readContext: eh, useCallback: P, useContext: P, useEffect: P, useImperativeHandle: P, useInsertionEffect: P, useLayoutEffect: P, useMemo: P, useReducer: P, useRef: P, useState: P, useDebugValue: P, useDeferredValue: P, useTransition: P, useMutableSource: P, useSyncExternalStore: P, useId: P, unstable_isNewReconciler: false }, Oh = { readContext: eh, useCallback: function(a, b2) {
  Th().memoizedState = [a, void 0 === b2 ? null : b2];
  return a;
}, useContext: eh, useEffect: mi, useImperativeHandle: function(a, b2, c2) {
  c2 = null !== c2 && void 0 !== c2 ? c2.concat([a]) : null;
  return ki(
    4194308,
    4,
    pi.bind(null, b2, a),
    c2
  );
}, useLayoutEffect: function(a, b2) {
  return ki(4194308, 4, a, b2);
}, useInsertionEffect: function(a, b2) {
  return ki(4, 2, a, b2);
}, useMemo: function(a, b2) {
  var c2 = Th();
  b2 = void 0 === b2 ? null : b2;
  a = a();
  c2.memoizedState = [a, b2];
  return a;
}, useReducer: function(a, b2, c2) {
  var d2 = Th();
  b2 = void 0 !== c2 ? c2(b2) : b2;
  d2.memoizedState = d2.baseState = b2;
  a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a, lastRenderedState: b2 };
  d2.queue = a;
  a = a.dispatch = xi.bind(null, M, a);
  return [d2.memoizedState, a];
}, useRef: function(a) {
  var b2 = Th();
  a = { current: a };
  return b2.memoizedState = a;
}, useState: hi$1, useDebugValue: ri, useDeferredValue: function(a) {
  return Th().memoizedState = a;
}, useTransition: function() {
  var a = hi$1(false), b2 = a[0];
  a = vi.bind(null, a[1]);
  Th().memoizedState = a;
  return [b2, a];
}, useMutableSource: function() {
}, useSyncExternalStore: function(a, b2, c2) {
  var d2 = M, e2 = Th();
  if (I) {
    if (void 0 === c2) throw Error(p$1(407));
    c2 = c2();
  } else {
    c2 = b2();
    if (null === Q) throw Error(p$1(349));
    0 !== (Hh & 30) || di(d2, b2, c2);
  }
  e2.memoizedState = c2;
  var f2 = { value: c2, getSnapshot: b2 };
  e2.queue = f2;
  mi(ai.bind(
    null,
    d2,
    f2,
    a
  ), [a]);
  d2.flags |= 2048;
  bi(9, ci.bind(null, d2, f2, c2, b2), void 0, null);
  return c2;
}, useId: function() {
  var a = Th(), b2 = Q.identifierPrefix;
  if (I) {
    var c2 = sg;
    var d2 = rg;
    c2 = (d2 & ~(1 << 32 - oc(d2) - 1)).toString(32) + c2;
    b2 = ":" + b2 + "R" + c2;
    c2 = Kh++;
    0 < c2 && (b2 += "H" + c2.toString(32));
    b2 += ":";
  } else c2 = Lh++, b2 = ":" + b2 + "r" + c2.toString(32) + ":";
  return a.memoizedState = b2;
}, unstable_isNewReconciler: false }, Ph = {
  readContext: eh,
  useCallback: si,
  useContext: eh,
  useEffect: $h,
  useImperativeHandle: qi,
  useInsertionEffect: ni,
  useLayoutEffect: oi,
  useMemo: ti,
  useReducer: Wh,
  useRef: ji,
  useState: function() {
    return Wh(Vh);
  },
  useDebugValue: ri,
  useDeferredValue: function(a) {
    var b2 = Uh();
    return ui(b2, N.memoizedState, a);
  },
  useTransition: function() {
    var a = Wh(Vh)[0], b2 = Uh().memoizedState;
    return [a, b2];
  },
  useMutableSource: Yh,
  useSyncExternalStore: Zh,
  useId: wi,
  unstable_isNewReconciler: false
}, Qh = { readContext: eh, useCallback: si, useContext: eh, useEffect: $h, useImperativeHandle: qi, useInsertionEffect: ni, useLayoutEffect: oi, useMemo: ti, useReducer: Xh, useRef: ji, useState: function() {
  return Xh(Vh);
}, useDebugValue: ri, useDeferredValue: function(a) {
  var b2 = Uh();
  return null === N ? b2.memoizedState = a : ui(b2, N.memoizedState, a);
}, useTransition: function() {
  var a = Xh(Vh)[0], b2 = Uh().memoizedState;
  return [a, b2];
}, useMutableSource: Yh, useSyncExternalStore: Zh, useId: wi, unstable_isNewReconciler: false };
function Ci(a, b2) {
  if (a && a.defaultProps) {
    b2 = A$1({}, b2);
    a = a.defaultProps;
    for (var c2 in a) void 0 === b2[c2] && (b2[c2] = a[c2]);
    return b2;
  }
  return b2;
}
function Di(a, b2, c2, d2) {
  b2 = a.memoizedState;
  c2 = c2(d2, b2);
  c2 = null === c2 || void 0 === c2 ? b2 : A$1({}, b2, c2);
  a.memoizedState = c2;
  0 === a.lanes && (a.updateQueue.baseState = c2);
}
var Ei = { isMounted: function(a) {
  return (a = a._reactInternals) ? Vb(a) === a : false;
}, enqueueSetState: function(a, b2, c2) {
  a = a._reactInternals;
  var d2 = R(), e2 = yi(a), f2 = mh(d2, e2);
  f2.payload = b2;
  void 0 !== c2 && null !== c2 && (f2.callback = c2);
  b2 = nh(a, f2, e2);
  null !== b2 && (gi(b2, a, e2, d2), oh(b2, a, e2));
}, enqueueReplaceState: function(a, b2, c2) {
  a = a._reactInternals;
  var d2 = R(), e2 = yi(a), f2 = mh(d2, e2);
  f2.tag = 1;
  f2.payload = b2;
  void 0 !== c2 && null !== c2 && (f2.callback = c2);
  b2 = nh(a, f2, e2);
  null !== b2 && (gi(b2, a, e2, d2), oh(b2, a, e2));
}, enqueueForceUpdate: function(a, b2) {
  a = a._reactInternals;
  var c2 = R(), d2 = yi(a), e2 = mh(c2, d2);
  e2.tag = 2;
  void 0 !== b2 && null !== b2 && (e2.callback = b2);
  b2 = nh(a, e2, d2);
  null !== b2 && (gi(b2, a, d2, c2), oh(b2, a, d2));
} };
function Fi(a, b2, c2, d2, e2, f2, g2) {
  a = a.stateNode;
  return "function" === typeof a.shouldComponentUpdate ? a.shouldComponentUpdate(d2, f2, g2) : b2.prototype && b2.prototype.isPureReactComponent ? !Ie(c2, d2) || !Ie(e2, f2) : true;
}
function Gi(a, b2, c2) {
  var d2 = false, e2 = Vf;
  var f2 = b2.contextType;
  "object" === typeof f2 && null !== f2 ? f2 = eh(f2) : (e2 = Zf(b2) ? Xf : H.current, d2 = b2.contextTypes, f2 = (d2 = null !== d2 && void 0 !== d2) ? Yf(a, e2) : Vf);
  b2 = new b2(c2, f2);
  a.memoizedState = null !== b2.state && void 0 !== b2.state ? b2.state : null;
  b2.updater = Ei;
  a.stateNode = b2;
  b2._reactInternals = a;
  d2 && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = e2, a.__reactInternalMemoizedMaskedChildContext = f2);
  return b2;
}
function Hi(a, b2, c2, d2) {
  a = b2.state;
  "function" === typeof b2.componentWillReceiveProps && b2.componentWillReceiveProps(c2, d2);
  "function" === typeof b2.UNSAFE_componentWillReceiveProps && b2.UNSAFE_componentWillReceiveProps(c2, d2);
  b2.state !== a && Ei.enqueueReplaceState(b2, b2.state, null);
}
function Ii(a, b2, c2, d2) {
  var e2 = a.stateNode;
  e2.props = c2;
  e2.state = a.memoizedState;
  e2.refs = {};
  kh(a);
  var f2 = b2.contextType;
  "object" === typeof f2 && null !== f2 ? e2.context = eh(f2) : (f2 = Zf(b2) ? Xf : H.current, e2.context = Yf(a, f2));
  e2.state = a.memoizedState;
  f2 = b2.getDerivedStateFromProps;
  "function" === typeof f2 && (Di(a, b2, f2, c2), e2.state = a.memoizedState);
  "function" === typeof b2.getDerivedStateFromProps || "function" === typeof e2.getSnapshotBeforeUpdate || "function" !== typeof e2.UNSAFE_componentWillMount && "function" !== typeof e2.componentWillMount || (b2 = e2.state, "function" === typeof e2.componentWillMount && e2.componentWillMount(), "function" === typeof e2.UNSAFE_componentWillMount && e2.UNSAFE_componentWillMount(), b2 !== e2.state && Ei.enqueueReplaceState(e2, e2.state, null), qh(a, c2, e2, d2), e2.state = a.memoizedState);
  "function" === typeof e2.componentDidMount && (a.flags |= 4194308);
}
function Ji(a, b2) {
  try {
    var c2 = "", d2 = b2;
    do
      c2 += Pa(d2), d2 = d2.return;
    while (d2);
    var e2 = c2;
  } catch (f2) {
    e2 = "\nError generating stack: " + f2.message + "\n" + f2.stack;
  }
  return { value: a, source: b2, stack: e2, digest: null };
}
function Ki(a, b2, c2) {
  return { value: a, source: null, stack: null != c2 ? c2 : null, digest: null != b2 ? b2 : null };
}
function Li(a, b2) {
  try {
    console.error(b2.value);
  } catch (c2) {
    setTimeout(function() {
      throw c2;
    });
  }
}
var Mi = "function" === typeof WeakMap ? WeakMap : Map;
function Ni(a, b2, c2) {
  c2 = mh(-1, c2);
  c2.tag = 3;
  c2.payload = { element: null };
  var d2 = b2.value;
  c2.callback = function() {
    Oi || (Oi = true, Pi = d2);
    Li(a, b2);
  };
  return c2;
}
function Qi(a, b2, c2) {
  c2 = mh(-1, c2);
  c2.tag = 3;
  var d2 = a.type.getDerivedStateFromError;
  if ("function" === typeof d2) {
    var e2 = b2.value;
    c2.payload = function() {
      return d2(e2);
    };
    c2.callback = function() {
      Li(a, b2);
    };
  }
  var f2 = a.stateNode;
  null !== f2 && "function" === typeof f2.componentDidCatch && (c2.callback = function() {
    Li(a, b2);
    "function" !== typeof d2 && (null === Ri ? Ri = /* @__PURE__ */ new Set([this]) : Ri.add(this));
    var c3 = b2.stack;
    this.componentDidCatch(b2.value, { componentStack: null !== c3 ? c3 : "" });
  });
  return c2;
}
function Si(a, b2, c2) {
  var d2 = a.pingCache;
  if (null === d2) {
    d2 = a.pingCache = new Mi();
    var e2 = /* @__PURE__ */ new Set();
    d2.set(b2, e2);
  } else e2 = d2.get(b2), void 0 === e2 && (e2 = /* @__PURE__ */ new Set(), d2.set(b2, e2));
  e2.has(c2) || (e2.add(c2), a = Ti.bind(null, a, b2, c2), b2.then(a, a));
}
function Ui(a) {
  do {
    var b2;
    if (b2 = 13 === a.tag) b2 = a.memoizedState, b2 = null !== b2 ? null !== b2.dehydrated ? true : false : true;
    if (b2) return a;
    a = a.return;
  } while (null !== a);
  return null;
}
function Vi(a, b2, c2, d2, e2) {
  if (0 === (a.mode & 1)) return a === b2 ? a.flags |= 65536 : (a.flags |= 128, c2.flags |= 131072, c2.flags &= -52805, 1 === c2.tag && (null === c2.alternate ? c2.tag = 17 : (b2 = mh(-1, 1), b2.tag = 2, nh(c2, b2, 1))), c2.lanes |= 1), a;
  a.flags |= 65536;
  a.lanes = e2;
  return a;
}
var Wi = ua.ReactCurrentOwner, dh = false;
function Xi(a, b2, c2, d2) {
  b2.child = null === a ? Vg(b2, null, c2, d2) : Ug(b2, a.child, c2, d2);
}
function Yi(a, b2, c2, d2, e2) {
  c2 = c2.render;
  var f2 = b2.ref;
  ch(b2, e2);
  d2 = Nh(a, b2, c2, d2, f2, e2);
  c2 = Sh();
  if (null !== a && !dh) return b2.updateQueue = a.updateQueue, b2.flags &= -2053, a.lanes &= ~e2, Zi(a, b2, e2);
  I && c2 && vg(b2);
  b2.flags |= 1;
  Xi(a, b2, d2, e2);
  return b2.child;
}
function $i(a, b2, c2, d2, e2) {
  if (null === a) {
    var f2 = c2.type;
    if ("function" === typeof f2 && !aj(f2) && void 0 === f2.defaultProps && null === c2.compare && void 0 === c2.defaultProps) return b2.tag = 15, b2.type = f2, bj(a, b2, f2, d2, e2);
    a = Rg(c2.type, null, d2, b2, b2.mode, e2);
    a.ref = b2.ref;
    a.return = b2;
    return b2.child = a;
  }
  f2 = a.child;
  if (0 === (a.lanes & e2)) {
    var g2 = f2.memoizedProps;
    c2 = c2.compare;
    c2 = null !== c2 ? c2 : Ie;
    if (c2(g2, d2) && a.ref === b2.ref) return Zi(a, b2, e2);
  }
  b2.flags |= 1;
  a = Pg(f2, d2);
  a.ref = b2.ref;
  a.return = b2;
  return b2.child = a;
}
function bj(a, b2, c2, d2, e2) {
  if (null !== a) {
    var f2 = a.memoizedProps;
    if (Ie(f2, d2) && a.ref === b2.ref) if (dh = false, b2.pendingProps = d2 = f2, 0 !== (a.lanes & e2)) 0 !== (a.flags & 131072) && (dh = true);
    else return b2.lanes = a.lanes, Zi(a, b2, e2);
  }
  return cj(a, b2, c2, d2, e2);
}
function dj(a, b2, c2) {
  var d2 = b2.pendingProps, e2 = d2.children, f2 = null !== a ? a.memoizedState : null;
  if ("hidden" === d2.mode) if (0 === (b2.mode & 1)) b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G(ej, fj), fj |= c2;
  else {
    if (0 === (c2 & 1073741824)) return a = null !== f2 ? f2.baseLanes | c2 : c2, b2.lanes = b2.childLanes = 1073741824, b2.memoizedState = { baseLanes: a, cachePool: null, transitions: null }, b2.updateQueue = null, G(ej, fj), fj |= a, null;
    b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
    d2 = null !== f2 ? f2.baseLanes : c2;
    G(ej, fj);
    fj |= d2;
  }
  else null !== f2 ? (d2 = f2.baseLanes | c2, b2.memoizedState = null) : d2 = c2, G(ej, fj), fj |= d2;
  Xi(a, b2, e2, c2);
  return b2.child;
}
function gj(a, b2) {
  var c2 = b2.ref;
  if (null === a && null !== c2 || null !== a && a.ref !== c2) b2.flags |= 512, b2.flags |= 2097152;
}
function cj(a, b2, c2, d2, e2) {
  var f2 = Zf(c2) ? Xf : H.current;
  f2 = Yf(b2, f2);
  ch(b2, e2);
  c2 = Nh(a, b2, c2, d2, f2, e2);
  d2 = Sh();
  if (null !== a && !dh) return b2.updateQueue = a.updateQueue, b2.flags &= -2053, a.lanes &= ~e2, Zi(a, b2, e2);
  I && d2 && vg(b2);
  b2.flags |= 1;
  Xi(a, b2, c2, e2);
  return b2.child;
}
function hj(a, b2, c2, d2, e2) {
  if (Zf(c2)) {
    var f2 = true;
    cg(b2);
  } else f2 = false;
  ch(b2, e2);
  if (null === b2.stateNode) ij(a, b2), Gi(b2, c2, d2), Ii(b2, c2, d2, e2), d2 = true;
  else if (null === a) {
    var g2 = b2.stateNode, h2 = b2.memoizedProps;
    g2.props = h2;
    var k2 = g2.context, l2 = c2.contextType;
    "object" === typeof l2 && null !== l2 ? l2 = eh(l2) : (l2 = Zf(c2) ? Xf : H.current, l2 = Yf(b2, l2));
    var m2 = c2.getDerivedStateFromProps, q2 = "function" === typeof m2 || "function" === typeof g2.getSnapshotBeforeUpdate;
    q2 || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== d2 || k2 !== l2) && Hi(b2, g2, d2, l2);
    jh = false;
    var r2 = b2.memoizedState;
    g2.state = r2;
    qh(b2, d2, g2, e2);
    k2 = b2.memoizedState;
    h2 !== d2 || r2 !== k2 || Wf.current || jh ? ("function" === typeof m2 && (Di(b2, c2, m2, d2), k2 = b2.memoizedState), (h2 = jh || Fi(b2, c2, h2, d2, r2, k2, l2)) ? (q2 || "function" !== typeof g2.UNSAFE_componentWillMount && "function" !== typeof g2.componentWillMount || ("function" === typeof g2.componentWillMount && g2.componentWillMount(), "function" === typeof g2.UNSAFE_componentWillMount && g2.UNSAFE_componentWillMount()), "function" === typeof g2.componentDidMount && (b2.flags |= 4194308)) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), b2.memoizedProps = d2, b2.memoizedState = k2), g2.props = d2, g2.state = k2, g2.context = l2, d2 = h2) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), d2 = false);
  } else {
    g2 = b2.stateNode;
    lh(a, b2);
    h2 = b2.memoizedProps;
    l2 = b2.type === b2.elementType ? h2 : Ci(b2.type, h2);
    g2.props = l2;
    q2 = b2.pendingProps;
    r2 = g2.context;
    k2 = c2.contextType;
    "object" === typeof k2 && null !== k2 ? k2 = eh(k2) : (k2 = Zf(c2) ? Xf : H.current, k2 = Yf(b2, k2));
    var y2 = c2.getDerivedStateFromProps;
    (m2 = "function" === typeof y2 || "function" === typeof g2.getSnapshotBeforeUpdate) || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== q2 || r2 !== k2) && Hi(b2, g2, d2, k2);
    jh = false;
    r2 = b2.memoizedState;
    g2.state = r2;
    qh(b2, d2, g2, e2);
    var n2 = b2.memoizedState;
    h2 !== q2 || r2 !== n2 || Wf.current || jh ? ("function" === typeof y2 && (Di(b2, c2, y2, d2), n2 = b2.memoizedState), (l2 = jh || Fi(b2, c2, l2, d2, r2, n2, k2) || false) ? (m2 || "function" !== typeof g2.UNSAFE_componentWillUpdate && "function" !== typeof g2.componentWillUpdate || ("function" === typeof g2.componentWillUpdate && g2.componentWillUpdate(d2, n2, k2), "function" === typeof g2.UNSAFE_componentWillUpdate && g2.UNSAFE_componentWillUpdate(d2, n2, k2)), "function" === typeof g2.componentDidUpdate && (b2.flags |= 4), "function" === typeof g2.getSnapshotBeforeUpdate && (b2.flags |= 1024)) : ("function" !== typeof g2.componentDidUpdate || h2 === a.memoizedProps && r2 === a.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a.memoizedProps && r2 === a.memoizedState || (b2.flags |= 1024), b2.memoizedProps = d2, b2.memoizedState = n2), g2.props = d2, g2.state = n2, g2.context = k2, d2 = l2) : ("function" !== typeof g2.componentDidUpdate || h2 === a.memoizedProps && r2 === a.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a.memoizedProps && r2 === a.memoizedState || (b2.flags |= 1024), d2 = false);
  }
  return jj(a, b2, c2, d2, f2, e2);
}
function jj(a, b2, c2, d2, e2, f2) {
  gj(a, b2);
  var g2 = 0 !== (b2.flags & 128);
  if (!d2 && !g2) return e2 && dg(b2, c2, false), Zi(a, b2, f2);
  d2 = b2.stateNode;
  Wi.current = b2;
  var h2 = g2 && "function" !== typeof c2.getDerivedStateFromError ? null : d2.render();
  b2.flags |= 1;
  null !== a && g2 ? (b2.child = Ug(b2, a.child, null, f2), b2.child = Ug(b2, null, h2, f2)) : Xi(a, b2, h2, f2);
  b2.memoizedState = d2.state;
  e2 && dg(b2, c2, true);
  return b2.child;
}
function kj(a) {
  var b2 = a.stateNode;
  b2.pendingContext ? ag(a, b2.pendingContext, b2.pendingContext !== b2.context) : b2.context && ag(a, b2.context, false);
  yh(a, b2.containerInfo);
}
function lj(a, b2, c2, d2, e2) {
  Ig();
  Jg(e2);
  b2.flags |= 256;
  Xi(a, b2, c2, d2);
  return b2.child;
}
var mj = { dehydrated: null, treeContext: null, retryLane: 0 };
function nj(a) {
  return { baseLanes: a, cachePool: null, transitions: null };
}
function oj(a, b2, c2) {
  var d2 = b2.pendingProps, e2 = L.current, f2 = false, g2 = 0 !== (b2.flags & 128), h2;
  (h2 = g2) || (h2 = null !== a && null === a.memoizedState ? false : 0 !== (e2 & 2));
  if (h2) f2 = true, b2.flags &= -129;
  else if (null === a || null !== a.memoizedState) e2 |= 1;
  G(L, e2 & 1);
  if (null === a) {
    Eg(b2);
    a = b2.memoizedState;
    if (null !== a && (a = a.dehydrated, null !== a)) return 0 === (b2.mode & 1) ? b2.lanes = 1 : "$!" === a.data ? b2.lanes = 8 : b2.lanes = 1073741824, null;
    g2 = d2.children;
    a = d2.fallback;
    return f2 ? (d2 = b2.mode, f2 = b2.child, g2 = { mode: "hidden", children: g2 }, 0 === (d2 & 1) && null !== f2 ? (f2.childLanes = 0, f2.pendingProps = g2) : f2 = pj(g2, d2, 0, null), a = Tg(a, d2, c2, null), f2.return = b2, a.return = b2, f2.sibling = a, b2.child = f2, b2.child.memoizedState = nj(c2), b2.memoizedState = mj, a) : qj(b2, g2);
  }
  e2 = a.memoizedState;
  if (null !== e2 && (h2 = e2.dehydrated, null !== h2)) return rj(a, b2, g2, d2, h2, e2, c2);
  if (f2) {
    f2 = d2.fallback;
    g2 = b2.mode;
    e2 = a.child;
    h2 = e2.sibling;
    var k2 = { mode: "hidden", children: d2.children };
    0 === (g2 & 1) && b2.child !== e2 ? (d2 = b2.child, d2.childLanes = 0, d2.pendingProps = k2, b2.deletions = null) : (d2 = Pg(e2, k2), d2.subtreeFlags = e2.subtreeFlags & 14680064);
    null !== h2 ? f2 = Pg(h2, f2) : (f2 = Tg(f2, g2, c2, null), f2.flags |= 2);
    f2.return = b2;
    d2.return = b2;
    d2.sibling = f2;
    b2.child = d2;
    d2 = f2;
    f2 = b2.child;
    g2 = a.child.memoizedState;
    g2 = null === g2 ? nj(c2) : { baseLanes: g2.baseLanes | c2, cachePool: null, transitions: g2.transitions };
    f2.memoizedState = g2;
    f2.childLanes = a.childLanes & ~c2;
    b2.memoizedState = mj;
    return d2;
  }
  f2 = a.child;
  a = f2.sibling;
  d2 = Pg(f2, { mode: "visible", children: d2.children });
  0 === (b2.mode & 1) && (d2.lanes = c2);
  d2.return = b2;
  d2.sibling = null;
  null !== a && (c2 = b2.deletions, null === c2 ? (b2.deletions = [a], b2.flags |= 16) : c2.push(a));
  b2.child = d2;
  b2.memoizedState = null;
  return d2;
}
function qj(a, b2) {
  b2 = pj({ mode: "visible", children: b2 }, a.mode, 0, null);
  b2.return = a;
  return a.child = b2;
}
function sj(a, b2, c2, d2) {
  null !== d2 && Jg(d2);
  Ug(b2, a.child, null, c2);
  a = qj(b2, b2.pendingProps.children);
  a.flags |= 2;
  b2.memoizedState = null;
  return a;
}
function rj(a, b2, c2, d2, e2, f2, g2) {
  if (c2) {
    if (b2.flags & 256) return b2.flags &= -257, d2 = Ki(Error(p$1(422))), sj(a, b2, g2, d2);
    if (null !== b2.memoizedState) return b2.child = a.child, b2.flags |= 128, null;
    f2 = d2.fallback;
    e2 = b2.mode;
    d2 = pj({ mode: "visible", children: d2.children }, e2, 0, null);
    f2 = Tg(f2, e2, g2, null);
    f2.flags |= 2;
    d2.return = b2;
    f2.return = b2;
    d2.sibling = f2;
    b2.child = d2;
    0 !== (b2.mode & 1) && Ug(b2, a.child, null, g2);
    b2.child.memoizedState = nj(g2);
    b2.memoizedState = mj;
    return f2;
  }
  if (0 === (b2.mode & 1)) return sj(a, b2, g2, null);
  if ("$!" === e2.data) {
    d2 = e2.nextSibling && e2.nextSibling.dataset;
    if (d2) var h2 = d2.dgst;
    d2 = h2;
    f2 = Error(p$1(419));
    d2 = Ki(f2, d2, void 0);
    return sj(a, b2, g2, d2);
  }
  h2 = 0 !== (g2 & a.childLanes);
  if (dh || h2) {
    d2 = Q;
    if (null !== d2) {
      switch (g2 & -g2) {
        case 4:
          e2 = 2;
          break;
        case 16:
          e2 = 8;
          break;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          e2 = 32;
          break;
        case 536870912:
          e2 = 268435456;
          break;
        default:
          e2 = 0;
      }
      e2 = 0 !== (e2 & (d2.suspendedLanes | g2)) ? 0 : e2;
      0 !== e2 && e2 !== f2.retryLane && (f2.retryLane = e2, ih(a, e2), gi(d2, a, e2, -1));
    }
    tj();
    d2 = Ki(Error(p$1(421)));
    return sj(a, b2, g2, d2);
  }
  if ("$?" === e2.data) return b2.flags |= 128, b2.child = a.child, b2 = uj.bind(null, a), e2._reactRetry = b2, null;
  a = f2.treeContext;
  yg = Lf(e2.nextSibling);
  xg = b2;
  I = true;
  zg = null;
  null !== a && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a.id, sg = a.overflow, qg = b2);
  b2 = qj(b2, d2.children);
  b2.flags |= 4096;
  return b2;
}
function vj(a, b2, c2) {
  a.lanes |= b2;
  var d2 = a.alternate;
  null !== d2 && (d2.lanes |= b2);
  bh(a.return, b2, c2);
}
function wj(a, b2, c2, d2, e2) {
  var f2 = a.memoizedState;
  null === f2 ? a.memoizedState = { isBackwards: b2, rendering: null, renderingStartTime: 0, last: d2, tail: c2, tailMode: e2 } : (f2.isBackwards = b2, f2.rendering = null, f2.renderingStartTime = 0, f2.last = d2, f2.tail = c2, f2.tailMode = e2);
}
function xj(a, b2, c2) {
  var d2 = b2.pendingProps, e2 = d2.revealOrder, f2 = d2.tail;
  Xi(a, b2, d2.children, c2);
  d2 = L.current;
  if (0 !== (d2 & 2)) d2 = d2 & 1 | 2, b2.flags |= 128;
  else {
    if (null !== a && 0 !== (a.flags & 128)) a: for (a = b2.child; null !== a; ) {
      if (13 === a.tag) null !== a.memoizedState && vj(a, c2, b2);
      else if (19 === a.tag) vj(a, c2, b2);
      else if (null !== a.child) {
        a.child.return = a;
        a = a.child;
        continue;
      }
      if (a === b2) break a;
      for (; null === a.sibling; ) {
        if (null === a.return || a.return === b2) break a;
        a = a.return;
      }
      a.sibling.return = a.return;
      a = a.sibling;
    }
    d2 &= 1;
  }
  G(L, d2);
  if (0 === (b2.mode & 1)) b2.memoizedState = null;
  else switch (e2) {
    case "forwards":
      c2 = b2.child;
      for (e2 = null; null !== c2; ) a = c2.alternate, null !== a && null === Ch(a) && (e2 = c2), c2 = c2.sibling;
      c2 = e2;
      null === c2 ? (e2 = b2.child, b2.child = null) : (e2 = c2.sibling, c2.sibling = null);
      wj(b2, false, e2, c2, f2);
      break;
    case "backwards":
      c2 = null;
      e2 = b2.child;
      for (b2.child = null; null !== e2; ) {
        a = e2.alternate;
        if (null !== a && null === Ch(a)) {
          b2.child = e2;
          break;
        }
        a = e2.sibling;
        e2.sibling = c2;
        c2 = e2;
        e2 = a;
      }
      wj(b2, true, c2, null, f2);
      break;
    case "together":
      wj(b2, false, null, null, void 0);
      break;
    default:
      b2.memoizedState = null;
  }
  return b2.child;
}
function ij(a, b2) {
  0 === (b2.mode & 1) && null !== a && (a.alternate = null, b2.alternate = null, b2.flags |= 2);
}
function Zi(a, b2, c2) {
  null !== a && (b2.dependencies = a.dependencies);
  rh |= b2.lanes;
  if (0 === (c2 & b2.childLanes)) return null;
  if (null !== a && b2.child !== a.child) throw Error(p$1(153));
  if (null !== b2.child) {
    a = b2.child;
    c2 = Pg(a, a.pendingProps);
    b2.child = c2;
    for (c2.return = b2; null !== a.sibling; ) a = a.sibling, c2 = c2.sibling = Pg(a, a.pendingProps), c2.return = b2;
    c2.sibling = null;
  }
  return b2.child;
}
function yj(a, b2, c2) {
  switch (b2.tag) {
    case 3:
      kj(b2);
      Ig();
      break;
    case 5:
      Ah(b2);
      break;
    case 1:
      Zf(b2.type) && cg(b2);
      break;
    case 4:
      yh(b2, b2.stateNode.containerInfo);
      break;
    case 10:
      var d2 = b2.type._context, e2 = b2.memoizedProps.value;
      G(Wg, d2._currentValue);
      d2._currentValue = e2;
      break;
    case 13:
      d2 = b2.memoizedState;
      if (null !== d2) {
        if (null !== d2.dehydrated) return G(L, L.current & 1), b2.flags |= 128, null;
        if (0 !== (c2 & b2.child.childLanes)) return oj(a, b2, c2);
        G(L, L.current & 1);
        a = Zi(a, b2, c2);
        return null !== a ? a.sibling : null;
      }
      G(L, L.current & 1);
      break;
    case 19:
      d2 = 0 !== (c2 & b2.childLanes);
      if (0 !== (a.flags & 128)) {
        if (d2) return xj(a, b2, c2);
        b2.flags |= 128;
      }
      e2 = b2.memoizedState;
      null !== e2 && (e2.rendering = null, e2.tail = null, e2.lastEffect = null);
      G(L, L.current);
      if (d2) break;
      else return null;
    case 22:
    case 23:
      return b2.lanes = 0, dj(a, b2, c2);
  }
  return Zi(a, b2, c2);
}
var zj, Aj, Bj, Cj;
zj = function(a, b2) {
  for (var c2 = b2.child; null !== c2; ) {
    if (5 === c2.tag || 6 === c2.tag) a.appendChild(c2.stateNode);
    else if (4 !== c2.tag && null !== c2.child) {
      c2.child.return = c2;
      c2 = c2.child;
      continue;
    }
    if (c2 === b2) break;
    for (; null === c2.sibling; ) {
      if (null === c2.return || c2.return === b2) return;
      c2 = c2.return;
    }
    c2.sibling.return = c2.return;
    c2 = c2.sibling;
  }
};
Aj = function() {
};
Bj = function(a, b2, c2, d2) {
  var e2 = a.memoizedProps;
  if (e2 !== d2) {
    a = b2.stateNode;
    xh(uh.current);
    var f2 = null;
    switch (c2) {
      case "input":
        e2 = Ya(a, e2);
        d2 = Ya(a, d2);
        f2 = [];
        break;
      case "select":
        e2 = A$1({}, e2, { value: void 0 });
        d2 = A$1({}, d2, { value: void 0 });
        f2 = [];
        break;
      case "textarea":
        e2 = gb(a, e2);
        d2 = gb(a, d2);
        f2 = [];
        break;
      default:
        "function" !== typeof e2.onClick && "function" === typeof d2.onClick && (a.onclick = Bf);
    }
    ub(c2, d2);
    var g2;
    c2 = null;
    for (l2 in e2) if (!d2.hasOwnProperty(l2) && e2.hasOwnProperty(l2) && null != e2[l2]) if ("style" === l2) {
      var h2 = e2[l2];
      for (g2 in h2) h2.hasOwnProperty(g2) && (c2 || (c2 = {}), c2[g2] = "");
    } else "dangerouslySetInnerHTML" !== l2 && "children" !== l2 && "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && "autoFocus" !== l2 && (ea.hasOwnProperty(l2) ? f2 || (f2 = []) : (f2 = f2 || []).push(l2, null));
    for (l2 in d2) {
      var k2 = d2[l2];
      h2 = null != e2 ? e2[l2] : void 0;
      if (d2.hasOwnProperty(l2) && k2 !== h2 && (null != k2 || null != h2)) if ("style" === l2) if (h2) {
        for (g2 in h2) !h2.hasOwnProperty(g2) || k2 && k2.hasOwnProperty(g2) || (c2 || (c2 = {}), c2[g2] = "");
        for (g2 in k2) k2.hasOwnProperty(g2) && h2[g2] !== k2[g2] && (c2 || (c2 = {}), c2[g2] = k2[g2]);
      } else c2 || (f2 || (f2 = []), f2.push(
        l2,
        c2
      )), c2 = k2;
      else "dangerouslySetInnerHTML" === l2 ? (k2 = k2 ? k2.__html : void 0, h2 = h2 ? h2.__html : void 0, null != k2 && h2 !== k2 && (f2 = f2 || []).push(l2, k2)) : "children" === l2 ? "string" !== typeof k2 && "number" !== typeof k2 || (f2 = f2 || []).push(l2, "" + k2) : "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && (ea.hasOwnProperty(l2) ? (null != k2 && "onScroll" === l2 && D("scroll", a), f2 || h2 === k2 || (f2 = [])) : (f2 = f2 || []).push(l2, k2));
    }
    c2 && (f2 = f2 || []).push("style", c2);
    var l2 = f2;
    if (b2.updateQueue = l2) b2.flags |= 4;
  }
};
Cj = function(a, b2, c2, d2) {
  c2 !== d2 && (b2.flags |= 4);
};
function Dj(a, b2) {
  if (!I) switch (a.tailMode) {
    case "hidden":
      b2 = a.tail;
      for (var c2 = null; null !== b2; ) null !== b2.alternate && (c2 = b2), b2 = b2.sibling;
      null === c2 ? a.tail = null : c2.sibling = null;
      break;
    case "collapsed":
      c2 = a.tail;
      for (var d2 = null; null !== c2; ) null !== c2.alternate && (d2 = c2), c2 = c2.sibling;
      null === d2 ? b2 || null === a.tail ? a.tail = null : a.tail.sibling = null : d2.sibling = null;
  }
}
function S(a) {
  var b2 = null !== a.alternate && a.alternate.child === a.child, c2 = 0, d2 = 0;
  if (b2) for (var e2 = a.child; null !== e2; ) c2 |= e2.lanes | e2.childLanes, d2 |= e2.subtreeFlags & 14680064, d2 |= e2.flags & 14680064, e2.return = a, e2 = e2.sibling;
  else for (e2 = a.child; null !== e2; ) c2 |= e2.lanes | e2.childLanes, d2 |= e2.subtreeFlags, d2 |= e2.flags, e2.return = a, e2 = e2.sibling;
  a.subtreeFlags |= d2;
  a.childLanes = c2;
  return b2;
}
function Ej(a, b2, c2) {
  var d2 = b2.pendingProps;
  wg(b2);
  switch (b2.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return S(b2), null;
    case 1:
      return Zf(b2.type) && $f(), S(b2), null;
    case 3:
      d2 = b2.stateNode;
      zh();
      E$2(Wf);
      E$2(H);
      Eh();
      d2.pendingContext && (d2.context = d2.pendingContext, d2.pendingContext = null);
      if (null === a || null === a.child) Gg(b2) ? b2.flags |= 4 : null === a || a.memoizedState.isDehydrated && 0 === (b2.flags & 256) || (b2.flags |= 1024, null !== zg && (Fj(zg), zg = null));
      Aj(a, b2);
      S(b2);
      return null;
    case 5:
      Bh(b2);
      var e2 = xh(wh.current);
      c2 = b2.type;
      if (null !== a && null != b2.stateNode) Bj(a, b2, c2, d2, e2), a.ref !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
      else {
        if (!d2) {
          if (null === b2.stateNode) throw Error(p$1(166));
          S(b2);
          return null;
        }
        a = xh(uh.current);
        if (Gg(b2)) {
          d2 = b2.stateNode;
          c2 = b2.type;
          var f2 = b2.memoizedProps;
          d2[Of] = b2;
          d2[Pf] = f2;
          a = 0 !== (b2.mode & 1);
          switch (c2) {
            case "dialog":
              D("cancel", d2);
              D("close", d2);
              break;
            case "iframe":
            case "object":
            case "embed":
              D("load", d2);
              break;
            case "video":
            case "audio":
              for (e2 = 0; e2 < lf.length; e2++) D(lf[e2], d2);
              break;
            case "source":
              D("error", d2);
              break;
            case "img":
            case "image":
            case "link":
              D(
                "error",
                d2
              );
              D("load", d2);
              break;
            case "details":
              D("toggle", d2);
              break;
            case "input":
              Za(d2, f2);
              D("invalid", d2);
              break;
            case "select":
              d2._wrapperState = { wasMultiple: !!f2.multiple };
              D("invalid", d2);
              break;
            case "textarea":
              hb(d2, f2), D("invalid", d2);
          }
          ub(c2, f2);
          e2 = null;
          for (var g2 in f2) if (f2.hasOwnProperty(g2)) {
            var h2 = f2[g2];
            "children" === g2 ? "string" === typeof h2 ? d2.textContent !== h2 && (true !== f2.suppressHydrationWarning && Af(d2.textContent, h2, a), e2 = ["children", h2]) : "number" === typeof h2 && d2.textContent !== "" + h2 && (true !== f2.suppressHydrationWarning && Af(
              d2.textContent,
              h2,
              a
            ), e2 = ["children", "" + h2]) : ea.hasOwnProperty(g2) && null != h2 && "onScroll" === g2 && D("scroll", d2);
          }
          switch (c2) {
            case "input":
              Va(d2);
              db(d2, f2, true);
              break;
            case "textarea":
              Va(d2);
              jb(d2);
              break;
            case "select":
            case "option":
              break;
            default:
              "function" === typeof f2.onClick && (d2.onclick = Bf);
          }
          d2 = e2;
          b2.updateQueue = d2;
          null !== d2 && (b2.flags |= 4);
        } else {
          g2 = 9 === e2.nodeType ? e2 : e2.ownerDocument;
          "http://www.w3.org/1999/xhtml" === a && (a = kb(c2));
          "http://www.w3.org/1999/xhtml" === a ? "script" === c2 ? (a = g2.createElement("div"), a.innerHTML = "<script><\/script>", a = a.removeChild(a.firstChild)) : "string" === typeof d2.is ? a = g2.createElement(c2, { is: d2.is }) : (a = g2.createElement(c2), "select" === c2 && (g2 = a, d2.multiple ? g2.multiple = true : d2.size && (g2.size = d2.size))) : a = g2.createElementNS(a, c2);
          a[Of] = b2;
          a[Pf] = d2;
          zj(a, b2, false, false);
          b2.stateNode = a;
          a: {
            g2 = vb(c2, d2);
            switch (c2) {
              case "dialog":
                D("cancel", a);
                D("close", a);
                e2 = d2;
                break;
              case "iframe":
              case "object":
              case "embed":
                D("load", a);
                e2 = d2;
                break;
              case "video":
              case "audio":
                for (e2 = 0; e2 < lf.length; e2++) D(lf[e2], a);
                e2 = d2;
                break;
              case "source":
                D("error", a);
                e2 = d2;
                break;
              case "img":
              case "image":
              case "link":
                D(
                  "error",
                  a
                );
                D("load", a);
                e2 = d2;
                break;
              case "details":
                D("toggle", a);
                e2 = d2;
                break;
              case "input":
                Za(a, d2);
                e2 = Ya(a, d2);
                D("invalid", a);
                break;
              case "option":
                e2 = d2;
                break;
              case "select":
                a._wrapperState = { wasMultiple: !!d2.multiple };
                e2 = A$1({}, d2, { value: void 0 });
                D("invalid", a);
                break;
              case "textarea":
                hb(a, d2);
                e2 = gb(a, d2);
                D("invalid", a);
                break;
              default:
                e2 = d2;
            }
            ub(c2, e2);
            h2 = e2;
            for (f2 in h2) if (h2.hasOwnProperty(f2)) {
              var k2 = h2[f2];
              "style" === f2 ? sb(a, k2) : "dangerouslySetInnerHTML" === f2 ? (k2 = k2 ? k2.__html : void 0, null != k2 && nb(a, k2)) : "children" === f2 ? "string" === typeof k2 ? ("textarea" !== c2 || "" !== k2) && ob(a, k2) : "number" === typeof k2 && ob(a, "" + k2) : "suppressContentEditableWarning" !== f2 && "suppressHydrationWarning" !== f2 && "autoFocus" !== f2 && (ea.hasOwnProperty(f2) ? null != k2 && "onScroll" === f2 && D("scroll", a) : null != k2 && ta(a, f2, k2, g2));
            }
            switch (c2) {
              case "input":
                Va(a);
                db(a, d2, false);
                break;
              case "textarea":
                Va(a);
                jb(a);
                break;
              case "option":
                null != d2.value && a.setAttribute("value", "" + Sa(d2.value));
                break;
              case "select":
                a.multiple = !!d2.multiple;
                f2 = d2.value;
                null != f2 ? fb(a, !!d2.multiple, f2, false) : null != d2.defaultValue && fb(
                  a,
                  !!d2.multiple,
                  d2.defaultValue,
                  true
                );
                break;
              default:
                "function" === typeof e2.onClick && (a.onclick = Bf);
            }
            switch (c2) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                d2 = !!d2.autoFocus;
                break a;
              case "img":
                d2 = true;
                break a;
              default:
                d2 = false;
            }
          }
          d2 && (b2.flags |= 4);
        }
        null !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
      }
      S(b2);
      return null;
    case 6:
      if (a && null != b2.stateNode) Cj(a, b2, a.memoizedProps, d2);
      else {
        if ("string" !== typeof d2 && null === b2.stateNode) throw Error(p$1(166));
        c2 = xh(wh.current);
        xh(uh.current);
        if (Gg(b2)) {
          d2 = b2.stateNode;
          c2 = b2.memoizedProps;
          d2[Of] = b2;
          if (f2 = d2.nodeValue !== c2) {
            if (a = xg, null !== a) switch (a.tag) {
              case 3:
                Af(d2.nodeValue, c2, 0 !== (a.mode & 1));
                break;
              case 5:
                true !== a.memoizedProps.suppressHydrationWarning && Af(d2.nodeValue, c2, 0 !== (a.mode & 1));
            }
          }
          f2 && (b2.flags |= 4);
        } else d2 = (9 === c2.nodeType ? c2 : c2.ownerDocument).createTextNode(d2), d2[Of] = b2, b2.stateNode = d2;
      }
      S(b2);
      return null;
    case 13:
      E$2(L);
      d2 = b2.memoizedState;
      if (null === a || null !== a.memoizedState && null !== a.memoizedState.dehydrated) {
        if (I && null !== yg && 0 !== (b2.mode & 1) && 0 === (b2.flags & 128)) Hg(), Ig(), b2.flags |= 98560, f2 = false;
        else if (f2 = Gg(b2), null !== d2 && null !== d2.dehydrated) {
          if (null === a) {
            if (!f2) throw Error(p$1(318));
            f2 = b2.memoizedState;
            f2 = null !== f2 ? f2.dehydrated : null;
            if (!f2) throw Error(p$1(317));
            f2[Of] = b2;
          } else Ig(), 0 === (b2.flags & 128) && (b2.memoizedState = null), b2.flags |= 4;
          S(b2);
          f2 = false;
        } else null !== zg && (Fj(zg), zg = null), f2 = true;
        if (!f2) return b2.flags & 65536 ? b2 : null;
      }
      if (0 !== (b2.flags & 128)) return b2.lanes = c2, b2;
      d2 = null !== d2;
      d2 !== (null !== a && null !== a.memoizedState) && d2 && (b2.child.flags |= 8192, 0 !== (b2.mode & 1) && (null === a || 0 !== (L.current & 1) ? 0 === T && (T = 3) : tj()));
      null !== b2.updateQueue && (b2.flags |= 4);
      S(b2);
      return null;
    case 4:
      return zh(), Aj(a, b2), null === a && sf(b2.stateNode.containerInfo), S(b2), null;
    case 10:
      return ah(b2.type._context), S(b2), null;
    case 17:
      return Zf(b2.type) && $f(), S(b2), null;
    case 19:
      E$2(L);
      f2 = b2.memoizedState;
      if (null === f2) return S(b2), null;
      d2 = 0 !== (b2.flags & 128);
      g2 = f2.rendering;
      if (null === g2) if (d2) Dj(f2, false);
      else {
        if (0 !== T || null !== a && 0 !== (a.flags & 128)) for (a = b2.child; null !== a; ) {
          g2 = Ch(a);
          if (null !== g2) {
            b2.flags |= 128;
            Dj(f2, false);
            d2 = g2.updateQueue;
            null !== d2 && (b2.updateQueue = d2, b2.flags |= 4);
            b2.subtreeFlags = 0;
            d2 = c2;
            for (c2 = b2.child; null !== c2; ) f2 = c2, a = d2, f2.flags &= 14680066, g2 = f2.alternate, null === g2 ? (f2.childLanes = 0, f2.lanes = a, f2.child = null, f2.subtreeFlags = 0, f2.memoizedProps = null, f2.memoizedState = null, f2.updateQueue = null, f2.dependencies = null, f2.stateNode = null) : (f2.childLanes = g2.childLanes, f2.lanes = g2.lanes, f2.child = g2.child, f2.subtreeFlags = 0, f2.deletions = null, f2.memoizedProps = g2.memoizedProps, f2.memoizedState = g2.memoizedState, f2.updateQueue = g2.updateQueue, f2.type = g2.type, a = g2.dependencies, f2.dependencies = null === a ? null : { lanes: a.lanes, firstContext: a.firstContext }), c2 = c2.sibling;
            G(L, L.current & 1 | 2);
            return b2.child;
          }
          a = a.sibling;
        }
        null !== f2.tail && B() > Gj && (b2.flags |= 128, d2 = true, Dj(f2, false), b2.lanes = 4194304);
      }
      else {
        if (!d2) if (a = Ch(g2), null !== a) {
          if (b2.flags |= 128, d2 = true, c2 = a.updateQueue, null !== c2 && (b2.updateQueue = c2, b2.flags |= 4), Dj(f2, true), null === f2.tail && "hidden" === f2.tailMode && !g2.alternate && !I) return S(b2), null;
        } else 2 * B() - f2.renderingStartTime > Gj && 1073741824 !== c2 && (b2.flags |= 128, d2 = true, Dj(f2, false), b2.lanes = 4194304);
        f2.isBackwards ? (g2.sibling = b2.child, b2.child = g2) : (c2 = f2.last, null !== c2 ? c2.sibling = g2 : b2.child = g2, f2.last = g2);
      }
      if (null !== f2.tail) return b2 = f2.tail, f2.rendering = b2, f2.tail = b2.sibling, f2.renderingStartTime = B(), b2.sibling = null, c2 = L.current, G(L, d2 ? c2 & 1 | 2 : c2 & 1), b2;
      S(b2);
      return null;
    case 22:
    case 23:
      return Hj(), d2 = null !== b2.memoizedState, null !== a && null !== a.memoizedState !== d2 && (b2.flags |= 8192), d2 && 0 !== (b2.mode & 1) ? 0 !== (fj & 1073741824) && (S(b2), b2.subtreeFlags & 6 && (b2.flags |= 8192)) : S(b2), null;
    case 24:
      return null;
    case 25:
      return null;
  }
  throw Error(p$1(156, b2.tag));
}
function Ij(a, b2) {
  wg(b2);
  switch (b2.tag) {
    case 1:
      return Zf(b2.type) && $f(), a = b2.flags, a & 65536 ? (b2.flags = a & -65537 | 128, b2) : null;
    case 3:
      return zh(), E$2(Wf), E$2(H), Eh(), a = b2.flags, 0 !== (a & 65536) && 0 === (a & 128) ? (b2.flags = a & -65537 | 128, b2) : null;
    case 5:
      return Bh(b2), null;
    case 13:
      E$2(L);
      a = b2.memoizedState;
      if (null !== a && null !== a.dehydrated) {
        if (null === b2.alternate) throw Error(p$1(340));
        Ig();
      }
      a = b2.flags;
      return a & 65536 ? (b2.flags = a & -65537 | 128, b2) : null;
    case 19:
      return E$2(L), null;
    case 4:
      return zh(), null;
    case 10:
      return ah(b2.type._context), null;
    case 22:
    case 23:
      return Hj(), null;
    case 24:
      return null;
    default:
      return null;
  }
}
var Jj = false, U = false, Kj = "function" === typeof WeakSet ? WeakSet : Set, V = null;
function Lj(a, b2) {
  var c2 = a.ref;
  if (null !== c2) if ("function" === typeof c2) try {
    c2(null);
  } catch (d2) {
    W(a, b2, d2);
  }
  else c2.current = null;
}
function Mj(a, b2, c2) {
  try {
    c2();
  } catch (d2) {
    W(a, b2, d2);
  }
}
var Nj = false;
function Oj(a, b2) {
  Cf = dd;
  a = Me();
  if (Ne(a)) {
    if ("selectionStart" in a) var c2 = { start: a.selectionStart, end: a.selectionEnd };
    else a: {
      c2 = (c2 = a.ownerDocument) && c2.defaultView || window;
      var d2 = c2.getSelection && c2.getSelection();
      if (d2 && 0 !== d2.rangeCount) {
        c2 = d2.anchorNode;
        var e2 = d2.anchorOffset, f2 = d2.focusNode;
        d2 = d2.focusOffset;
        try {
          c2.nodeType, f2.nodeType;
        } catch (F2) {
          c2 = null;
          break a;
        }
        var g2 = 0, h2 = -1, k2 = -1, l2 = 0, m2 = 0, q2 = a, r2 = null;
        b: for (; ; ) {
          for (var y2; ; ) {
            q2 !== c2 || 0 !== e2 && 3 !== q2.nodeType || (h2 = g2 + e2);
            q2 !== f2 || 0 !== d2 && 3 !== q2.nodeType || (k2 = g2 + d2);
            3 === q2.nodeType && (g2 += q2.nodeValue.length);
            if (null === (y2 = q2.firstChild)) break;
            r2 = q2;
            q2 = y2;
          }
          for (; ; ) {
            if (q2 === a) break b;
            r2 === c2 && ++l2 === e2 && (h2 = g2);
            r2 === f2 && ++m2 === d2 && (k2 = g2);
            if (null !== (y2 = q2.nextSibling)) break;
            q2 = r2;
            r2 = q2.parentNode;
          }
          q2 = y2;
        }
        c2 = -1 === h2 || -1 === k2 ? null : { start: h2, end: k2 };
      } else c2 = null;
    }
    c2 = c2 || { start: 0, end: 0 };
  } else c2 = null;
  Df = { focusedElem: a, selectionRange: c2 };
  dd = false;
  for (V = b2; null !== V; ) if (b2 = V, a = b2.child, 0 !== (b2.subtreeFlags & 1028) && null !== a) a.return = b2, V = a;
  else for (; null !== V; ) {
    b2 = V;
    try {
      var n2 = b2.alternate;
      if (0 !== (b2.flags & 1024)) switch (b2.tag) {
        case 0:
        case 11:
        case 15:
          break;
        case 1:
          if (null !== n2) {
            var t2 = n2.memoizedProps, J2 = n2.memoizedState, x2 = b2.stateNode, w2 = x2.getSnapshotBeforeUpdate(b2.elementType === b2.type ? t2 : Ci(b2.type, t2), J2);
            x2.__reactInternalSnapshotBeforeUpdate = w2;
          }
          break;
        case 3:
          var u2 = b2.stateNode.containerInfo;
          1 === u2.nodeType ? u2.textContent = "" : 9 === u2.nodeType && u2.documentElement && u2.removeChild(u2.documentElement);
          break;
        case 5:
        case 6:
        case 4:
        case 17:
          break;
        default:
          throw Error(p$1(163));
      }
    } catch (F2) {
      W(b2, b2.return, F2);
    }
    a = b2.sibling;
    if (null !== a) {
      a.return = b2.return;
      V = a;
      break;
    }
    V = b2.return;
  }
  n2 = Nj;
  Nj = false;
  return n2;
}
function Pj(a, b2, c2) {
  var d2 = b2.updateQueue;
  d2 = null !== d2 ? d2.lastEffect : null;
  if (null !== d2) {
    var e2 = d2 = d2.next;
    do {
      if ((e2.tag & a) === a) {
        var f2 = e2.destroy;
        e2.destroy = void 0;
        void 0 !== f2 && Mj(b2, c2, f2);
      }
      e2 = e2.next;
    } while (e2 !== d2);
  }
}
function Qj(a, b2) {
  b2 = b2.updateQueue;
  b2 = null !== b2 ? b2.lastEffect : null;
  if (null !== b2) {
    var c2 = b2 = b2.next;
    do {
      if ((c2.tag & a) === a) {
        var d2 = c2.create;
        c2.destroy = d2();
      }
      c2 = c2.next;
    } while (c2 !== b2);
  }
}
function Rj(a) {
  var b2 = a.ref;
  if (null !== b2) {
    var c2 = a.stateNode;
    switch (a.tag) {
      case 5:
        a = c2;
        break;
      default:
        a = c2;
    }
    "function" === typeof b2 ? b2(a) : b2.current = a;
  }
}
function Sj(a) {
  var b2 = a.alternate;
  null !== b2 && (a.alternate = null, Sj(b2));
  a.child = null;
  a.deletions = null;
  a.sibling = null;
  5 === a.tag && (b2 = a.stateNode, null !== b2 && (delete b2[Of], delete b2[Pf], delete b2[of], delete b2[Qf], delete b2[Rf]));
  a.stateNode = null;
  a.return = null;
  a.dependencies = null;
  a.memoizedProps = null;
  a.memoizedState = null;
  a.pendingProps = null;
  a.stateNode = null;
  a.updateQueue = null;
}
function Tj(a) {
  return 5 === a.tag || 3 === a.tag || 4 === a.tag;
}
function Uj(a) {
  a: for (; ; ) {
    for (; null === a.sibling; ) {
      if (null === a.return || Tj(a.return)) return null;
      a = a.return;
    }
    a.sibling.return = a.return;
    for (a = a.sibling; 5 !== a.tag && 6 !== a.tag && 18 !== a.tag; ) {
      if (a.flags & 2) continue a;
      if (null === a.child || 4 === a.tag) continue a;
      else a.child.return = a, a = a.child;
    }
    if (!(a.flags & 2)) return a.stateNode;
  }
}
function Vj(a, b2, c2) {
  var d2 = a.tag;
  if (5 === d2 || 6 === d2) a = a.stateNode, b2 ? 8 === c2.nodeType ? c2.parentNode.insertBefore(a, b2) : c2.insertBefore(a, b2) : (8 === c2.nodeType ? (b2 = c2.parentNode, b2.insertBefore(a, c2)) : (b2 = c2, b2.appendChild(a)), c2 = c2._reactRootContainer, null !== c2 && void 0 !== c2 || null !== b2.onclick || (b2.onclick = Bf));
  else if (4 !== d2 && (a = a.child, null !== a)) for (Vj(a, b2, c2), a = a.sibling; null !== a; ) Vj(a, b2, c2), a = a.sibling;
}
function Wj(a, b2, c2) {
  var d2 = a.tag;
  if (5 === d2 || 6 === d2) a = a.stateNode, b2 ? c2.insertBefore(a, b2) : c2.appendChild(a);
  else if (4 !== d2 && (a = a.child, null !== a)) for (Wj(a, b2, c2), a = a.sibling; null !== a; ) Wj(a, b2, c2), a = a.sibling;
}
var X = null, Xj = false;
function Yj(a, b2, c2) {
  for (c2 = c2.child; null !== c2; ) Zj(a, b2, c2), c2 = c2.sibling;
}
function Zj(a, b2, c2) {
  if (lc && "function" === typeof lc.onCommitFiberUnmount) try {
    lc.onCommitFiberUnmount(kc, c2);
  } catch (h2) {
  }
  switch (c2.tag) {
    case 5:
      U || Lj(c2, b2);
    case 6:
      var d2 = X, e2 = Xj;
      X = null;
      Yj(a, b2, c2);
      X = d2;
      Xj = e2;
      null !== X && (Xj ? (a = X, c2 = c2.stateNode, 8 === a.nodeType ? a.parentNode.removeChild(c2) : a.removeChild(c2)) : X.removeChild(c2.stateNode));
      break;
    case 18:
      null !== X && (Xj ? (a = X, c2 = c2.stateNode, 8 === a.nodeType ? Kf(a.parentNode, c2) : 1 === a.nodeType && Kf(a, c2), bd(a)) : Kf(X, c2.stateNode));
      break;
    case 4:
      d2 = X;
      e2 = Xj;
      X = c2.stateNode.containerInfo;
      Xj = true;
      Yj(a, b2, c2);
      X = d2;
      Xj = e2;
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      if (!U && (d2 = c2.updateQueue, null !== d2 && (d2 = d2.lastEffect, null !== d2))) {
        e2 = d2 = d2.next;
        do {
          var f2 = e2, g2 = f2.destroy;
          f2 = f2.tag;
          void 0 !== g2 && (0 !== (f2 & 2) ? Mj(c2, b2, g2) : 0 !== (f2 & 4) && Mj(c2, b2, g2));
          e2 = e2.next;
        } while (e2 !== d2);
      }
      Yj(a, b2, c2);
      break;
    case 1:
      if (!U && (Lj(c2, b2), d2 = c2.stateNode, "function" === typeof d2.componentWillUnmount)) try {
        d2.props = c2.memoizedProps, d2.state = c2.memoizedState, d2.componentWillUnmount();
      } catch (h2) {
        W(c2, b2, h2);
      }
      Yj(a, b2, c2);
      break;
    case 21:
      Yj(a, b2, c2);
      break;
    case 22:
      c2.mode & 1 ? (U = (d2 = U) || null !== c2.memoizedState, Yj(a, b2, c2), U = d2) : Yj(a, b2, c2);
      break;
    default:
      Yj(a, b2, c2);
  }
}
function ak(a) {
  var b2 = a.updateQueue;
  if (null !== b2) {
    a.updateQueue = null;
    var c2 = a.stateNode;
    null === c2 && (c2 = a.stateNode = new Kj());
    b2.forEach(function(b3) {
      var d2 = bk.bind(null, a, b3);
      c2.has(b3) || (c2.add(b3), b3.then(d2, d2));
    });
  }
}
function ck(a, b2) {
  var c2 = b2.deletions;
  if (null !== c2) for (var d2 = 0; d2 < c2.length; d2++) {
    var e2 = c2[d2];
    try {
      var f2 = a, g2 = b2, h2 = g2;
      a: for (; null !== h2; ) {
        switch (h2.tag) {
          case 5:
            X = h2.stateNode;
            Xj = false;
            break a;
          case 3:
            X = h2.stateNode.containerInfo;
            Xj = true;
            break a;
          case 4:
            X = h2.stateNode.containerInfo;
            Xj = true;
            break a;
        }
        h2 = h2.return;
      }
      if (null === X) throw Error(p$1(160));
      Zj(f2, g2, e2);
      X = null;
      Xj = false;
      var k2 = e2.alternate;
      null !== k2 && (k2.return = null);
      e2.return = null;
    } catch (l2) {
      W(e2, b2, l2);
    }
  }
  if (b2.subtreeFlags & 12854) for (b2 = b2.child; null !== b2; ) dk(b2, a), b2 = b2.sibling;
}
function dk(a, b2) {
  var c2 = a.alternate, d2 = a.flags;
  switch (a.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      ck(b2, a);
      ek(a);
      if (d2 & 4) {
        try {
          Pj(3, a, a.return), Qj(3, a);
        } catch (t2) {
          W(a, a.return, t2);
        }
        try {
          Pj(5, a, a.return);
        } catch (t2) {
          W(a, a.return, t2);
        }
      }
      break;
    case 1:
      ck(b2, a);
      ek(a);
      d2 & 512 && null !== c2 && Lj(c2, c2.return);
      break;
    case 5:
      ck(b2, a);
      ek(a);
      d2 & 512 && null !== c2 && Lj(c2, c2.return);
      if (a.flags & 32) {
        var e2 = a.stateNode;
        try {
          ob(e2, "");
        } catch (t2) {
          W(a, a.return, t2);
        }
      }
      if (d2 & 4 && (e2 = a.stateNode, null != e2)) {
        var f2 = a.memoizedProps, g2 = null !== c2 ? c2.memoizedProps : f2, h2 = a.type, k2 = a.updateQueue;
        a.updateQueue = null;
        if (null !== k2) try {
          "input" === h2 && "radio" === f2.type && null != f2.name && ab(e2, f2);
          vb(h2, g2);
          var l2 = vb(h2, f2);
          for (g2 = 0; g2 < k2.length; g2 += 2) {
            var m2 = k2[g2], q2 = k2[g2 + 1];
            "style" === m2 ? sb(e2, q2) : "dangerouslySetInnerHTML" === m2 ? nb(e2, q2) : "children" === m2 ? ob(e2, q2) : ta(e2, m2, q2, l2);
          }
          switch (h2) {
            case "input":
              bb(e2, f2);
              break;
            case "textarea":
              ib(e2, f2);
              break;
            case "select":
              var r2 = e2._wrapperState.wasMultiple;
              e2._wrapperState.wasMultiple = !!f2.multiple;
              var y2 = f2.value;
              null != y2 ? fb(e2, !!f2.multiple, y2, false) : r2 !== !!f2.multiple && (null != f2.defaultValue ? fb(
                e2,
                !!f2.multiple,
                f2.defaultValue,
                true
              ) : fb(e2, !!f2.multiple, f2.multiple ? [] : "", false));
          }
          e2[Pf] = f2;
        } catch (t2) {
          W(a, a.return, t2);
        }
      }
      break;
    case 6:
      ck(b2, a);
      ek(a);
      if (d2 & 4) {
        if (null === a.stateNode) throw Error(p$1(162));
        e2 = a.stateNode;
        f2 = a.memoizedProps;
        try {
          e2.nodeValue = f2;
        } catch (t2) {
          W(a, a.return, t2);
        }
      }
      break;
    case 3:
      ck(b2, a);
      ek(a);
      if (d2 & 4 && null !== c2 && c2.memoizedState.isDehydrated) try {
        bd(b2.containerInfo);
      } catch (t2) {
        W(a, a.return, t2);
      }
      break;
    case 4:
      ck(b2, a);
      ek(a);
      break;
    case 13:
      ck(b2, a);
      ek(a);
      e2 = a.child;
      e2.flags & 8192 && (f2 = null !== e2.memoizedState, e2.stateNode.isHidden = f2, !f2 || null !== e2.alternate && null !== e2.alternate.memoizedState || (fk = B()));
      d2 & 4 && ak(a);
      break;
    case 22:
      m2 = null !== c2 && null !== c2.memoizedState;
      a.mode & 1 ? (U = (l2 = U) || m2, ck(b2, a), U = l2) : ck(b2, a);
      ek(a);
      if (d2 & 8192) {
        l2 = null !== a.memoizedState;
        if ((a.stateNode.isHidden = l2) && !m2 && 0 !== (a.mode & 1)) for (V = a, m2 = a.child; null !== m2; ) {
          for (q2 = V = m2; null !== V; ) {
            r2 = V;
            y2 = r2.child;
            switch (r2.tag) {
              case 0:
              case 11:
              case 14:
              case 15:
                Pj(4, r2, r2.return);
                break;
              case 1:
                Lj(r2, r2.return);
                var n2 = r2.stateNode;
                if ("function" === typeof n2.componentWillUnmount) {
                  d2 = r2;
                  c2 = r2.return;
                  try {
                    b2 = d2, n2.props = b2.memoizedProps, n2.state = b2.memoizedState, n2.componentWillUnmount();
                  } catch (t2) {
                    W(d2, c2, t2);
                  }
                }
                break;
              case 5:
                Lj(r2, r2.return);
                break;
              case 22:
                if (null !== r2.memoizedState) {
                  gk(q2);
                  continue;
                }
            }
            null !== y2 ? (y2.return = r2, V = y2) : gk(q2);
          }
          m2 = m2.sibling;
        }
        a: for (m2 = null, q2 = a; ; ) {
          if (5 === q2.tag) {
            if (null === m2) {
              m2 = q2;
              try {
                e2 = q2.stateNode, l2 ? (f2 = e2.style, "function" === typeof f2.setProperty ? f2.setProperty("display", "none", "important") : f2.display = "none") : (h2 = q2.stateNode, k2 = q2.memoizedProps.style, g2 = void 0 !== k2 && null !== k2 && k2.hasOwnProperty("display") ? k2.display : null, h2.style.display = rb("display", g2));
              } catch (t2) {
                W(a, a.return, t2);
              }
            }
          } else if (6 === q2.tag) {
            if (null === m2) try {
              q2.stateNode.nodeValue = l2 ? "" : q2.memoizedProps;
            } catch (t2) {
              W(a, a.return, t2);
            }
          } else if ((22 !== q2.tag && 23 !== q2.tag || null === q2.memoizedState || q2 === a) && null !== q2.child) {
            q2.child.return = q2;
            q2 = q2.child;
            continue;
          }
          if (q2 === a) break a;
          for (; null === q2.sibling; ) {
            if (null === q2.return || q2.return === a) break a;
            m2 === q2 && (m2 = null);
            q2 = q2.return;
          }
          m2 === q2 && (m2 = null);
          q2.sibling.return = q2.return;
          q2 = q2.sibling;
        }
      }
      break;
    case 19:
      ck(b2, a);
      ek(a);
      d2 & 4 && ak(a);
      break;
    case 21:
      break;
    default:
      ck(
        b2,
        a
      ), ek(a);
  }
}
function ek(a) {
  var b2 = a.flags;
  if (b2 & 2) {
    try {
      a: {
        for (var c2 = a.return; null !== c2; ) {
          if (Tj(c2)) {
            var d2 = c2;
            break a;
          }
          c2 = c2.return;
        }
        throw Error(p$1(160));
      }
      switch (d2.tag) {
        case 5:
          var e2 = d2.stateNode;
          d2.flags & 32 && (ob(e2, ""), d2.flags &= -33);
          var f2 = Uj(a);
          Wj(a, f2, e2);
          break;
        case 3:
        case 4:
          var g2 = d2.stateNode.containerInfo, h2 = Uj(a);
          Vj(a, h2, g2);
          break;
        default:
          throw Error(p$1(161));
      }
    } catch (k2) {
      W(a, a.return, k2);
    }
    a.flags &= -3;
  }
  b2 & 4096 && (a.flags &= -4097);
}
function hk(a, b2, c2) {
  V = a;
  ik(a);
}
function ik(a, b2, c2) {
  for (var d2 = 0 !== (a.mode & 1); null !== V; ) {
    var e2 = V, f2 = e2.child;
    if (22 === e2.tag && d2) {
      var g2 = null !== e2.memoizedState || Jj;
      if (!g2) {
        var h2 = e2.alternate, k2 = null !== h2 && null !== h2.memoizedState || U;
        h2 = Jj;
        var l2 = U;
        Jj = g2;
        if ((U = k2) && !l2) for (V = e2; null !== V; ) g2 = V, k2 = g2.child, 22 === g2.tag && null !== g2.memoizedState ? jk(e2) : null !== k2 ? (k2.return = g2, V = k2) : jk(e2);
        for (; null !== f2; ) V = f2, ik(f2), f2 = f2.sibling;
        V = e2;
        Jj = h2;
        U = l2;
      }
      kk(a);
    } else 0 !== (e2.subtreeFlags & 8772) && null !== f2 ? (f2.return = e2, V = f2) : kk(a);
  }
}
function kk(a) {
  for (; null !== V; ) {
    var b2 = V;
    if (0 !== (b2.flags & 8772)) {
      var c2 = b2.alternate;
      try {
        if (0 !== (b2.flags & 8772)) switch (b2.tag) {
          case 0:
          case 11:
          case 15:
            U || Qj(5, b2);
            break;
          case 1:
            var d2 = b2.stateNode;
            if (b2.flags & 4 && !U) if (null === c2) d2.componentDidMount();
            else {
              var e2 = b2.elementType === b2.type ? c2.memoizedProps : Ci(b2.type, c2.memoizedProps);
              d2.componentDidUpdate(e2, c2.memoizedState, d2.__reactInternalSnapshotBeforeUpdate);
            }
            var f2 = b2.updateQueue;
            null !== f2 && sh(b2, f2, d2);
            break;
          case 3:
            var g2 = b2.updateQueue;
            if (null !== g2) {
              c2 = null;
              if (null !== b2.child) switch (b2.child.tag) {
                case 5:
                  c2 = b2.child.stateNode;
                  break;
                case 1:
                  c2 = b2.child.stateNode;
              }
              sh(b2, g2, c2);
            }
            break;
          case 5:
            var h2 = b2.stateNode;
            if (null === c2 && b2.flags & 4) {
              c2 = h2;
              var k2 = b2.memoizedProps;
              switch (b2.type) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  k2.autoFocus && c2.focus();
                  break;
                case "img":
                  k2.src && (c2.src = k2.src);
              }
            }
            break;
          case 6:
            break;
          case 4:
            break;
          case 12:
            break;
          case 13:
            if (null === b2.memoizedState) {
              var l2 = b2.alternate;
              if (null !== l2) {
                var m2 = l2.memoizedState;
                if (null !== m2) {
                  var q2 = m2.dehydrated;
                  null !== q2 && bd(q2);
                }
              }
            }
            break;
          case 19:
          case 17:
          case 21:
          case 22:
          case 23:
          case 25:
            break;
          default:
            throw Error(p$1(163));
        }
        U || b2.flags & 512 && Rj(b2);
      } catch (r2) {
        W(b2, b2.return, r2);
      }
    }
    if (b2 === a) {
      V = null;
      break;
    }
    c2 = b2.sibling;
    if (null !== c2) {
      c2.return = b2.return;
      V = c2;
      break;
    }
    V = b2.return;
  }
}
function gk(a) {
  for (; null !== V; ) {
    var b2 = V;
    if (b2 === a) {
      V = null;
      break;
    }
    var c2 = b2.sibling;
    if (null !== c2) {
      c2.return = b2.return;
      V = c2;
      break;
    }
    V = b2.return;
  }
}
function jk(a) {
  for (; null !== V; ) {
    var b2 = V;
    try {
      switch (b2.tag) {
        case 0:
        case 11:
        case 15:
          var c2 = b2.return;
          try {
            Qj(4, b2);
          } catch (k2) {
            W(b2, c2, k2);
          }
          break;
        case 1:
          var d2 = b2.stateNode;
          if ("function" === typeof d2.componentDidMount) {
            var e2 = b2.return;
            try {
              d2.componentDidMount();
            } catch (k2) {
              W(b2, e2, k2);
            }
          }
          var f2 = b2.return;
          try {
            Rj(b2);
          } catch (k2) {
            W(b2, f2, k2);
          }
          break;
        case 5:
          var g2 = b2.return;
          try {
            Rj(b2);
          } catch (k2) {
            W(b2, g2, k2);
          }
      }
    } catch (k2) {
      W(b2, b2.return, k2);
    }
    if (b2 === a) {
      V = null;
      break;
    }
    var h2 = b2.sibling;
    if (null !== h2) {
      h2.return = b2.return;
      V = h2;
      break;
    }
    V = b2.return;
  }
}
var lk = Math.ceil, mk = ua.ReactCurrentDispatcher, nk = ua.ReactCurrentOwner, ok = ua.ReactCurrentBatchConfig, K = 0, Q = null, Y = null, Z = 0, fj = 0, ej = Uf(0), T = 0, pk = null, rh = 0, qk = 0, rk = 0, sk = null, tk = null, fk = 0, Gj = Infinity, uk = null, Oi = false, Pi = null, Ri = null, vk = false, wk = null, xk = 0, yk = 0, zk = null, Ak = -1, Bk = 0;
function R() {
  return 0 !== (K & 6) ? B() : -1 !== Ak ? Ak : Ak = B();
}
function yi(a) {
  if (0 === (a.mode & 1)) return 1;
  if (0 !== (K & 2) && 0 !== Z) return Z & -Z;
  if (null !== Kg.transition) return 0 === Bk && (Bk = yc()), Bk;
  a = C;
  if (0 !== a) return a;
  a = window.event;
  a = void 0 === a ? 16 : jd(a.type);
  return a;
}
function gi(a, b2, c2, d2) {
  if (50 < yk) throw yk = 0, zk = null, Error(p$1(185));
  Ac(a, c2, d2);
  if (0 === (K & 2) || a !== Q) a === Q && (0 === (K & 2) && (qk |= c2), 4 === T && Ck(a, Z)), Dk(a, d2), 1 === c2 && 0 === K && 0 === (b2.mode & 1) && (Gj = B() + 500, fg && jg());
}
function Dk(a, b2) {
  var c2 = a.callbackNode;
  wc(a, b2);
  var d2 = uc(a, a === Q ? Z : 0);
  if (0 === d2) null !== c2 && bc(c2), a.callbackNode = null, a.callbackPriority = 0;
  else if (b2 = d2 & -d2, a.callbackPriority !== b2) {
    null != c2 && bc(c2);
    if (1 === b2) 0 === a.tag ? ig(Ek.bind(null, a)) : hg(Ek.bind(null, a)), Jf(function() {
      0 === (K & 6) && jg();
    }), c2 = null;
    else {
      switch (Dc(d2)) {
        case 1:
          c2 = fc;
          break;
        case 4:
          c2 = gc;
          break;
        case 16:
          c2 = hc;
          break;
        case 536870912:
          c2 = jc;
          break;
        default:
          c2 = hc;
      }
      c2 = Fk(c2, Gk.bind(null, a));
    }
    a.callbackPriority = b2;
    a.callbackNode = c2;
  }
}
function Gk(a, b2) {
  Ak = -1;
  Bk = 0;
  if (0 !== (K & 6)) throw Error(p$1(327));
  var c2 = a.callbackNode;
  if (Hk() && a.callbackNode !== c2) return null;
  var d2 = uc(a, a === Q ? Z : 0);
  if (0 === d2) return null;
  if (0 !== (d2 & 30) || 0 !== (d2 & a.expiredLanes) || b2) b2 = Ik(a, d2);
  else {
    b2 = d2;
    var e2 = K;
    K |= 2;
    var f2 = Jk();
    if (Q !== a || Z !== b2) uk = null, Gj = B() + 500, Kk(a, b2);
    do
      try {
        Lk();
        break;
      } catch (h2) {
        Mk(a, h2);
      }
    while (1);
    $g();
    mk.current = f2;
    K = e2;
    null !== Y ? b2 = 0 : (Q = null, Z = 0, b2 = T);
  }
  if (0 !== b2) {
    2 === b2 && (e2 = xc(a), 0 !== e2 && (d2 = e2, b2 = Nk(a, e2)));
    if (1 === b2) throw c2 = pk, Kk(a, 0), Ck(a, d2), Dk(a, B()), c2;
    if (6 === b2) Ck(a, d2);
    else {
      e2 = a.current.alternate;
      if (0 === (d2 & 30) && !Ok(e2) && (b2 = Ik(a, d2), 2 === b2 && (f2 = xc(a), 0 !== f2 && (d2 = f2, b2 = Nk(a, f2))), 1 === b2)) throw c2 = pk, Kk(a, 0), Ck(a, d2), Dk(a, B()), c2;
      a.finishedWork = e2;
      a.finishedLanes = d2;
      switch (b2) {
        case 0:
        case 1:
          throw Error(p$1(345));
        case 2:
          Pk(a, tk, uk);
          break;
        case 3:
          Ck(a, d2);
          if ((d2 & 130023424) === d2 && (b2 = fk + 500 - B(), 10 < b2)) {
            if (0 !== uc(a, 0)) break;
            e2 = a.suspendedLanes;
            if ((e2 & d2) !== d2) {
              R();
              a.pingedLanes |= a.suspendedLanes & e2;
              break;
            }
            a.timeoutHandle = Ff(Pk.bind(null, a, tk, uk), b2);
            break;
          }
          Pk(a, tk, uk);
          break;
        case 4:
          Ck(a, d2);
          if ((d2 & 4194240) === d2) break;
          b2 = a.eventTimes;
          for (e2 = -1; 0 < d2; ) {
            var g2 = 31 - oc(d2);
            f2 = 1 << g2;
            g2 = b2[g2];
            g2 > e2 && (e2 = g2);
            d2 &= ~f2;
          }
          d2 = e2;
          d2 = B() - d2;
          d2 = (120 > d2 ? 120 : 480 > d2 ? 480 : 1080 > d2 ? 1080 : 1920 > d2 ? 1920 : 3e3 > d2 ? 3e3 : 4320 > d2 ? 4320 : 1960 * lk(d2 / 1960)) - d2;
          if (10 < d2) {
            a.timeoutHandle = Ff(Pk.bind(null, a, tk, uk), d2);
            break;
          }
          Pk(a, tk, uk);
          break;
        case 5:
          Pk(a, tk, uk);
          break;
        default:
          throw Error(p$1(329));
      }
    }
  }
  Dk(a, B());
  return a.callbackNode === c2 ? Gk.bind(null, a) : null;
}
function Nk(a, b2) {
  var c2 = sk;
  a.current.memoizedState.isDehydrated && (Kk(a, b2).flags |= 256);
  a = Ik(a, b2);
  2 !== a && (b2 = tk, tk = c2, null !== b2 && Fj(b2));
  return a;
}
function Fj(a) {
  null === tk ? tk = a : tk.push.apply(tk, a);
}
function Ok(a) {
  for (var b2 = a; ; ) {
    if (b2.flags & 16384) {
      var c2 = b2.updateQueue;
      if (null !== c2 && (c2 = c2.stores, null !== c2)) for (var d2 = 0; d2 < c2.length; d2++) {
        var e2 = c2[d2], f2 = e2.getSnapshot;
        e2 = e2.value;
        try {
          if (!He(f2(), e2)) return false;
        } catch (g2) {
          return false;
        }
      }
    }
    c2 = b2.child;
    if (b2.subtreeFlags & 16384 && null !== c2) c2.return = b2, b2 = c2;
    else {
      if (b2 === a) break;
      for (; null === b2.sibling; ) {
        if (null === b2.return || b2.return === a) return true;
        b2 = b2.return;
      }
      b2.sibling.return = b2.return;
      b2 = b2.sibling;
    }
  }
  return true;
}
function Ck(a, b2) {
  b2 &= ~rk;
  b2 &= ~qk;
  a.suspendedLanes |= b2;
  a.pingedLanes &= ~b2;
  for (a = a.expirationTimes; 0 < b2; ) {
    var c2 = 31 - oc(b2), d2 = 1 << c2;
    a[c2] = -1;
    b2 &= ~d2;
  }
}
function Ek(a) {
  if (0 !== (K & 6)) throw Error(p$1(327));
  Hk();
  var b2 = uc(a, 0);
  if (0 === (b2 & 1)) return Dk(a, B()), null;
  var c2 = Ik(a, b2);
  if (0 !== a.tag && 2 === c2) {
    var d2 = xc(a);
    0 !== d2 && (b2 = d2, c2 = Nk(a, d2));
  }
  if (1 === c2) throw c2 = pk, Kk(a, 0), Ck(a, b2), Dk(a, B()), c2;
  if (6 === c2) throw Error(p$1(345));
  a.finishedWork = a.current.alternate;
  a.finishedLanes = b2;
  Pk(a, tk, uk);
  Dk(a, B());
  return null;
}
function Qk(a, b2) {
  var c2 = K;
  K |= 1;
  try {
    return a(b2);
  } finally {
    K = c2, 0 === K && (Gj = B() + 500, fg && jg());
  }
}
function Rk(a) {
  null !== wk && 0 === wk.tag && 0 === (K & 6) && Hk();
  var b2 = K;
  K |= 1;
  var c2 = ok.transition, d2 = C;
  try {
    if (ok.transition = null, C = 1, a) return a();
  } finally {
    C = d2, ok.transition = c2, K = b2, 0 === (K & 6) && jg();
  }
}
function Hj() {
  fj = ej.current;
  E$2(ej);
}
function Kk(a, b2) {
  a.finishedWork = null;
  a.finishedLanes = 0;
  var c2 = a.timeoutHandle;
  -1 !== c2 && (a.timeoutHandle = -1, Gf(c2));
  if (null !== Y) for (c2 = Y.return; null !== c2; ) {
    var d2 = c2;
    wg(d2);
    switch (d2.tag) {
      case 1:
        d2 = d2.type.childContextTypes;
        null !== d2 && void 0 !== d2 && $f();
        break;
      case 3:
        zh();
        E$2(Wf);
        E$2(H);
        Eh();
        break;
      case 5:
        Bh(d2);
        break;
      case 4:
        zh();
        break;
      case 13:
        E$2(L);
        break;
      case 19:
        E$2(L);
        break;
      case 10:
        ah(d2.type._context);
        break;
      case 22:
      case 23:
        Hj();
    }
    c2 = c2.return;
  }
  Q = a;
  Y = a = Pg(a.current, null);
  Z = fj = b2;
  T = 0;
  pk = null;
  rk = qk = rh = 0;
  tk = sk = null;
  if (null !== fh) {
    for (b2 = 0; b2 < fh.length; b2++) if (c2 = fh[b2], d2 = c2.interleaved, null !== d2) {
      c2.interleaved = null;
      var e2 = d2.next, f2 = c2.pending;
      if (null !== f2) {
        var g2 = f2.next;
        f2.next = e2;
        d2.next = g2;
      }
      c2.pending = d2;
    }
    fh = null;
  }
  return a;
}
function Mk(a, b2) {
  do {
    var c2 = Y;
    try {
      $g();
      Fh.current = Rh;
      if (Ih) {
        for (var d2 = M.memoizedState; null !== d2; ) {
          var e2 = d2.queue;
          null !== e2 && (e2.pending = null);
          d2 = d2.next;
        }
        Ih = false;
      }
      Hh = 0;
      O = N = M = null;
      Jh = false;
      Kh = 0;
      nk.current = null;
      if (null === c2 || null === c2.return) {
        T = 1;
        pk = b2;
        Y = null;
        break;
      }
      a: {
        var f2 = a, g2 = c2.return, h2 = c2, k2 = b2;
        b2 = Z;
        h2.flags |= 32768;
        if (null !== k2 && "object" === typeof k2 && "function" === typeof k2.then) {
          var l2 = k2, m2 = h2, q2 = m2.tag;
          if (0 === (m2.mode & 1) && (0 === q2 || 11 === q2 || 15 === q2)) {
            var r2 = m2.alternate;
            r2 ? (m2.updateQueue = r2.updateQueue, m2.memoizedState = r2.memoizedState, m2.lanes = r2.lanes) : (m2.updateQueue = null, m2.memoizedState = null);
          }
          var y2 = Ui(g2);
          if (null !== y2) {
            y2.flags &= -257;
            Vi(y2, g2, h2, f2, b2);
            y2.mode & 1 && Si(f2, l2, b2);
            b2 = y2;
            k2 = l2;
            var n2 = b2.updateQueue;
            if (null === n2) {
              var t2 = /* @__PURE__ */ new Set();
              t2.add(k2);
              b2.updateQueue = t2;
            } else n2.add(k2);
            break a;
          } else {
            if (0 === (b2 & 1)) {
              Si(f2, l2, b2);
              tj();
              break a;
            }
            k2 = Error(p$1(426));
          }
        } else if (I && h2.mode & 1) {
          var J2 = Ui(g2);
          if (null !== J2) {
            0 === (J2.flags & 65536) && (J2.flags |= 256);
            Vi(J2, g2, h2, f2, b2);
            Jg(Ji(k2, h2));
            break a;
          }
        }
        f2 = k2 = Ji(k2, h2);
        4 !== T && (T = 2);
        null === sk ? sk = [f2] : sk.push(f2);
        f2 = g2;
        do {
          switch (f2.tag) {
            case 3:
              f2.flags |= 65536;
              b2 &= -b2;
              f2.lanes |= b2;
              var x2 = Ni(f2, k2, b2);
              ph(f2, x2);
              break a;
            case 1:
              h2 = k2;
              var w2 = f2.type, u2 = f2.stateNode;
              if (0 === (f2.flags & 128) && ("function" === typeof w2.getDerivedStateFromError || null !== u2 && "function" === typeof u2.componentDidCatch && (null === Ri || !Ri.has(u2)))) {
                f2.flags |= 65536;
                b2 &= -b2;
                f2.lanes |= b2;
                var F2 = Qi(f2, h2, b2);
                ph(f2, F2);
                break a;
              }
          }
          f2 = f2.return;
        } while (null !== f2);
      }
      Sk(c2);
    } catch (na) {
      b2 = na;
      Y === c2 && null !== c2 && (Y = c2 = c2.return);
      continue;
    }
    break;
  } while (1);
}
function Jk() {
  var a = mk.current;
  mk.current = Rh;
  return null === a ? Rh : a;
}
function tj() {
  if (0 === T || 3 === T || 2 === T) T = 4;
  null === Q || 0 === (rh & 268435455) && 0 === (qk & 268435455) || Ck(Q, Z);
}
function Ik(a, b2) {
  var c2 = K;
  K |= 2;
  var d2 = Jk();
  if (Q !== a || Z !== b2) uk = null, Kk(a, b2);
  do
    try {
      Tk();
      break;
    } catch (e2) {
      Mk(a, e2);
    }
  while (1);
  $g();
  K = c2;
  mk.current = d2;
  if (null !== Y) throw Error(p$1(261));
  Q = null;
  Z = 0;
  return T;
}
function Tk() {
  for (; null !== Y; ) Uk(Y);
}
function Lk() {
  for (; null !== Y && !cc(); ) Uk(Y);
}
function Uk(a) {
  var b2 = Vk(a.alternate, a, fj);
  a.memoizedProps = a.pendingProps;
  null === b2 ? Sk(a) : Y = b2;
  nk.current = null;
}
function Sk(a) {
  var b2 = a;
  do {
    var c2 = b2.alternate;
    a = b2.return;
    if (0 === (b2.flags & 32768)) {
      if (c2 = Ej(c2, b2, fj), null !== c2) {
        Y = c2;
        return;
      }
    } else {
      c2 = Ij(c2, b2);
      if (null !== c2) {
        c2.flags &= 32767;
        Y = c2;
        return;
      }
      if (null !== a) a.flags |= 32768, a.subtreeFlags = 0, a.deletions = null;
      else {
        T = 6;
        Y = null;
        return;
      }
    }
    b2 = b2.sibling;
    if (null !== b2) {
      Y = b2;
      return;
    }
    Y = b2 = a;
  } while (null !== b2);
  0 === T && (T = 5);
}
function Pk(a, b2, c2) {
  var d2 = C, e2 = ok.transition;
  try {
    ok.transition = null, C = 1, Wk(a, b2, c2, d2);
  } finally {
    ok.transition = e2, C = d2;
  }
  return null;
}
function Wk(a, b2, c2, d2) {
  do
    Hk();
  while (null !== wk);
  if (0 !== (K & 6)) throw Error(p$1(327));
  c2 = a.finishedWork;
  var e2 = a.finishedLanes;
  if (null === c2) return null;
  a.finishedWork = null;
  a.finishedLanes = 0;
  if (c2 === a.current) throw Error(p$1(177));
  a.callbackNode = null;
  a.callbackPriority = 0;
  var f2 = c2.lanes | c2.childLanes;
  Bc(a, f2);
  a === Q && (Y = Q = null, Z = 0);
  0 === (c2.subtreeFlags & 2064) && 0 === (c2.flags & 2064) || vk || (vk = true, Fk(hc, function() {
    Hk();
    return null;
  }));
  f2 = 0 !== (c2.flags & 15990);
  if (0 !== (c2.subtreeFlags & 15990) || f2) {
    f2 = ok.transition;
    ok.transition = null;
    var g2 = C;
    C = 1;
    var h2 = K;
    K |= 4;
    nk.current = null;
    Oj(a, c2);
    dk(c2, a);
    Oe(Df);
    dd = !!Cf;
    Df = Cf = null;
    a.current = c2;
    hk(c2);
    dc();
    K = h2;
    C = g2;
    ok.transition = f2;
  } else a.current = c2;
  vk && (vk = false, wk = a, xk = e2);
  f2 = a.pendingLanes;
  0 === f2 && (Ri = null);
  mc(c2.stateNode);
  Dk(a, B());
  if (null !== b2) for (d2 = a.onRecoverableError, c2 = 0; c2 < b2.length; c2++) e2 = b2[c2], d2(e2.value, { componentStack: e2.stack, digest: e2.digest });
  if (Oi) throw Oi = false, a = Pi, Pi = null, a;
  0 !== (xk & 1) && 0 !== a.tag && Hk();
  f2 = a.pendingLanes;
  0 !== (f2 & 1) ? a === zk ? yk++ : (yk = 0, zk = a) : yk = 0;
  jg();
  return null;
}
function Hk() {
  if (null !== wk) {
    var a = Dc(xk), b2 = ok.transition, c2 = C;
    try {
      ok.transition = null;
      C = 16 > a ? 16 : a;
      if (null === wk) var d2 = false;
      else {
        a = wk;
        wk = null;
        xk = 0;
        if (0 !== (K & 6)) throw Error(p$1(331));
        var e2 = K;
        K |= 4;
        for (V = a.current; null !== V; ) {
          var f2 = V, g2 = f2.child;
          if (0 !== (V.flags & 16)) {
            var h2 = f2.deletions;
            if (null !== h2) {
              for (var k2 = 0; k2 < h2.length; k2++) {
                var l2 = h2[k2];
                for (V = l2; null !== V; ) {
                  var m2 = V;
                  switch (m2.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Pj(8, m2, f2);
                  }
                  var q2 = m2.child;
                  if (null !== q2) q2.return = m2, V = q2;
                  else for (; null !== V; ) {
                    m2 = V;
                    var r2 = m2.sibling, y2 = m2.return;
                    Sj(m2);
                    if (m2 === l2) {
                      V = null;
                      break;
                    }
                    if (null !== r2) {
                      r2.return = y2;
                      V = r2;
                      break;
                    }
                    V = y2;
                  }
                }
              }
              var n2 = f2.alternate;
              if (null !== n2) {
                var t2 = n2.child;
                if (null !== t2) {
                  n2.child = null;
                  do {
                    var J2 = t2.sibling;
                    t2.sibling = null;
                    t2 = J2;
                  } while (null !== t2);
                }
              }
              V = f2;
            }
          }
          if (0 !== (f2.subtreeFlags & 2064) && null !== g2) g2.return = f2, V = g2;
          else b: for (; null !== V; ) {
            f2 = V;
            if (0 !== (f2.flags & 2048)) switch (f2.tag) {
              case 0:
              case 11:
              case 15:
                Pj(9, f2, f2.return);
            }
            var x2 = f2.sibling;
            if (null !== x2) {
              x2.return = f2.return;
              V = x2;
              break b;
            }
            V = f2.return;
          }
        }
        var w2 = a.current;
        for (V = w2; null !== V; ) {
          g2 = V;
          var u2 = g2.child;
          if (0 !== (g2.subtreeFlags & 2064) && null !== u2) u2.return = g2, V = u2;
          else b: for (g2 = w2; null !== V; ) {
            h2 = V;
            if (0 !== (h2.flags & 2048)) try {
              switch (h2.tag) {
                case 0:
                case 11:
                case 15:
                  Qj(9, h2);
              }
            } catch (na) {
              W(h2, h2.return, na);
            }
            if (h2 === g2) {
              V = null;
              break b;
            }
            var F2 = h2.sibling;
            if (null !== F2) {
              F2.return = h2.return;
              V = F2;
              break b;
            }
            V = h2.return;
          }
        }
        K = e2;
        jg();
        if (lc && "function" === typeof lc.onPostCommitFiberRoot) try {
          lc.onPostCommitFiberRoot(kc, a);
        } catch (na) {
        }
        d2 = true;
      }
      return d2;
    } finally {
      C = c2, ok.transition = b2;
    }
  }
  return false;
}
function Xk(a, b2, c2) {
  b2 = Ji(c2, b2);
  b2 = Ni(a, b2, 1);
  a = nh(a, b2, 1);
  b2 = R();
  null !== a && (Ac(a, 1, b2), Dk(a, b2));
}
function W(a, b2, c2) {
  if (3 === a.tag) Xk(a, a, c2);
  else for (; null !== b2; ) {
    if (3 === b2.tag) {
      Xk(b2, a, c2);
      break;
    } else if (1 === b2.tag) {
      var d2 = b2.stateNode;
      if ("function" === typeof b2.type.getDerivedStateFromError || "function" === typeof d2.componentDidCatch && (null === Ri || !Ri.has(d2))) {
        a = Ji(c2, a);
        a = Qi(b2, a, 1);
        b2 = nh(b2, a, 1);
        a = R();
        null !== b2 && (Ac(b2, 1, a), Dk(b2, a));
        break;
      }
    }
    b2 = b2.return;
  }
}
function Ti(a, b2, c2) {
  var d2 = a.pingCache;
  null !== d2 && d2.delete(b2);
  b2 = R();
  a.pingedLanes |= a.suspendedLanes & c2;
  Q === a && (Z & c2) === c2 && (4 === T || 3 === T && (Z & 130023424) === Z && 500 > B() - fk ? Kk(a, 0) : rk |= c2);
  Dk(a, b2);
}
function Yk(a, b2) {
  0 === b2 && (0 === (a.mode & 1) ? b2 = 1 : (b2 = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
  var c2 = R();
  a = ih(a, b2);
  null !== a && (Ac(a, b2, c2), Dk(a, c2));
}
function uj(a) {
  var b2 = a.memoizedState, c2 = 0;
  null !== b2 && (c2 = b2.retryLane);
  Yk(a, c2);
}
function bk(a, b2) {
  var c2 = 0;
  switch (a.tag) {
    case 13:
      var d2 = a.stateNode;
      var e2 = a.memoizedState;
      null !== e2 && (c2 = e2.retryLane);
      break;
    case 19:
      d2 = a.stateNode;
      break;
    default:
      throw Error(p$1(314));
  }
  null !== d2 && d2.delete(b2);
  Yk(a, c2);
}
var Vk;
Vk = function(a, b2, c2) {
  if (null !== a) if (a.memoizedProps !== b2.pendingProps || Wf.current) dh = true;
  else {
    if (0 === (a.lanes & c2) && 0 === (b2.flags & 128)) return dh = false, yj(a, b2, c2);
    dh = 0 !== (a.flags & 131072) ? true : false;
  }
  else dh = false, I && 0 !== (b2.flags & 1048576) && ug(b2, ng, b2.index);
  b2.lanes = 0;
  switch (b2.tag) {
    case 2:
      var d2 = b2.type;
      ij(a, b2);
      a = b2.pendingProps;
      var e2 = Yf(b2, H.current);
      ch(b2, c2);
      e2 = Nh(null, b2, d2, a, e2, c2);
      var f2 = Sh();
      b2.flags |= 1;
      "object" === typeof e2 && null !== e2 && "function" === typeof e2.render && void 0 === e2.$$typeof ? (b2.tag = 1, b2.memoizedState = null, b2.updateQueue = null, Zf(d2) ? (f2 = true, cg(b2)) : f2 = false, b2.memoizedState = null !== e2.state && void 0 !== e2.state ? e2.state : null, kh(b2), e2.updater = Ei, b2.stateNode = e2, e2._reactInternals = b2, Ii(b2, d2, a, c2), b2 = jj(null, b2, d2, true, f2, c2)) : (b2.tag = 0, I && f2 && vg(b2), Xi(null, b2, e2, c2), b2 = b2.child);
      return b2;
    case 16:
      d2 = b2.elementType;
      a: {
        ij(a, b2);
        a = b2.pendingProps;
        e2 = d2._init;
        d2 = e2(d2._payload);
        b2.type = d2;
        e2 = b2.tag = Zk(d2);
        a = Ci(d2, a);
        switch (e2) {
          case 0:
            b2 = cj(null, b2, d2, a, c2);
            break a;
          case 1:
            b2 = hj(null, b2, d2, a, c2);
            break a;
          case 11:
            b2 = Yi(null, b2, d2, a, c2);
            break a;
          case 14:
            b2 = $i(null, b2, d2, Ci(d2.type, a), c2);
            break a;
        }
        throw Error(p$1(
          306,
          d2,
          ""
        ));
      }
      return b2;
    case 0:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Ci(d2, e2), cj(a, b2, d2, e2, c2);
    case 1:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Ci(d2, e2), hj(a, b2, d2, e2, c2);
    case 3:
      a: {
        kj(b2);
        if (null === a) throw Error(p$1(387));
        d2 = b2.pendingProps;
        f2 = b2.memoizedState;
        e2 = f2.element;
        lh(a, b2);
        qh(b2, d2, null, c2);
        var g2 = b2.memoizedState;
        d2 = g2.element;
        if (f2.isDehydrated) if (f2 = { element: d2, isDehydrated: false, cache: g2.cache, pendingSuspenseBoundaries: g2.pendingSuspenseBoundaries, transitions: g2.transitions }, b2.updateQueue.baseState = f2, b2.memoizedState = f2, b2.flags & 256) {
          e2 = Ji(Error(p$1(423)), b2);
          b2 = lj(a, b2, d2, c2, e2);
          break a;
        } else if (d2 !== e2) {
          e2 = Ji(Error(p$1(424)), b2);
          b2 = lj(a, b2, d2, c2, e2);
          break a;
        } else for (yg = Lf(b2.stateNode.containerInfo.firstChild), xg = b2, I = true, zg = null, c2 = Vg(b2, null, d2, c2), b2.child = c2; c2; ) c2.flags = c2.flags & -3 | 4096, c2 = c2.sibling;
        else {
          Ig();
          if (d2 === e2) {
            b2 = Zi(a, b2, c2);
            break a;
          }
          Xi(a, b2, d2, c2);
        }
        b2 = b2.child;
      }
      return b2;
    case 5:
      return Ah(b2), null === a && Eg(b2), d2 = b2.type, e2 = b2.pendingProps, f2 = null !== a ? a.memoizedProps : null, g2 = e2.children, Ef(d2, e2) ? g2 = null : null !== f2 && Ef(d2, f2) && (b2.flags |= 32), gj(a, b2), Xi(a, b2, g2, c2), b2.child;
    case 6:
      return null === a && Eg(b2), null;
    case 13:
      return oj(a, b2, c2);
    case 4:
      return yh(b2, b2.stateNode.containerInfo), d2 = b2.pendingProps, null === a ? b2.child = Ug(b2, null, d2, c2) : Xi(a, b2, d2, c2), b2.child;
    case 11:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Ci(d2, e2), Yi(a, b2, d2, e2, c2);
    case 7:
      return Xi(a, b2, b2.pendingProps, c2), b2.child;
    case 8:
      return Xi(a, b2, b2.pendingProps.children, c2), b2.child;
    case 12:
      return Xi(a, b2, b2.pendingProps.children, c2), b2.child;
    case 10:
      a: {
        d2 = b2.type._context;
        e2 = b2.pendingProps;
        f2 = b2.memoizedProps;
        g2 = e2.value;
        G(Wg, d2._currentValue);
        d2._currentValue = g2;
        if (null !== f2) if (He(f2.value, g2)) {
          if (f2.children === e2.children && !Wf.current) {
            b2 = Zi(a, b2, c2);
            break a;
          }
        } else for (f2 = b2.child, null !== f2 && (f2.return = b2); null !== f2; ) {
          var h2 = f2.dependencies;
          if (null !== h2) {
            g2 = f2.child;
            for (var k2 = h2.firstContext; null !== k2; ) {
              if (k2.context === d2) {
                if (1 === f2.tag) {
                  k2 = mh(-1, c2 & -c2);
                  k2.tag = 2;
                  var l2 = f2.updateQueue;
                  if (null !== l2) {
                    l2 = l2.shared;
                    var m2 = l2.pending;
                    null === m2 ? k2.next = k2 : (k2.next = m2.next, m2.next = k2);
                    l2.pending = k2;
                  }
                }
                f2.lanes |= c2;
                k2 = f2.alternate;
                null !== k2 && (k2.lanes |= c2);
                bh(
                  f2.return,
                  c2,
                  b2
                );
                h2.lanes |= c2;
                break;
              }
              k2 = k2.next;
            }
          } else if (10 === f2.tag) g2 = f2.type === b2.type ? null : f2.child;
          else if (18 === f2.tag) {
            g2 = f2.return;
            if (null === g2) throw Error(p$1(341));
            g2.lanes |= c2;
            h2 = g2.alternate;
            null !== h2 && (h2.lanes |= c2);
            bh(g2, c2, b2);
            g2 = f2.sibling;
          } else g2 = f2.child;
          if (null !== g2) g2.return = f2;
          else for (g2 = f2; null !== g2; ) {
            if (g2 === b2) {
              g2 = null;
              break;
            }
            f2 = g2.sibling;
            if (null !== f2) {
              f2.return = g2.return;
              g2 = f2;
              break;
            }
            g2 = g2.return;
          }
          f2 = g2;
        }
        Xi(a, b2, e2.children, c2);
        b2 = b2.child;
      }
      return b2;
    case 9:
      return e2 = b2.type, d2 = b2.pendingProps.children, ch(b2, c2), e2 = eh(e2), d2 = d2(e2), b2.flags |= 1, Xi(a, b2, d2, c2), b2.child;
    case 14:
      return d2 = b2.type, e2 = Ci(d2, b2.pendingProps), e2 = Ci(d2.type, e2), $i(a, b2, d2, e2, c2);
    case 15:
      return bj(a, b2, b2.type, b2.pendingProps, c2);
    case 17:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Ci(d2, e2), ij(a, b2), b2.tag = 1, Zf(d2) ? (a = true, cg(b2)) : a = false, ch(b2, c2), Gi(b2, d2, e2), Ii(b2, d2, e2, c2), jj(null, b2, d2, true, a, c2);
    case 19:
      return xj(a, b2, c2);
    case 22:
      return dj(a, b2, c2);
  }
  throw Error(p$1(156, b2.tag));
};
function Fk(a, b2) {
  return ac(a, b2);
}
function $k(a, b2, c2, d2) {
  this.tag = a;
  this.key = c2;
  this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
  this.index = 0;
  this.ref = null;
  this.pendingProps = b2;
  this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
  this.mode = d2;
  this.subtreeFlags = this.flags = 0;
  this.deletions = null;
  this.childLanes = this.lanes = 0;
  this.alternate = null;
}
function Bg(a, b2, c2, d2) {
  return new $k(a, b2, c2, d2);
}
function aj(a) {
  a = a.prototype;
  return !(!a || !a.isReactComponent);
}
function Zk(a) {
  if ("function" === typeof a) return aj(a) ? 1 : 0;
  if (void 0 !== a && null !== a) {
    a = a.$$typeof;
    if (a === Da) return 11;
    if (a === Ga) return 14;
  }
  return 2;
}
function Pg(a, b2) {
  var c2 = a.alternate;
  null === c2 ? (c2 = Bg(a.tag, b2, a.key, a.mode), c2.elementType = a.elementType, c2.type = a.type, c2.stateNode = a.stateNode, c2.alternate = a, a.alternate = c2) : (c2.pendingProps = b2, c2.type = a.type, c2.flags = 0, c2.subtreeFlags = 0, c2.deletions = null);
  c2.flags = a.flags & 14680064;
  c2.childLanes = a.childLanes;
  c2.lanes = a.lanes;
  c2.child = a.child;
  c2.memoizedProps = a.memoizedProps;
  c2.memoizedState = a.memoizedState;
  c2.updateQueue = a.updateQueue;
  b2 = a.dependencies;
  c2.dependencies = null === b2 ? null : { lanes: b2.lanes, firstContext: b2.firstContext };
  c2.sibling = a.sibling;
  c2.index = a.index;
  c2.ref = a.ref;
  return c2;
}
function Rg(a, b2, c2, d2, e2, f2) {
  var g2 = 2;
  d2 = a;
  if ("function" === typeof a) aj(a) && (g2 = 1);
  else if ("string" === typeof a) g2 = 5;
  else a: switch (a) {
    case ya:
      return Tg(c2.children, e2, f2, b2);
    case za:
      g2 = 8;
      e2 |= 8;
      break;
    case Aa:
      return a = Bg(12, c2, b2, e2 | 2), a.elementType = Aa, a.lanes = f2, a;
    case Ea:
      return a = Bg(13, c2, b2, e2), a.elementType = Ea, a.lanes = f2, a;
    case Fa:
      return a = Bg(19, c2, b2, e2), a.elementType = Fa, a.lanes = f2, a;
    case Ia:
      return pj(c2, e2, f2, b2);
    default:
      if ("object" === typeof a && null !== a) switch (a.$$typeof) {
        case Ba:
          g2 = 10;
          break a;
        case Ca:
          g2 = 9;
          break a;
        case Da:
          g2 = 11;
          break a;
        case Ga:
          g2 = 14;
          break a;
        case Ha:
          g2 = 16;
          d2 = null;
          break a;
      }
      throw Error(p$1(130, null == a ? a : typeof a, ""));
  }
  b2 = Bg(g2, c2, b2, e2);
  b2.elementType = a;
  b2.type = d2;
  b2.lanes = f2;
  return b2;
}
function Tg(a, b2, c2, d2) {
  a = Bg(7, a, d2, b2);
  a.lanes = c2;
  return a;
}
function pj(a, b2, c2, d2) {
  a = Bg(22, a, d2, b2);
  a.elementType = Ia;
  a.lanes = c2;
  a.stateNode = { isHidden: false };
  return a;
}
function Qg(a, b2, c2) {
  a = Bg(6, a, null, b2);
  a.lanes = c2;
  return a;
}
function Sg(a, b2, c2) {
  b2 = Bg(4, null !== a.children ? a.children : [], a.key, b2);
  b2.lanes = c2;
  b2.stateNode = { containerInfo: a.containerInfo, pendingChildren: null, implementation: a.implementation };
  return b2;
}
function al(a, b2, c2, d2, e2) {
  this.tag = b2;
  this.containerInfo = a;
  this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
  this.timeoutHandle = -1;
  this.callbackNode = this.pendingContext = this.context = null;
  this.callbackPriority = 0;
  this.eventTimes = zc(0);
  this.expirationTimes = zc(-1);
  this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
  this.entanglements = zc(0);
  this.identifierPrefix = d2;
  this.onRecoverableError = e2;
  this.mutableSourceEagerHydrationData = null;
}
function bl(a, b2, c2, d2, e2, f2, g2, h2, k2) {
  a = new al(a, b2, c2, h2, k2);
  1 === b2 ? (b2 = 1, true === f2 && (b2 |= 8)) : b2 = 0;
  f2 = Bg(3, null, null, b2);
  a.current = f2;
  f2.stateNode = a;
  f2.memoizedState = { element: d2, isDehydrated: c2, cache: null, transitions: null, pendingSuspenseBoundaries: null };
  kh(f2);
  return a;
}
function cl(a, b2, c2) {
  var d2 = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
  return { $$typeof: wa, key: null == d2 ? null : "" + d2, children: a, containerInfo: b2, implementation: c2 };
}
function dl(a) {
  if (!a) return Vf;
  a = a._reactInternals;
  a: {
    if (Vb(a) !== a || 1 !== a.tag) throw Error(p$1(170));
    var b2 = a;
    do {
      switch (b2.tag) {
        case 3:
          b2 = b2.stateNode.context;
          break a;
        case 1:
          if (Zf(b2.type)) {
            b2 = b2.stateNode.__reactInternalMemoizedMergedChildContext;
            break a;
          }
      }
      b2 = b2.return;
    } while (null !== b2);
    throw Error(p$1(171));
  }
  if (1 === a.tag) {
    var c2 = a.type;
    if (Zf(c2)) return bg(a, c2, b2);
  }
  return b2;
}
function el(a, b2, c2, d2, e2, f2, g2, h2, k2) {
  a = bl(c2, d2, true, a, e2, f2, g2, h2, k2);
  a.context = dl(null);
  c2 = a.current;
  d2 = R();
  e2 = yi(c2);
  f2 = mh(d2, e2);
  f2.callback = void 0 !== b2 && null !== b2 ? b2 : null;
  nh(c2, f2, e2);
  a.current.lanes = e2;
  Ac(a, e2, d2);
  Dk(a, d2);
  return a;
}
function fl(a, b2, c2, d2) {
  var e2 = b2.current, f2 = R(), g2 = yi(e2);
  c2 = dl(c2);
  null === b2.context ? b2.context = c2 : b2.pendingContext = c2;
  b2 = mh(f2, g2);
  b2.payload = { element: a };
  d2 = void 0 === d2 ? null : d2;
  null !== d2 && (b2.callback = d2);
  a = nh(e2, b2, g2);
  null !== a && (gi(a, e2, g2, f2), oh(a, e2, g2));
  return g2;
}
function gl(a) {
  a = a.current;
  if (!a.child) return null;
  switch (a.child.tag) {
    case 5:
      return a.child.stateNode;
    default:
      return a.child.stateNode;
  }
}
function hl(a, b2) {
  a = a.memoizedState;
  if (null !== a && null !== a.dehydrated) {
    var c2 = a.retryLane;
    a.retryLane = 0 !== c2 && c2 < b2 ? c2 : b2;
  }
}
function il(a, b2) {
  hl(a, b2);
  (a = a.alternate) && hl(a, b2);
}
var kl = "function" === typeof reportError ? reportError : function(a) {
  console.error(a);
};
function ll(a) {
  this._internalRoot = a;
}
ml.prototype.render = ll.prototype.render = function(a) {
  var b2 = this._internalRoot;
  if (null === b2) throw Error(p$1(409));
  fl(a, b2, null, null);
};
ml.prototype.unmount = ll.prototype.unmount = function() {
  var a = this._internalRoot;
  if (null !== a) {
    this._internalRoot = null;
    var b2 = a.containerInfo;
    Rk(function() {
      fl(null, a, null, null);
    });
    b2[uf] = null;
  }
};
function ml(a) {
  this._internalRoot = a;
}
ml.prototype.unstable_scheduleHydration = function(a) {
  if (a) {
    var b2 = Hc();
    a = { blockedOn: null, target: a, priority: b2 };
    for (var c2 = 0; c2 < Qc.length && 0 !== b2 && b2 < Qc[c2].priority; c2++) ;
    Qc.splice(c2, 0, a);
    0 === c2 && Vc(a);
  }
};
function nl(a) {
  return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType);
}
function ol(a) {
  return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType && (8 !== a.nodeType || " react-mount-point-unstable " !== a.nodeValue));
}
function pl() {
}
function ql(a, b2, c2, d2, e2) {
  if (e2) {
    if ("function" === typeof d2) {
      var f2 = d2;
      d2 = function() {
        var a2 = gl(g2);
        f2.call(a2);
      };
    }
    var g2 = el(b2, d2, a, 0, null, false, false, "", pl);
    a._reactRootContainer = g2;
    a[uf] = g2.current;
    sf(8 === a.nodeType ? a.parentNode : a);
    Rk();
    return g2;
  }
  for (; e2 = a.lastChild; ) a.removeChild(e2);
  if ("function" === typeof d2) {
    var h2 = d2;
    d2 = function() {
      var a2 = gl(k2);
      h2.call(a2);
    };
  }
  var k2 = bl(a, 0, false, null, null, false, false, "", pl);
  a._reactRootContainer = k2;
  a[uf] = k2.current;
  sf(8 === a.nodeType ? a.parentNode : a);
  Rk(function() {
    fl(b2, k2, c2, d2);
  });
  return k2;
}
function rl(a, b2, c2, d2, e2) {
  var f2 = c2._reactRootContainer;
  if (f2) {
    var g2 = f2;
    if ("function" === typeof e2) {
      var h2 = e2;
      e2 = function() {
        var a2 = gl(g2);
        h2.call(a2);
      };
    }
    fl(b2, g2, a, e2);
  } else g2 = ql(c2, b2, a, e2, d2);
  return gl(g2);
}
Ec = function(a) {
  switch (a.tag) {
    case 3:
      var b2 = a.stateNode;
      if (b2.current.memoizedState.isDehydrated) {
        var c2 = tc(b2.pendingLanes);
        0 !== c2 && (Cc(b2, c2 | 1), Dk(b2, B()), 0 === (K & 6) && (Gj = B() + 500, jg()));
      }
      break;
    case 13:
      Rk(function() {
        var b3 = ih(a, 1);
        if (null !== b3) {
          var c3 = R();
          gi(b3, a, 1, c3);
        }
      }), il(a, 1);
  }
};
Fc = function(a) {
  if (13 === a.tag) {
    var b2 = ih(a, 134217728);
    if (null !== b2) {
      var c2 = R();
      gi(b2, a, 134217728, c2);
    }
    il(a, 134217728);
  }
};
Gc = function(a) {
  if (13 === a.tag) {
    var b2 = yi(a), c2 = ih(a, b2);
    if (null !== c2) {
      var d2 = R();
      gi(c2, a, b2, d2);
    }
    il(a, b2);
  }
};
Hc = function() {
  return C;
};
Ic = function(a, b2) {
  var c2 = C;
  try {
    return C = a, b2();
  } finally {
    C = c2;
  }
};
yb = function(a, b2, c2) {
  switch (b2) {
    case "input":
      bb(a, c2);
      b2 = c2.name;
      if ("radio" === c2.type && null != b2) {
        for (c2 = a; c2.parentNode; ) c2 = c2.parentNode;
        c2 = c2.querySelectorAll("input[name=" + JSON.stringify("" + b2) + '][type="radio"]');
        for (b2 = 0; b2 < c2.length; b2++) {
          var d2 = c2[b2];
          if (d2 !== a && d2.form === a.form) {
            var e2 = Db(d2);
            if (!e2) throw Error(p$1(90));
            Wa(d2);
            bb(d2, e2);
          }
        }
      }
      break;
    case "textarea":
      ib(a, c2);
      break;
    case "select":
      b2 = c2.value, null != b2 && fb(a, !!c2.multiple, b2, false);
  }
};
Gb = Qk;
Hb = Rk;
var sl = { usingClientEntryPoint: false, Events: [Cb, ue, Db, Eb, Fb, Qk] }, tl = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" };
var ul = { bundleType: tl.bundleType, version: tl.version, rendererPackageName: tl.rendererPackageName, rendererConfig: tl.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua.ReactCurrentDispatcher, findHostInstanceByFiber: function(a) {
  a = Zb(a);
  return null === a ? null : a.stateNode;
}, findFiberByHostInstance: tl.findFiberByHostInstance, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" };
if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
  var vl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!vl.isDisabled && vl.supportsFiber) try {
    kc = vl.inject(ul), lc = vl;
  } catch (a) {
  }
}
reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = sl;
reactDom_production_min.createPortal = function(a, b2) {
  var c2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
  if (!nl(b2)) throw Error(p$1(200));
  return cl(a, b2, null, c2);
};
reactDom_production_min.createRoot = function(a, b2) {
  if (!nl(a)) throw Error(p$1(299));
  var c2 = false, d2 = "", e2 = kl;
  null !== b2 && void 0 !== b2 && (true === b2.unstable_strictMode && (c2 = true), void 0 !== b2.identifierPrefix && (d2 = b2.identifierPrefix), void 0 !== b2.onRecoverableError && (e2 = b2.onRecoverableError));
  b2 = bl(a, 1, false, null, null, c2, false, d2, e2);
  a[uf] = b2.current;
  sf(8 === a.nodeType ? a.parentNode : a);
  return new ll(b2);
};
reactDom_production_min.findDOMNode = function(a) {
  if (null == a) return null;
  if (1 === a.nodeType) return a;
  var b2 = a._reactInternals;
  if (void 0 === b2) {
    if ("function" === typeof a.render) throw Error(p$1(188));
    a = Object.keys(a).join(",");
    throw Error(p$1(268, a));
  }
  a = Zb(b2);
  a = null === a ? null : a.stateNode;
  return a;
};
reactDom_production_min.flushSync = function(a) {
  return Rk(a);
};
reactDom_production_min.hydrate = function(a, b2, c2) {
  if (!ol(b2)) throw Error(p$1(200));
  return rl(null, a, b2, true, c2);
};
reactDom_production_min.hydrateRoot = function(a, b2, c2) {
  if (!nl(a)) throw Error(p$1(405));
  var d2 = null != c2 && c2.hydratedSources || null, e2 = false, f2 = "", g2 = kl;
  null !== c2 && void 0 !== c2 && (true === c2.unstable_strictMode && (e2 = true), void 0 !== c2.identifierPrefix && (f2 = c2.identifierPrefix), void 0 !== c2.onRecoverableError && (g2 = c2.onRecoverableError));
  b2 = el(b2, null, a, 1, null != c2 ? c2 : null, e2, false, f2, g2);
  a[uf] = b2.current;
  sf(a);
  if (d2) for (a = 0; a < d2.length; a++) c2 = d2[a], e2 = c2._getVersion, e2 = e2(c2._source), null == b2.mutableSourceEagerHydrationData ? b2.mutableSourceEagerHydrationData = [c2, e2] : b2.mutableSourceEagerHydrationData.push(
    c2,
    e2
  );
  return new ml(b2);
};
reactDom_production_min.render = function(a, b2, c2) {
  if (!ol(b2)) throw Error(p$1(200));
  return rl(null, a, b2, false, c2);
};
reactDom_production_min.unmountComponentAtNode = function(a) {
  if (!ol(a)) throw Error(p$1(40));
  return a._reactRootContainer ? (Rk(function() {
    rl(null, null, a, false, function() {
      a._reactRootContainer = null;
      a[uf] = null;
    });
  }), true) : false;
};
reactDom_production_min.unstable_batchedUpdates = Qk;
reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a, b2, c2, d2) {
  if (!ol(c2)) throw Error(p$1(200));
  if (null == a || void 0 === a._reactInternals) throw Error(p$1(38));
  return rl(a, b2, c2, false, d2);
};
reactDom_production_min.version = "18.3.1-next-f1338f8080-20240426";
function checkDCE() {
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
    return;
  }
  try {
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    console.error(err);
  }
}
{
  checkDCE();
  reactDom.exports = reactDom_production_min;
}
var reactDomExports = reactDom.exports;
const ReactDOM = /* @__PURE__ */ getDefaultExportFromCjs$2(reactDomExports);
var createRoot;
var m$1 = reactDomExports;
{
  createRoot = m$1.createRoot;
  m$1.hydrateRoot;
}
var withSelector = { exports: {} };
var useSyncExternalStoreWithSelector_production = {};
/**
 * @license React
 * use-sync-external-store-with-selector.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var React = reactExports;
function is$1(x2, y2) {
  return x2 === y2 && (0 !== x2 || 1 / x2 === 1 / y2) || x2 !== x2 && y2 !== y2;
}
var objectIs = "function" === typeof Object.is ? Object.is : is$1, useSyncExternalStore = React.useSyncExternalStore, useRef = React.useRef, useEffect = React.useEffect, useMemo = React.useMemo, useDebugValue = React.useDebugValue;
useSyncExternalStoreWithSelector_production.useSyncExternalStoreWithSelector = function(subscribe2, getSnapshot, getServerSnapshot, selector, isEqual) {
  var instRef = useRef(null);
  if (null === instRef.current) {
    var inst = { hasValue: false, value: null };
    instRef.current = inst;
  } else inst = instRef.current;
  instRef = useMemo(
    function() {
      function memoizedSelector(nextSnapshot) {
        if (!hasMemo) {
          hasMemo = true;
          memoizedSnapshot = nextSnapshot;
          nextSnapshot = selector(nextSnapshot);
          if (void 0 !== isEqual && inst.hasValue) {
            var currentSelection = inst.value;
            if (isEqual(currentSelection, nextSnapshot))
              return memoizedSelection = currentSelection;
          }
          return memoizedSelection = nextSnapshot;
        }
        currentSelection = memoizedSelection;
        if (objectIs(memoizedSnapshot, nextSnapshot)) return currentSelection;
        var nextSelection = selector(nextSnapshot);
        if (void 0 !== isEqual && isEqual(currentSelection, nextSelection))
          return memoizedSnapshot = nextSnapshot, currentSelection;
        memoizedSnapshot = nextSnapshot;
        return memoizedSelection = nextSelection;
      }
      var hasMemo = false, memoizedSnapshot, memoizedSelection, maybeGetServerSnapshot = void 0 === getServerSnapshot ? null : getServerSnapshot;
      return [
        function() {
          return memoizedSelector(getSnapshot());
        },
        null === maybeGetServerSnapshot ? void 0 : function() {
          return memoizedSelector(maybeGetServerSnapshot());
        }
      ];
    },
    [getSnapshot, getServerSnapshot, selector, isEqual]
  );
  var value = useSyncExternalStore(subscribe2, instRef[0], instRef[1]);
  useEffect(
    function() {
      inst.hasValue = true;
      inst.value = value;
    },
    [value]
  );
  useDebugValue(value);
  return value;
};
{
  withSelector.exports = useSyncExternalStoreWithSelector_production;
}
var withSelectorExports = withSelector.exports;
function defaultNoopBatch(callback2) {
  callback2();
}
function createListenerCollection() {
  let first = null;
  let last = null;
  return {
    clear() {
      first = null;
      last = null;
    },
    notify() {
      defaultNoopBatch(() => {
        let listener = first;
        while (listener) {
          listener.callback();
          listener = listener.next;
        }
      });
    },
    get() {
      const listeners = [];
      let listener = first;
      while (listener) {
        listeners.push(listener);
        listener = listener.next;
      }
      return listeners;
    },
    subscribe(callback2) {
      let isSubscribed = true;
      const listener = last = {
        callback: callback2,
        next: null,
        prev: last
      };
      if (listener.prev) {
        listener.prev.next = listener;
      } else {
        first = listener;
      }
      return function unsubscribe2() {
        if (!isSubscribed || first === null) return;
        isSubscribed = false;
        if (listener.next) {
          listener.next.prev = listener.prev;
        } else {
          last = listener.prev;
        }
        if (listener.prev) {
          listener.prev.next = listener.next;
        } else {
          first = listener.next;
        }
      };
    }
  };
}
var nullListeners = {
  notify() {
  },
  get: () => []
};
function createSubscription(store2, parentSub) {
  let unsubscribe2;
  let listeners = nullListeners;
  let subscriptionsAmount = 0;
  let selfSubscribed = false;
  function addNestedSub(listener) {
    trySubscribe();
    const cleanupListener = listeners.subscribe(listener);
    let removed = false;
    return () => {
      if (!removed) {
        removed = true;
        cleanupListener();
        tryUnsubscribe();
      }
    };
  }
  function notifyNestedSubs() {
    listeners.notify();
  }
  function handleChangeWrapper() {
    if (subscription.onStateChange) {
      subscription.onStateChange();
    }
  }
  function isSubscribed() {
    return selfSubscribed;
  }
  function trySubscribe() {
    subscriptionsAmount++;
    if (!unsubscribe2) {
      unsubscribe2 = store2.subscribe(handleChangeWrapper);
      listeners = createListenerCollection();
    }
  }
  function tryUnsubscribe() {
    subscriptionsAmount--;
    if (unsubscribe2 && subscriptionsAmount === 0) {
      unsubscribe2();
      unsubscribe2 = void 0;
      listeners.clear();
      listeners = nullListeners;
    }
  }
  function trySubscribeSelf() {
    if (!selfSubscribed) {
      selfSubscribed = true;
      trySubscribe();
    }
  }
  function tryUnsubscribeSelf() {
    if (selfSubscribed) {
      selfSubscribed = false;
      tryUnsubscribe();
    }
  }
  const subscription = {
    addNestedSub,
    notifyNestedSubs,
    handleChangeWrapper,
    isSubscribed,
    trySubscribe: trySubscribeSelf,
    tryUnsubscribe: tryUnsubscribeSelf,
    getListeners: () => listeners
  };
  return subscription;
}
var canUseDOM = () => !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
var isDOM = /* @__PURE__ */ canUseDOM();
var isRunningInReactNative = () => typeof navigator !== "undefined" && navigator.product === "ReactNative";
var isReactNative = /* @__PURE__ */ isRunningInReactNative();
var getUseIsomorphicLayoutEffect = () => isDOM || isReactNative ? reactExports.useLayoutEffect : reactExports.useEffect;
var useIsomorphicLayoutEffect$1 = /* @__PURE__ */ getUseIsomorphicLayoutEffect();
var ContextKey = /* @__PURE__ */ Symbol.for(`react-redux-context`);
var gT = typeof globalThis !== "undefined" ? globalThis : (
  /* fall back to a per-module scope (pre-8.1 behaviour) if `globalThis` is not available */
  {}
);
function getContext() {
  if (!reactExports.createContext) return {};
  const contextMap = gT[ContextKey] ?? (gT[ContextKey] = /* @__PURE__ */ new Map());
  let realContext = contextMap.get(reactExports.createContext);
  if (!realContext) {
    realContext = reactExports.createContext(
      null
    );
    contextMap.set(reactExports.createContext, realContext);
  }
  return realContext;
}
var ReactReduxContext = /* @__PURE__ */ getContext();
function Provider(providerProps) {
  const { children, context, serverState, store: store2 } = providerProps;
  const contextValue = reactExports.useMemo(() => {
    const subscription = createSubscription(store2);
    const baseContextValue = {
      store: store2,
      subscription,
      getServerState: serverState ? () => serverState : void 0
    };
    {
      return baseContextValue;
    }
  }, [store2, serverState]);
  const previousState = reactExports.useMemo(() => store2.getState(), [store2]);
  useIsomorphicLayoutEffect$1(() => {
    const { subscription } = contextValue;
    subscription.onStateChange = subscription.notifyNestedSubs;
    subscription.trySubscribe();
    if (previousState !== store2.getState()) {
      subscription.notifyNestedSubs();
    }
    return () => {
      subscription.tryUnsubscribe();
      subscription.onStateChange = void 0;
    };
  }, [contextValue, previousState]);
  const Context2 = context || ReactReduxContext;
  return /* @__PURE__ */ reactExports.createElement(Context2.Provider, { value: contextValue }, children);
}
var Provider_default = Provider;
function createReduxContextHook(context = ReactReduxContext) {
  return function useReduxContext2() {
    const contextValue = reactExports.useContext(context);
    return contextValue;
  };
}
var useReduxContext = /* @__PURE__ */ createReduxContextHook();
function createStoreHook(context = ReactReduxContext) {
  const useReduxContext2 = context === ReactReduxContext ? useReduxContext : (
    // @ts-ignore
    createReduxContextHook(context)
  );
  const useStore2 = () => {
    const { store: store2 } = useReduxContext2();
    return store2;
  };
  Object.assign(useStore2, {
    withTypes: () => useStore2
  });
  return useStore2;
}
var useStore = /* @__PURE__ */ createStoreHook();
function createDispatchHook(context = ReactReduxContext) {
  const useStore2 = context === ReactReduxContext ? useStore : createStoreHook(context);
  const useDispatch2 = () => {
    const store2 = useStore2();
    return store2.dispatch;
  };
  Object.assign(useDispatch2, {
    withTypes: () => useDispatch2
  });
  return useDispatch2;
}
var useDispatch = /* @__PURE__ */ createDispatchHook();
var refEquality = (a, b2) => a === b2;
function createSelectorHook(context = ReactReduxContext) {
  const useReduxContext2 = context === ReactReduxContext ? useReduxContext : createReduxContextHook(context);
  const useSelector2 = (selector, equalityFnOrOptions = {}) => {
    const { equalityFn = refEquality } = typeof equalityFnOrOptions === "function" ? { equalityFn: equalityFnOrOptions } : equalityFnOrOptions;
    const reduxContext = useReduxContext2();
    const { store: store2, subscription, getServerState } = reduxContext;
    reactExports.useRef(true);
    const wrappedSelector = reactExports.useCallback(
      {
        [selector.name](state) {
          const selected = selector(state);
          return selected;
        }
      }[selector.name],
      [selector]
    );
    const selectedState = withSelectorExports.useSyncExternalStoreWithSelector(
      subscription.addNestedSub,
      store2.getState,
      getServerState || store2.getState,
      wrappedSelector,
      equalityFn
    );
    reactExports.useDebugValue(selectedState);
    return selectedState;
  };
  Object.assign(useSelector2, {
    withTypes: () => useSelector2
  });
  return useSelector2;
}
var useSelector = /* @__PURE__ */ createSelectorHook();
var check = function(it) {
  return it && it.Math === Math && it;
};
var globalThis_1 = (
  // eslint-disable-next-line es/no-global-this -- safe
  check(typeof globalThis == "object" && globalThis) || check(typeof window == "object" && window) || // eslint-disable-next-line no-restricted-globals -- safe
  check(typeof self == "object" && self) || check(typeof commonjsGlobal == "object" && commonjsGlobal) || check(typeof commonjsGlobal == "object" && commonjsGlobal) || // eslint-disable-next-line no-new-func -- fallback
  /* @__PURE__ */ function() {
    return this;
  }() || Function("return this")()
);
var objectGetOwnPropertyDescriptor = {};
var fails$1z = function(exec2) {
  try {
    return !!exec2();
  } catch (error2) {
    return true;
  }
};
var fails$1y = fails$1z;
var descriptors$1 = !fails$1y(function() {
  return Object.defineProperty({}, 1, { get: function() {
    return 7;
  } })[1] !== 7;
});
var fails$1x = fails$1z;
var functionBindNative = !fails$1x(function() {
  var test2 = (function() {
  }).bind();
  return typeof test2 != "function" || test2.hasOwnProperty("prototype");
});
var NATIVE_BIND$4 = functionBindNative;
var call$1j = Function.prototype.call;
var functionCall = NATIVE_BIND$4 ? call$1j.bind(call$1j) : function() {
  return call$1j.apply(call$1j, arguments);
};
var objectPropertyIsEnumerable = {};
var $propertyIsEnumerable$2 = {}.propertyIsEnumerable;
var getOwnPropertyDescriptor$d = Object.getOwnPropertyDescriptor;
var NASHORN_BUG = getOwnPropertyDescriptor$d && !$propertyIsEnumerable$2.call({ 1: 2 }, 1);
objectPropertyIsEnumerable.f = NASHORN_BUG ? function propertyIsEnumerable(V2) {
  var descriptor = getOwnPropertyDescriptor$d(this, V2);
  return !!descriptor && descriptor.enumerable;
} : $propertyIsEnumerable$2;
var createPropertyDescriptor$d = function(bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value
  };
};
var NATIVE_BIND$3 = functionBindNative;
var FunctionPrototype$5 = Function.prototype;
var call$1i = FunctionPrototype$5.call;
var uncurryThisWithBind = NATIVE_BIND$3 && FunctionPrototype$5.bind.bind(call$1i, call$1i);
var functionUncurryThis = NATIVE_BIND$3 ? uncurryThisWithBind : function(fn) {
  return function() {
    return call$1i.apply(fn, arguments);
  };
};
var uncurryThis$1Y = functionUncurryThis;
var toString$M = uncurryThis$1Y({}.toString);
var stringSlice$m = uncurryThis$1Y("".slice);
var classofRaw$2 = function(it) {
  return stringSlice$m(toString$M(it), 8, -1);
};
var uncurryThis$1X = functionUncurryThis;
var fails$1w = fails$1z;
var classof$q = classofRaw$2;
var $Object$8 = Object;
var split$5 = uncurryThis$1X("".split);
var indexedObject = fails$1w(function() {
  return !$Object$8("z").propertyIsEnumerable(0);
}) ? function(it) {
  return classof$q(it) === "String" ? split$5(it, "") : $Object$8(it);
} : $Object$8;
var isNullOrUndefined$j = function(it) {
  return it === null || it === void 0;
};
var isNullOrUndefined$i = isNullOrUndefined$j;
var $TypeError$M = TypeError;
var requireObjectCoercible$q = function(it) {
  if (isNullOrUndefined$i(it)) throw new $TypeError$M("Can't call method on " + it);
  return it;
};
var IndexedObject$7 = indexedObject;
var requireObjectCoercible$p = requireObjectCoercible$q;
var toIndexedObject$k = function(it) {
  return IndexedObject$7(requireObjectCoercible$p(it));
};
var documentAll = typeof document == "object" && document.all;
var isCallable$I = typeof documentAll == "undefined" && documentAll !== void 0 ? function(argument) {
  return typeof argument == "function" || argument === documentAll;
} : function(argument) {
  return typeof argument == "function";
};
var isCallable$H = isCallable$I;
var isObject$O = function(it) {
  return typeof it == "object" ? it !== null : isCallable$H(it);
};
var globalThis$1k = globalThis_1;
var isCallable$G = isCallable$I;
var aFunction = function(argument) {
  return isCallable$G(argument) ? argument : void 0;
};
var getBuiltIn$O = function(namespace, method) {
  return arguments.length < 2 ? aFunction(globalThis$1k[namespace]) : globalThis$1k[namespace] && globalThis$1k[namespace][method];
};
var uncurryThis$1W = functionUncurryThis;
var objectIsPrototypeOf = uncurryThis$1W({}.isPrototypeOf);
var globalThis$1j = globalThis_1;
var navigator$1 = globalThis$1j.navigator;
var userAgent$8 = navigator$1 && navigator$1.userAgent;
var environmentUserAgent = userAgent$8 ? String(userAgent$8) : "";
var globalThis$1i = globalThis_1;
var userAgent$7 = environmentUserAgent;
var process$4 = globalThis$1i.process;
var Deno$1 = globalThis$1i.Deno;
var versions = process$4 && process$4.versions || Deno$1 && Deno$1.version;
var v8 = versions && versions.v8;
var match$2, version;
if (v8) {
  match$2 = v8.split(".");
  version = match$2[0] > 0 && match$2[0] < 4 ? 1 : +(match$2[0] + match$2[1]);
}
if (!version && userAgent$7) {
  match$2 = userAgent$7.match(/Edge\/(\d+)/);
  if (!match$2 || match$2[1] >= 74) {
    match$2 = userAgent$7.match(/Chrome\/(\d+)/);
    if (match$2) version = +match$2[1];
  }
}
var environmentV8Version = version;
var V8_VERSION$3 = environmentV8Version;
var fails$1v = fails$1z;
var globalThis$1h = globalThis_1;
var $String$a = globalThis$1h.String;
var symbolConstructorDetection = !!Object.getOwnPropertySymbols && !fails$1v(function() {
  var symbol = Symbol("symbol detection");
  return !$String$a(symbol) || !(Object(symbol) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
  !Symbol.sham && V8_VERSION$3 && V8_VERSION$3 < 41;
});
var NATIVE_SYMBOL$7 = symbolConstructorDetection;
var useSymbolAsUid = NATIVE_SYMBOL$7 && !Symbol.sham && typeof Symbol.iterator == "symbol";
var getBuiltIn$N = getBuiltIn$O;
var isCallable$F = isCallable$I;
var isPrototypeOf$f = objectIsPrototypeOf;
var USE_SYMBOL_AS_UID$1 = useSymbolAsUid;
var $Object$7 = Object;
var isSymbol$8 = USE_SYMBOL_AS_UID$1 ? function(it) {
  return typeof it == "symbol";
} : function(it) {
  var $Symbol2 = getBuiltIn$N("Symbol");
  return isCallable$F($Symbol2) && isPrototypeOf$f($Symbol2.prototype, $Object$7(it));
};
var $String$9 = String;
var tryToString$7 = function(argument) {
  try {
    return $String$9(argument);
  } catch (error2) {
    return "Object";
  }
};
var isCallable$E = isCallable$I;
var tryToString$6 = tryToString$7;
var $TypeError$L = TypeError;
var aCallable$Q = function(argument) {
  if (isCallable$E(argument)) return argument;
  throw new $TypeError$L(tryToString$6(argument) + " is not a function");
};
var aCallable$P = aCallable$Q;
var isNullOrUndefined$h = isNullOrUndefined$j;
var getMethod$l = function(V2, P2) {
  var func = V2[P2];
  return isNullOrUndefined$h(func) ? void 0 : aCallable$P(func);
};
var call$1h = functionCall;
var isCallable$D = isCallable$I;
var isObject$N = isObject$O;
var $TypeError$K = TypeError;
var ordinaryToPrimitive$2 = function(input, pref) {
  var fn, val;
  if (pref === "string" && isCallable$D(fn = input.toString) && !isObject$N(val = call$1h(fn, input))) return val;
  if (isCallable$D(fn = input.valueOf) && !isObject$N(val = call$1h(fn, input))) return val;
  if (pref !== "string" && isCallable$D(fn = input.toString) && !isObject$N(val = call$1h(fn, input))) return val;
  throw new $TypeError$K("Can't convert object to primitive value");
};
var sharedStore = { exports: {} };
var isPure = false;
var globalThis$1g = globalThis_1;
var defineProperty$i = Object.defineProperty;
var defineGlobalProperty$3 = function(key, value) {
  try {
    defineProperty$i(globalThis$1g, key, { value, configurable: true, writable: true });
  } catch (error2) {
    globalThis$1g[key] = value;
  }
  return value;
};
var globalThis$1f = globalThis_1;
var defineGlobalProperty$2 = defineGlobalProperty$3;
var SHARED = "__core-js_shared__";
var store$6 = sharedStore.exports = globalThis$1f[SHARED] || defineGlobalProperty$2(SHARED, {});
(store$6.versions || (store$6.versions = [])).push({
  version: "3.39.0",
  mode: "global",
  copyright: "© 2014-2024 Denis Pushkarev (zloirock.ru)",
  license: "https://github.com/zloirock/core-js/blob/v3.39.0/LICENSE",
  source: "https://github.com/zloirock/core-js"
});
var sharedStoreExports = sharedStore.exports;
var store$5 = sharedStoreExports;
var shared$a = function(key, value) {
  return store$5[key] || (store$5[key] = value || {});
};
var requireObjectCoercible$o = requireObjectCoercible$q;
var $Object$6 = Object;
var toObject$E = function(argument) {
  return $Object$6(requireObjectCoercible$o(argument));
};
var uncurryThis$1V = functionUncurryThis;
var toObject$D = toObject$E;
var hasOwnProperty$1 = uncurryThis$1V({}.hasOwnProperty);
var hasOwnProperty_1 = Object.hasOwn || function hasOwn(it, key) {
  return hasOwnProperty$1(toObject$D(it), key);
};
var uncurryThis$1U = functionUncurryThis;
var id$2 = 0;
var postfix = Math.random();
var toString$L = uncurryThis$1U(1 .toString);
var uid$7 = function(key) {
  return "Symbol(" + (key === void 0 ? "" : key) + ")_" + toString$L(++id$2 + postfix, 36);
};
var globalThis$1e = globalThis_1;
var shared$9 = shared$a;
var hasOwn$H = hasOwnProperty_1;
var uid$6 = uid$7;
var NATIVE_SYMBOL$6 = symbolConstructorDetection;
var USE_SYMBOL_AS_UID = useSymbolAsUid;
var Symbol$7 = globalThis$1e.Symbol;
var WellKnownSymbolsStore$2 = shared$9("wks");
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol$7["for"] || Symbol$7 : Symbol$7 && Symbol$7.withoutSetter || uid$6;
var wellKnownSymbol$S = function(name) {
  if (!hasOwn$H(WellKnownSymbolsStore$2, name)) {
    WellKnownSymbolsStore$2[name] = NATIVE_SYMBOL$6 && hasOwn$H(Symbol$7, name) ? Symbol$7[name] : createWellKnownSymbol("Symbol." + name);
  }
  return WellKnownSymbolsStore$2[name];
};
var call$1g = functionCall;
var isObject$M = isObject$O;
var isSymbol$7 = isSymbol$8;
var getMethod$k = getMethod$l;
var ordinaryToPrimitive$1 = ordinaryToPrimitive$2;
var wellKnownSymbol$R = wellKnownSymbol$S;
var $TypeError$J = TypeError;
var TO_PRIMITIVE$1 = wellKnownSymbol$R("toPrimitive");
var toPrimitive$4 = function(input, pref) {
  if (!isObject$M(input) || isSymbol$7(input)) return input;
  var exoticToPrim = getMethod$k(input, TO_PRIMITIVE$1);
  var result;
  if (exoticToPrim) {
    if (pref === void 0) pref = "default";
    result = call$1g(exoticToPrim, input, pref);
    if (!isObject$M(result) || isSymbol$7(result)) return result;
    throw new $TypeError$J("Can't convert object to primitive value");
  }
  if (pref === void 0) pref = "number";
  return ordinaryToPrimitive$1(input, pref);
};
var toPrimitive$3 = toPrimitive$4;
var isSymbol$6 = isSymbol$8;
var toPropertyKey$9 = function(argument) {
  var key = toPrimitive$3(argument, "string");
  return isSymbol$6(key) ? key : key + "";
};
var globalThis$1d = globalThis_1;
var isObject$L = isObject$O;
var document$3 = globalThis$1d.document;
var EXISTS$1 = isObject$L(document$3) && isObject$L(document$3.createElement);
var documentCreateElement$2 = function(it) {
  return EXISTS$1 ? document$3.createElement(it) : {};
};
var DESCRIPTORS$W = descriptors$1;
var fails$1u = fails$1z;
var createElement$1 = documentCreateElement$2;
var ie8DomDefine = !DESCRIPTORS$W && !fails$1u(function() {
  return Object.defineProperty(createElement$1("div"), "a", {
    get: function() {
      return 7;
    }
  }).a !== 7;
});
var DESCRIPTORS$V = descriptors$1;
var call$1f = functionCall;
var propertyIsEnumerableModule$2 = objectPropertyIsEnumerable;
var createPropertyDescriptor$c = createPropertyDescriptor$d;
var toIndexedObject$j = toIndexedObject$k;
var toPropertyKey$8 = toPropertyKey$9;
var hasOwn$G = hasOwnProperty_1;
var IE8_DOM_DEFINE$1 = ie8DomDefine;
var $getOwnPropertyDescriptor$2 = Object.getOwnPropertyDescriptor;
objectGetOwnPropertyDescriptor.f = DESCRIPTORS$V ? $getOwnPropertyDescriptor$2 : function getOwnPropertyDescriptor(O2, P2) {
  O2 = toIndexedObject$j(O2);
  P2 = toPropertyKey$8(P2);
  if (IE8_DOM_DEFINE$1) try {
    return $getOwnPropertyDescriptor$2(O2, P2);
  } catch (error2) {
  }
  if (hasOwn$G(O2, P2)) return createPropertyDescriptor$c(!call$1f(propertyIsEnumerableModule$2.f, O2, P2), O2[P2]);
};
var objectDefineProperty = {};
var DESCRIPTORS$U = descriptors$1;
var fails$1t = fails$1z;
var v8PrototypeDefineBug = DESCRIPTORS$U && fails$1t(function() {
  return Object.defineProperty(function() {
  }, "prototype", {
    value: 42,
    writable: false
  }).prototype !== 42;
});
var isObject$K = isObject$O;
var $String$8 = String;
var $TypeError$I = TypeError;
var anObject$1i = function(argument) {
  if (isObject$K(argument)) return argument;
  throw new $TypeError$I($String$8(argument) + " is not an object");
};
var DESCRIPTORS$T = descriptors$1;
var IE8_DOM_DEFINE = ie8DomDefine;
var V8_PROTOTYPE_DEFINE_BUG$1 = v8PrototypeDefineBug;
var anObject$1h = anObject$1i;
var toPropertyKey$7 = toPropertyKey$9;
var $TypeError$H = TypeError;
var $defineProperty$1 = Object.defineProperty;
var $getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;
var ENUMERABLE = "enumerable";
var CONFIGURABLE$1 = "configurable";
var WRITABLE = "writable";
objectDefineProperty.f = DESCRIPTORS$T ? V8_PROTOTYPE_DEFINE_BUG$1 ? function defineProperty(O2, P2, Attributes) {
  anObject$1h(O2);
  P2 = toPropertyKey$7(P2);
  anObject$1h(Attributes);
  if (typeof O2 === "function" && P2 === "prototype" && "value" in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
    var current = $getOwnPropertyDescriptor$1(O2, P2);
    if (current && current[WRITABLE]) {
      O2[P2] = Attributes.value;
      Attributes = {
        configurable: CONFIGURABLE$1 in Attributes ? Attributes[CONFIGURABLE$1] : current[CONFIGURABLE$1],
        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
        writable: false
      };
    }
  }
  return $defineProperty$1(O2, P2, Attributes);
} : $defineProperty$1 : function defineProperty2(O2, P2, Attributes) {
  anObject$1h(O2);
  P2 = toPropertyKey$7(P2);
  anObject$1h(Attributes);
  if (IE8_DOM_DEFINE) try {
    return $defineProperty$1(O2, P2, Attributes);
  } catch (error2) {
  }
  if ("get" in Attributes || "set" in Attributes) throw new $TypeError$H("Accessors not supported");
  if ("value" in Attributes) O2[P2] = Attributes.value;
  return O2;
};
var DESCRIPTORS$S = descriptors$1;
var definePropertyModule$b = objectDefineProperty;
var createPropertyDescriptor$b = createPropertyDescriptor$d;
var createNonEnumerableProperty$j = DESCRIPTORS$S ? function(object, key, value) {
  return definePropertyModule$b.f(object, key, createPropertyDescriptor$b(1, value));
} : function(object, key, value) {
  object[key] = value;
  return object;
};
var makeBuiltIn$5 = { exports: {} };
var DESCRIPTORS$R = descriptors$1;
var hasOwn$F = hasOwnProperty_1;
var FunctionPrototype$4 = Function.prototype;
var getDescriptor = DESCRIPTORS$R && Object.getOwnPropertyDescriptor;
var EXISTS = hasOwn$F(FunctionPrototype$4, "name");
var PROPER = EXISTS && (function something() {
}).name === "something";
var CONFIGURABLE = EXISTS && (!DESCRIPTORS$R || DESCRIPTORS$R && getDescriptor(FunctionPrototype$4, "name").configurable);
var functionName = {
  EXISTS,
  PROPER,
  CONFIGURABLE
};
var uncurryThis$1T = functionUncurryThis;
var isCallable$C = isCallable$I;
var store$4 = sharedStoreExports;
var functionToString$1 = uncurryThis$1T(Function.toString);
if (!isCallable$C(store$4.inspectSource)) {
  store$4.inspectSource = function(it) {
    return functionToString$1(it);
  };
}
var inspectSource$4 = store$4.inspectSource;
var globalThis$1c = globalThis_1;
var isCallable$B = isCallable$I;
var WeakMap$4 = globalThis$1c.WeakMap;
var weakMapBasicDetection = isCallable$B(WeakMap$4) && /native code/.test(String(WeakMap$4));
var shared$8 = shared$a;
var uid$5 = uid$7;
var keys$2 = shared$8("keys");
var sharedKey$4 = function(key) {
  return keys$2[key] || (keys$2[key] = uid$5(key));
};
var hiddenKeys$6 = {};
var NATIVE_WEAK_MAP$1 = weakMapBasicDetection;
var globalThis$1b = globalThis_1;
var isObject$J = isObject$O;
var createNonEnumerableProperty$i = createNonEnumerableProperty$j;
var hasOwn$E = hasOwnProperty_1;
var shared$7 = sharedStoreExports;
var sharedKey$3 = sharedKey$4;
var hiddenKeys$5 = hiddenKeys$6;
var OBJECT_ALREADY_INITIALIZED = "Object already initialized";
var TypeError$a = globalThis$1b.TypeError;
var WeakMap$3 = globalThis$1b.WeakMap;
var set$f, get$a, has$h;
var enforce = function(it) {
  return has$h(it) ? get$a(it) : set$f(it, {});
};
var getterFor$2 = function(TYPE) {
  return function(it) {
    var state;
    if (!isObject$J(it) || (state = get$a(it)).type !== TYPE) {
      throw new TypeError$a("Incompatible receiver, " + TYPE + " required");
    }
    return state;
  };
};
if (NATIVE_WEAK_MAP$1 || shared$7.state) {
  var store$3 = shared$7.state || (shared$7.state = new WeakMap$3());
  store$3.get = store$3.get;
  store$3.has = store$3.has;
  store$3.set = store$3.set;
  set$f = function(it, metadata3) {
    if (store$3.has(it)) throw new TypeError$a(OBJECT_ALREADY_INITIALIZED);
    metadata3.facade = it;
    store$3.set(it, metadata3);
    return metadata3;
  };
  get$a = function(it) {
    return store$3.get(it) || {};
  };
  has$h = function(it) {
    return store$3.has(it);
  };
} else {
  var STATE = sharedKey$3("state");
  hiddenKeys$5[STATE] = true;
  set$f = function(it, metadata3) {
    if (hasOwn$E(it, STATE)) throw new TypeError$a(OBJECT_ALREADY_INITIALIZED);
    metadata3.facade = it;
    createNonEnumerableProperty$i(it, STATE, metadata3);
    return metadata3;
  };
  get$a = function(it) {
    return hasOwn$E(it, STATE) ? it[STATE] : {};
  };
  has$h = function(it) {
    return hasOwn$E(it, STATE);
  };
}
var internalState = {
  set: set$f,
  get: get$a,
  has: has$h,
  enforce,
  getterFor: getterFor$2
};
var uncurryThis$1S = functionUncurryThis;
var fails$1s = fails$1z;
var isCallable$A = isCallable$I;
var hasOwn$D = hasOwnProperty_1;
var DESCRIPTORS$Q = descriptors$1;
var CONFIGURABLE_FUNCTION_NAME$2 = functionName.CONFIGURABLE;
var inspectSource$3 = inspectSource$4;
var InternalStateModule$n = internalState;
var enforceInternalState$4 = InternalStateModule$n.enforce;
var getInternalState$g = InternalStateModule$n.get;
var $String$7 = String;
var defineProperty$h = Object.defineProperty;
var stringSlice$l = uncurryThis$1S("".slice);
var replace$e = uncurryThis$1S("".replace);
var join$a = uncurryThis$1S([].join);
var CONFIGURABLE_LENGTH = DESCRIPTORS$Q && !fails$1s(function() {
  return defineProperty$h(function() {
  }, "length", { value: 8 }).length !== 8;
});
var TEMPLATE = String(String).split("String");
var makeBuiltIn$4 = makeBuiltIn$5.exports = function(value, name, options) {
  if (stringSlice$l($String$7(name), 0, 7) === "Symbol(") {
    name = "[" + replace$e($String$7(name), /^Symbol\(([^)]*)\).*$/, "$1") + "]";
  }
  if (options && options.getter) name = "get " + name;
  if (options && options.setter) name = "set " + name;
  if (!hasOwn$D(value, "name") || CONFIGURABLE_FUNCTION_NAME$2 && value.name !== name) {
    if (DESCRIPTORS$Q) defineProperty$h(value, "name", { value: name, configurable: true });
    else value.name = name;
  }
  if (CONFIGURABLE_LENGTH && options && hasOwn$D(options, "arity") && value.length !== options.arity) {
    defineProperty$h(value, "length", { value: options.arity });
  }
  try {
    if (options && hasOwn$D(options, "constructor") && options.constructor) {
      if (DESCRIPTORS$Q) defineProperty$h(value, "prototype", { writable: false });
    } else if (value.prototype) value.prototype = void 0;
  } catch (error2) {
  }
  var state = enforceInternalState$4(value);
  if (!hasOwn$D(state, "source")) {
    state.source = join$a(TEMPLATE, typeof name == "string" ? name : "");
  }
  return value;
};
Function.prototype.toString = makeBuiltIn$4(function toString() {
  return isCallable$A(this) && getInternalState$g(this).source || inspectSource$3(this);
}, "toString");
var makeBuiltInExports = makeBuiltIn$5.exports;
var isCallable$z = isCallable$I;
var definePropertyModule$a = objectDefineProperty;
var makeBuiltIn$3 = makeBuiltInExports;
var defineGlobalProperty$1 = defineGlobalProperty$3;
var defineBuiltIn$u = function(O2, key, value, options) {
  if (!options) options = {};
  var simple = options.enumerable;
  var name = options.name !== void 0 ? options.name : key;
  if (isCallable$z(value)) makeBuiltIn$3(value, name, options);
  if (options.global) {
    if (simple) O2[key] = value;
    else defineGlobalProperty$1(key, value);
  } else {
    try {
      if (!options.unsafe) delete O2[key];
      else if (O2[key]) simple = true;
    } catch (error2) {
    }
    if (simple) O2[key] = value;
    else definePropertyModule$a.f(O2, key, {
      value,
      enumerable: false,
      configurable: !options.nonConfigurable,
      writable: !options.nonWritable
    });
  }
  return O2;
};
var objectGetOwnPropertyNames = {};
var ceil$1 = Math.ceil;
var floor$a = Math.floor;
var mathTrunc = Math.trunc || function trunc(x2) {
  var n2 = +x2;
  return (n2 > 0 ? floor$a : ceil$1)(n2);
};
var trunc$1 = mathTrunc;
var toIntegerOrInfinity$p = function(argument) {
  var number = +argument;
  return number !== number || number === 0 ? 0 : trunc$1(number);
};
var toIntegerOrInfinity$o = toIntegerOrInfinity$p;
var max$9 = Math.max;
var min$f = Math.min;
var toAbsoluteIndex$a = function(index, length2) {
  var integer = toIntegerOrInfinity$o(index);
  return integer < 0 ? max$9(integer + length2, 0) : min$f(integer, length2);
};
var toIntegerOrInfinity$n = toIntegerOrInfinity$p;
var min$e = Math.min;
var toLength$d = function(argument) {
  var len = toIntegerOrInfinity$n(argument);
  return len > 0 ? min$e(len, 9007199254740991) : 0;
};
var toLength$c = toLength$d;
var lengthOfArrayLike$B = function(obj) {
  return toLength$c(obj.length);
};
var toIndexedObject$i = toIndexedObject$k;
var toAbsoluteIndex$9 = toAbsoluteIndex$a;
var lengthOfArrayLike$A = lengthOfArrayLike$B;
var createMethod$8 = function(IS_INCLUDES) {
  return function($this, el2, fromIndex) {
    var O2 = toIndexedObject$i($this);
    var length2 = lengthOfArrayLike$A(O2);
    if (length2 === 0) return !IS_INCLUDES && -1;
    var index = toAbsoluteIndex$9(fromIndex, length2);
    var value;
    if (IS_INCLUDES && el2 !== el2) while (length2 > index) {
      value = O2[index++];
      if (value !== value) return true;
    }
    else for (; length2 > index; index++) {
      if ((IS_INCLUDES || index in O2) && O2[index] === el2) return IS_INCLUDES || index || 0;
    }
    return !IS_INCLUDES && -1;
  };
};
var arrayIncludes = {
  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  includes: createMethod$8(true),
  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod$8(false)
};
var uncurryThis$1R = functionUncurryThis;
var hasOwn$C = hasOwnProperty_1;
var toIndexedObject$h = toIndexedObject$k;
var indexOf$2 = arrayIncludes.indexOf;
var hiddenKeys$4 = hiddenKeys$6;
var push$s = uncurryThis$1R([].push);
var objectKeysInternal = function(object, names) {
  var O2 = toIndexedObject$h(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O2) !hasOwn$C(hiddenKeys$4, key) && hasOwn$C(O2, key) && push$s(result, key);
  while (names.length > i) if (hasOwn$C(O2, key = names[i++])) {
    ~indexOf$2(result, key) || push$s(result, key);
  }
  return result;
};
var enumBugKeys$3 = [
  "constructor",
  "hasOwnProperty",
  "isPrototypeOf",
  "propertyIsEnumerable",
  "toLocaleString",
  "toString",
  "valueOf"
];
var internalObjectKeys$1 = objectKeysInternal;
var enumBugKeys$2 = enumBugKeys$3;
var hiddenKeys$3 = enumBugKeys$2.concat("length", "prototype");
objectGetOwnPropertyNames.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O2) {
  return internalObjectKeys$1(O2, hiddenKeys$3);
};
var objectGetOwnPropertySymbols = {};
objectGetOwnPropertySymbols.f = Object.getOwnPropertySymbols;
var getBuiltIn$M = getBuiltIn$O;
var uncurryThis$1Q = functionUncurryThis;
var getOwnPropertyNamesModule$2 = objectGetOwnPropertyNames;
var getOwnPropertySymbolsModule$3 = objectGetOwnPropertySymbols;
var anObject$1g = anObject$1i;
var concat$4 = uncurryThis$1Q([].concat);
var ownKeys$3 = getBuiltIn$M("Reflect", "ownKeys") || function ownKeys(it) {
  var keys6 = getOwnPropertyNamesModule$2.f(anObject$1g(it));
  var getOwnPropertySymbols2 = getOwnPropertySymbolsModule$3.f;
  return getOwnPropertySymbols2 ? concat$4(keys6, getOwnPropertySymbols2(it)) : keys6;
};
var hasOwn$B = hasOwnProperty_1;
var ownKeys$2 = ownKeys$3;
var getOwnPropertyDescriptorModule$6 = objectGetOwnPropertyDescriptor;
var definePropertyModule$9 = objectDefineProperty;
var copyConstructorProperties$7 = function(target, source, exceptions) {
  var keys6 = ownKeys$2(source);
  var defineProperty7 = definePropertyModule$9.f;
  var getOwnPropertyDescriptor7 = getOwnPropertyDescriptorModule$6.f;
  for (var i = 0; i < keys6.length; i++) {
    var key = keys6[i];
    if (!hasOwn$B(target, key) && !(exceptions && hasOwn$B(exceptions, key))) {
      defineProperty7(target, key, getOwnPropertyDescriptor7(source, key));
    }
  }
};
var fails$1r = fails$1z;
var isCallable$y = isCallable$I;
var replacement = /#|\.prototype\./;
var isForced$5 = function(feature, detection) {
  var value = data[normalize(feature)];
  return value === POLYFILL ? true : value === NATIVE ? false : isCallable$y(detection) ? fails$1r(detection) : !!detection;
};
var normalize = isForced$5.normalize = function(string) {
  return String(string).replace(replacement, ".").toLowerCase();
};
var data = isForced$5.data = {};
var NATIVE = isForced$5.NATIVE = "N";
var POLYFILL = isForced$5.POLYFILL = "P";
var isForced_1 = isForced$5;
var globalThis$1a = globalThis_1;
var getOwnPropertyDescriptor$c = objectGetOwnPropertyDescriptor.f;
var createNonEnumerableProperty$h = createNonEnumerableProperty$j;
var defineBuiltIn$t = defineBuiltIn$u;
var defineGlobalProperty = defineGlobalProperty$3;
var copyConstructorProperties$6 = copyConstructorProperties$7;
var isForced$4 = isForced_1;
var _export = function(options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED2, target, key, targetProperty, sourceProperty, descriptor;
  if (GLOBAL) {
    target = globalThis$1a;
  } else if (STATIC) {
    target = globalThis$1a[TARGET] || defineGlobalProperty(TARGET, {});
  } else {
    target = globalThis$1a[TARGET] && globalThis$1a[TARGET].prototype;
  }
  if (target) for (key in source) {
    sourceProperty = source[key];
    if (options.dontCallGetSet) {
      descriptor = getOwnPropertyDescriptor$c(target, key);
      targetProperty = descriptor && descriptor.value;
    } else targetProperty = target[key];
    FORCED2 = isForced$4(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options.forced);
    if (!FORCED2 && targetProperty !== void 0) {
      if (typeof sourceProperty == typeof targetProperty) continue;
      copyConstructorProperties$6(sourceProperty, targetProperty);
    }
    if (options.sham || targetProperty && targetProperty.sham) {
      createNonEnumerableProperty$h(sourceProperty, "sham", true);
    }
    defineBuiltIn$t(target, key, sourceProperty, options);
  }
};
var wellKnownSymbol$Q = wellKnownSymbol$S;
var TO_STRING_TAG$b = wellKnownSymbol$Q("toStringTag");
var test$3 = {};
test$3[TO_STRING_TAG$b] = "z";
var toStringTagSupport = String(test$3) === "[object z]";
var TO_STRING_TAG_SUPPORT$2 = toStringTagSupport;
var isCallable$x = isCallable$I;
var classofRaw$1 = classofRaw$2;
var wellKnownSymbol$P = wellKnownSymbol$S;
var TO_STRING_TAG$a = wellKnownSymbol$P("toStringTag");
var $Object$5 = Object;
var CORRECT_ARGUMENTS = classofRaw$1(/* @__PURE__ */ function() {
  return arguments;
}()) === "Arguments";
var tryGet = function(it, key) {
  try {
    return it[key];
  } catch (error2) {
  }
};
var classof$p = TO_STRING_TAG_SUPPORT$2 ? classofRaw$1 : function(it) {
  var O2, tag, result;
  return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (tag = tryGet(O2 = $Object$5(it), TO_STRING_TAG$a)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw$1(O2) : (result = classofRaw$1(O2)) === "Object" && isCallable$x(O2.callee) ? "Arguments" : result;
};
var classof$o = classof$p;
var $String$6 = String;
var toString$K = function(argument) {
  if (classof$o(argument) === "Symbol") throw new TypeError("Cannot convert a Symbol value to a string");
  return $String$6(argument);
};
var objectDefineProperties = {};
var internalObjectKeys = objectKeysInternal;
var enumBugKeys$1 = enumBugKeys$3;
var objectKeys$6 = Object.keys || function keys(O2) {
  return internalObjectKeys(O2, enumBugKeys$1);
};
var DESCRIPTORS$P = descriptors$1;
var V8_PROTOTYPE_DEFINE_BUG = v8PrototypeDefineBug;
var definePropertyModule$8 = objectDefineProperty;
var anObject$1f = anObject$1i;
var toIndexedObject$g = toIndexedObject$k;
var objectKeys$5 = objectKeys$6;
objectDefineProperties.f = DESCRIPTORS$P && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O2, Properties) {
  anObject$1f(O2);
  var props = toIndexedObject$g(Properties);
  var keys6 = objectKeys$5(Properties);
  var length2 = keys6.length;
  var index = 0;
  var key;
  while (length2 > index) definePropertyModule$8.f(O2, key = keys6[index++], props[key]);
  return O2;
};
var getBuiltIn$L = getBuiltIn$O;
var html$2 = getBuiltIn$L("document", "documentElement");
var anObject$1e = anObject$1i;
var definePropertiesModule$1 = objectDefineProperties;
var enumBugKeys = enumBugKeys$3;
var hiddenKeys$2 = hiddenKeys$6;
var html$1 = html$2;
var documentCreateElement$1 = documentCreateElement$2;
var sharedKey$2 = sharedKey$4;
var GT = ">";
var LT = "<";
var PROTOTYPE$2 = "prototype";
var SCRIPT = "script";
var IE_PROTO$1 = sharedKey$2("IE_PROTO");
var EmptyConstructor = function() {
};
var scriptTag = function(content) {
  return LT + SCRIPT + GT + content + LT + "/" + SCRIPT + GT;
};
var NullProtoObjectViaActiveX = function(activeXDocument2) {
  activeXDocument2.write(scriptTag(""));
  activeXDocument2.close();
  var temp = activeXDocument2.parentWindow.Object;
  activeXDocument2 = null;
  return temp;
};
var NullProtoObjectViaIFrame = function() {
  var iframe = documentCreateElement$1("iframe");
  var JS = "java" + SCRIPT + ":";
  var iframeDocument;
  iframe.style.display = "none";
  html$1.appendChild(iframe);
  iframe.src = String(JS);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(scriptTag("document.F=Object"));
  iframeDocument.close();
  return iframeDocument.F;
};
var activeXDocument;
var NullProtoObject = function() {
  try {
    activeXDocument = new ActiveXObject("htmlfile");
  } catch (error2) {
  }
  NullProtoObject = typeof document != "undefined" ? document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame() : NullProtoObjectViaActiveX(activeXDocument);
  var length2 = enumBugKeys.length;
  while (length2--) delete NullProtoObject[PROTOTYPE$2][enumBugKeys[length2]];
  return NullProtoObject();
};
hiddenKeys$2[IE_PROTO$1] = true;
var objectCreate$1 = Object.create || function create(O2, Properties) {
  var result;
  if (O2 !== null) {
    EmptyConstructor[PROTOTYPE$2] = anObject$1e(O2);
    result = new EmptyConstructor();
    EmptyConstructor[PROTOTYPE$2] = null;
    result[IE_PROTO$1] = O2;
  } else result = NullProtoObject();
  return Properties === void 0 ? result : definePropertiesModule$1.f(result, Properties);
};
var objectGetOwnPropertyNamesExternal = {};
var uncurryThis$1P = functionUncurryThis;
var arraySlice$a = uncurryThis$1P([].slice);
var classof$n = classofRaw$2;
var toIndexedObject$f = toIndexedObject$k;
var $getOwnPropertyNames$1 = objectGetOwnPropertyNames.f;
var arraySlice$9 = arraySlice$a;
var windowNames = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
var getWindowNames = function(it) {
  try {
    return $getOwnPropertyNames$1(it);
  } catch (error2) {
    return arraySlice$9(windowNames);
  }
};
objectGetOwnPropertyNamesExternal.f = function getOwnPropertyNames2(it) {
  return windowNames && classof$n(it) === "Window" ? getWindowNames(it) : $getOwnPropertyNames$1(toIndexedObject$f(it));
};
var makeBuiltIn$2 = makeBuiltInExports;
var defineProperty$g = objectDefineProperty;
var defineBuiltInAccessor$p = function(target, name, descriptor) {
  if (descriptor.get) makeBuiltIn$2(descriptor.get, name, { getter: true });
  if (descriptor.set) makeBuiltIn$2(descriptor.set, name, { setter: true });
  return defineProperty$g.f(target, name, descriptor);
};
var wellKnownSymbolWrapped = {};
var wellKnownSymbol$O = wellKnownSymbol$S;
wellKnownSymbolWrapped.f = wellKnownSymbol$O;
var globalThis$19 = globalThis_1;
var path$2 = globalThis$19;
var path$1 = path$2;
var hasOwn$A = hasOwnProperty_1;
var wrappedWellKnownSymbolModule$1 = wellKnownSymbolWrapped;
var defineProperty$f = objectDefineProperty.f;
var wellKnownSymbolDefine = function(NAME2) {
  var Symbol2 = path$1.Symbol || (path$1.Symbol = {});
  if (!hasOwn$A(Symbol2, NAME2)) defineProperty$f(Symbol2, NAME2, {
    value: wrappedWellKnownSymbolModule$1.f(NAME2)
  });
};
var call$1e = functionCall;
var getBuiltIn$K = getBuiltIn$O;
var wellKnownSymbol$N = wellKnownSymbol$S;
var defineBuiltIn$s = defineBuiltIn$u;
var symbolDefineToPrimitive = function() {
  var Symbol2 = getBuiltIn$K("Symbol");
  var SymbolPrototype2 = Symbol2 && Symbol2.prototype;
  var valueOf = SymbolPrototype2 && SymbolPrototype2.valueOf;
  var TO_PRIMITIVE2 = wellKnownSymbol$N("toPrimitive");
  if (SymbolPrototype2 && !SymbolPrototype2[TO_PRIMITIVE2]) {
    defineBuiltIn$s(SymbolPrototype2, TO_PRIMITIVE2, function(hint) {
      return call$1e(valueOf, this);
    }, { arity: 1 });
  }
};
var defineProperty$e = objectDefineProperty.f;
var hasOwn$z = hasOwnProperty_1;
var wellKnownSymbol$M = wellKnownSymbol$S;
var TO_STRING_TAG$9 = wellKnownSymbol$M("toStringTag");
var setToStringTag$e = function(target, TAG, STATIC) {
  if (target && !STATIC) target = target.prototype;
  if (target && !hasOwn$z(target, TO_STRING_TAG$9)) {
    defineProperty$e(target, TO_STRING_TAG$9, { configurable: true, value: TAG });
  }
};
var classofRaw = classofRaw$2;
var uncurryThis$1O = functionUncurryThis;
var functionUncurryThisClause = function(fn) {
  if (classofRaw(fn) === "Function") return uncurryThis$1O(fn);
};
var uncurryThis$1N = functionUncurryThisClause;
var aCallable$O = aCallable$Q;
var NATIVE_BIND$2 = functionBindNative;
var bind$w = uncurryThis$1N(uncurryThis$1N.bind);
var functionBindContext = function(fn, that) {
  aCallable$O(fn);
  return that === void 0 ? fn : NATIVE_BIND$2 ? bind$w(fn, that) : function() {
    return fn.apply(that, arguments);
  };
};
var classof$m = classofRaw$2;
var isArray$c = Array.isArray || function isArray(argument) {
  return classof$m(argument) === "Array";
};
var uncurryThis$1M = functionUncurryThis;
var fails$1q = fails$1z;
var isCallable$w = isCallable$I;
var classof$l = classof$p;
var getBuiltIn$J = getBuiltIn$O;
var inspectSource$2 = inspectSource$4;
var noop$4 = function() {
};
var construct$1 = getBuiltIn$J("Reflect", "construct");
var constructorRegExp = /^\s*(?:class|function)\b/;
var exec$h = uncurryThis$1M(constructorRegExp.exec);
var INCORRECT_TO_STRING$2 = !constructorRegExp.test(noop$4);
var isConstructorModern = function isConstructor(argument) {
  if (!isCallable$w(argument)) return false;
  try {
    construct$1(noop$4, [], argument);
    return true;
  } catch (error2) {
    return false;
  }
};
var isConstructorLegacy = function isConstructor2(argument) {
  if (!isCallable$w(argument)) return false;
  switch (classof$l(argument)) {
    case "AsyncFunction":
    case "GeneratorFunction":
    case "AsyncGeneratorFunction":
      return false;
  }
  try {
    return INCORRECT_TO_STRING$2 || !!exec$h(constructorRegExp, inspectSource$2(argument));
  } catch (error2) {
    return true;
  }
};
isConstructorLegacy.sham = true;
var isConstructor$a = !construct$1 || fails$1q(function() {
  var called;
  return isConstructorModern(isConstructorModern.call) || !isConstructorModern(Object) || !isConstructorModern(function() {
    called = true;
  }) || called;
}) ? isConstructorLegacy : isConstructorModern;
var isArray$b = isArray$c;
var isConstructor$9 = isConstructor$a;
var isObject$I = isObject$O;
var wellKnownSymbol$L = wellKnownSymbol$S;
var SPECIES$6 = wellKnownSymbol$L("species");
var $Array$d = Array;
var arraySpeciesConstructor$1 = function(originalArray) {
  var C2;
  if (isArray$b(originalArray)) {
    C2 = originalArray.constructor;
    if (isConstructor$9(C2) && (C2 === $Array$d || isArray$b(C2.prototype))) C2 = void 0;
    else if (isObject$I(C2)) {
      C2 = C2[SPECIES$6];
      if (C2 === null) C2 = void 0;
    }
  }
  return C2 === void 0 ? $Array$d : C2;
};
var arraySpeciesConstructor = arraySpeciesConstructor$1;
var arraySpeciesCreate$5 = function(originalArray, length2) {
  return new (arraySpeciesConstructor(originalArray))(length2 === 0 ? 0 : length2);
};
var bind$v = functionBindContext;
var uncurryThis$1L = functionUncurryThis;
var IndexedObject$6 = indexedObject;
var toObject$C = toObject$E;
var lengthOfArrayLike$z = lengthOfArrayLike$B;
var arraySpeciesCreate$4 = arraySpeciesCreate$5;
var push$r = uncurryThis$1L([].push);
var createMethod$7 = function(TYPE) {
  var IS_MAP = TYPE === 1;
  var IS_FILTER = TYPE === 2;
  var IS_SOME = TYPE === 3;
  var IS_EVERY = TYPE === 4;
  var IS_FIND_INDEX = TYPE === 6;
  var IS_FILTER_REJECT = TYPE === 7;
  var NO_HOLES = TYPE === 5 || IS_FIND_INDEX;
  return function($this, callbackfn, that, specificCreate) {
    var O2 = toObject$C($this);
    var self2 = IndexedObject$6(O2);
    var length2 = lengthOfArrayLike$z(self2);
    var boundFunction = bind$v(callbackfn, that);
    var index = 0;
    var create4 = specificCreate || arraySpeciesCreate$4;
    var target = IS_MAP ? create4($this, length2) : IS_FILTER || IS_FILTER_REJECT ? create4($this, 0) : void 0;
    var value, result;
    for (; length2 > index; index++) if (NO_HOLES || index in self2) {
      value = self2[index];
      result = boundFunction(value, index, O2);
      if (TYPE) {
        if (IS_MAP) target[index] = result;
        else if (result) switch (TYPE) {
          case 3:
            return true;
          case 5:
            return value;
          case 6:
            return index;
          case 2:
            push$r(target, value);
        }
        else switch (TYPE) {
          case 4:
            return false;
          case 7:
            push$r(target, value);
        }
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
  };
};
var arrayIteration = {
  // `Array.prototype.forEach` method
  // https://tc39.es/ecma262/#sec-array.prototype.foreach
  forEach: createMethod$7(0),
  // `Array.prototype.map` method
  // https://tc39.es/ecma262/#sec-array.prototype.map
  map: createMethod$7(1),
  // `Array.prototype.filter` method
  // https://tc39.es/ecma262/#sec-array.prototype.filter
  filter: createMethod$7(2),
  // `Array.prototype.some` method
  // https://tc39.es/ecma262/#sec-array.prototype.some
  some: createMethod$7(3),
  // `Array.prototype.every` method
  // https://tc39.es/ecma262/#sec-array.prototype.every
  every: createMethod$7(4),
  // `Array.prototype.find` method
  // https://tc39.es/ecma262/#sec-array.prototype.find
  find: createMethod$7(5),
  // `Array.prototype.findIndex` method
  // https://tc39.es/ecma262/#sec-array.prototype.findIndex
  findIndex: createMethod$7(6),
  // `Array.prototype.filterReject` method
  // https://github.com/tc39/proposal-array-filtering
  filterReject: createMethod$7(7)
};
var $$5E = _export;
var globalThis$18 = globalThis_1;
var call$1d = functionCall;
var uncurryThis$1K = functionUncurryThis;
var DESCRIPTORS$O = descriptors$1;
var NATIVE_SYMBOL$5 = symbolConstructorDetection;
var fails$1p = fails$1z;
var hasOwn$y = hasOwnProperty_1;
var isPrototypeOf$e = objectIsPrototypeOf;
var anObject$1d = anObject$1i;
var toIndexedObject$e = toIndexedObject$k;
var toPropertyKey$6 = toPropertyKey$9;
var $toString$3 = toString$K;
var createPropertyDescriptor$a = createPropertyDescriptor$d;
var nativeObjectCreate = objectCreate$1;
var objectKeys$4 = objectKeys$6;
var getOwnPropertyNamesModule$1 = objectGetOwnPropertyNames;
var getOwnPropertyNamesExternal = objectGetOwnPropertyNamesExternal;
var getOwnPropertySymbolsModule$2 = objectGetOwnPropertySymbols;
var getOwnPropertyDescriptorModule$5 = objectGetOwnPropertyDescriptor;
var definePropertyModule$7 = objectDefineProperty;
var definePropertiesModule = objectDefineProperties;
var propertyIsEnumerableModule$1 = objectPropertyIsEnumerable;
var defineBuiltIn$r = defineBuiltIn$u;
var defineBuiltInAccessor$o = defineBuiltInAccessor$p;
var shared$6 = shared$a;
var sharedKey$1 = sharedKey$4;
var hiddenKeys$1 = hiddenKeys$6;
var uid$4 = uid$7;
var wellKnownSymbol$K = wellKnownSymbol$S;
var wrappedWellKnownSymbolModule = wellKnownSymbolWrapped;
var defineWellKnownSymbol$m = wellKnownSymbolDefine;
var defineSymbolToPrimitive$1 = symbolDefineToPrimitive;
var setToStringTag$d = setToStringTag$e;
var InternalStateModule$m = internalState;
var $forEach$3 = arrayIteration.forEach;
var HIDDEN = sharedKey$1("hidden");
var SYMBOL = "Symbol";
var PROTOTYPE$1 = "prototype";
var setInternalState$m = InternalStateModule$m.set;
var getInternalState$f = InternalStateModule$m.getterFor(SYMBOL);
var ObjectPrototype$5 = Object[PROTOTYPE$1];
var $Symbol = globalThis$18.Symbol;
var SymbolPrototype$1 = $Symbol && $Symbol[PROTOTYPE$1];
var RangeError$4 = globalThis$18.RangeError;
var TypeError$9 = globalThis$18.TypeError;
var QObject = globalThis$18.QObject;
var nativeGetOwnPropertyDescriptor$2 = getOwnPropertyDescriptorModule$5.f;
var nativeDefineProperty$1 = definePropertyModule$7.f;
var nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f;
var nativePropertyIsEnumerable = propertyIsEnumerableModule$1.f;
var push$q = uncurryThis$1K([].push);
var AllSymbols = shared$6("symbols");
var ObjectPrototypeSymbols = shared$6("op-symbols");
var WellKnownSymbolsStore$1 = shared$6("wks");
var USE_SETTER = !QObject || !QObject[PROTOTYPE$1] || !QObject[PROTOTYPE$1].findChild;
var fallbackDefineProperty = function(O2, P2, Attributes) {
  var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor$2(ObjectPrototype$5, P2);
  if (ObjectPrototypeDescriptor) delete ObjectPrototype$5[P2];
  nativeDefineProperty$1(O2, P2, Attributes);
  if (ObjectPrototypeDescriptor && O2 !== ObjectPrototype$5) {
    nativeDefineProperty$1(ObjectPrototype$5, P2, ObjectPrototypeDescriptor);
  }
};
var setSymbolDescriptor = DESCRIPTORS$O && fails$1p(function() {
  return nativeObjectCreate(nativeDefineProperty$1({}, "a", {
    get: function() {
      return nativeDefineProperty$1(this, "a", { value: 7 }).a;
    }
  })).a !== 7;
}) ? fallbackDefineProperty : nativeDefineProperty$1;
var wrap = function(tag, description) {
  var symbol = AllSymbols[tag] = nativeObjectCreate(SymbolPrototype$1);
  setInternalState$m(symbol, {
    type: SYMBOL,
    tag,
    description
  });
  if (!DESCRIPTORS$O) symbol.description = description;
  return symbol;
};
var $defineProperty = function defineProperty3(O2, P2, Attributes) {
  if (O2 === ObjectPrototype$5) $defineProperty(ObjectPrototypeSymbols, P2, Attributes);
  anObject$1d(O2);
  var key = toPropertyKey$6(P2);
  anObject$1d(Attributes);
  if (hasOwn$y(AllSymbols, key)) {
    if (!Attributes.enumerable) {
      if (!hasOwn$y(O2, HIDDEN)) nativeDefineProperty$1(O2, HIDDEN, createPropertyDescriptor$a(1, nativeObjectCreate(null)));
      O2[HIDDEN][key] = true;
    } else {
      if (hasOwn$y(O2, HIDDEN) && O2[HIDDEN][key]) O2[HIDDEN][key] = false;
      Attributes = nativeObjectCreate(Attributes, { enumerable: createPropertyDescriptor$a(0, false) });
    }
    return setSymbolDescriptor(O2, key, Attributes);
  }
  return nativeDefineProperty$1(O2, key, Attributes);
};
var $defineProperties = function defineProperties2(O2, Properties) {
  anObject$1d(O2);
  var properties2 = toIndexedObject$e(Properties);
  var keys6 = objectKeys$4(properties2).concat($getOwnPropertySymbols(properties2));
  $forEach$3(keys6, function(key) {
    if (!DESCRIPTORS$O || call$1d($propertyIsEnumerable$1, properties2, key)) $defineProperty(O2, key, properties2[key]);
  });
  return O2;
};
var $create = function create2(O2, Properties) {
  return Properties === void 0 ? nativeObjectCreate(O2) : $defineProperties(nativeObjectCreate(O2), Properties);
};
var $propertyIsEnumerable$1 = function propertyIsEnumerable2(V2) {
  var P2 = toPropertyKey$6(V2);
  var enumerable = call$1d(nativePropertyIsEnumerable, this, P2);
  if (this === ObjectPrototype$5 && hasOwn$y(AllSymbols, P2) && !hasOwn$y(ObjectPrototypeSymbols, P2)) return false;
  return enumerable || !hasOwn$y(this, P2) || !hasOwn$y(AllSymbols, P2) || hasOwn$y(this, HIDDEN) && this[HIDDEN][P2] ? enumerable : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor2(O2, P2) {
  var it = toIndexedObject$e(O2);
  var key = toPropertyKey$6(P2);
  if (it === ObjectPrototype$5 && hasOwn$y(AllSymbols, key) && !hasOwn$y(ObjectPrototypeSymbols, key)) return;
  var descriptor = nativeGetOwnPropertyDescriptor$2(it, key);
  if (descriptor && hasOwn$y(AllSymbols, key) && !(hasOwn$y(it, HIDDEN) && it[HIDDEN][key])) {
    descriptor.enumerable = true;
  }
  return descriptor;
};
var $getOwnPropertyNames = function getOwnPropertyNames3(O2) {
  var names = nativeGetOwnPropertyNames(toIndexedObject$e(O2));
  var result = [];
  $forEach$3(names, function(key) {
    if (!hasOwn$y(AllSymbols, key) && !hasOwn$y(hiddenKeys$1, key)) push$q(result, key);
  });
  return result;
};
var $getOwnPropertySymbols = function(O2) {
  var IS_OBJECT_PROTOTYPE = O2 === ObjectPrototype$5;
  var names = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject$e(O2));
  var result = [];
  $forEach$3(names, function(key) {
    if (hasOwn$y(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || hasOwn$y(ObjectPrototype$5, key))) {
      push$q(result, AllSymbols[key]);
    }
  });
  return result;
};
if (!NATIVE_SYMBOL$5) {
  $Symbol = function Symbol2() {
    if (isPrototypeOf$e(SymbolPrototype$1, this)) throw new TypeError$9("Symbol is not a constructor");
    var description = !arguments.length || arguments[0] === void 0 ? void 0 : $toString$3(arguments[0]);
    var tag = uid$4(description);
    var setter = function(value) {
      var $this = this === void 0 ? globalThis$18 : this;
      if ($this === ObjectPrototype$5) call$1d(setter, ObjectPrototypeSymbols, value);
      if (hasOwn$y($this, HIDDEN) && hasOwn$y($this[HIDDEN], tag)) $this[HIDDEN][tag] = false;
      var descriptor = createPropertyDescriptor$a(1, value);
      try {
        setSymbolDescriptor($this, tag, descriptor);
      } catch (error2) {
        if (!(error2 instanceof RangeError$4)) throw error2;
        fallbackDefineProperty($this, tag, descriptor);
      }
    };
    if (DESCRIPTORS$O && USE_SETTER) setSymbolDescriptor(ObjectPrototype$5, tag, { configurable: true, set: setter });
    return wrap(tag, description);
  };
  SymbolPrototype$1 = $Symbol[PROTOTYPE$1];
  defineBuiltIn$r(SymbolPrototype$1, "toString", function toString8() {
    return getInternalState$f(this).tag;
  });
  defineBuiltIn$r($Symbol, "withoutSetter", function(description) {
    return wrap(uid$4(description), description);
  });
  propertyIsEnumerableModule$1.f = $propertyIsEnumerable$1;
  definePropertyModule$7.f = $defineProperty;
  definePropertiesModule.f = $defineProperties;
  getOwnPropertyDescriptorModule$5.f = $getOwnPropertyDescriptor;
  getOwnPropertyNamesModule$1.f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames;
  getOwnPropertySymbolsModule$2.f = $getOwnPropertySymbols;
  wrappedWellKnownSymbolModule.f = function(name) {
    return wrap(wellKnownSymbol$K(name), name);
  };
  if (DESCRIPTORS$O) {
    defineBuiltInAccessor$o(SymbolPrototype$1, "description", {
      configurable: true,
      get: function description() {
        return getInternalState$f(this).description;
      }
    });
    {
      defineBuiltIn$r(ObjectPrototype$5, "propertyIsEnumerable", $propertyIsEnumerable$1, { unsafe: true });
    }
  }
}
$$5E({ global: true, constructor: true, wrap: true, forced: !NATIVE_SYMBOL$5, sham: !NATIVE_SYMBOL$5 }, {
  Symbol: $Symbol
});
$forEach$3(objectKeys$4(WellKnownSymbolsStore$1), function(name) {
  defineWellKnownSymbol$m(name);
});
$$5E({ target: SYMBOL, stat: true, forced: !NATIVE_SYMBOL$5 }, {
  useSetter: function() {
    USE_SETTER = true;
  },
  useSimple: function() {
    USE_SETTER = false;
  }
});
$$5E({ target: "Object", stat: true, forced: !NATIVE_SYMBOL$5, sham: !DESCRIPTORS$O }, {
  // `Object.create` method
  // https://tc39.es/ecma262/#sec-object.create
  create: $create,
  // `Object.defineProperty` method
  // https://tc39.es/ecma262/#sec-object.defineproperty
  defineProperty: $defineProperty,
  // `Object.defineProperties` method
  // https://tc39.es/ecma262/#sec-object.defineproperties
  defineProperties: $defineProperties,
  // `Object.getOwnPropertyDescriptor` method
  // https://tc39.es/ecma262/#sec-object.getownpropertydescriptors
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor
});
$$5E({ target: "Object", stat: true, forced: !NATIVE_SYMBOL$5 }, {
  // `Object.getOwnPropertyNames` method
  // https://tc39.es/ecma262/#sec-object.getownpropertynames
  getOwnPropertyNames: $getOwnPropertyNames
});
defineSymbolToPrimitive$1();
setToStringTag$d($Symbol, SYMBOL);
hiddenKeys$1[HIDDEN] = true;
var NATIVE_SYMBOL$4 = symbolConstructorDetection;
var symbolRegistryDetection = NATIVE_SYMBOL$4 && !!Symbol["for"] && !!Symbol.keyFor;
var $$5D = _export;
var getBuiltIn$I = getBuiltIn$O;
var hasOwn$x = hasOwnProperty_1;
var toString$J = toString$K;
var shared$5 = shared$a;
var NATIVE_SYMBOL_REGISTRY$1 = symbolRegistryDetection;
var StringToSymbolRegistry = shared$5("string-to-symbol-registry");
var SymbolToStringRegistry$1 = shared$5("symbol-to-string-registry");
$$5D({ target: "Symbol", stat: true, forced: !NATIVE_SYMBOL_REGISTRY$1 }, {
  "for": function(key) {
    var string = toString$J(key);
    if (hasOwn$x(StringToSymbolRegistry, string)) return StringToSymbolRegistry[string];
    var symbol = getBuiltIn$I("Symbol")(string);
    StringToSymbolRegistry[string] = symbol;
    SymbolToStringRegistry$1[symbol] = string;
    return symbol;
  }
});
var $$5C = _export;
var hasOwn$w = hasOwnProperty_1;
var isSymbol$5 = isSymbol$8;
var tryToString$5 = tryToString$7;
var shared$4 = shared$a;
var NATIVE_SYMBOL_REGISTRY = symbolRegistryDetection;
var SymbolToStringRegistry = shared$4("symbol-to-string-registry");
$$5C({ target: "Symbol", stat: true, forced: !NATIVE_SYMBOL_REGISTRY }, {
  keyFor: function keyFor(sym) {
    if (!isSymbol$5(sym)) throw new TypeError(tryToString$5(sym) + " is not a symbol");
    if (hasOwn$w(SymbolToStringRegistry, sym)) return SymbolToStringRegistry[sym];
  }
});
var NATIVE_BIND$1 = functionBindNative;
var FunctionPrototype$3 = Function.prototype;
var apply$e = FunctionPrototype$3.apply;
var call$1c = FunctionPrototype$3.call;
var functionApply$1 = typeof Reflect == "object" && Reflect.apply || (NATIVE_BIND$1 ? call$1c.bind(apply$e) : function() {
  return call$1c.apply(apply$e, arguments);
});
var uncurryThis$1J = functionUncurryThis;
var isArray$a = isArray$c;
var isCallable$v = isCallable$I;
var classof$k = classofRaw$2;
var toString$I = toString$K;
var push$p = uncurryThis$1J([].push);
var getJsonReplacerFunction = function(replacer2) {
  if (isCallable$v(replacer2)) return replacer2;
  if (!isArray$a(replacer2)) return;
  var rawLength = replacer2.length;
  var keys6 = [];
  for (var i = 0; i < rawLength; i++) {
    var element = replacer2[i];
    if (typeof element == "string") push$p(keys6, element);
    else if (typeof element == "number" || classof$k(element) === "Number" || classof$k(element) === "String") push$p(keys6, toString$I(element));
  }
  var keysLength = keys6.length;
  var root2 = true;
  return function(key, value) {
    if (root2) {
      root2 = false;
      return value;
    }
    if (isArray$a(this)) return value;
    for (var j = 0; j < keysLength; j++) if (keys6[j] === key) return value;
  };
};
var $$5B = _export;
var getBuiltIn$H = getBuiltIn$O;
var apply$d = functionApply$1;
var call$1b = functionCall;
var uncurryThis$1I = functionUncurryThis;
var fails$1o = fails$1z;
var isCallable$u = isCallable$I;
var isSymbol$4 = isSymbol$8;
var arraySlice$8 = arraySlice$a;
var getReplacerFunction$1 = getJsonReplacerFunction;
var NATIVE_SYMBOL$3 = symbolConstructorDetection;
var $String$5 = String;
var $stringify$1 = getBuiltIn$H("JSON", "stringify");
var exec$g = uncurryThis$1I(/./.exec);
var charAt$m = uncurryThis$1I("".charAt);
var charCodeAt$9 = uncurryThis$1I("".charCodeAt);
var replace$d = uncurryThis$1I("".replace);
var numberToString$5 = uncurryThis$1I(1 .toString);
var tester = /[\uD800-\uDFFF]/g;
var low = /^[\uD800-\uDBFF]$/;
var hi = /^[\uDC00-\uDFFF]$/;
var WRONG_SYMBOLS_CONVERSION = !NATIVE_SYMBOL$3 || fails$1o(function() {
  var symbol = getBuiltIn$H("Symbol")("stringify detection");
  return $stringify$1([symbol]) !== "[null]" || $stringify$1({ a: symbol }) !== "{}" || $stringify$1(Object(symbol)) !== "{}";
});
var ILL_FORMED_UNICODE = fails$1o(function() {
  return $stringify$1("\uDF06\uD834") !== '"\\udf06\\ud834"' || $stringify$1("\uDEAD") !== '"\\udead"';
});
var stringifyWithSymbolsFix = function(it, replacer2) {
  var args = arraySlice$8(arguments);
  var $replacer = getReplacerFunction$1(replacer2);
  if (!isCallable$u($replacer) && (it === void 0 || isSymbol$4(it))) return;
  args[1] = function(key, value) {
    if (isCallable$u($replacer)) value = call$1b($replacer, this, $String$5(key), value);
    if (!isSymbol$4(value)) return value;
  };
  return apply$d($stringify$1, null, args);
};
var fixIllFormed = function(match2, offset, string) {
  var prev2 = charAt$m(string, offset - 1);
  var next11 = charAt$m(string, offset + 1);
  if (exec$g(low, match2) && !exec$g(hi, next11) || exec$g(hi, match2) && !exec$g(low, prev2)) {
    return "\\u" + numberToString$5(charCodeAt$9(match2, 0), 16);
  }
  return match2;
};
if ($stringify$1) {
  $$5B({ target: "JSON", stat: true, arity: 3, forced: WRONG_SYMBOLS_CONVERSION || ILL_FORMED_UNICODE }, {
    // eslint-disable-next-line no-unused-vars -- required for `.length`
    stringify: function stringify3(it, replacer2, space) {
      var args = arraySlice$8(arguments);
      var result = apply$d(WRONG_SYMBOLS_CONVERSION ? stringifyWithSymbolsFix : $stringify$1, null, args);
      return ILL_FORMED_UNICODE && typeof result == "string" ? replace$d(result, tester, fixIllFormed) : result;
    }
  });
}
var $$5A = _export;
var NATIVE_SYMBOL$2 = symbolConstructorDetection;
var fails$1n = fails$1z;
var getOwnPropertySymbolsModule$1 = objectGetOwnPropertySymbols;
var toObject$B = toObject$E;
var FORCED$H = !NATIVE_SYMBOL$2 || fails$1n(function() {
  getOwnPropertySymbolsModule$1.f(1);
});
$$5A({ target: "Object", stat: true, forced: FORCED$H }, {
  getOwnPropertySymbols: function getOwnPropertySymbols(it) {
    var $getOwnPropertySymbols2 = getOwnPropertySymbolsModule$1.f;
    return $getOwnPropertySymbols2 ? $getOwnPropertySymbols2(toObject$B(it)) : [];
  }
});
var $$5z = _export;
var DESCRIPTORS$N = descriptors$1;
var globalThis$17 = globalThis_1;
var uncurryThis$1H = functionUncurryThis;
var hasOwn$v = hasOwnProperty_1;
var isCallable$t = isCallable$I;
var isPrototypeOf$d = objectIsPrototypeOf;
var toString$H = toString$K;
var defineBuiltInAccessor$n = defineBuiltInAccessor$p;
var copyConstructorProperties$5 = copyConstructorProperties$7;
var NativeSymbol = globalThis$17.Symbol;
var SymbolPrototype = NativeSymbol && NativeSymbol.prototype;
if (DESCRIPTORS$N && isCallable$t(NativeSymbol) && (!("description" in SymbolPrototype) || // Safari 12 bug
NativeSymbol().description !== void 0)) {
  var EmptyStringDescriptionStore = {};
  var SymbolWrapper = function Symbol2() {
    var description = arguments.length < 1 || arguments[0] === void 0 ? void 0 : toString$H(arguments[0]);
    var result = isPrototypeOf$d(SymbolPrototype, this) ? new NativeSymbol(description) : description === void 0 ? NativeSymbol() : NativeSymbol(description);
    if (description === "") EmptyStringDescriptionStore[result] = true;
    return result;
  };
  copyConstructorProperties$5(SymbolWrapper, NativeSymbol);
  SymbolWrapper.prototype = SymbolPrototype;
  SymbolPrototype.constructor = SymbolWrapper;
  var NATIVE_SYMBOL$1 = String(NativeSymbol("description detection")) === "Symbol(description detection)";
  var thisSymbolValue$2 = uncurryThis$1H(SymbolPrototype.valueOf);
  var symbolDescriptiveString = uncurryThis$1H(SymbolPrototype.toString);
  var regexp = /^Symbol\((.*)\)[^)]+$/;
  var replace$c = uncurryThis$1H("".replace);
  var stringSlice$k = uncurryThis$1H("".slice);
  defineBuiltInAccessor$n(SymbolPrototype, "description", {
    configurable: true,
    get: function description() {
      var symbol = thisSymbolValue$2(this);
      if (hasOwn$v(EmptyStringDescriptionStore, symbol)) return "";
      var string = symbolDescriptiveString(symbol);
      var desc = NATIVE_SYMBOL$1 ? stringSlice$k(string, 7, -1) : replace$c(string, regexp, "$1");
      return desc === "" ? void 0 : desc;
    }
  });
  $$5z({ global: true, constructor: true, forced: true }, {
    Symbol: SymbolWrapper
  });
}
var defineWellKnownSymbol$l = wellKnownSymbolDefine;
defineWellKnownSymbol$l("asyncIterator");
var defineWellKnownSymbol$k = wellKnownSymbolDefine;
defineWellKnownSymbol$k("hasInstance");
var defineWellKnownSymbol$j = wellKnownSymbolDefine;
defineWellKnownSymbol$j("isConcatSpreadable");
var defineWellKnownSymbol$i = wellKnownSymbolDefine;
defineWellKnownSymbol$i("iterator");
var defineWellKnownSymbol$h = wellKnownSymbolDefine;
defineWellKnownSymbol$h("match");
var defineWellKnownSymbol$g = wellKnownSymbolDefine;
defineWellKnownSymbol$g("matchAll");
var defineWellKnownSymbol$f = wellKnownSymbolDefine;
defineWellKnownSymbol$f("replace");
var defineWellKnownSymbol$e = wellKnownSymbolDefine;
defineWellKnownSymbol$e("search");
var defineWellKnownSymbol$d = wellKnownSymbolDefine;
defineWellKnownSymbol$d("species");
var defineWellKnownSymbol$c = wellKnownSymbolDefine;
defineWellKnownSymbol$c("split");
var defineWellKnownSymbol$b = wellKnownSymbolDefine;
var defineSymbolToPrimitive = symbolDefineToPrimitive;
defineWellKnownSymbol$b("toPrimitive");
defineSymbolToPrimitive();
var getBuiltIn$G = getBuiltIn$O;
var defineWellKnownSymbol$a = wellKnownSymbolDefine;
var setToStringTag$c = setToStringTag$e;
defineWellKnownSymbol$a("toStringTag");
setToStringTag$c(getBuiltIn$G("Symbol"), "Symbol");
var defineWellKnownSymbol$9 = wellKnownSymbolDefine;
defineWellKnownSymbol$9("unscopables");
var uncurryThis$1G = functionUncurryThis;
var aCallable$N = aCallable$Q;
var functionUncurryThisAccessor = function(object, key, method) {
  try {
    return uncurryThis$1G(aCallable$N(Object.getOwnPropertyDescriptor(object, key)[method]));
  } catch (error2) {
  }
};
var isObject$H = isObject$O;
var isPossiblePrototype$2 = function(argument) {
  return isObject$H(argument) || argument === null;
};
var isPossiblePrototype$1 = isPossiblePrototype$2;
var $String$4 = String;
var $TypeError$G = TypeError;
var aPossiblePrototype$2 = function(argument) {
  if (isPossiblePrototype$1(argument)) return argument;
  throw new $TypeError$G("Can't set " + $String$4(argument) + " as a prototype");
};
var uncurryThisAccessor$3 = functionUncurryThisAccessor;
var isObject$G = isObject$O;
var requireObjectCoercible$n = requireObjectCoercible$q;
var aPossiblePrototype$1 = aPossiblePrototype$2;
var objectSetPrototypeOf$1 = Object.setPrototypeOf || ("__proto__" in {} ? function() {
  var CORRECT_SETTER = false;
  var test2 = {};
  var setter;
  try {
    setter = uncurryThisAccessor$3(Object.prototype, "__proto__", "set");
    setter(test2, []);
    CORRECT_SETTER = test2 instanceof Array;
  } catch (error2) {
  }
  return function setPrototypeOf3(O2, proto) {
    requireObjectCoercible$n(O2);
    aPossiblePrototype$1(proto);
    if (!isObject$G(O2)) return O2;
    if (CORRECT_SETTER) setter(O2, proto);
    else O2.__proto__ = proto;
    return O2;
  };
}() : void 0);
var defineProperty$d = objectDefineProperty.f;
var proxyAccessor$2 = function(Target, Source, key) {
  key in Target || defineProperty$d(Target, key, {
    configurable: true,
    get: function() {
      return Source[key];
    },
    set: function(it) {
      Source[key] = it;
    }
  });
};
var isCallable$s = isCallable$I;
var isObject$F = isObject$O;
var setPrototypeOf$a = objectSetPrototypeOf$1;
var inheritIfRequired$7 = function($this, dummy, Wrapper) {
  var NewTarget, NewTargetPrototype;
  if (
    // it can work only with native `setPrototypeOf`
    setPrototypeOf$a && // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
    isCallable$s(NewTarget = dummy.constructor) && NewTarget !== Wrapper && isObject$F(NewTargetPrototype = NewTarget.prototype) && NewTargetPrototype !== Wrapper.prototype
  ) setPrototypeOf$a($this, NewTargetPrototype);
  return $this;
};
var toString$G = toString$K;
var normalizeStringArgument$6 = function(argument, $default) {
  return argument === void 0 ? arguments.length < 2 ? "" : $default : toString$G(argument);
};
var isObject$E = isObject$O;
var createNonEnumerableProperty$g = createNonEnumerableProperty$j;
var installErrorCause$2 = function(O2, options) {
  if (isObject$E(options) && "cause" in options) {
    createNonEnumerableProperty$g(O2, "cause", options.cause);
  }
};
var uncurryThis$1F = functionUncurryThis;
var $Error$2 = Error;
var replace$b = uncurryThis$1F("".replace);
var TEST = function(arg2) {
  return String(new $Error$2(arg2).stack);
}("zxcasd");
var V8_OR_CHAKRA_STACK_ENTRY = /\n\s*at [^:]*:[^\n]*/;
var IS_V8_OR_CHAKRA_STACK = V8_OR_CHAKRA_STACK_ENTRY.test(TEST);
var errorStackClear = function(stack, dropEntries) {
  if (IS_V8_OR_CHAKRA_STACK && typeof stack == "string" && !$Error$2.prepareStackTrace) {
    while (dropEntries--) stack = replace$b(stack, V8_OR_CHAKRA_STACK_ENTRY, "");
  }
  return stack;
};
var fails$1m = fails$1z;
var createPropertyDescriptor$9 = createPropertyDescriptor$d;
var errorStackInstallable = !fails$1m(function() {
  var error2 = new Error("a");
  if (!("stack" in error2)) return true;
  Object.defineProperty(error2, "stack", createPropertyDescriptor$9(1, 7));
  return error2.stack !== 7;
});
var createNonEnumerableProperty$f = createNonEnumerableProperty$j;
var clearErrorStack$2 = errorStackClear;
var ERROR_STACK_INSTALLABLE$1 = errorStackInstallable;
var captureStackTrace = Error.captureStackTrace;
var errorStackInstall = function(error2, C2, stack, dropEntries) {
  if (ERROR_STACK_INSTALLABLE$1) {
    if (captureStackTrace) captureStackTrace(error2, C2);
    else createNonEnumerableProperty$f(error2, "stack", clearErrorStack$2(stack, dropEntries));
  }
};
var getBuiltIn$F = getBuiltIn$O;
var hasOwn$u = hasOwnProperty_1;
var createNonEnumerableProperty$e = createNonEnumerableProperty$j;
var isPrototypeOf$c = objectIsPrototypeOf;
var setPrototypeOf$9 = objectSetPrototypeOf$1;
var copyConstructorProperties$4 = copyConstructorProperties$7;
var proxyAccessor$1 = proxyAccessor$2;
var inheritIfRequired$6 = inheritIfRequired$7;
var normalizeStringArgument$5 = normalizeStringArgument$6;
var installErrorCause$1 = installErrorCause$2;
var installErrorStack$2 = errorStackInstall;
var DESCRIPTORS$M = descriptors$1;
var wrapErrorConstructorWithCause$2 = function(FULL_NAME, wrapper2, FORCED2, IS_AGGREGATE_ERROR) {
  var STACK_TRACE_LIMIT = "stackTraceLimit";
  var OPTIONS_POSITION = IS_AGGREGATE_ERROR ? 2 : 1;
  var path2 = FULL_NAME.split(".");
  var ERROR_NAME = path2[path2.length - 1];
  var OriginalError = getBuiltIn$F.apply(null, path2);
  if (!OriginalError) return;
  var OriginalErrorPrototype = OriginalError.prototype;
  if (hasOwn$u(OriginalErrorPrototype, "cause")) delete OriginalErrorPrototype.cause;
  if (!FORCED2) return OriginalError;
  var BaseError = getBuiltIn$F("Error");
  var WrappedError = wrapper2(function(a, b2) {
    var message = normalizeStringArgument$5(IS_AGGREGATE_ERROR ? b2 : a, void 0);
    var result = IS_AGGREGATE_ERROR ? new OriginalError(a) : new OriginalError();
    if (message !== void 0) createNonEnumerableProperty$e(result, "message", message);
    installErrorStack$2(result, WrappedError, result.stack, 2);
    if (this && isPrototypeOf$c(OriginalErrorPrototype, this)) inheritIfRequired$6(result, this, WrappedError);
    if (arguments.length > OPTIONS_POSITION) installErrorCause$1(result, arguments[OPTIONS_POSITION]);
    return result;
  });
  WrappedError.prototype = OriginalErrorPrototype;
  if (ERROR_NAME !== "Error") {
    if (setPrototypeOf$9) setPrototypeOf$9(WrappedError, BaseError);
    else copyConstructorProperties$4(WrappedError, BaseError, { name: true });
  } else if (DESCRIPTORS$M && STACK_TRACE_LIMIT in OriginalError) {
    proxyAccessor$1(WrappedError, OriginalError, STACK_TRACE_LIMIT);
    proxyAccessor$1(WrappedError, OriginalError, "prepareStackTrace");
  }
  copyConstructorProperties$4(WrappedError, OriginalError);
  try {
    if (OriginalErrorPrototype.name !== ERROR_NAME) {
      createNonEnumerableProperty$e(OriginalErrorPrototype, "name", ERROR_NAME);
    }
    OriginalErrorPrototype.constructor = WrappedError;
  } catch (error2) {
  }
  return WrappedError;
};
var $$5y = _export;
var globalThis$16 = globalThis_1;
var apply$c = functionApply$1;
var wrapErrorConstructorWithCause$1 = wrapErrorConstructorWithCause$2;
var WEB_ASSEMBLY = "WebAssembly";
var WebAssembly = globalThis$16[WEB_ASSEMBLY];
var FORCED$G = new Error("e", { cause: 7 }).cause !== 7;
var exportGlobalErrorCauseWrapper = function(ERROR_NAME, wrapper2) {
  var O2 = {};
  O2[ERROR_NAME] = wrapErrorConstructorWithCause$1(ERROR_NAME, wrapper2, FORCED$G);
  $$5y({ global: true, constructor: true, arity: 1, forced: FORCED$G }, O2);
};
var exportWebAssemblyErrorCauseWrapper = function(ERROR_NAME, wrapper2) {
  if (WebAssembly && WebAssembly[ERROR_NAME]) {
    var O2 = {};
    O2[ERROR_NAME] = wrapErrorConstructorWithCause$1(WEB_ASSEMBLY + "." + ERROR_NAME, wrapper2, FORCED$G);
    $$5y({ target: WEB_ASSEMBLY, stat: true, constructor: true, arity: 1, forced: FORCED$G }, O2);
  }
};
exportGlobalErrorCauseWrapper("Error", function(init) {
  return function Error2(message) {
    return apply$c(init, this, arguments);
  };
});
exportGlobalErrorCauseWrapper("EvalError", function(init) {
  return function EvalError(message) {
    return apply$c(init, this, arguments);
  };
});
exportGlobalErrorCauseWrapper("RangeError", function(init) {
  return function RangeError2(message) {
    return apply$c(init, this, arguments);
  };
});
exportGlobalErrorCauseWrapper("ReferenceError", function(init) {
  return function ReferenceError2(message) {
    return apply$c(init, this, arguments);
  };
});
exportGlobalErrorCauseWrapper("SyntaxError", function(init) {
  return function SyntaxError2(message) {
    return apply$c(init, this, arguments);
  };
});
exportGlobalErrorCauseWrapper("TypeError", function(init) {
  return function TypeError2(message) {
    return apply$c(init, this, arguments);
  };
});
exportGlobalErrorCauseWrapper("URIError", function(init) {
  return function URIError(message) {
    return apply$c(init, this, arguments);
  };
});
exportWebAssemblyErrorCauseWrapper("CompileError", function(init) {
  return function CompileError(message) {
    return apply$c(init, this, arguments);
  };
});
exportWebAssemblyErrorCauseWrapper("LinkError", function(init) {
  return function LinkError(message) {
    return apply$c(init, this, arguments);
  };
});
exportWebAssemblyErrorCauseWrapper("RuntimeError", function(init) {
  return function RuntimeError(message) {
    return apply$c(init, this, arguments);
  };
});
var DESCRIPTORS$L = descriptors$1;
var fails$1l = fails$1z;
var anObject$1c = anObject$1i;
var normalizeStringArgument$4 = normalizeStringArgument$6;
var nativeErrorToString = Error.prototype.toString;
var INCORRECT_TO_STRING$1 = fails$1l(function() {
  if (DESCRIPTORS$L) {
    var object = Object.create(Object.defineProperty({}, "name", { get: function() {
      return this === object;
    } }));
    if (nativeErrorToString.call(object) !== "true") return true;
  }
  return nativeErrorToString.call({ message: 1, name: 2 }) !== "2: 1" || nativeErrorToString.call({}) !== "Error";
});
var errorToString$2 = INCORRECT_TO_STRING$1 ? function toString2() {
  var O2 = anObject$1c(this);
  var name = normalizeStringArgument$4(O2.name, "Error");
  var message = normalizeStringArgument$4(O2.message);
  return !name ? message : !message ? name : name + ": " + message;
} : nativeErrorToString;
var defineBuiltIn$q = defineBuiltIn$u;
var errorToString$1 = errorToString$2;
var ErrorPrototype$1 = Error.prototype;
if (ErrorPrototype$1.toString !== errorToString$1) {
  defineBuiltIn$q(ErrorPrototype$1, "toString", errorToString$1);
}
var fails$1k = fails$1z;
var correctPrototypeGetter = !fails$1k(function() {
  function F2() {
  }
  F2.prototype.constructor = null;
  return Object.getPrototypeOf(new F2()) !== F2.prototype;
});
var hasOwn$t = hasOwnProperty_1;
var isCallable$r = isCallable$I;
var toObject$A = toObject$E;
var sharedKey = sharedKey$4;
var CORRECT_PROTOTYPE_GETTER$2 = correctPrototypeGetter;
var IE_PROTO = sharedKey("IE_PROTO");
var $Object$4 = Object;
var ObjectPrototype$4 = $Object$4.prototype;
var objectGetPrototypeOf$2 = CORRECT_PROTOTYPE_GETTER$2 ? $Object$4.getPrototypeOf : function(O2) {
  var object = toObject$A(O2);
  if (hasOwn$t(object, IE_PROTO)) return object[IE_PROTO];
  var constructor = object.constructor;
  if (isCallable$r(constructor) && object instanceof constructor) {
    return constructor.prototype;
  }
  return object instanceof $Object$4 ? ObjectPrototype$4 : null;
};
var iterators = {};
var wellKnownSymbol$J = wellKnownSymbol$S;
var Iterators$5 = iterators;
var ITERATOR$c = wellKnownSymbol$J("iterator");
var ArrayPrototype$1 = Array.prototype;
var isArrayIteratorMethod$3 = function(it) {
  return it !== void 0 && (Iterators$5.Array === it || ArrayPrototype$1[ITERATOR$c] === it);
};
var classof$j = classof$p;
var getMethod$j = getMethod$l;
var isNullOrUndefined$g = isNullOrUndefined$j;
var Iterators$4 = iterators;
var wellKnownSymbol$I = wellKnownSymbol$S;
var ITERATOR$b = wellKnownSymbol$I("iterator");
var getIteratorMethod$9 = function(it) {
  if (!isNullOrUndefined$g(it)) return getMethod$j(it, ITERATOR$b) || getMethod$j(it, "@@iterator") || Iterators$4[classof$j(it)];
};
var call$1a = functionCall;
var aCallable$M = aCallable$Q;
var anObject$1b = anObject$1i;
var tryToString$4 = tryToString$7;
var getIteratorMethod$8 = getIteratorMethod$9;
var $TypeError$F = TypeError;
var getIterator$7 = function(argument, usingIterator) {
  var iteratorMethod = arguments.length < 2 ? getIteratorMethod$8(argument) : usingIterator;
  if (aCallable$M(iteratorMethod)) return anObject$1b(call$1a(iteratorMethod, argument));
  throw new $TypeError$F(tryToString$4(argument) + " is not iterable");
};
var call$19 = functionCall;
var anObject$1a = anObject$1i;
var getMethod$i = getMethod$l;
var iteratorClose$8 = function(iterator, kind, value) {
  var innerResult, innerError;
  anObject$1a(iterator);
  try {
    innerResult = getMethod$i(iterator, "return");
    if (!innerResult) {
      if (kind === "throw") throw value;
      return value;
    }
    innerResult = call$19(innerResult, iterator);
  } catch (error2) {
    innerError = true;
    innerResult = error2;
  }
  if (kind === "throw") throw value;
  if (innerError) throw innerResult;
  anObject$1a(innerResult);
  return value;
};
var bind$u = functionBindContext;
var call$18 = functionCall;
var anObject$19 = anObject$1i;
var tryToString$3 = tryToString$7;
var isArrayIteratorMethod$2 = isArrayIteratorMethod$3;
var lengthOfArrayLike$y = lengthOfArrayLike$B;
var isPrototypeOf$b = objectIsPrototypeOf;
var getIterator$6 = getIterator$7;
var getIteratorMethod$7 = getIteratorMethod$9;
var iteratorClose$7 = iteratorClose$8;
var $TypeError$E = TypeError;
var Result = function(stopped, result) {
  this.stopped = stopped;
  this.result = result;
};
var ResultPrototype = Result.prototype;
var iterate$H = function(iterable, unboundFunction, options) {
  var that = options && options.that;
  var AS_ENTRIES = !!(options && options.AS_ENTRIES);
  var IS_RECORD = !!(options && options.IS_RECORD);
  var IS_ITERATOR = !!(options && options.IS_ITERATOR);
  var INTERRUPTED = !!(options && options.INTERRUPTED);
  var fn = bind$u(unboundFunction, that);
  var iterator, iterFn, index, length2, result, next11, step;
  var stop = function(condition) {
    if (iterator) iteratorClose$7(iterator, "normal", condition);
    return new Result(true, condition);
  };
  var callFn = function(value) {
    if (AS_ENTRIES) {
      anObject$19(value);
      return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
    }
    return INTERRUPTED ? fn(value, stop) : fn(value);
  };
  if (IS_RECORD) {
    iterator = iterable.iterator;
  } else if (IS_ITERATOR) {
    iterator = iterable;
  } else {
    iterFn = getIteratorMethod$7(iterable);
    if (!iterFn) throw new $TypeError$E(tryToString$3(iterable) + " is not iterable");
    if (isArrayIteratorMethod$2(iterFn)) {
      for (index = 0, length2 = lengthOfArrayLike$y(iterable); length2 > index; index++) {
        result = callFn(iterable[index]);
        if (result && isPrototypeOf$b(ResultPrototype, result)) return result;
      }
      return new Result(false);
    }
    iterator = getIterator$6(iterable, iterFn);
  }
  next11 = IS_RECORD ? iterable.next : iterator.next;
  while (!(step = call$18(next11, iterator)).done) {
    try {
      result = callFn(step.value);
    } catch (error2) {
      iteratorClose$7(iterator, "throw", error2);
    }
    if (typeof result == "object" && result && isPrototypeOf$b(ResultPrototype, result)) return result;
  }
  return new Result(false);
};
var $$5x = _export;
var isPrototypeOf$a = objectIsPrototypeOf;
var getPrototypeOf$h = objectGetPrototypeOf$2;
var setPrototypeOf$8 = objectSetPrototypeOf$1;
var copyConstructorProperties$3 = copyConstructorProperties$7;
var create$i = objectCreate$1;
var createNonEnumerableProperty$d = createNonEnumerableProperty$j;
var createPropertyDescriptor$8 = createPropertyDescriptor$d;
var installErrorCause = installErrorCause$2;
var installErrorStack$1 = errorStackInstall;
var iterate$G = iterate$H;
var normalizeStringArgument$3 = normalizeStringArgument$6;
var wellKnownSymbol$H = wellKnownSymbol$S;
var TO_STRING_TAG$8 = wellKnownSymbol$H("toStringTag");
var $Error$1 = Error;
var push$o = [].push;
var $AggregateError$1 = function AggregateError(errors, message) {
  var isInstance = isPrototypeOf$a(AggregateErrorPrototype, this);
  var that;
  if (setPrototypeOf$8) {
    that = setPrototypeOf$8(new $Error$1(), isInstance ? getPrototypeOf$h(this) : AggregateErrorPrototype);
  } else {
    that = isInstance ? this : create$i(AggregateErrorPrototype);
    createNonEnumerableProperty$d(that, TO_STRING_TAG$8, "Error");
  }
  if (message !== void 0) createNonEnumerableProperty$d(that, "message", normalizeStringArgument$3(message));
  installErrorStack$1(that, $AggregateError$1, that.stack, 1);
  if (arguments.length > 2) installErrorCause(that, arguments[2]);
  var errorsArray = [];
  iterate$G(errors, push$o, { that: errorsArray });
  createNonEnumerableProperty$d(that, "errors", errorsArray);
  return that;
};
if (setPrototypeOf$8) setPrototypeOf$8($AggregateError$1, $Error$1);
else copyConstructorProperties$3($AggregateError$1, $Error$1, { name: true });
var AggregateErrorPrototype = $AggregateError$1.prototype = create$i($Error$1.prototype, {
  constructor: createPropertyDescriptor$8(1, $AggregateError$1),
  message: createPropertyDescriptor$8(1, ""),
  name: createPropertyDescriptor$8(1, "AggregateError")
});
$$5x({ global: true, constructor: true, arity: 2 }, {
  AggregateError: $AggregateError$1
});
var $$5w = _export;
var getBuiltIn$E = getBuiltIn$O;
var apply$b = functionApply$1;
var fails$1j = fails$1z;
var wrapErrorConstructorWithCause = wrapErrorConstructorWithCause$2;
var AGGREGATE_ERROR = "AggregateError";
var $AggregateError = getBuiltIn$E(AGGREGATE_ERROR);
var FORCED$F = !fails$1j(function() {
  return $AggregateError([1]).errors[0] !== 1;
}) && fails$1j(function() {
  return $AggregateError([1], AGGREGATE_ERROR, { cause: 7 }).cause !== 7;
});
$$5w({ global: true, constructor: true, arity: 2, forced: FORCED$F }, {
  AggregateError: wrapErrorConstructorWithCause(AGGREGATE_ERROR, function(init) {
    return function AggregateError2(errors, message) {
      return apply$b(init, this, arguments);
    };
  }, FORCED$F, true)
});
var wellKnownSymbol$G = wellKnownSymbol$S;
var create$h = objectCreate$1;
var defineProperty$c = objectDefineProperty.f;
var UNSCOPABLES = wellKnownSymbol$G("unscopables");
var ArrayPrototype = Array.prototype;
if (ArrayPrototype[UNSCOPABLES] === void 0) {
  defineProperty$c(ArrayPrototype, UNSCOPABLES, {
    configurable: true,
    value: create$h(null)
  });
}
var addToUnscopables$n = function(key) {
  ArrayPrototype[UNSCOPABLES][key] = true;
};
var $$5v = _export;
var toObject$z = toObject$E;
var lengthOfArrayLike$x = lengthOfArrayLike$B;
var toIntegerOrInfinity$m = toIntegerOrInfinity$p;
var addToUnscopables$m = addToUnscopables$n;
$$5v({ target: "Array", proto: true }, {
  at: function at(index) {
    var O2 = toObject$z(this);
    var len = lengthOfArrayLike$x(O2);
    var relativeIndex = toIntegerOrInfinity$m(index);
    var k2 = relativeIndex >= 0 ? relativeIndex : len + relativeIndex;
    return k2 < 0 || k2 >= len ? void 0 : O2[k2];
  }
});
addToUnscopables$m("at");
var $TypeError$D = TypeError;
var MAX_SAFE_INTEGER$1 = 9007199254740991;
var doesNotExceedSafeInteger$7 = function(it) {
  if (it > MAX_SAFE_INTEGER$1) throw $TypeError$D("Maximum allowed index exceeded");
  return it;
};
var DESCRIPTORS$K = descriptors$1;
var definePropertyModule$6 = objectDefineProperty;
var createPropertyDescriptor$7 = createPropertyDescriptor$d;
var createProperty$b = function(object, key, value) {
  if (DESCRIPTORS$K) definePropertyModule$6.f(object, key, createPropertyDescriptor$7(0, value));
  else object[key] = value;
};
var fails$1i = fails$1z;
var wellKnownSymbol$F = wellKnownSymbol$S;
var V8_VERSION$2 = environmentV8Version;
var SPECIES$5 = wellKnownSymbol$F("species");
var arrayMethodHasSpeciesSupport$5 = function(METHOD_NAME) {
  return V8_VERSION$2 >= 51 || !fails$1i(function() {
    var array = [];
    var constructor = array.constructor = {};
    constructor[SPECIES$5] = function() {
      return { foo: 1 };
    };
    return array[METHOD_NAME](Boolean).foo !== 1;
  });
};
var $$5u = _export;
var fails$1h = fails$1z;
var isArray$9 = isArray$c;
var isObject$D = isObject$O;
var toObject$y = toObject$E;
var lengthOfArrayLike$w = lengthOfArrayLike$B;
var doesNotExceedSafeInteger$6 = doesNotExceedSafeInteger$7;
var createProperty$a = createProperty$b;
var arraySpeciesCreate$3 = arraySpeciesCreate$5;
var arrayMethodHasSpeciesSupport$4 = arrayMethodHasSpeciesSupport$5;
var wellKnownSymbol$E = wellKnownSymbol$S;
var V8_VERSION$1 = environmentV8Version;
var IS_CONCAT_SPREADABLE = wellKnownSymbol$E("isConcatSpreadable");
var IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION$1 >= 51 || !fails$1h(function() {
  var array = [];
  array[IS_CONCAT_SPREADABLE] = false;
  return array.concat()[0] !== array;
});
var isConcatSpreadable = function(O2) {
  if (!isObject$D(O2)) return false;
  var spreadable = O2[IS_CONCAT_SPREADABLE];
  return spreadable !== void 0 ? !!spreadable : isArray$9(O2);
};
var FORCED$E = !IS_CONCAT_SPREADABLE_SUPPORT || !arrayMethodHasSpeciesSupport$4("concat");
$$5u({ target: "Array", proto: true, arity: 1, forced: FORCED$E }, {
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  concat: function concat(arg2) {
    var O2 = toObject$y(this);
    var A2 = arraySpeciesCreate$3(O2, 0);
    var n2 = 0;
    var i, k2, length2, len, E2;
    for (i = -1, length2 = arguments.length; i < length2; i++) {
      E2 = i === -1 ? O2 : arguments[i];
      if (isConcatSpreadable(E2)) {
        len = lengthOfArrayLike$w(E2);
        doesNotExceedSafeInteger$6(n2 + len);
        for (k2 = 0; k2 < len; k2++, n2++) if (k2 in E2) createProperty$a(A2, n2, E2[k2]);
      } else {
        doesNotExceedSafeInteger$6(n2 + 1);
        createProperty$a(A2, n2++, E2);
      }
    }
    A2.length = n2;
    return A2;
  }
});
var tryToString$2 = tryToString$7;
var $TypeError$C = TypeError;
var deletePropertyOrThrow$4 = function(O2, P2) {
  if (!delete O2[P2]) throw new $TypeError$C("Cannot delete property " + tryToString$2(P2) + " of " + tryToString$2(O2));
};
var toObject$x = toObject$E;
var toAbsoluteIndex$8 = toAbsoluteIndex$a;
var lengthOfArrayLike$v = lengthOfArrayLike$B;
var deletePropertyOrThrow$3 = deletePropertyOrThrow$4;
var min$d = Math.min;
var arrayCopyWithin = [].copyWithin || function copyWithin(target, start) {
  var O2 = toObject$x(this);
  var len = lengthOfArrayLike$v(O2);
  var to = toAbsoluteIndex$8(target, len);
  var from7 = toAbsoluteIndex$8(start, len);
  var end = arguments.length > 2 ? arguments[2] : void 0;
  var count = min$d((end === void 0 ? len : toAbsoluteIndex$8(end, len)) - from7, len - to);
  var inc = 1;
  if (from7 < to && to < from7 + count) {
    inc = -1;
    from7 += count - 1;
    to += count - 1;
  }
  while (count-- > 0) {
    if (from7 in O2) O2[to] = O2[from7];
    else deletePropertyOrThrow$3(O2, to);
    to += inc;
    from7 += inc;
  }
  return O2;
};
var $$5t = _export;
var copyWithin2 = arrayCopyWithin;
var addToUnscopables$l = addToUnscopables$n;
$$5t({ target: "Array", proto: true }, {
  copyWithin: copyWithin2
});
addToUnscopables$l("copyWithin");
var fails$1g = fails$1z;
var arrayMethodIsStrict$b = function(METHOD_NAME, argument) {
  var method = [][METHOD_NAME];
  return !!method && fails$1g(function() {
    method.call(null, argument || function() {
      return 1;
    }, 1);
  });
};
var $$5s = _export;
var $every$2 = arrayIteration.every;
var arrayMethodIsStrict$a = arrayMethodIsStrict$b;
var STRICT_METHOD$4 = arrayMethodIsStrict$a("every");
$$5s({ target: "Array", proto: true, forced: !STRICT_METHOD$4 }, {
  every: function every(callbackfn) {
    return $every$2(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
  }
});
var toObject$w = toObject$E;
var toAbsoluteIndex$7 = toAbsoluteIndex$a;
var lengthOfArrayLike$u = lengthOfArrayLike$B;
var arrayFill$1 = function fill(value) {
  var O2 = toObject$w(this);
  var length2 = lengthOfArrayLike$u(O2);
  var argumentsLength = arguments.length;
  var index = toAbsoluteIndex$7(argumentsLength > 1 ? arguments[1] : void 0, length2);
  var end = argumentsLength > 2 ? arguments[2] : void 0;
  var endPos = end === void 0 ? length2 : toAbsoluteIndex$7(end, length2);
  while (endPos > index) O2[index++] = value;
  return O2;
};
var $$5r = _export;
var fill$1 = arrayFill$1;
var addToUnscopables$k = addToUnscopables$n;
$$5r({ target: "Array", proto: true }, {
  fill: fill$1
});
addToUnscopables$k("fill");
var $$5q = _export;
var $filter$1 = arrayIteration.filter;
var arrayMethodHasSpeciesSupport$3 = arrayMethodHasSpeciesSupport$5;
var HAS_SPECIES_SUPPORT$3 = arrayMethodHasSpeciesSupport$3("filter");
$$5q({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT$3 }, {
  filter: function filter(callbackfn) {
    return $filter$1(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
  }
});
var $$5p = _export;
var $find$2 = arrayIteration.find;
var addToUnscopables$j = addToUnscopables$n;
var FIND = "find";
var SKIPS_HOLES$1 = true;
if (FIND in []) Array(1)[FIND](function() {
  SKIPS_HOLES$1 = false;
});
$$5p({ target: "Array", proto: true, forced: SKIPS_HOLES$1 }, {
  find: function find(callbackfn) {
    return $find$2(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
  }
});
addToUnscopables$j(FIND);
var $$5o = _export;
var $findIndex$1 = arrayIteration.findIndex;
var addToUnscopables$i = addToUnscopables$n;
var FIND_INDEX = "findIndex";
var SKIPS_HOLES = true;
if (FIND_INDEX in []) Array(1)[FIND_INDEX](function() {
  SKIPS_HOLES = false;
});
$$5o({ target: "Array", proto: true, forced: SKIPS_HOLES }, {
  findIndex: function findIndex(callbackfn) {
    return $findIndex$1(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
  }
});
addToUnscopables$i(FIND_INDEX);
var bind$t = functionBindContext;
var IndexedObject$5 = indexedObject;
var toObject$v = toObject$E;
var lengthOfArrayLike$t = lengthOfArrayLike$B;
var createMethod$6 = function(TYPE) {
  var IS_FIND_LAST_INDEX = TYPE === 1;
  return function($this, callbackfn, that) {
    var O2 = toObject$v($this);
    var self2 = IndexedObject$5(O2);
    var index = lengthOfArrayLike$t(self2);
    var boundFunction = bind$t(callbackfn, that);
    var value, result;
    while (index-- > 0) {
      value = self2[index];
      result = boundFunction(value, index, O2);
      if (result) switch (TYPE) {
        case 0:
          return value;
        case 1:
          return index;
      }
    }
    return IS_FIND_LAST_INDEX ? -1 : void 0;
  };
};
var arrayIterationFromLast = {
  // `Array.prototype.findLast` method
  // https://github.com/tc39/proposal-array-find-from-last
  findLast: createMethod$6(0),
  // `Array.prototype.findLastIndex` method
  // https://github.com/tc39/proposal-array-find-from-last
  findLastIndex: createMethod$6(1)
};
var $$5n = _export;
var $findLast$1 = arrayIterationFromLast.findLast;
var addToUnscopables$h = addToUnscopables$n;
$$5n({ target: "Array", proto: true }, {
  findLast: function findLast(callbackfn) {
    return $findLast$1(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
  }
});
addToUnscopables$h("findLast");
var $$5m = _export;
var $findLastIndex$1 = arrayIterationFromLast.findLastIndex;
var addToUnscopables$g = addToUnscopables$n;
$$5m({ target: "Array", proto: true }, {
  findLastIndex: function findLastIndex(callbackfn) {
    return $findLastIndex$1(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
  }
});
addToUnscopables$g("findLastIndex");
var isArray$8 = isArray$c;
var lengthOfArrayLike$s = lengthOfArrayLike$B;
var doesNotExceedSafeInteger$5 = doesNotExceedSafeInteger$7;
var bind$s = functionBindContext;
var flattenIntoArray$2 = function(target, original, source, sourceLen, start, depth, mapper, thisArg) {
  var targetIndex = start;
  var sourceIndex = 0;
  var mapFn = mapper ? bind$s(mapper, thisArg) : false;
  var element, elementLen;
  while (sourceIndex < sourceLen) {
    if (sourceIndex in source) {
      element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];
      if (depth > 0 && isArray$8(element)) {
        elementLen = lengthOfArrayLike$s(element);
        targetIndex = flattenIntoArray$2(target, original, element, elementLen, targetIndex, depth - 1) - 1;
      } else {
        doesNotExceedSafeInteger$5(targetIndex + 1);
        target[targetIndex] = element;
      }
      targetIndex++;
    }
    sourceIndex++;
  }
  return targetIndex;
};
var flattenIntoArray_1 = flattenIntoArray$2;
var $$5l = _export;
var flattenIntoArray$1 = flattenIntoArray_1;
var toObject$u = toObject$E;
var lengthOfArrayLike$r = lengthOfArrayLike$B;
var toIntegerOrInfinity$l = toIntegerOrInfinity$p;
var arraySpeciesCreate$2 = arraySpeciesCreate$5;
$$5l({ target: "Array", proto: true }, {
  flat: function flat() {
    var depthArg = arguments.length ? arguments[0] : void 0;
    var O2 = toObject$u(this);
    var sourceLen = lengthOfArrayLike$r(O2);
    var A2 = arraySpeciesCreate$2(O2, 0);
    A2.length = flattenIntoArray$1(A2, O2, O2, sourceLen, 0, depthArg === void 0 ? 1 : toIntegerOrInfinity$l(depthArg));
    return A2;
  }
});
var $$5k = _export;
var flattenIntoArray = flattenIntoArray_1;
var aCallable$L = aCallable$Q;
var toObject$t = toObject$E;
var lengthOfArrayLike$q = lengthOfArrayLike$B;
var arraySpeciesCreate$1 = arraySpeciesCreate$5;
$$5k({ target: "Array", proto: true }, {
  flatMap: function flatMap(callbackfn) {
    var O2 = toObject$t(this);
    var sourceLen = lengthOfArrayLike$q(O2);
    var A2;
    aCallable$L(callbackfn);
    A2 = arraySpeciesCreate$1(O2, 0);
    A2.length = flattenIntoArray(A2, O2, O2, sourceLen, 0, 1, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
    return A2;
  }
});
var $forEach$2 = arrayIteration.forEach;
var arrayMethodIsStrict$9 = arrayMethodIsStrict$b;
var STRICT_METHOD$3 = arrayMethodIsStrict$9("forEach");
var arrayForEach = !STRICT_METHOD$3 ? function forEach(callbackfn) {
  return $forEach$2(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
} : [].forEach;
var $$5j = _export;
var forEach$7 = arrayForEach;
$$5j({ target: "Array", proto: true, forced: [].forEach !== forEach$7 }, {
  forEach: forEach$7
});
var anObject$18 = anObject$1i;
var iteratorClose$6 = iteratorClose$8;
var callWithSafeIterationClosing$3 = function(iterator, fn, value, ENTRIES2) {
  try {
    return ENTRIES2 ? fn(anObject$18(value)[0], value[1]) : fn(value);
  } catch (error2) {
    iteratorClose$6(iterator, "throw", error2);
  }
};
var bind$r = functionBindContext;
var call$17 = functionCall;
var toObject$s = toObject$E;
var callWithSafeIterationClosing$2 = callWithSafeIterationClosing$3;
var isArrayIteratorMethod$1 = isArrayIteratorMethod$3;
var isConstructor$8 = isConstructor$a;
var lengthOfArrayLike$p = lengthOfArrayLike$B;
var createProperty$9 = createProperty$b;
var getIterator$5 = getIterator$7;
var getIteratorMethod$6 = getIteratorMethod$9;
var $Array$c = Array;
var arrayFrom$1 = function from(arrayLike) {
  var O2 = toObject$s(arrayLike);
  var IS_CONSTRUCTOR = isConstructor$8(this);
  var argumentsLength = arguments.length;
  var mapfn = argumentsLength > 1 ? arguments[1] : void 0;
  var mapping = mapfn !== void 0;
  if (mapping) mapfn = bind$r(mapfn, argumentsLength > 2 ? arguments[2] : void 0);
  var iteratorMethod = getIteratorMethod$6(O2);
  var index = 0;
  var length2, result, step, iterator, next11, value;
  if (iteratorMethod && !(this === $Array$c && isArrayIteratorMethod$1(iteratorMethod))) {
    result = IS_CONSTRUCTOR ? new this() : [];
    iterator = getIterator$5(O2, iteratorMethod);
    next11 = iterator.next;
    for (; !(step = call$17(next11, iterator)).done; index++) {
      value = mapping ? callWithSafeIterationClosing$2(iterator, mapfn, [step.value, index], true) : step.value;
      createProperty$9(result, index, value);
    }
  } else {
    length2 = lengthOfArrayLike$p(O2);
    result = IS_CONSTRUCTOR ? new this(length2) : $Array$c(length2);
    for (; length2 > index; index++) {
      value = mapping ? mapfn(O2[index], index) : O2[index];
      createProperty$9(result, index, value);
    }
  }
  result.length = index;
  return result;
};
var wellKnownSymbol$D = wellKnownSymbol$S;
var ITERATOR$a = wellKnownSymbol$D("iterator");
var SAFE_CLOSING = false;
try {
  var called = 0;
  var iteratorWithReturn = {
    next: function() {
      return { done: !!called++ };
    },
    "return": function() {
      SAFE_CLOSING = true;
    }
  };
  iteratorWithReturn[ITERATOR$a] = function() {
    return this;
  };
  Array.from(iteratorWithReturn, function() {
    throw 2;
  });
} catch (error2) {
}
var checkCorrectnessOfIteration$4 = function(exec2, SKIP_CLOSING) {
  try {
    if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
  } catch (error2) {
    return false;
  }
  var ITERATION_SUPPORT = false;
  try {
    var object = {};
    object[ITERATOR$a] = function() {
      return {
        next: function() {
          return { done: ITERATION_SUPPORT = true };
        }
      };
    };
    exec2(object);
  } catch (error2) {
  }
  return ITERATION_SUPPORT;
};
var $$5i = _export;
var from$2 = arrayFrom$1;
var checkCorrectnessOfIteration$3 = checkCorrectnessOfIteration$4;
var INCORRECT_ITERATION = !checkCorrectnessOfIteration$3(function(iterable) {
  Array.from(iterable);
});
$$5i({ target: "Array", stat: true, forced: INCORRECT_ITERATION }, {
  from: from$2
});
var $$5h = _export;
var $includes$1 = arrayIncludes.includes;
var fails$1f = fails$1z;
var addToUnscopables$f = addToUnscopables$n;
var BROKEN_ON_SPARSE = fails$1f(function() {
  return !Array(1).includes();
});
$$5h({ target: "Array", proto: true, forced: BROKEN_ON_SPARSE }, {
  includes: function includes(el2) {
    return $includes$1(this, el2, arguments.length > 1 ? arguments[1] : void 0);
  }
});
addToUnscopables$f("includes");
var $$5g = _export;
var uncurryThis$1E = functionUncurryThisClause;
var $indexOf$1 = arrayIncludes.indexOf;
var arrayMethodIsStrict$8 = arrayMethodIsStrict$b;
var nativeIndexOf = uncurryThis$1E([].indexOf);
var NEGATIVE_ZERO$1 = !!nativeIndexOf && 1 / nativeIndexOf([1], 1, -0) < 0;
var FORCED$D = NEGATIVE_ZERO$1 || !arrayMethodIsStrict$8("indexOf");
$$5g({ target: "Array", proto: true, forced: FORCED$D }, {
  indexOf: function indexOf(searchElement) {
    var fromIndex = arguments.length > 1 ? arguments[1] : void 0;
    return NEGATIVE_ZERO$1 ? nativeIndexOf(this, searchElement, fromIndex) || 0 : $indexOf$1(this, searchElement, fromIndex);
  }
});
var $$5f = _export;
var isArray$7 = isArray$c;
$$5f({ target: "Array", stat: true }, {
  isArray: isArray$7
});
var fails$1e = fails$1z;
var isCallable$q = isCallable$I;
var isObject$C = isObject$O;
var getPrototypeOf$g = objectGetPrototypeOf$2;
var defineBuiltIn$p = defineBuiltIn$u;
var wellKnownSymbol$C = wellKnownSymbol$S;
var ITERATOR$9 = wellKnownSymbol$C("iterator");
var BUGGY_SAFARI_ITERATORS$1 = false;
var IteratorPrototype$6, PrototypeOfArrayIteratorPrototype, arrayIterator$1;
if ([].keys) {
  arrayIterator$1 = [].keys();
  if (!("next" in arrayIterator$1)) BUGGY_SAFARI_ITERATORS$1 = true;
  else {
    PrototypeOfArrayIteratorPrototype = getPrototypeOf$g(getPrototypeOf$g(arrayIterator$1));
    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype$6 = PrototypeOfArrayIteratorPrototype;
  }
}
var NEW_ITERATOR_PROTOTYPE = !isObject$C(IteratorPrototype$6) || fails$1e(function() {
  var test2 = {};
  return IteratorPrototype$6[ITERATOR$9].call(test2) !== test2;
});
if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype$6 = {};
if (!isCallable$q(IteratorPrototype$6[ITERATOR$9])) {
  defineBuiltIn$p(IteratorPrototype$6, ITERATOR$9, function() {
    return this;
  });
}
var iteratorsCore = {
  IteratorPrototype: IteratorPrototype$6,
  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS$1
};
var IteratorPrototype$5 = iteratorsCore.IteratorPrototype;
var create$g = objectCreate$1;
var createPropertyDescriptor$6 = createPropertyDescriptor$d;
var setToStringTag$b = setToStringTag$e;
var Iterators$3 = iterators;
var returnThis$1 = function() {
  return this;
};
var iteratorCreateConstructor = function(IteratorConstructor2, NAME2, next11, ENUMERABLE_NEXT) {
  var TO_STRING_TAG2 = NAME2 + " Iterator";
  IteratorConstructor2.prototype = create$g(IteratorPrototype$5, { next: createPropertyDescriptor$6(+!ENUMERABLE_NEXT, next11) });
  setToStringTag$b(IteratorConstructor2, TO_STRING_TAG2, false);
  Iterators$3[TO_STRING_TAG2] = returnThis$1;
  return IteratorConstructor2;
};
var $$5e = _export;
var call$16 = functionCall;
var FunctionName$1 = functionName;
var isCallable$p = isCallable$I;
var createIteratorConstructor$6 = iteratorCreateConstructor;
var getPrototypeOf$f = objectGetPrototypeOf$2;
var setPrototypeOf$7 = objectSetPrototypeOf$1;
var setToStringTag$a = setToStringTag$e;
var createNonEnumerableProperty$c = createNonEnumerableProperty$j;
var defineBuiltIn$o = defineBuiltIn$u;
var wellKnownSymbol$B = wellKnownSymbol$S;
var Iterators$2 = iterators;
var IteratorsCore = iteratorsCore;
var PROPER_FUNCTION_NAME$3 = FunctionName$1.PROPER;
var CONFIGURABLE_FUNCTION_NAME$1 = FunctionName$1.CONFIGURABLE;
var IteratorPrototype$4 = IteratorsCore.IteratorPrototype;
var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
var ITERATOR$8 = wellKnownSymbol$B("iterator");
var KEYS = "keys";
var VALUES = "values";
var ENTRIES = "entries";
var returnThis = function() {
  return this;
};
var iteratorDefine = function(Iterable, NAME2, IteratorConstructor2, next11, DEFAULT, IS_SET, FORCED2) {
  createIteratorConstructor$6(IteratorConstructor2, NAME2, next11);
  var getIterationMethod = function(KIND) {
    if (KIND === DEFAULT && defaultIterator) return defaultIterator;
    if (!BUGGY_SAFARI_ITERATORS && KIND && KIND in IterablePrototype) return IterablePrototype[KIND];
    switch (KIND) {
      case KEYS:
        return function keys6() {
          return new IteratorConstructor2(this, KIND);
        };
      case VALUES:
        return function values5() {
          return new IteratorConstructor2(this, KIND);
        };
      case ENTRIES:
        return function entries5() {
          return new IteratorConstructor2(this, KIND);
        };
    }
    return function() {
      return new IteratorConstructor2(this);
    };
  };
  var TO_STRING_TAG2 = NAME2 + " Iterator";
  var INCORRECT_VALUES_NAME = false;
  var IterablePrototype = Iterable.prototype;
  var nativeIterator = IterablePrototype[ITERATOR$8] || IterablePrototype["@@iterator"] || DEFAULT && IterablePrototype[DEFAULT];
  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
  var anyNativeIterator = NAME2 === "Array" ? IterablePrototype.entries || nativeIterator : nativeIterator;
  var CurrentIteratorPrototype, methods, KEY;
  if (anyNativeIterator) {
    CurrentIteratorPrototype = getPrototypeOf$f(anyNativeIterator.call(new Iterable()));
    if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
      if (getPrototypeOf$f(CurrentIteratorPrototype) !== IteratorPrototype$4) {
        if (setPrototypeOf$7) {
          setPrototypeOf$7(CurrentIteratorPrototype, IteratorPrototype$4);
        } else if (!isCallable$p(CurrentIteratorPrototype[ITERATOR$8])) {
          defineBuiltIn$o(CurrentIteratorPrototype, ITERATOR$8, returnThis);
        }
      }
      setToStringTag$a(CurrentIteratorPrototype, TO_STRING_TAG2, true);
    }
  }
  if (PROPER_FUNCTION_NAME$3 && DEFAULT === VALUES && nativeIterator && nativeIterator.name !== VALUES) {
    if (CONFIGURABLE_FUNCTION_NAME$1) {
      createNonEnumerableProperty$c(IterablePrototype, "name", VALUES);
    } else {
      INCORRECT_VALUES_NAME = true;
      defaultIterator = function values5() {
        return call$16(nativeIterator, this);
      };
    }
  }
  if (DEFAULT) {
    methods = {
      values: getIterationMethod(VALUES),
      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
      entries: getIterationMethod(ENTRIES)
    };
    if (FORCED2) for (KEY in methods) {
      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
        defineBuiltIn$o(IterablePrototype, KEY, methods[KEY]);
      }
    }
    else $$5e({ target: NAME2, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
  }
  if (IterablePrototype[ITERATOR$8] !== defaultIterator) {
    defineBuiltIn$o(IterablePrototype, ITERATOR$8, defaultIterator, { name: DEFAULT });
  }
  Iterators$2[NAME2] = defaultIterator;
  return methods;
};
var createIterResultObject$h = function(value, done) {
  return { value, done };
};
var toIndexedObject$d = toIndexedObject$k;
var addToUnscopables$e = addToUnscopables$n;
var Iterators$1 = iterators;
var InternalStateModule$l = internalState;
var defineProperty$b = objectDefineProperty.f;
var defineIterator$2 = iteratorDefine;
var createIterResultObject$g = createIterResultObject$h;
var DESCRIPTORS$J = descriptors$1;
var ARRAY_ITERATOR = "Array Iterator";
var setInternalState$l = InternalStateModule$l.set;
var getInternalState$e = InternalStateModule$l.getterFor(ARRAY_ITERATOR);
var es_array_iterator = defineIterator$2(Array, "Array", function(iterated, kind) {
  setInternalState$l(this, {
    type: ARRAY_ITERATOR,
    target: toIndexedObject$d(iterated),
    // target
    index: 0,
    // next index
    kind
    // kind
  });
}, function() {
  var state = getInternalState$e(this);
  var target = state.target;
  var index = state.index++;
  if (!target || index >= target.length) {
    state.target = null;
    return createIterResultObject$g(void 0, true);
  }
  switch (state.kind) {
    case "keys":
      return createIterResultObject$g(index, false);
    case "values":
      return createIterResultObject$g(target[index], false);
  }
  return createIterResultObject$g([index, target[index]], false);
}, "values");
var values$2 = Iterators$1.Arguments = Iterators$1.Array;
addToUnscopables$e("keys");
addToUnscopables$e("values");
addToUnscopables$e("entries");
if (DESCRIPTORS$J && values$2.name !== "values") try {
  defineProperty$b(values$2, "name", { value: "values" });
} catch (error2) {
}
var $$5d = _export;
var uncurryThis$1D = functionUncurryThis;
var IndexedObject$4 = indexedObject;
var toIndexedObject$c = toIndexedObject$k;
var arrayMethodIsStrict$7 = arrayMethodIsStrict$b;
var nativeJoin = uncurryThis$1D([].join);
var ES3_STRINGS = IndexedObject$4 !== Object;
var FORCED$C = ES3_STRINGS || !arrayMethodIsStrict$7("join", ",");
$$5d({ target: "Array", proto: true, forced: FORCED$C }, {
  join: function join(separator) {
    return nativeJoin(toIndexedObject$c(this), separator === void 0 ? "," : separator);
  }
});
var apply$a = functionApply$1;
var toIndexedObject$b = toIndexedObject$k;
var toIntegerOrInfinity$k = toIntegerOrInfinity$p;
var lengthOfArrayLike$o = lengthOfArrayLike$B;
var arrayMethodIsStrict$6 = arrayMethodIsStrict$b;
var min$c = Math.min;
var $lastIndexOf$1 = [].lastIndexOf;
var NEGATIVE_ZERO = !!$lastIndexOf$1 && 1 / [1].lastIndexOf(1, -0) < 0;
var STRICT_METHOD$2 = arrayMethodIsStrict$6("lastIndexOf");
var FORCED$B = NEGATIVE_ZERO || !STRICT_METHOD$2;
var arrayLastIndexOf = FORCED$B ? function lastIndexOf(searchElement) {
  if (NEGATIVE_ZERO) return apply$a($lastIndexOf$1, this, arguments) || 0;
  var O2 = toIndexedObject$b(this);
  var length2 = lengthOfArrayLike$o(O2);
  if (length2 === 0) return -1;
  var index = length2 - 1;
  if (arguments.length > 1) index = min$c(index, toIntegerOrInfinity$k(arguments[1]));
  if (index < 0) index = length2 + index;
  for (; index >= 0; index--) if (index in O2 && O2[index] === searchElement) return index || 0;
  return -1;
} : $lastIndexOf$1;
var $$5c = _export;
var lastIndexOf2 = arrayLastIndexOf;
$$5c({ target: "Array", proto: true, forced: lastIndexOf2 !== [].lastIndexOf }, {
  lastIndexOf: lastIndexOf2
});
var $$5b = _export;
var $map$1 = arrayIteration.map;
var arrayMethodHasSpeciesSupport$2 = arrayMethodHasSpeciesSupport$5;
var HAS_SPECIES_SUPPORT$2 = arrayMethodHasSpeciesSupport$2("map");
$$5b({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT$2 }, {
  map: function map(callbackfn) {
    return $map$1(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
  }
});
var $$5a = _export;
var fails$1d = fails$1z;
var isConstructor$7 = isConstructor$a;
var createProperty$8 = createProperty$b;
var $Array$b = Array;
var ISNT_GENERIC = fails$1d(function() {
  function F2() {
  }
  return !($Array$b.of.call(F2) instanceof F2);
});
$$5a({ target: "Array", stat: true, forced: ISNT_GENERIC }, {
  of: function of2() {
    var index = 0;
    var argumentsLength = arguments.length;
    var result = new (isConstructor$7(this) ? this : $Array$b)(argumentsLength);
    while (argumentsLength > index) createProperty$8(result, index, arguments[index++]);
    result.length = argumentsLength;
    return result;
  }
});
var DESCRIPTORS$I = descriptors$1;
var isArray$6 = isArray$c;
var $TypeError$B = TypeError;
var getOwnPropertyDescriptor$b = Object.getOwnPropertyDescriptor;
var SILENT_ON_NON_WRITABLE_LENGTH_SET = DESCRIPTORS$I && !function() {
  if (this !== void 0) return true;
  try {
    Object.defineProperty([], "length", { writable: false }).length = 1;
  } catch (error2) {
    return error2 instanceof TypeError;
  }
}();
var arraySetLength = SILENT_ON_NON_WRITABLE_LENGTH_SET ? function(O2, length2) {
  if (isArray$6(O2) && !getOwnPropertyDescriptor$b(O2, "length").writable) {
    throw new $TypeError$B("Cannot set read only .length");
  }
  return O2.length = length2;
} : function(O2, length2) {
  return O2.length = length2;
};
var $$59 = _export;
var toObject$r = toObject$E;
var lengthOfArrayLike$n = lengthOfArrayLike$B;
var setArrayLength$2 = arraySetLength;
var doesNotExceedSafeInteger$4 = doesNotExceedSafeInteger$7;
var fails$1c = fails$1z;
var INCORRECT_TO_LENGTH = fails$1c(function() {
  return [].push.call({ length: 4294967296 }, 1) !== 4294967297;
});
var properErrorOnNonWritableLength$1 = function() {
  try {
    Object.defineProperty([], "length", { writable: false }).push();
  } catch (error2) {
    return error2 instanceof TypeError;
  }
};
var FORCED$A = INCORRECT_TO_LENGTH || !properErrorOnNonWritableLength$1();
$$59({ target: "Array", proto: true, arity: 1, forced: FORCED$A }, {
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  push: function push(item) {
    var O2 = toObject$r(this);
    var len = lengthOfArrayLike$n(O2);
    var argCount = arguments.length;
    doesNotExceedSafeInteger$4(len + argCount);
    for (var i = 0; i < argCount; i++) {
      O2[len] = arguments[i];
      len++;
    }
    setArrayLength$2(O2, len);
    return len;
  }
});
var aCallable$K = aCallable$Q;
var toObject$q = toObject$E;
var IndexedObject$3 = indexedObject;
var lengthOfArrayLike$m = lengthOfArrayLike$B;
var $TypeError$A = TypeError;
var REDUCE_EMPTY = "Reduce of empty array with no initial value";
var createMethod$5 = function(IS_RIGHT) {
  return function(that, callbackfn, argumentsLength, memo) {
    var O2 = toObject$q(that);
    var self2 = IndexedObject$3(O2);
    var length2 = lengthOfArrayLike$m(O2);
    aCallable$K(callbackfn);
    if (length2 === 0 && argumentsLength < 2) throw new $TypeError$A(REDUCE_EMPTY);
    var index = IS_RIGHT ? length2 - 1 : 0;
    var i = IS_RIGHT ? -1 : 1;
    if (argumentsLength < 2) while (true) {
      if (index in self2) {
        memo = self2[index];
        index += i;
        break;
      }
      index += i;
      if (IS_RIGHT ? index < 0 : length2 <= index) {
        throw new $TypeError$A(REDUCE_EMPTY);
      }
    }
    for (; IS_RIGHT ? index >= 0 : length2 > index; index += i) if (index in self2) {
      memo = callbackfn(memo, self2[index], index, O2);
    }
    return memo;
  };
};
var arrayReduce = {
  // `Array.prototype.reduce` method
  // https://tc39.es/ecma262/#sec-array.prototype.reduce
  left: createMethod$5(false),
  // `Array.prototype.reduceRight` method
  // https://tc39.es/ecma262/#sec-array.prototype.reduceright
  right: createMethod$5(true)
};
var globalThis$15 = globalThis_1;
var userAgent$6 = environmentUserAgent;
var classof$i = classofRaw$2;
var userAgentStartsWith = function(string) {
  return userAgent$6.slice(0, string.length) === string;
};
var environment = function() {
  if (userAgentStartsWith("Bun/")) return "BUN";
  if (userAgentStartsWith("Cloudflare-Workers")) return "CLOUDFLARE";
  if (userAgentStartsWith("Deno/")) return "DENO";
  if (userAgentStartsWith("Node.js/")) return "NODE";
  if (globalThis$15.Bun && typeof Bun.version == "string") return "BUN";
  if (globalThis$15.Deno && typeof Deno.version == "object") return "DENO";
  if (classof$i(globalThis$15.process) === "process") return "NODE";
  if (globalThis$15.window && globalThis$15.document) return "BROWSER";
  return "REST";
}();
var ENVIRONMENT$3 = environment;
var environmentIsNode = ENVIRONMENT$3 === "NODE";
var $$58 = _export;
var $reduce$1 = arrayReduce.left;
var arrayMethodIsStrict$5 = arrayMethodIsStrict$b;
var CHROME_VERSION$1 = environmentV8Version;
var IS_NODE$5 = environmentIsNode;
var CHROME_BUG$1 = !IS_NODE$5 && CHROME_VERSION$1 > 79 && CHROME_VERSION$1 < 83;
var FORCED$z = CHROME_BUG$1 || !arrayMethodIsStrict$5("reduce");
$$58({ target: "Array", proto: true, forced: FORCED$z }, {
  reduce: function reduce(callbackfn) {
    var length2 = arguments.length;
    return $reduce$1(this, callbackfn, length2, length2 > 1 ? arguments[1] : void 0);
  }
});
var $$57 = _export;
var $reduceRight$1 = arrayReduce.right;
var arrayMethodIsStrict$4 = arrayMethodIsStrict$b;
var CHROME_VERSION = environmentV8Version;
var IS_NODE$4 = environmentIsNode;
var CHROME_BUG = !IS_NODE$4 && CHROME_VERSION > 79 && CHROME_VERSION < 83;
var FORCED$y = CHROME_BUG || !arrayMethodIsStrict$4("reduceRight");
$$57({ target: "Array", proto: true, forced: FORCED$y }, {
  reduceRight: function reduceRight(callbackfn) {
    return $reduceRight$1(this, callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : void 0);
  }
});
var $$56 = _export;
var uncurryThis$1C = functionUncurryThis;
var isArray$5 = isArray$c;
var nativeReverse = uncurryThis$1C([].reverse);
var test$2 = [1, 2];
$$56({ target: "Array", proto: true, forced: String(test$2) === String(test$2.reverse()) }, {
  reverse: function reverse() {
    if (isArray$5(this)) this.length = this.length;
    return nativeReverse(this);
  }
});
var $$55 = _export;
var isArray$4 = isArray$c;
var isConstructor$6 = isConstructor$a;
var isObject$B = isObject$O;
var toAbsoluteIndex$6 = toAbsoluteIndex$a;
var lengthOfArrayLike$l = lengthOfArrayLike$B;
var toIndexedObject$a = toIndexedObject$k;
var createProperty$7 = createProperty$b;
var wellKnownSymbol$A = wellKnownSymbol$S;
var arrayMethodHasSpeciesSupport$1 = arrayMethodHasSpeciesSupport$5;
var nativeSlice = arraySlice$a;
var HAS_SPECIES_SUPPORT$1 = arrayMethodHasSpeciesSupport$1("slice");
var SPECIES$4 = wellKnownSymbol$A("species");
var $Array$a = Array;
var max$8 = Math.max;
$$55({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT$1 }, {
  slice: function slice(start, end) {
    var O2 = toIndexedObject$a(this);
    var length2 = lengthOfArrayLike$l(O2);
    var k2 = toAbsoluteIndex$6(start, length2);
    var fin = toAbsoluteIndex$6(end === void 0 ? length2 : end, length2);
    var Constructor2, result, n2;
    if (isArray$4(O2)) {
      Constructor2 = O2.constructor;
      if (isConstructor$6(Constructor2) && (Constructor2 === $Array$a || isArray$4(Constructor2.prototype))) {
        Constructor2 = void 0;
      } else if (isObject$B(Constructor2)) {
        Constructor2 = Constructor2[SPECIES$4];
        if (Constructor2 === null) Constructor2 = void 0;
      }
      if (Constructor2 === $Array$a || Constructor2 === void 0) {
        return nativeSlice(O2, k2, fin);
      }
    }
    result = new (Constructor2 === void 0 ? $Array$a : Constructor2)(max$8(fin - k2, 0));
    for (n2 = 0; k2 < fin; k2++, n2++) if (k2 in O2) createProperty$7(result, n2, O2[k2]);
    result.length = n2;
    return result;
  }
});
var $$54 = _export;
var $some$2 = arrayIteration.some;
var arrayMethodIsStrict$3 = arrayMethodIsStrict$b;
var STRICT_METHOD$1 = arrayMethodIsStrict$3("some");
$$54({ target: "Array", proto: true, forced: !STRICT_METHOD$1 }, {
  some: function some(callbackfn) {
    return $some$2(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
  }
});
var arraySlice$7 = arraySlice$a;
var floor$9 = Math.floor;
var sort$2 = function(array, comparefn) {
  var length2 = array.length;
  if (length2 < 8) {
    var i = 1;
    var element, j;
    while (i < length2) {
      j = i;
      element = array[i];
      while (j && comparefn(array[j - 1], element) > 0) {
        array[j] = array[--j];
      }
      if (j !== i++) array[j] = element;
    }
  } else {
    var middle = floor$9(length2 / 2);
    var left = sort$2(arraySlice$7(array, 0, middle), comparefn);
    var right = sort$2(arraySlice$7(array, middle), comparefn);
    var llength = left.length;
    var rlength = right.length;
    var lindex = 0;
    var rindex = 0;
    while (lindex < llength || rindex < rlength) {
      array[lindex + rindex] = lindex < llength && rindex < rlength ? comparefn(left[lindex], right[rindex]) <= 0 ? left[lindex++] : right[rindex++] : lindex < llength ? left[lindex++] : right[rindex++];
    }
  }
  return array;
};
var arraySort$1 = sort$2;
var userAgent$5 = environmentUserAgent;
var firefox = userAgent$5.match(/firefox\/(\d+)/i);
var environmentFfVersion = !!firefox && +firefox[1];
var UA = environmentUserAgent;
var environmentIsIeOrEdge = /MSIE|Trident/.test(UA);
var userAgent$4 = environmentUserAgent;
var webkit = userAgent$4.match(/AppleWebKit\/(\d+)\./);
var environmentWebkitVersion = !!webkit && +webkit[1];
var $$53 = _export;
var uncurryThis$1B = functionUncurryThis;
var aCallable$J = aCallable$Q;
var toObject$p = toObject$E;
var lengthOfArrayLike$k = lengthOfArrayLike$B;
var deletePropertyOrThrow$2 = deletePropertyOrThrow$4;
var toString$F = toString$K;
var fails$1b = fails$1z;
var internalSort$1 = arraySort$1;
var arrayMethodIsStrict$2 = arrayMethodIsStrict$b;
var FF$1 = environmentFfVersion;
var IE_OR_EDGE$1 = environmentIsIeOrEdge;
var V8$2 = environmentV8Version;
var WEBKIT$4 = environmentWebkitVersion;
var test$1 = [];
var nativeSort$1 = uncurryThis$1B(test$1.sort);
var push$n = uncurryThis$1B(test$1.push);
var FAILS_ON_UNDEFINED = fails$1b(function() {
  test$1.sort(void 0);
});
var FAILS_ON_NULL = fails$1b(function() {
  test$1.sort(null);
});
var STRICT_METHOD = arrayMethodIsStrict$2("sort");
var STABLE_SORT$1 = !fails$1b(function() {
  if (V8$2) return V8$2 < 70;
  if (FF$1 && FF$1 > 3) return;
  if (IE_OR_EDGE$1) return true;
  if (WEBKIT$4) return WEBKIT$4 < 603;
  var result = "";
  var code, chr, value, index;
  for (code = 65; code < 76; code++) {
    chr = String.fromCharCode(code);
    switch (code) {
      case 66:
      case 69:
      case 70:
      case 72:
        value = 3;
        break;
      case 68:
      case 71:
        value = 4;
        break;
      default:
        value = 2;
    }
    for (index = 0; index < 47; index++) {
      test$1.push({ k: chr + index, v: value });
    }
  }
  test$1.sort(function(a, b2) {
    return b2.v - a.v;
  });
  for (index = 0; index < test$1.length; index++) {
    chr = test$1[index].k.charAt(0);
    if (result.charAt(result.length - 1) !== chr) result += chr;
  }
  return result !== "DGBEFHACIJK";
});
var FORCED$x = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || !STRICT_METHOD || !STABLE_SORT$1;
var getSortCompare$1 = function(comparefn) {
  return function(x2, y2) {
    if (y2 === void 0) return -1;
    if (x2 === void 0) return 1;
    if (comparefn !== void 0) return +comparefn(x2, y2) || 0;
    return toString$F(x2) > toString$F(y2) ? 1 : -1;
  };
};
$$53({ target: "Array", proto: true, forced: FORCED$x }, {
  sort: function sort(comparefn) {
    if (comparefn !== void 0) aCallable$J(comparefn);
    var array = toObject$p(this);
    if (STABLE_SORT$1) return comparefn === void 0 ? nativeSort$1(array) : nativeSort$1(array, comparefn);
    var items = [];
    var arrayLength = lengthOfArrayLike$k(array);
    var itemsLength, index;
    for (index = 0; index < arrayLength; index++) {
      if (index in array) push$n(items, array[index]);
    }
    internalSort$1(items, getSortCompare$1(comparefn));
    itemsLength = lengthOfArrayLike$k(items);
    index = 0;
    while (index < itemsLength) array[index] = items[index++];
    while (index < arrayLength) deletePropertyOrThrow$2(array, index++);
    return array;
  }
});
var getBuiltIn$D = getBuiltIn$O;
var defineBuiltInAccessor$m = defineBuiltInAccessor$p;
var wellKnownSymbol$z = wellKnownSymbol$S;
var DESCRIPTORS$H = descriptors$1;
var SPECIES$3 = wellKnownSymbol$z("species");
var setSpecies$7 = function(CONSTRUCTOR_NAME) {
  var Constructor2 = getBuiltIn$D(CONSTRUCTOR_NAME);
  if (DESCRIPTORS$H && Constructor2 && !Constructor2[SPECIES$3]) {
    defineBuiltInAccessor$m(Constructor2, SPECIES$3, {
      configurable: true,
      get: function() {
        return this;
      }
    });
  }
};
var setSpecies$6 = setSpecies$7;
setSpecies$6("Array");
var $$52 = _export;
var toObject$o = toObject$E;
var toAbsoluteIndex$5 = toAbsoluteIndex$a;
var toIntegerOrInfinity$j = toIntegerOrInfinity$p;
var lengthOfArrayLike$j = lengthOfArrayLike$B;
var setArrayLength$1 = arraySetLength;
var doesNotExceedSafeInteger$3 = doesNotExceedSafeInteger$7;
var arraySpeciesCreate = arraySpeciesCreate$5;
var createProperty$6 = createProperty$b;
var deletePropertyOrThrow$1 = deletePropertyOrThrow$4;
var arrayMethodHasSpeciesSupport = arrayMethodHasSpeciesSupport$5;
var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("splice");
var max$7 = Math.max;
var min$b = Math.min;
$$52({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT }, {
  splice: function splice(start, deleteCount) {
    var O2 = toObject$o(this);
    var len = lengthOfArrayLike$j(O2);
    var actualStart = toAbsoluteIndex$5(start, len);
    var argumentsLength = arguments.length;
    var insertCount, actualDeleteCount, A2, k2, from7, to;
    if (argumentsLength === 0) {
      insertCount = actualDeleteCount = 0;
    } else if (argumentsLength === 1) {
      insertCount = 0;
      actualDeleteCount = len - actualStart;
    } else {
      insertCount = argumentsLength - 2;
      actualDeleteCount = min$b(max$7(toIntegerOrInfinity$j(deleteCount), 0), len - actualStart);
    }
    doesNotExceedSafeInteger$3(len + insertCount - actualDeleteCount);
    A2 = arraySpeciesCreate(O2, actualDeleteCount);
    for (k2 = 0; k2 < actualDeleteCount; k2++) {
      from7 = actualStart + k2;
      if (from7 in O2) createProperty$6(A2, k2, O2[from7]);
    }
    A2.length = actualDeleteCount;
    if (insertCount < actualDeleteCount) {
      for (k2 = actualStart; k2 < len - actualDeleteCount; k2++) {
        from7 = k2 + actualDeleteCount;
        to = k2 + insertCount;
        if (from7 in O2) O2[to] = O2[from7];
        else deletePropertyOrThrow$1(O2, to);
      }
      for (k2 = len; k2 > len - actualDeleteCount + insertCount; k2--) deletePropertyOrThrow$1(O2, k2 - 1);
    } else if (insertCount > actualDeleteCount) {
      for (k2 = len - actualDeleteCount; k2 > actualStart; k2--) {
        from7 = k2 + actualDeleteCount - 1;
        to = k2 + insertCount - 1;
        if (from7 in O2) O2[to] = O2[from7];
        else deletePropertyOrThrow$1(O2, to);
      }
    }
    for (k2 = 0; k2 < insertCount; k2++) {
      O2[k2 + actualStart] = arguments[k2 + 2];
    }
    setArrayLength$1(O2, len - actualDeleteCount + insertCount);
    return A2;
  }
});
var lengthOfArrayLike$i = lengthOfArrayLike$B;
var arrayToReversed$2 = function(O2, C2) {
  var len = lengthOfArrayLike$i(O2);
  var A2 = new C2(len);
  var k2 = 0;
  for (; k2 < len; k2++) A2[k2] = O2[len - k2 - 1];
  return A2;
};
var $$51 = _export;
var arrayToReversed$1 = arrayToReversed$2;
var toIndexedObject$9 = toIndexedObject$k;
var addToUnscopables$d = addToUnscopables$n;
var $Array$9 = Array;
$$51({ target: "Array", proto: true }, {
  toReversed: function toReversed() {
    return arrayToReversed$1(toIndexedObject$9(this), $Array$9);
  }
});
addToUnscopables$d("toReversed");
var lengthOfArrayLike$h = lengthOfArrayLike$B;
var arrayFromConstructorAndList$8 = function(Constructor2, list, $length) {
  var index = 0;
  var length2 = arguments.length > 2 ? $length : lengthOfArrayLike$h(list);
  var result = new Constructor2(length2);
  while (length2 > index) result[index] = list[index++];
  return result;
};
var globalThis$14 = globalThis_1;
var getBuiltInPrototypeMethod$2 = function(CONSTRUCTOR2, METHOD) {
  var Constructor2 = globalThis$14[CONSTRUCTOR2];
  var Prototype2 = Constructor2 && Constructor2.prototype;
  return Prototype2 && Prototype2[METHOD];
};
var $$50 = _export;
var uncurryThis$1A = functionUncurryThis;
var aCallable$I = aCallable$Q;
var toIndexedObject$8 = toIndexedObject$k;
var arrayFromConstructorAndList$7 = arrayFromConstructorAndList$8;
var getBuiltInPrototypeMethod$1 = getBuiltInPrototypeMethod$2;
var addToUnscopables$c = addToUnscopables$n;
var $Array$8 = Array;
var sort$1 = uncurryThis$1A(getBuiltInPrototypeMethod$1("Array", "sort"));
$$50({ target: "Array", proto: true }, {
  toSorted: function toSorted(compareFn) {
    if (compareFn !== void 0) aCallable$I(compareFn);
    var O2 = toIndexedObject$8(this);
    var A2 = arrayFromConstructorAndList$7($Array$8, O2);
    return sort$1(A2, compareFn);
  }
});
addToUnscopables$c("toSorted");
var $$4$ = _export;
var addToUnscopables$b = addToUnscopables$n;
var doesNotExceedSafeInteger$2 = doesNotExceedSafeInteger$7;
var lengthOfArrayLike$g = lengthOfArrayLike$B;
var toAbsoluteIndex$4 = toAbsoluteIndex$a;
var toIndexedObject$7 = toIndexedObject$k;
var toIntegerOrInfinity$i = toIntegerOrInfinity$p;
var $Array$7 = Array;
var max$6 = Math.max;
var min$a = Math.min;
$$4$({ target: "Array", proto: true }, {
  toSpliced: function toSpliced(start, deleteCount) {
    var O2 = toIndexedObject$7(this);
    var len = lengthOfArrayLike$g(O2);
    var actualStart = toAbsoluteIndex$4(start, len);
    var argumentsLength = arguments.length;
    var k2 = 0;
    var insertCount, actualDeleteCount, newLen, A2;
    if (argumentsLength === 0) {
      insertCount = actualDeleteCount = 0;
    } else if (argumentsLength === 1) {
      insertCount = 0;
      actualDeleteCount = len - actualStart;
    } else {
      insertCount = argumentsLength - 2;
      actualDeleteCount = min$a(max$6(toIntegerOrInfinity$i(deleteCount), 0), len - actualStart);
    }
    newLen = doesNotExceedSafeInteger$2(len + insertCount - actualDeleteCount);
    A2 = $Array$7(newLen);
    for (; k2 < actualStart; k2++) A2[k2] = O2[k2];
    for (; k2 < actualStart + insertCount; k2++) A2[k2] = arguments[k2 - actualStart + 2];
    for (; k2 < newLen; k2++) A2[k2] = O2[k2 + actualDeleteCount - insertCount];
    return A2;
  }
});
addToUnscopables$b("toSpliced");
var addToUnscopables$a = addToUnscopables$n;
addToUnscopables$a("flat");
var addToUnscopables$9 = addToUnscopables$n;
addToUnscopables$9("flatMap");
var $$4_ = _export;
var toObject$n = toObject$E;
var lengthOfArrayLike$f = lengthOfArrayLike$B;
var setArrayLength = arraySetLength;
var deletePropertyOrThrow = deletePropertyOrThrow$4;
var doesNotExceedSafeInteger$1 = doesNotExceedSafeInteger$7;
var INCORRECT_RESULT = [].unshift(0) !== 1;
var properErrorOnNonWritableLength = function() {
  try {
    Object.defineProperty([], "length", { writable: false }).unshift();
  } catch (error2) {
    return error2 instanceof TypeError;
  }
};
var FORCED$w = INCORRECT_RESULT || !properErrorOnNonWritableLength();
$$4_({ target: "Array", proto: true, arity: 1, forced: FORCED$w }, {
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  unshift: function unshift(item) {
    var O2 = toObject$n(this);
    var len = lengthOfArrayLike$f(O2);
    var argCount = arguments.length;
    if (argCount) {
      doesNotExceedSafeInteger$1(len + argCount);
      var k2 = len;
      while (k2--) {
        var to = k2 + argCount;
        if (k2 in O2) O2[to] = O2[k2];
        else deletePropertyOrThrow(O2, to);
      }
      for (var j = 0; j < argCount; j++) {
        O2[j] = arguments[j];
      }
    }
    return setArrayLength(O2, len + argCount);
  }
});
var lengthOfArrayLike$e = lengthOfArrayLike$B;
var toIntegerOrInfinity$h = toIntegerOrInfinity$p;
var $RangeError$e = RangeError;
var arrayWith$2 = function(O2, C2, index, value) {
  var len = lengthOfArrayLike$e(O2);
  var relativeIndex = toIntegerOrInfinity$h(index);
  var actualIndex = relativeIndex < 0 ? len + relativeIndex : relativeIndex;
  if (actualIndex >= len || actualIndex < 0) throw new $RangeError$e("Incorrect index");
  var A2 = new C2(len);
  var k2 = 0;
  for (; k2 < len; k2++) A2[k2] = k2 === actualIndex ? value : O2[k2];
  return A2;
};
var $$4Z = _export;
var arrayWith$1 = arrayWith$2;
var toIndexedObject$6 = toIndexedObject$k;
var $Array$6 = Array;
$$4Z({ target: "Array", proto: true }, {
  "with": function(index, value) {
    return arrayWith$1(toIndexedObject$6(this), $Array$6, index, value);
  }
});
var arrayBufferBasicDetection = typeof ArrayBuffer != "undefined" && typeof DataView != "undefined";
var defineBuiltIn$n = defineBuiltIn$u;
var defineBuiltIns$b = function(target, src, options) {
  for (var key in src) defineBuiltIn$n(target, key, src[key], options);
  return target;
};
var isPrototypeOf$9 = objectIsPrototypeOf;
var $TypeError$z = TypeError;
var anInstance$f = function(it, Prototype2) {
  if (isPrototypeOf$9(Prototype2, it)) return it;
  throw new $TypeError$z("Incorrect invocation");
};
var toIntegerOrInfinity$g = toIntegerOrInfinity$p;
var toLength$b = toLength$d;
var $RangeError$d = RangeError;
var toIndex$5 = function(it) {
  if (it === void 0) return 0;
  var number = toIntegerOrInfinity$g(it);
  var length2 = toLength$b(number);
  if (number !== length2) throw new $RangeError$d("Wrong length or index");
  return length2;
};
var mathSign = Math.sign || function sign(x2) {
  var n2 = +x2;
  return n2 === 0 || n2 !== n2 ? n2 : n2 < 0 ? -1 : 1;
};
var sign$2 = mathSign;
var abs$b = Math.abs;
var EPSILON = 2220446049250313e-31;
var INVERSE_EPSILON = 1 / EPSILON;
var roundTiesToEven = function(n2) {
  return n2 + INVERSE_EPSILON - INVERSE_EPSILON;
};
var mathFloatRound = function(x2, FLOAT_EPSILON, FLOAT_MAX_VALUE, FLOAT_MIN_VALUE) {
  var n2 = +x2;
  var absolute = abs$b(n2);
  var s = sign$2(n2);
  if (absolute < FLOAT_MIN_VALUE) return s * roundTiesToEven(absolute / FLOAT_MIN_VALUE / FLOAT_EPSILON) * FLOAT_MIN_VALUE * FLOAT_EPSILON;
  var a = (1 + FLOAT_EPSILON / EPSILON) * absolute;
  var result = a - (a - absolute);
  if (result > FLOAT_MAX_VALUE || result !== result) return s * Infinity;
  return s * result;
};
var floatRound$1 = mathFloatRound;
var FLOAT32_EPSILON = 11920928955078125e-23;
var FLOAT32_MAX_VALUE = 34028234663852886e22;
var FLOAT32_MIN_VALUE = 11754943508222875e-54;
var mathFround = Math.fround || function fround(x2) {
  return floatRound$1(x2, FLOAT32_EPSILON, FLOAT32_MAX_VALUE, FLOAT32_MIN_VALUE);
};
var $Array$5 = Array;
var abs$a = Math.abs;
var pow$6 = Math.pow;
var floor$8 = Math.floor;
var log$8 = Math.log;
var LN2$2 = Math.LN2;
var pack = function(number, mantissaLength, bytes) {
  var buffer2 = $Array$5(bytes);
  var exponentLength = bytes * 8 - mantissaLength - 1;
  var eMax = (1 << exponentLength) - 1;
  var eBias = eMax >> 1;
  var rt = mantissaLength === 23 ? pow$6(2, -24) - pow$6(2, -77) : 0;
  var sign3 = number < 0 || number === 0 && 1 / number < 0 ? 1 : 0;
  var index = 0;
  var exponent, mantissa, c2;
  number = abs$a(number);
  if (number !== number || number === Infinity) {
    mantissa = number !== number ? 1 : 0;
    exponent = eMax;
  } else {
    exponent = floor$8(log$8(number) / LN2$2);
    c2 = pow$6(2, -exponent);
    if (number * c2 < 1) {
      exponent--;
      c2 *= 2;
    }
    if (exponent + eBias >= 1) {
      number += rt / c2;
    } else {
      number += rt * pow$6(2, 1 - eBias);
    }
    if (number * c2 >= 2) {
      exponent++;
      c2 /= 2;
    }
    if (exponent + eBias >= eMax) {
      mantissa = 0;
      exponent = eMax;
    } else if (exponent + eBias >= 1) {
      mantissa = (number * c2 - 1) * pow$6(2, mantissaLength);
      exponent += eBias;
    } else {
      mantissa = number * pow$6(2, eBias - 1) * pow$6(2, mantissaLength);
      exponent = 0;
    }
  }
  while (mantissaLength >= 8) {
    buffer2[index++] = mantissa & 255;
    mantissa /= 256;
    mantissaLength -= 8;
  }
  exponent = exponent << mantissaLength | mantissa;
  exponentLength += mantissaLength;
  while (exponentLength > 0) {
    buffer2[index++] = exponent & 255;
    exponent /= 256;
    exponentLength -= 8;
  }
  buffer2[index - 1] |= sign3 * 128;
  return buffer2;
};
var unpack = function(buffer2, mantissaLength) {
  var bytes = buffer2.length;
  var exponentLength = bytes * 8 - mantissaLength - 1;
  var eMax = (1 << exponentLength) - 1;
  var eBias = eMax >> 1;
  var nBits = exponentLength - 7;
  var index = bytes - 1;
  var sign3 = buffer2[index--];
  var exponent = sign3 & 127;
  var mantissa;
  sign3 >>= 7;
  while (nBits > 0) {
    exponent = exponent * 256 + buffer2[index--];
    nBits -= 8;
  }
  mantissa = exponent & (1 << -nBits) - 1;
  exponent >>= -nBits;
  nBits += mantissaLength;
  while (nBits > 0) {
    mantissa = mantissa * 256 + buffer2[index--];
    nBits -= 8;
  }
  if (exponent === 0) {
    exponent = 1 - eBias;
  } else if (exponent === eMax) {
    return mantissa ? NaN : sign3 ? -Infinity : Infinity;
  } else {
    mantissa += pow$6(2, mantissaLength);
    exponent -= eBias;
  }
  return (sign3 ? -1 : 1) * mantissa * pow$6(2, exponent - mantissaLength);
};
var ieee754 = {
  pack,
  unpack
};
var globalThis$13 = globalThis_1;
var uncurryThis$1z = functionUncurryThis;
var DESCRIPTORS$G = descriptors$1;
var NATIVE_ARRAY_BUFFER$2 = arrayBufferBasicDetection;
var FunctionName = functionName;
var createNonEnumerableProperty$b = createNonEnumerableProperty$j;
var defineBuiltInAccessor$l = defineBuiltInAccessor$p;
var defineBuiltIns$a = defineBuiltIns$b;
var fails$1a = fails$1z;
var anInstance$e = anInstance$f;
var toIntegerOrInfinity$f = toIntegerOrInfinity$p;
var toLength$a = toLength$d;
var toIndex$4 = toIndex$5;
var fround$2 = mathFround;
var IEEE754 = ieee754;
var getPrototypeOf$e = objectGetPrototypeOf$2;
var setPrototypeOf$6 = objectSetPrototypeOf$1;
var arrayFill = arrayFill$1;
var arraySlice$6 = arraySlice$a;
var inheritIfRequired$5 = inheritIfRequired$7;
var copyConstructorProperties$2 = copyConstructorProperties$7;
var setToStringTag$9 = setToStringTag$e;
var InternalStateModule$k = internalState;
var PROPER_FUNCTION_NAME$2 = FunctionName.PROPER;
var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
var ARRAY_BUFFER$1 = "ArrayBuffer";
var DATA_VIEW = "DataView";
var PROTOTYPE = "prototype";
var WRONG_LENGTH$1 = "Wrong length";
var WRONG_INDEX = "Wrong index";
var getInternalArrayBufferState = InternalStateModule$k.getterFor(ARRAY_BUFFER$1);
var getInternalDataViewState = InternalStateModule$k.getterFor(DATA_VIEW);
var setInternalState$k = InternalStateModule$k.set;
var NativeArrayBuffer$1 = globalThis$13[ARRAY_BUFFER$1];
var $ArrayBuffer$1 = NativeArrayBuffer$1;
var ArrayBufferPrototype$4 = $ArrayBuffer$1 && $ArrayBuffer$1[PROTOTYPE];
var $DataView = globalThis$13[DATA_VIEW];
var DataViewPrototype$2 = $DataView && $DataView[PROTOTYPE];
var ObjectPrototype$3 = Object.prototype;
var Array$3 = globalThis$13.Array;
var RangeError$3 = globalThis$13.RangeError;
var fill2 = uncurryThis$1z(arrayFill);
var reverse2 = uncurryThis$1z([].reverse);
var packIEEE754$1 = IEEE754.pack;
var unpackIEEE754$1 = IEEE754.unpack;
var packInt8 = function(number) {
  return [number & 255];
};
var packInt16 = function(number) {
  return [number & 255, number >> 8 & 255];
};
var packInt32 = function(number) {
  return [number & 255, number >> 8 & 255, number >> 16 & 255, number >> 24 & 255];
};
var unpackInt32 = function(buffer2) {
  return buffer2[3] << 24 | buffer2[2] << 16 | buffer2[1] << 8 | buffer2[0];
};
var packFloat32 = function(number) {
  return packIEEE754$1(fround$2(number), 23, 4);
};
var packFloat64 = function(number) {
  return packIEEE754$1(number, 52, 8);
};
var addGetter$2 = function(Constructor2, key, getInternalState2) {
  defineBuiltInAccessor$l(Constructor2[PROTOTYPE], key, {
    configurable: true,
    get: function() {
      return getInternalState2(this)[key];
    }
  });
};
var get$9 = function(view, count, index, isLittleEndian) {
  var store2 = getInternalDataViewState(view);
  var intIndex = toIndex$4(index);
  var boolIsLittleEndian = !!isLittleEndian;
  if (intIndex + count > store2.byteLength) throw new RangeError$3(WRONG_INDEX);
  var bytes = store2.bytes;
  var start = intIndex + store2.byteOffset;
  var pack2 = arraySlice$6(bytes, start, start + count);
  return boolIsLittleEndian ? pack2 : reverse2(pack2);
};
var set$e = function(view, count, index, conversion, value, isLittleEndian) {
  var store2 = getInternalDataViewState(view);
  var intIndex = toIndex$4(index);
  var pack2 = conversion(+value);
  var boolIsLittleEndian = !!isLittleEndian;
  if (intIndex + count > store2.byteLength) throw new RangeError$3(WRONG_INDEX);
  var bytes = store2.bytes;
  var start = intIndex + store2.byteOffset;
  for (var i = 0; i < count; i++) bytes[start + i] = pack2[boolIsLittleEndian ? i : count - i - 1];
};
if (!NATIVE_ARRAY_BUFFER$2) {
  $ArrayBuffer$1 = function ArrayBuffer2(length2) {
    anInstance$e(this, ArrayBufferPrototype$4);
    var byteLength = toIndex$4(length2);
    setInternalState$k(this, {
      type: ARRAY_BUFFER$1,
      bytes: fill2(Array$3(byteLength), 0),
      byteLength
    });
    if (!DESCRIPTORS$G) {
      this.byteLength = byteLength;
      this.detached = false;
    }
  };
  ArrayBufferPrototype$4 = $ArrayBuffer$1[PROTOTYPE];
  $DataView = function DataView2(buffer2, byteOffset, byteLength) {
    anInstance$e(this, DataViewPrototype$2);
    anInstance$e(buffer2, ArrayBufferPrototype$4);
    var bufferState = getInternalArrayBufferState(buffer2);
    var bufferLength = bufferState.byteLength;
    var offset = toIntegerOrInfinity$f(byteOffset);
    if (offset < 0 || offset > bufferLength) throw new RangeError$3("Wrong offset");
    byteLength = byteLength === void 0 ? bufferLength - offset : toLength$a(byteLength);
    if (offset + byteLength > bufferLength) throw new RangeError$3(WRONG_LENGTH$1);
    setInternalState$k(this, {
      type: DATA_VIEW,
      buffer: buffer2,
      byteLength,
      byteOffset: offset,
      bytes: bufferState.bytes
    });
    if (!DESCRIPTORS$G) {
      this.buffer = buffer2;
      this.byteLength = byteLength;
      this.byteOffset = offset;
    }
  };
  DataViewPrototype$2 = $DataView[PROTOTYPE];
  if (DESCRIPTORS$G) {
    addGetter$2($ArrayBuffer$1, "byteLength", getInternalArrayBufferState);
    addGetter$2($DataView, "buffer", getInternalDataViewState);
    addGetter$2($DataView, "byteLength", getInternalDataViewState);
    addGetter$2($DataView, "byteOffset", getInternalDataViewState);
  }
  defineBuiltIns$a(DataViewPrototype$2, {
    getInt8: function getInt82(byteOffset) {
      return get$9(this, 1, byteOffset)[0] << 24 >> 24;
    },
    getUint8: function getUint82(byteOffset) {
      return get$9(this, 1, byteOffset)[0];
    },
    getInt16: function getInt16(byteOffset) {
      var bytes = get$9(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : false);
      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
    },
    getUint16: function getUint162(byteOffset) {
      var bytes = get$9(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : false);
      return bytes[1] << 8 | bytes[0];
    },
    getInt32: function getInt32(byteOffset) {
      return unpackInt32(get$9(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : false));
    },
    getUint32: function getUint32(byteOffset) {
      return unpackInt32(get$9(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : false)) >>> 0;
    },
    getFloat32: function getFloat32(byteOffset) {
      return unpackIEEE754$1(get$9(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : false), 23);
    },
    getFloat64: function getFloat64(byteOffset) {
      return unpackIEEE754$1(get$9(this, 8, byteOffset, arguments.length > 1 ? arguments[1] : false), 52);
    },
    setInt8: function setInt82(byteOffset, value) {
      set$e(this, 1, byteOffset, packInt8, value);
    },
    setUint8: function setUint82(byteOffset, value) {
      set$e(this, 1, byteOffset, packInt8, value);
    },
    setInt16: function setInt16(byteOffset, value) {
      set$e(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : false);
    },
    setUint16: function setUint162(byteOffset, value) {
      set$e(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : false);
    },
    setInt32: function setInt32(byteOffset, value) {
      set$e(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : false);
    },
    setUint32: function setUint32(byteOffset, value) {
      set$e(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : false);
    },
    setFloat32: function setFloat32(byteOffset, value) {
      set$e(this, 4, byteOffset, packFloat32, value, arguments.length > 2 ? arguments[2] : false);
    },
    setFloat64: function setFloat64(byteOffset, value) {
      set$e(this, 8, byteOffset, packFloat64, value, arguments.length > 2 ? arguments[2] : false);
    }
  });
} else {
  var INCORRECT_ARRAY_BUFFER_NAME = PROPER_FUNCTION_NAME$2 && NativeArrayBuffer$1.name !== ARRAY_BUFFER$1;
  if (!fails$1a(function() {
    NativeArrayBuffer$1(1);
  }) || !fails$1a(function() {
    new NativeArrayBuffer$1(-1);
  }) || fails$1a(function() {
    new NativeArrayBuffer$1();
    new NativeArrayBuffer$1(1.5);
    new NativeArrayBuffer$1(NaN);
    return NativeArrayBuffer$1.length !== 1 || INCORRECT_ARRAY_BUFFER_NAME && !CONFIGURABLE_FUNCTION_NAME;
  })) {
    $ArrayBuffer$1 = function ArrayBuffer2(length2) {
      anInstance$e(this, ArrayBufferPrototype$4);
      return inheritIfRequired$5(new NativeArrayBuffer$1(toIndex$4(length2)), this, $ArrayBuffer$1);
    };
    $ArrayBuffer$1[PROTOTYPE] = ArrayBufferPrototype$4;
    ArrayBufferPrototype$4.constructor = $ArrayBuffer$1;
    copyConstructorProperties$2($ArrayBuffer$1, NativeArrayBuffer$1);
  } else if (INCORRECT_ARRAY_BUFFER_NAME && CONFIGURABLE_FUNCTION_NAME) {
    createNonEnumerableProperty$b(NativeArrayBuffer$1, "name", ARRAY_BUFFER$1);
  }
  if (setPrototypeOf$6 && getPrototypeOf$e(DataViewPrototype$2) !== ObjectPrototype$3) {
    setPrototypeOf$6(DataViewPrototype$2, ObjectPrototype$3);
  }
  var testView = new $DataView(new $ArrayBuffer$1(2));
  var $setInt8 = uncurryThis$1z(DataViewPrototype$2.setInt8);
  testView.setInt8(0, 2147483648);
  testView.setInt8(1, 2147483649);
  if (testView.getInt8(0) || !testView.getInt8(1)) defineBuiltIns$a(DataViewPrototype$2, {
    setInt8: function setInt82(byteOffset, value) {
      $setInt8(this, byteOffset, value << 24 >> 24);
    },
    setUint8: function setUint82(byteOffset, value) {
      $setInt8(this, byteOffset, value << 24 >> 24);
    }
  }, { unsafe: true });
}
setToStringTag$9($ArrayBuffer$1, ARRAY_BUFFER$1);
setToStringTag$9($DataView, DATA_VIEW);
var arrayBuffer = {
  ArrayBuffer: $ArrayBuffer$1,
  DataView: $DataView
};
var $$4Y = _export;
var globalThis$12 = globalThis_1;
var arrayBufferModule = arrayBuffer;
var setSpecies$5 = setSpecies$7;
var ARRAY_BUFFER = "ArrayBuffer";
var ArrayBuffer$7 = arrayBufferModule[ARRAY_BUFFER];
var NativeArrayBuffer = globalThis$12[ARRAY_BUFFER];
$$4Y({ global: true, constructor: true, forced: NativeArrayBuffer !== ArrayBuffer$7 }, {
  ArrayBuffer: ArrayBuffer$7
});
setSpecies$5(ARRAY_BUFFER);
var NATIVE_ARRAY_BUFFER$1 = arrayBufferBasicDetection;
var DESCRIPTORS$F = descriptors$1;
var globalThis$11 = globalThis_1;
var isCallable$o = isCallable$I;
var isObject$A = isObject$O;
var hasOwn$s = hasOwnProperty_1;
var classof$h = classof$p;
var tryToString$1 = tryToString$7;
var createNonEnumerableProperty$a = createNonEnumerableProperty$j;
var defineBuiltIn$m = defineBuiltIn$u;
var defineBuiltInAccessor$k = defineBuiltInAccessor$p;
var isPrototypeOf$8 = objectIsPrototypeOf;
var getPrototypeOf$d = objectGetPrototypeOf$2;
var setPrototypeOf$5 = objectSetPrototypeOf$1;
var wellKnownSymbol$y = wellKnownSymbol$S;
var uid$3 = uid$7;
var InternalStateModule$j = internalState;
var enforceInternalState$3 = InternalStateModule$j.enforce;
var getInternalState$d = InternalStateModule$j.get;
var Int8Array$4 = globalThis$11.Int8Array;
var Int8ArrayPrototype$1 = Int8Array$4 && Int8Array$4.prototype;
var Uint8ClampedArray$1 = globalThis$11.Uint8ClampedArray;
var Uint8ClampedArrayPrototype = Uint8ClampedArray$1 && Uint8ClampedArray$1.prototype;
var TypedArray$1 = Int8Array$4 && getPrototypeOf$d(Int8Array$4);
var TypedArrayPrototype$2 = Int8ArrayPrototype$1 && getPrototypeOf$d(Int8ArrayPrototype$1);
var ObjectPrototype$2 = Object.prototype;
var TypeError$8 = globalThis$11.TypeError;
var TO_STRING_TAG$7 = wellKnownSymbol$y("toStringTag");
var TYPED_ARRAY_TAG$1 = uid$3("TYPED_ARRAY_TAG");
var TYPED_ARRAY_CONSTRUCTOR = "TypedArrayConstructor";
var NATIVE_ARRAY_BUFFER_VIEWS$3 = NATIVE_ARRAY_BUFFER$1 && !!setPrototypeOf$5 && classof$h(globalThis$11.opera) !== "Opera";
var TYPED_ARRAY_TAG_REQUIRED = false;
var NAME$1, Constructor, Prototype;
var TypedArrayConstructorsList = {
  Int8Array: 1,
  Uint8Array: 1,
  Uint8ClampedArray: 1,
  Int16Array: 2,
  Uint16Array: 2,
  Int32Array: 4,
  Uint32Array: 4,
  Float32Array: 4,
  Float64Array: 8
};
var BigIntArrayConstructorsList = {
  BigInt64Array: 8,
  BigUint64Array: 8
};
var isView = function isView2(it) {
  if (!isObject$A(it)) return false;
  var klass = classof$h(it);
  return klass === "DataView" || hasOwn$s(TypedArrayConstructorsList, klass) || hasOwn$s(BigIntArrayConstructorsList, klass);
};
var getTypedArrayConstructor$a = function(it) {
  var proto = getPrototypeOf$d(it);
  if (!isObject$A(proto)) return;
  var state = getInternalState$d(proto);
  return state && hasOwn$s(state, TYPED_ARRAY_CONSTRUCTOR) ? state[TYPED_ARRAY_CONSTRUCTOR] : getTypedArrayConstructor$a(proto);
};
var isTypedArray$2 = function(it) {
  if (!isObject$A(it)) return false;
  var klass = classof$h(it);
  return hasOwn$s(TypedArrayConstructorsList, klass) || hasOwn$s(BigIntArrayConstructorsList, klass);
};
var aTypedArray$x = function(it) {
  if (isTypedArray$2(it)) return it;
  throw new TypeError$8("Target is not a typed array");
};
var aTypedArrayConstructor$3 = function(C2) {
  if (isCallable$o(C2) && (!setPrototypeOf$5 || isPrototypeOf$8(TypedArray$1, C2))) return C2;
  throw new TypeError$8(tryToString$1(C2) + " is not a typed array constructor");
};
var exportTypedArrayMethod$y = function(KEY, property, forced, options) {
  if (!DESCRIPTORS$F) return;
  if (forced) for (var ARRAY in TypedArrayConstructorsList) {
    var TypedArrayConstructor = globalThis$11[ARRAY];
    if (TypedArrayConstructor && hasOwn$s(TypedArrayConstructor.prototype, KEY)) try {
      delete TypedArrayConstructor.prototype[KEY];
    } catch (error2) {
      try {
        TypedArrayConstructor.prototype[KEY] = property;
      } catch (error22) {
      }
    }
  }
  if (!TypedArrayPrototype$2[KEY] || forced) {
    defineBuiltIn$m(TypedArrayPrototype$2, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS$3 && Int8ArrayPrototype$1[KEY] || property, options);
  }
};
var exportTypedArrayStaticMethod$3 = function(KEY, property, forced) {
  var ARRAY, TypedArrayConstructor;
  if (!DESCRIPTORS$F) return;
  if (setPrototypeOf$5) {
    if (forced) for (ARRAY in TypedArrayConstructorsList) {
      TypedArrayConstructor = globalThis$11[ARRAY];
      if (TypedArrayConstructor && hasOwn$s(TypedArrayConstructor, KEY)) try {
        delete TypedArrayConstructor[KEY];
      } catch (error2) {
      }
    }
    if (!TypedArray$1[KEY] || forced) {
      try {
        return defineBuiltIn$m(TypedArray$1, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS$3 && TypedArray$1[KEY] || property);
      } catch (error2) {
      }
    } else return;
  }
  for (ARRAY in TypedArrayConstructorsList) {
    TypedArrayConstructor = globalThis$11[ARRAY];
    if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) {
      defineBuiltIn$m(TypedArrayConstructor, KEY, property);
    }
  }
};
for (NAME$1 in TypedArrayConstructorsList) {
  Constructor = globalThis$11[NAME$1];
  Prototype = Constructor && Constructor.prototype;
  if (Prototype) enforceInternalState$3(Prototype)[TYPED_ARRAY_CONSTRUCTOR] = Constructor;
  else NATIVE_ARRAY_BUFFER_VIEWS$3 = false;
}
for (NAME$1 in BigIntArrayConstructorsList) {
  Constructor = globalThis$11[NAME$1];
  Prototype = Constructor && Constructor.prototype;
  if (Prototype) enforceInternalState$3(Prototype)[TYPED_ARRAY_CONSTRUCTOR] = Constructor;
}
if (!NATIVE_ARRAY_BUFFER_VIEWS$3 || !isCallable$o(TypedArray$1) || TypedArray$1 === Function.prototype) {
  TypedArray$1 = function TypedArray2() {
    throw new TypeError$8("Incorrect invocation");
  };
  if (NATIVE_ARRAY_BUFFER_VIEWS$3) for (NAME$1 in TypedArrayConstructorsList) {
    if (globalThis$11[NAME$1]) setPrototypeOf$5(globalThis$11[NAME$1], TypedArray$1);
  }
}
if (!NATIVE_ARRAY_BUFFER_VIEWS$3 || !TypedArrayPrototype$2 || TypedArrayPrototype$2 === ObjectPrototype$2) {
  TypedArrayPrototype$2 = TypedArray$1.prototype;
  if (NATIVE_ARRAY_BUFFER_VIEWS$3) for (NAME$1 in TypedArrayConstructorsList) {
    if (globalThis$11[NAME$1]) setPrototypeOf$5(globalThis$11[NAME$1].prototype, TypedArrayPrototype$2);
  }
}
if (NATIVE_ARRAY_BUFFER_VIEWS$3 && getPrototypeOf$d(Uint8ClampedArrayPrototype) !== TypedArrayPrototype$2) {
  setPrototypeOf$5(Uint8ClampedArrayPrototype, TypedArrayPrototype$2);
}
if (DESCRIPTORS$F && !hasOwn$s(TypedArrayPrototype$2, TO_STRING_TAG$7)) {
  TYPED_ARRAY_TAG_REQUIRED = true;
  defineBuiltInAccessor$k(TypedArrayPrototype$2, TO_STRING_TAG$7, {
    configurable: true,
    get: function() {
      return isObject$A(this) ? this[TYPED_ARRAY_TAG$1] : void 0;
    }
  });
  for (NAME$1 in TypedArrayConstructorsList) if (globalThis$11[NAME$1]) {
    createNonEnumerableProperty$a(globalThis$11[NAME$1], TYPED_ARRAY_TAG$1, NAME$1);
  }
}
var arrayBufferViewCore = {
  NATIVE_ARRAY_BUFFER_VIEWS: NATIVE_ARRAY_BUFFER_VIEWS$3,
  TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQUIRED && TYPED_ARRAY_TAG$1,
  aTypedArray: aTypedArray$x,
  aTypedArrayConstructor: aTypedArrayConstructor$3,
  exportTypedArrayMethod: exportTypedArrayMethod$y,
  exportTypedArrayStaticMethod: exportTypedArrayStaticMethod$3,
  getTypedArrayConstructor: getTypedArrayConstructor$a,
  isView,
  isTypedArray: isTypedArray$2,
  TypedArray: TypedArray$1,
  TypedArrayPrototype: TypedArrayPrototype$2
};
var $$4X = _export;
var ArrayBufferViewCore$A = arrayBufferViewCore;
var NATIVE_ARRAY_BUFFER_VIEWS$2 = ArrayBufferViewCore$A.NATIVE_ARRAY_BUFFER_VIEWS;
$$4X({ target: "ArrayBuffer", stat: true, forced: !NATIVE_ARRAY_BUFFER_VIEWS$2 }, {
  isView: ArrayBufferViewCore$A.isView
});
var $$4W = _export;
var uncurryThis$1y = functionUncurryThisClause;
var fails$19 = fails$1z;
var ArrayBufferModule$2 = arrayBuffer;
var anObject$17 = anObject$1i;
var toAbsoluteIndex$3 = toAbsoluteIndex$a;
var toLength$9 = toLength$d;
var ArrayBuffer$6 = ArrayBufferModule$2.ArrayBuffer;
var DataView$3 = ArrayBufferModule$2.DataView;
var DataViewPrototype$1 = DataView$3.prototype;
var nativeArrayBufferSlice = uncurryThis$1y(ArrayBuffer$6.prototype.slice);
var getUint8$1 = uncurryThis$1y(DataViewPrototype$1.getUint8);
var setUint8$1 = uncurryThis$1y(DataViewPrototype$1.setUint8);
var INCORRECT_SLICE = fails$19(function() {
  return !new ArrayBuffer$6(2).slice(1, void 0).byteLength;
});
$$4W({ target: "ArrayBuffer", proto: true, unsafe: true, forced: INCORRECT_SLICE }, {
  slice: function slice2(start, end) {
    if (nativeArrayBufferSlice && end === void 0) {
      return nativeArrayBufferSlice(anObject$17(this), start);
    }
    var length2 = anObject$17(this).byteLength;
    var first = toAbsoluteIndex$3(start, length2);
    var fin = toAbsoluteIndex$3(end === void 0 ? length2 : end, length2);
    var result = new ArrayBuffer$6(toLength$9(fin - first));
    var viewSource = new DataView$3(this);
    var viewTarget = new DataView$3(result);
    var index = 0;
    while (first < fin) {
      setUint8$1(viewTarget, index++, getUint8$1(viewSource, first++));
    }
    return result;
  }
});
var $$4V = _export;
var ArrayBufferModule$1 = arrayBuffer;
var NATIVE_ARRAY_BUFFER = arrayBufferBasicDetection;
$$4V({ global: true, constructor: true, forced: !NATIVE_ARRAY_BUFFER }, {
  DataView: ArrayBufferModule$1.DataView
});
var globalThis$10 = globalThis_1;
var uncurryThisAccessor$2 = functionUncurryThisAccessor;
var classof$g = classofRaw$2;
var ArrayBuffer$5 = globalThis$10.ArrayBuffer;
var TypeError$7 = globalThis$10.TypeError;
var arrayBufferByteLength$2 = ArrayBuffer$5 && uncurryThisAccessor$2(ArrayBuffer$5.prototype, "byteLength", "get") || function(O2) {
  if (classof$g(O2) !== "ArrayBuffer") throw new TypeError$7("ArrayBuffer expected");
  return O2.byteLength;
};
var globalThis$$ = globalThis_1;
var uncurryThis$1x = functionUncurryThisClause;
var arrayBufferByteLength$1 = arrayBufferByteLength$2;
var ArrayBuffer$4 = globalThis$$.ArrayBuffer;
var ArrayBufferPrototype$3 = ArrayBuffer$4 && ArrayBuffer$4.prototype;
var slice$9 = ArrayBufferPrototype$3 && uncurryThis$1x(ArrayBufferPrototype$3.slice);
var arrayBufferIsDetached = function(O2) {
  if (arrayBufferByteLength$1(O2) !== 0) return false;
  if (!slice$9) return false;
  try {
    slice$9(O2, 0, 0);
    return false;
  } catch (error2) {
    return true;
  }
};
var DESCRIPTORS$E = descriptors$1;
var defineBuiltInAccessor$j = defineBuiltInAccessor$p;
var isDetached$1 = arrayBufferIsDetached;
var ArrayBufferPrototype$2 = ArrayBuffer.prototype;
if (DESCRIPTORS$E && !("detached" in ArrayBufferPrototype$2)) {
  defineBuiltInAccessor$j(ArrayBufferPrototype$2, "detached", {
    configurable: true,
    get: function detached() {
      return isDetached$1(this);
    }
  });
}
var isDetached = arrayBufferIsDetached;
var $TypeError$y = TypeError;
var arrayBufferNotDetached = function(it) {
  if (isDetached(it)) throw new $TypeError$y("ArrayBuffer is detached");
  return it;
};
var globalThis$_ = globalThis_1;
var IS_NODE$3 = environmentIsNode;
var getBuiltInNodeModule$2 = function(name) {
  if (IS_NODE$3) {
    try {
      return globalThis$_.process.getBuiltinModule(name);
    } catch (error2) {
    }
    try {
      return Function('return require("' + name + '")')();
    } catch (error2) {
    }
  }
};
var globalThis$Z = globalThis_1;
var fails$18 = fails$1z;
var V8$1 = environmentV8Version;
var ENVIRONMENT$2 = environment;
var structuredClone$2 = globalThis$Z.structuredClone;
var structuredCloneProperTransfer = !!structuredClone$2 && !fails$18(function() {
  if (ENVIRONMENT$2 === "DENO" && V8$1 > 92 || ENVIRONMENT$2 === "NODE" && V8$1 > 94 || ENVIRONMENT$2 === "BROWSER" && V8$1 > 97) return false;
  var buffer2 = new ArrayBuffer(8);
  var clone2 = structuredClone$2(buffer2, { transfer: [buffer2] });
  return buffer2.byteLength !== 0 || clone2.byteLength !== 8;
});
var globalThis$Y = globalThis_1;
var getBuiltInNodeModule$1 = getBuiltInNodeModule$2;
var PROPER_STRUCTURED_CLONE_TRANSFER$2 = structuredCloneProperTransfer;
var structuredClone$1 = globalThis$Y.structuredClone;
var $ArrayBuffer = globalThis$Y.ArrayBuffer;
var $MessageChannel = globalThis$Y.MessageChannel;
var detach = false;
var WorkerThreads, channel$1, buffer, $detach;
if (PROPER_STRUCTURED_CLONE_TRANSFER$2) {
  detach = function(transferable) {
    structuredClone$1(transferable, { transfer: [transferable] });
  };
} else if ($ArrayBuffer) try {
  if (!$MessageChannel) {
    WorkerThreads = getBuiltInNodeModule$1("worker_threads");
    if (WorkerThreads) $MessageChannel = WorkerThreads.MessageChannel;
  }
  if ($MessageChannel) {
    channel$1 = new $MessageChannel();
    buffer = new $ArrayBuffer(2);
    $detach = function(transferable) {
      channel$1.port1.postMessage(null, [transferable]);
    };
    if (buffer.byteLength === 2) {
      $detach(buffer);
      if (buffer.byteLength === 0) detach = $detach;
    }
  }
} catch (error2) {
}
var detachTransferable$2 = detach;
var globalThis$X = globalThis_1;
var uncurryThis$1w = functionUncurryThis;
var uncurryThisAccessor$1 = functionUncurryThisAccessor;
var toIndex$3 = toIndex$5;
var notDetached$4 = arrayBufferNotDetached;
var arrayBufferByteLength = arrayBufferByteLength$2;
var detachTransferable$1 = detachTransferable$2;
var PROPER_STRUCTURED_CLONE_TRANSFER$1 = structuredCloneProperTransfer;
var structuredClone = globalThis$X.structuredClone;
var ArrayBuffer$3 = globalThis$X.ArrayBuffer;
var DataView$2 = globalThis$X.DataView;
var min$9 = Math.min;
var ArrayBufferPrototype$1 = ArrayBuffer$3.prototype;
var DataViewPrototype = DataView$2.prototype;
var slice$8 = uncurryThis$1w(ArrayBufferPrototype$1.slice);
var isResizable = uncurryThisAccessor$1(ArrayBufferPrototype$1, "resizable", "get");
var maxByteLength = uncurryThisAccessor$1(ArrayBufferPrototype$1, "maxByteLength", "get");
var getInt8 = uncurryThis$1w(DataViewPrototype.getInt8);
var setInt8 = uncurryThis$1w(DataViewPrototype.setInt8);
var arrayBufferTransfer = (PROPER_STRUCTURED_CLONE_TRANSFER$1 || detachTransferable$1) && function(arrayBuffer2, newLength, preserveResizability) {
  var byteLength = arrayBufferByteLength(arrayBuffer2);
  var newByteLength = newLength === void 0 ? byteLength : toIndex$3(newLength);
  var fixedLength = !isResizable || !isResizable(arrayBuffer2);
  var newBuffer;
  notDetached$4(arrayBuffer2);
  if (PROPER_STRUCTURED_CLONE_TRANSFER$1) {
    arrayBuffer2 = structuredClone(arrayBuffer2, { transfer: [arrayBuffer2] });
    if (byteLength === newByteLength && (preserveResizability || fixedLength)) return arrayBuffer2;
  }
  if (byteLength >= newByteLength && (!preserveResizability || fixedLength)) {
    newBuffer = slice$8(arrayBuffer2, 0, newByteLength);
  } else {
    var options = preserveResizability && !fixedLength && maxByteLength ? { maxByteLength: maxByteLength(arrayBuffer2) } : void 0;
    newBuffer = new ArrayBuffer$3(newByteLength, options);
    var a = new DataView$2(arrayBuffer2);
    var b2 = new DataView$2(newBuffer);
    var copyLength = min$9(newByteLength, byteLength);
    for (var i = 0; i < copyLength; i++) setInt8(b2, i, getInt8(a, i));
  }
  if (!PROPER_STRUCTURED_CLONE_TRANSFER$1) detachTransferable$1(arrayBuffer2);
  return newBuffer;
};
var $$4U = _export;
var $transfer$1 = arrayBufferTransfer;
if ($transfer$1) $$4U({ target: "ArrayBuffer", proto: true }, {
  transfer: function transfer() {
    return $transfer$1(this, arguments.length ? arguments[0] : void 0, true);
  }
});
var $$4T = _export;
var $transfer = arrayBufferTransfer;
if ($transfer) $$4T({ target: "ArrayBuffer", proto: true }, {
  transferToFixedLength: function transferToFixedLength() {
    return $transfer(this, arguments.length ? arguments[0] : void 0, false);
  }
});
var $$4S = _export;
var uncurryThis$1v = functionUncurryThis;
var fails$17 = fails$1z;
var FORCED$v = fails$17(function() {
  return (/* @__PURE__ */ new Date(16e11)).getYear() !== 120;
});
var getFullYear = uncurryThis$1v(Date.prototype.getFullYear);
$$4S({ target: "Date", proto: true, forced: FORCED$v }, {
  getYear: function getYear() {
    return getFullYear(this) - 1900;
  }
});
var $$4R = _export;
var uncurryThis$1u = functionUncurryThis;
var $Date = Date;
var thisTimeValue$4 = uncurryThis$1u($Date.prototype.getTime);
$$4R({ target: "Date", stat: true }, {
  now: function now() {
    return thisTimeValue$4(new $Date());
  }
});
var $$4Q = _export;
var uncurryThis$1t = functionUncurryThis;
var toIntegerOrInfinity$e = toIntegerOrInfinity$p;
var DatePrototype$3 = Date.prototype;
var thisTimeValue$3 = uncurryThis$1t(DatePrototype$3.getTime);
var setFullYear = uncurryThis$1t(DatePrototype$3.setFullYear);
$$4Q({ target: "Date", proto: true }, {
  setYear: function setYear(year) {
    thisTimeValue$3(this);
    var yi2 = toIntegerOrInfinity$e(year);
    var yyyy = yi2 >= 0 && yi2 <= 99 ? yi2 + 1900 : yi2;
    return setFullYear(this, yyyy);
  }
});
var $$4P = _export;
$$4P({ target: "Date", proto: true }, {
  toGMTString: Date.prototype.toUTCString
});
var toIntegerOrInfinity$d = toIntegerOrInfinity$p;
var toString$E = toString$K;
var requireObjectCoercible$m = requireObjectCoercible$q;
var $RangeError$c = RangeError;
var stringRepeat = function repeat(count) {
  var str = toString$E(requireObjectCoercible$m(this));
  var result = "";
  var n2 = toIntegerOrInfinity$d(count);
  if (n2 < 0 || n2 === Infinity) throw new $RangeError$c("Wrong number of repetitions");
  for (; n2 > 0; (n2 >>>= 1) && (str += str)) if (n2 & 1) result += str;
  return result;
};
var uncurryThis$1s = functionUncurryThis;
var toLength$8 = toLength$d;
var toString$D = toString$K;
var $repeat$2 = stringRepeat;
var requireObjectCoercible$l = requireObjectCoercible$q;
var repeat$3 = uncurryThis$1s($repeat$2);
var stringSlice$j = uncurryThis$1s("".slice);
var ceil = Math.ceil;
var createMethod$4 = function(IS_END) {
  return function($this, maxLength, fillString) {
    var S2 = toString$D(requireObjectCoercible$l($this));
    var intMaxLength = toLength$8(maxLength);
    var stringLength = S2.length;
    var fillStr = fillString === void 0 ? " " : toString$D(fillString);
    var fillLen, stringFiller;
    if (intMaxLength <= stringLength || fillStr === "") return S2;
    fillLen = intMaxLength - stringLength;
    stringFiller = repeat$3(fillStr, ceil(fillLen / fillStr.length));
    if (stringFiller.length > fillLen) stringFiller = stringSlice$j(stringFiller, 0, fillLen);
    return IS_END ? S2 + stringFiller : stringFiller + S2;
  };
};
var stringPad = {
  // `String.prototype.padStart` method
  // https://tc39.es/ecma262/#sec-string.prototype.padstart
  start: createMethod$4(false),
  // `String.prototype.padEnd` method
  // https://tc39.es/ecma262/#sec-string.prototype.padend
  end: createMethod$4(true)
};
var uncurryThis$1r = functionUncurryThis;
var fails$16 = fails$1z;
var padStart$1 = stringPad.start;
var $RangeError$b = RangeError;
var $isFinite$1 = isFinite;
var abs$9 = Math.abs;
var DatePrototype$2 = Date.prototype;
var nativeDateToISOString = DatePrototype$2.toISOString;
var thisTimeValue$2 = uncurryThis$1r(DatePrototype$2.getTime);
var getUTCDate = uncurryThis$1r(DatePrototype$2.getUTCDate);
var getUTCFullYear = uncurryThis$1r(DatePrototype$2.getUTCFullYear);
var getUTCHours = uncurryThis$1r(DatePrototype$2.getUTCHours);
var getUTCMilliseconds = uncurryThis$1r(DatePrototype$2.getUTCMilliseconds);
var getUTCMinutes = uncurryThis$1r(DatePrototype$2.getUTCMinutes);
var getUTCMonth = uncurryThis$1r(DatePrototype$2.getUTCMonth);
var getUTCSeconds = uncurryThis$1r(DatePrototype$2.getUTCSeconds);
var dateToIsoString = fails$16(function() {
  return nativeDateToISOString.call(new Date(-5e13 - 1)) !== "0385-07-25T07:06:39.999Z";
}) || !fails$16(function() {
  nativeDateToISOString.call(/* @__PURE__ */ new Date(NaN));
}) ? function toISOString() {
  if (!$isFinite$1(thisTimeValue$2(this))) throw new $RangeError$b("Invalid time value");
  var date = this;
  var year = getUTCFullYear(date);
  var milliseconds = getUTCMilliseconds(date);
  var sign3 = year < 0 ? "-" : year > 9999 ? "+" : "";
  return sign3 + padStart$1(abs$9(year), sign3 ? 6 : 4, 0) + "-" + padStart$1(getUTCMonth(date) + 1, 2, 0) + "-" + padStart$1(getUTCDate(date), 2, 0) + "T" + padStart$1(getUTCHours(date), 2, 0) + ":" + padStart$1(getUTCMinutes(date), 2, 0) + ":" + padStart$1(getUTCSeconds(date), 2, 0) + "." + padStart$1(milliseconds, 3, 0) + "Z";
} : nativeDateToISOString;
var $$4O = _export;
var toISOString2 = dateToIsoString;
$$4O({ target: "Date", proto: true, forced: Date.prototype.toISOString !== toISOString2 }, {
  toISOString: toISOString2
});
var $$4N = _export;
var fails$15 = fails$1z;
var toObject$m = toObject$E;
var toPrimitive$2 = toPrimitive$4;
var FORCED$u = fails$15(function() {
  return (/* @__PURE__ */ new Date(NaN)).toJSON() !== null || Date.prototype.toJSON.call({ toISOString: function() {
    return 1;
  } }) !== 1;
});
$$4N({ target: "Date", proto: true, arity: 1, forced: FORCED$u }, {
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  toJSON: function toJSON(key) {
    var O2 = toObject$m(this);
    var pv = toPrimitive$2(O2, "number");
    return typeof pv == "number" && !isFinite(pv) ? null : O2.toISOString();
  }
});
var anObject$16 = anObject$1i;
var ordinaryToPrimitive = ordinaryToPrimitive$2;
var $TypeError$x = TypeError;
var dateToPrimitive$1 = function(hint) {
  anObject$16(this);
  if (hint === "string" || hint === "default") hint = "string";
  else if (hint !== "number") throw new $TypeError$x("Incorrect hint");
  return ordinaryToPrimitive(this, hint);
};
var hasOwn$r = hasOwnProperty_1;
var defineBuiltIn$l = defineBuiltIn$u;
var dateToPrimitive = dateToPrimitive$1;
var wellKnownSymbol$x = wellKnownSymbol$S;
var TO_PRIMITIVE = wellKnownSymbol$x("toPrimitive");
var DatePrototype$1 = Date.prototype;
if (!hasOwn$r(DatePrototype$1, TO_PRIMITIVE)) {
  defineBuiltIn$l(DatePrototype$1, TO_PRIMITIVE, dateToPrimitive);
}
var uncurryThis$1q = functionUncurryThis;
var defineBuiltIn$k = defineBuiltIn$u;
var DatePrototype = Date.prototype;
var INVALID_DATE = "Invalid Date";
var TO_STRING$1 = "toString";
var nativeDateToString = uncurryThis$1q(DatePrototype[TO_STRING$1]);
var thisTimeValue$1 = uncurryThis$1q(DatePrototype.getTime);
if (String(/* @__PURE__ */ new Date(NaN)) !== INVALID_DATE) {
  defineBuiltIn$k(DatePrototype, TO_STRING$1, function toString8() {
    var value = thisTimeValue$1(this);
    return value === value ? nativeDateToString(this) : INVALID_DATE;
  });
}
var $$4M = _export;
var uncurryThis$1p = functionUncurryThis;
var toString$C = toString$K;
var charAt$l = uncurryThis$1p("".charAt);
var charCodeAt$8 = uncurryThis$1p("".charCodeAt);
var exec$f = uncurryThis$1p(/./.exec);
var numberToString$4 = uncurryThis$1p(1 .toString);
var toUpperCase = uncurryThis$1p("".toUpperCase);
var raw = /[\w*+\-./@]/;
var hex$1 = function(code, length2) {
  var result = numberToString$4(code, 16);
  while (result.length < length2) result = "0" + result;
  return result;
};
$$4M({ global: true }, {
  escape: function escape2(string) {
    var str = toString$C(string);
    var result = "";
    var length2 = str.length;
    var index = 0;
    var chr, code;
    while (index < length2) {
      chr = charAt$l(str, index++);
      if (exec$f(raw, chr)) {
        result += chr;
      } else {
        code = charCodeAt$8(chr, 0);
        if (code < 256) {
          result += "%" + hex$1(code, 2);
        } else {
          result += "%u" + toUpperCase(hex$1(code, 4));
        }
      }
    }
    return result;
  }
});
var uncurryThis$1o = functionUncurryThis;
var aCallable$H = aCallable$Q;
var isObject$z = isObject$O;
var hasOwn$q = hasOwnProperty_1;
var arraySlice$5 = arraySlice$a;
var NATIVE_BIND = functionBindNative;
var $Function = Function;
var concat$3 = uncurryThis$1o([].concat);
var join$9 = uncurryThis$1o([].join);
var factories = {};
var construct = function(C2, argsLength, args) {
  if (!hasOwn$q(factories, argsLength)) {
    var list = [];
    var i = 0;
    for (; i < argsLength; i++) list[i] = "a[" + i + "]";
    factories[argsLength] = $Function("C,a", "return new C(" + join$9(list, ",") + ")");
  }
  return factories[argsLength](C2, args);
};
var functionBind = NATIVE_BIND ? $Function.bind : function bind(that) {
  var F2 = aCallable$H(this);
  var Prototype2 = F2.prototype;
  var partArgs = arraySlice$5(arguments, 1);
  var boundFunction = function bound() {
    var args = concat$3(partArgs, arraySlice$5(arguments));
    return this instanceof boundFunction ? construct(F2, args.length, args) : F2.apply(that, args);
  };
  if (isObject$z(Prototype2)) boundFunction.prototype = Prototype2;
  return boundFunction;
};
var $$4L = _export;
var bind$q = functionBind;
$$4L({ target: "Function", proto: true, forced: Function.bind !== bind$q }, {
  bind: bind$q
});
var isCallable$n = isCallable$I;
var isObject$y = isObject$O;
var definePropertyModule$5 = objectDefineProperty;
var isPrototypeOf$7 = objectIsPrototypeOf;
var wellKnownSymbol$w = wellKnownSymbol$S;
var makeBuiltIn$1 = makeBuiltInExports;
var HAS_INSTANCE = wellKnownSymbol$w("hasInstance");
var FunctionPrototype$2 = Function.prototype;
if (!(HAS_INSTANCE in FunctionPrototype$2)) {
  definePropertyModule$5.f(FunctionPrototype$2, HAS_INSTANCE, { value: makeBuiltIn$1(function(O2) {
    if (!isCallable$n(this) || !isObject$y(O2)) return false;
    var P2 = this.prototype;
    return isObject$y(P2) ? isPrototypeOf$7(P2, O2) : O2 instanceof this;
  }, HAS_INSTANCE) });
}
var DESCRIPTORS$D = descriptors$1;
var FUNCTION_NAME_EXISTS = functionName.EXISTS;
var uncurryThis$1n = functionUncurryThis;
var defineBuiltInAccessor$i = defineBuiltInAccessor$p;
var FunctionPrototype$1 = Function.prototype;
var functionToString = uncurryThis$1n(FunctionPrototype$1.toString);
var nameRE = /function\b(?:\s|\/\*[\S\s]*?\*\/|\/\/[^\n\r]*[\n\r]+)*([^\s(/]*)/;
var regExpExec$5 = uncurryThis$1n(nameRE.exec);
var NAME = "name";
if (DESCRIPTORS$D && !FUNCTION_NAME_EXISTS) {
  defineBuiltInAccessor$i(FunctionPrototype$1, NAME, {
    configurable: true,
    get: function() {
      try {
        return regExpExec$5(nameRE, functionToString(this))[1];
      } catch (error2) {
        return "";
      }
    }
  });
}
var $$4K = _export;
var globalThis$W = globalThis_1;
$$4K({ global: true, forced: globalThis$W.globalThis !== globalThis$W }, {
  globalThis: globalThis$W
});
var $$4J = _export;
var globalThis$V = globalThis_1;
var anInstance$d = anInstance$f;
var anObject$15 = anObject$1i;
var isCallable$m = isCallable$I;
var getPrototypeOf$c = objectGetPrototypeOf$2;
var defineBuiltInAccessor$h = defineBuiltInAccessor$p;
var createProperty$5 = createProperty$b;
var fails$14 = fails$1z;
var hasOwn$p = hasOwnProperty_1;
var wellKnownSymbol$v = wellKnownSymbol$S;
var IteratorPrototype$3 = iteratorsCore.IteratorPrototype;
var DESCRIPTORS$C = descriptors$1;
var CONSTRUCTOR = "constructor";
var ITERATOR$7 = "Iterator";
var TO_STRING_TAG$6 = wellKnownSymbol$v("toStringTag");
var $TypeError$w = TypeError;
var NativeIterator = globalThis$V[ITERATOR$7];
var FORCED$t = !isCallable$m(NativeIterator) || NativeIterator.prototype !== IteratorPrototype$3 || !fails$14(function() {
  NativeIterator({});
});
var IteratorConstructor = function Iterator() {
  anInstance$d(this, IteratorPrototype$3);
  if (getPrototypeOf$c(this) === IteratorPrototype$3) throw new $TypeError$w("Abstract class Iterator not directly constructable");
};
var defineIteratorPrototypeAccessor = function(key, value) {
  if (DESCRIPTORS$C) {
    defineBuiltInAccessor$h(IteratorPrototype$3, key, {
      configurable: true,
      get: function() {
        return value;
      },
      set: function(replacement2) {
        anObject$15(this);
        if (this === IteratorPrototype$3) throw new $TypeError$w("You can't redefine this property");
        if (hasOwn$p(this, key)) this[key] = replacement2;
        else createProperty$5(this, key, replacement2);
      }
    });
  } else IteratorPrototype$3[key] = value;
};
if (!hasOwn$p(IteratorPrototype$3, TO_STRING_TAG$6)) defineIteratorPrototypeAccessor(TO_STRING_TAG$6, ITERATOR$7);
if (FORCED$t || !hasOwn$p(IteratorPrototype$3, CONSTRUCTOR) || IteratorPrototype$3[CONSTRUCTOR] === Object) {
  defineIteratorPrototypeAccessor(CONSTRUCTOR, IteratorConstructor);
}
IteratorConstructor.prototype = IteratorPrototype$3;
$$4J({ global: true, constructor: true, forced: FORCED$t }, {
  Iterator: IteratorConstructor
});
var getIteratorDirect$o = function(obj) {
  return {
    iterator: obj,
    next: obj.next,
    done: false
  };
};
var $RangeError$a = RangeError;
var notANan = function(it) {
  if (it === it) return it;
  throw new $RangeError$a("NaN is not allowed");
};
var toIntegerOrInfinity$c = toIntegerOrInfinity$p;
var $RangeError$9 = RangeError;
var toPositiveInteger$5 = function(it) {
  var result = toIntegerOrInfinity$c(it);
  if (result < 0) throw new $RangeError$9("The argument can't be less than 0");
  return result;
};
var call$15 = functionCall;
var create$f = objectCreate$1;
var createNonEnumerableProperty$9 = createNonEnumerableProperty$j;
var defineBuiltIns$9 = defineBuiltIns$b;
var wellKnownSymbol$u = wellKnownSymbol$S;
var InternalStateModule$i = internalState;
var getMethod$h = getMethod$l;
var IteratorPrototype$2 = iteratorsCore.IteratorPrototype;
var createIterResultObject$f = createIterResultObject$h;
var iteratorClose$5 = iteratorClose$8;
var TO_STRING_TAG$5 = wellKnownSymbol$u("toStringTag");
var ITERATOR_HELPER = "IteratorHelper";
var WRAP_FOR_VALID_ITERATOR = "WrapForValidIterator";
var setInternalState$j = InternalStateModule$i.set;
var createIteratorProxyPrototype = function(IS_ITERATOR) {
  var getInternalState2 = InternalStateModule$i.getterFor(IS_ITERATOR ? WRAP_FOR_VALID_ITERATOR : ITERATOR_HELPER);
  return defineBuiltIns$9(create$f(IteratorPrototype$2), {
    next: function next11() {
      var state = getInternalState2(this);
      if (IS_ITERATOR) return state.nextHandler();
      try {
        var result = state.done ? void 0 : state.nextHandler();
        return createIterResultObject$f(result, state.done);
      } catch (error2) {
        state.done = true;
        throw error2;
      }
    },
    "return": function() {
      var state = getInternalState2(this);
      var iterator = state.iterator;
      state.done = true;
      if (IS_ITERATOR) {
        var returnMethod = getMethod$h(iterator, "return");
        return returnMethod ? call$15(returnMethod, iterator) : createIterResultObject$f(void 0, true);
      }
      if (state.inner) try {
        iteratorClose$5(state.inner.iterator, "normal");
      } catch (error2) {
        return iteratorClose$5(iterator, "throw", error2);
      }
      if (iterator) iteratorClose$5(iterator, "normal");
      return createIterResultObject$f(void 0, true);
    }
  });
};
var WrapForValidIteratorPrototype = createIteratorProxyPrototype(true);
var IteratorHelperPrototype = createIteratorProxyPrototype(false);
createNonEnumerableProperty$9(IteratorHelperPrototype, TO_STRING_TAG$5, "Iterator Helper");
var iteratorCreateProxy = function(nextHandler, IS_ITERATOR) {
  var IteratorProxy2 = function Iterator3(record, state) {
    if (state) {
      state.iterator = record.iterator;
      state.next = record.next;
    } else state = record;
    state.type = IS_ITERATOR ? WRAP_FOR_VALID_ITERATOR : ITERATOR_HELPER;
    state.nextHandler = nextHandler;
    state.counter = 0;
    state.done = false;
    setInternalState$j(this, state);
  };
  IteratorProxy2.prototype = IS_ITERATOR ? WrapForValidIteratorPrototype : IteratorHelperPrototype;
  return IteratorProxy2;
};
var $$4I = _export;
var call$14 = functionCall;
var anObject$14 = anObject$1i;
var getIteratorDirect$n = getIteratorDirect$o;
var notANaN$3 = notANan;
var toPositiveInteger$4 = toPositiveInteger$5;
var createIteratorProxy$6 = iteratorCreateProxy;
var IS_PURE$h = isPure;
var IteratorProxy$6 = createIteratorProxy$6(function() {
  var iterator = this.iterator;
  var next11 = this.next;
  var result, done;
  while (this.remaining) {
    this.remaining--;
    result = anObject$14(call$14(next11, iterator));
    done = this.done = !!result.done;
    if (done) return;
  }
  result = anObject$14(call$14(next11, iterator));
  done = this.done = !!result.done;
  if (!done) return result.value;
});
$$4I({ target: "Iterator", proto: true, real: true, forced: IS_PURE$h }, {
  drop: function drop(limit) {
    anObject$14(this);
    var remaining = toPositiveInteger$4(notANaN$3(+limit));
    return new IteratorProxy$6(getIteratorDirect$n(this), {
      remaining
    });
  }
});
var $$4H = _export;
var iterate$F = iterate$H;
var aCallable$G = aCallable$Q;
var anObject$13 = anObject$1i;
var getIteratorDirect$m = getIteratorDirect$o;
$$4H({ target: "Iterator", proto: true, real: true }, {
  every: function every2(predicate) {
    anObject$13(this);
    aCallable$G(predicate);
    var record = getIteratorDirect$m(this);
    var counter2 = 0;
    return !iterate$F(record, function(value, stop) {
      if (!predicate(value, counter2++)) return stop();
    }, { IS_RECORD: true, INTERRUPTED: true }).stopped;
  }
});
var $$4G = _export;
var call$13 = functionCall;
var aCallable$F = aCallable$Q;
var anObject$12 = anObject$1i;
var getIteratorDirect$l = getIteratorDirect$o;
var createIteratorProxy$5 = iteratorCreateProxy;
var callWithSafeIterationClosing$1 = callWithSafeIterationClosing$3;
var IS_PURE$g = isPure;
var IteratorProxy$5 = createIteratorProxy$5(function() {
  var iterator = this.iterator;
  var predicate = this.predicate;
  var next11 = this.next;
  var result, done, value;
  while (true) {
    result = anObject$12(call$13(next11, iterator));
    done = this.done = !!result.done;
    if (done) return;
    value = result.value;
    if (callWithSafeIterationClosing$1(iterator, predicate, [value, this.counter++], true)) return value;
  }
});
$$4G({ target: "Iterator", proto: true, real: true, forced: IS_PURE$g }, {
  filter: function filter2(predicate) {
    anObject$12(this);
    aCallable$F(predicate);
    return new IteratorProxy$5(getIteratorDirect$l(this), {
      predicate
    });
  }
});
var $$4F = _export;
var iterate$E = iterate$H;
var aCallable$E = aCallable$Q;
var anObject$11 = anObject$1i;
var getIteratorDirect$k = getIteratorDirect$o;
$$4F({ target: "Iterator", proto: true, real: true }, {
  find: function find2(predicate) {
    anObject$11(this);
    aCallable$E(predicate);
    var record = getIteratorDirect$k(this);
    var counter2 = 0;
    return iterate$E(record, function(value, stop) {
      if (predicate(value, counter2++)) return stop(value);
    }, { IS_RECORD: true, INTERRUPTED: true }).result;
  }
});
var call$12 = functionCall;
var anObject$10 = anObject$1i;
var getIteratorDirect$j = getIteratorDirect$o;
var getIteratorMethod$5 = getIteratorMethod$9;
var getIteratorFlattenable$2 = function(obj, stringHandling) {
  if (!stringHandling || typeof obj !== "string") anObject$10(obj);
  var method = getIteratorMethod$5(obj);
  return getIteratorDirect$j(anObject$10(method !== void 0 ? call$12(method, obj) : obj));
};
var $$4E = _export;
var call$11 = functionCall;
var aCallable$D = aCallable$Q;
var anObject$$ = anObject$1i;
var getIteratorDirect$i = getIteratorDirect$o;
var getIteratorFlattenable$1 = getIteratorFlattenable$2;
var createIteratorProxy$4 = iteratorCreateProxy;
var iteratorClose$4 = iteratorClose$8;
var IS_PURE$f = isPure;
var IteratorProxy$4 = createIteratorProxy$4(function() {
  var iterator = this.iterator;
  var mapper = this.mapper;
  var result, inner;
  while (true) {
    if (inner = this.inner) try {
      result = anObject$$(call$11(inner.next, inner.iterator));
      if (!result.done) return result.value;
      this.inner = null;
    } catch (error2) {
      iteratorClose$4(iterator, "throw", error2);
    }
    result = anObject$$(call$11(this.next, iterator));
    if (this.done = !!result.done) return;
    try {
      this.inner = getIteratorFlattenable$1(mapper(result.value, this.counter++), false);
    } catch (error2) {
      iteratorClose$4(iterator, "throw", error2);
    }
  }
});
$$4E({ target: "Iterator", proto: true, real: true, forced: IS_PURE$f }, {
  flatMap: function flatMap2(mapper) {
    anObject$$(this);
    aCallable$D(mapper);
    return new IteratorProxy$4(getIteratorDirect$i(this), {
      mapper,
      inner: null
    });
  }
});
var $$4D = _export;
var iterate$D = iterate$H;
var aCallable$C = aCallable$Q;
var anObject$_ = anObject$1i;
var getIteratorDirect$h = getIteratorDirect$o;
$$4D({ target: "Iterator", proto: true, real: true }, {
  forEach: function forEach2(fn) {
    anObject$_(this);
    aCallable$C(fn);
    var record = getIteratorDirect$h(this);
    var counter2 = 0;
    iterate$D(record, function(value) {
      fn(value, counter2++);
    }, { IS_RECORD: true });
  }
});
var $$4C = _export;
var call$10 = functionCall;
var toObject$l = toObject$E;
var isPrototypeOf$6 = objectIsPrototypeOf;
var IteratorPrototype$1 = iteratorsCore.IteratorPrototype;
var createIteratorProxy$3 = iteratorCreateProxy;
var getIteratorFlattenable = getIteratorFlattenable$2;
var IS_PURE$e = isPure;
var IteratorProxy$3 = createIteratorProxy$3(function() {
  return call$10(this.next, this.iterator);
}, true);
$$4C({ target: "Iterator", stat: true, forced: IS_PURE$e }, {
  from: function from2(O2) {
    var iteratorRecord = getIteratorFlattenable(typeof O2 == "string" ? toObject$l(O2) : O2, true);
    return isPrototypeOf$6(IteratorPrototype$1, iteratorRecord.iterator) ? iteratorRecord.iterator : new IteratorProxy$3(iteratorRecord);
  }
});
var call$$ = functionCall;
var aCallable$B = aCallable$Q;
var anObject$Z = anObject$1i;
var getIteratorDirect$g = getIteratorDirect$o;
var createIteratorProxy$2 = iteratorCreateProxy;
var callWithSafeIterationClosing = callWithSafeIterationClosing$3;
var IteratorProxy$2 = createIteratorProxy$2(function() {
  var iterator = this.iterator;
  var result = anObject$Z(call$$(this.next, iterator));
  var done = this.done = !!result.done;
  if (!done) return callWithSafeIterationClosing(iterator, this.mapper, [result.value, this.counter++], true);
});
var iteratorMap = function map2(mapper) {
  anObject$Z(this);
  aCallable$B(mapper);
  return new IteratorProxy$2(getIteratorDirect$g(this), {
    mapper
  });
};
var $$4B = _export;
var map$3 = iteratorMap;
var IS_PURE$d = isPure;
$$4B({ target: "Iterator", proto: true, real: true, forced: IS_PURE$d }, {
  map: map$3
});
var $$4A = _export;
var iterate$C = iterate$H;
var aCallable$A = aCallable$Q;
var anObject$Y = anObject$1i;
var getIteratorDirect$f = getIteratorDirect$o;
var $TypeError$v = TypeError;
$$4A({ target: "Iterator", proto: true, real: true }, {
  reduce: function reduce2(reducer) {
    anObject$Y(this);
    aCallable$A(reducer);
    var record = getIteratorDirect$f(this);
    var noInitial = arguments.length < 2;
    var accumulator = noInitial ? void 0 : arguments[1];
    var counter2 = 0;
    iterate$C(record, function(value) {
      if (noInitial) {
        noInitial = false;
        accumulator = value;
      } else {
        accumulator = reducer(accumulator, value, counter2);
      }
      counter2++;
    }, { IS_RECORD: true });
    if (noInitial) throw new $TypeError$v("Reduce of empty iterator with no initial value");
    return accumulator;
  }
});
var $$4z = _export;
var iterate$B = iterate$H;
var aCallable$z = aCallable$Q;
var anObject$X = anObject$1i;
var getIteratorDirect$e = getIteratorDirect$o;
$$4z({ target: "Iterator", proto: true, real: true }, {
  some: function some2(predicate) {
    anObject$X(this);
    aCallable$z(predicate);
    var record = getIteratorDirect$e(this);
    var counter2 = 0;
    return iterate$B(record, function(value, stop) {
      if (predicate(value, counter2++)) return stop();
    }, { IS_RECORD: true, INTERRUPTED: true }).stopped;
  }
});
var $$4y = _export;
var call$_ = functionCall;
var anObject$W = anObject$1i;
var getIteratorDirect$d = getIteratorDirect$o;
var notANaN$2 = notANan;
var toPositiveInteger$3 = toPositiveInteger$5;
var createIteratorProxy$1 = iteratorCreateProxy;
var iteratorClose$3 = iteratorClose$8;
var IS_PURE$c = isPure;
var IteratorProxy$1 = createIteratorProxy$1(function() {
  var iterator = this.iterator;
  if (!this.remaining--) {
    this.done = true;
    return iteratorClose$3(iterator, "normal", void 0);
  }
  var result = anObject$W(call$_(this.next, iterator));
  var done = this.done = !!result.done;
  if (!done) return result.value;
});
$$4y({ target: "Iterator", proto: true, real: true, forced: IS_PURE$c }, {
  take: function take(limit) {
    anObject$W(this);
    var remaining = toPositiveInteger$3(notANaN$2(+limit));
    return new IteratorProxy$1(getIteratorDirect$d(this), {
      remaining
    });
  }
});
var $$4x = _export;
var anObject$V = anObject$1i;
var iterate$A = iterate$H;
var getIteratorDirect$c = getIteratorDirect$o;
var push$m = [].push;
$$4x({ target: "Iterator", proto: true, real: true }, {
  toArray: function toArray() {
    var result = [];
    iterate$A(getIteratorDirect$c(anObject$V(this)), push$m, { that: result, IS_RECORD: true });
    return result;
  }
});
var globalThis$U = globalThis_1;
var setToStringTag$8 = setToStringTag$e;
setToStringTag$8(globalThis$U.JSON, "JSON", true);
var internalMetadata = { exports: {} };
var fails$13 = fails$1z;
var arrayBufferNonExtensible = fails$13(function() {
  if (typeof ArrayBuffer == "function") {
    var buffer2 = new ArrayBuffer(8);
    if (Object.isExtensible(buffer2)) Object.defineProperty(buffer2, "a", { value: 8 });
  }
});
var fails$12 = fails$1z;
var isObject$x = isObject$O;
var classof$f = classofRaw$2;
var ARRAY_BUFFER_NON_EXTENSIBLE$2 = arrayBufferNonExtensible;
var $isExtensible$2 = Object.isExtensible;
var FAILS_ON_PRIMITIVES$6 = fails$12(function() {
  $isExtensible$2(1);
});
var objectIsExtensible = FAILS_ON_PRIMITIVES$6 || ARRAY_BUFFER_NON_EXTENSIBLE$2 ? function isExtensible(it) {
  if (!isObject$x(it)) return false;
  if (ARRAY_BUFFER_NON_EXTENSIBLE$2 && classof$f(it) === "ArrayBuffer") return false;
  return $isExtensible$2 ? $isExtensible$2(it) : true;
} : $isExtensible$2;
var fails$11 = fails$1z;
var freezing = !fails$11(function() {
  return Object.isExtensible(Object.preventExtensions({}));
});
var $$4w = _export;
var uncurryThis$1m = functionUncurryThis;
var hiddenKeys = hiddenKeys$6;
var isObject$w = isObject$O;
var hasOwn$o = hasOwnProperty_1;
var defineProperty$a = objectDefineProperty.f;
var getOwnPropertyNamesModule = objectGetOwnPropertyNames;
var getOwnPropertyNamesExternalModule = objectGetOwnPropertyNamesExternal;
var isExtensible$1 = objectIsExtensible;
var uid$2 = uid$7;
var FREEZING$7 = freezing;
var REQUIRED = false;
var METADATA$1 = uid$2("meta");
var id$1 = 0;
var setMetadata = function(it) {
  defineProperty$a(it, METADATA$1, { value: {
    objectID: "O" + id$1++,
    // object ID
    weakData: {}
    // weak collections IDs
  } });
};
var fastKey$1 = function(it, create4) {
  if (!isObject$w(it)) return typeof it == "symbol" ? it : (typeof it == "string" ? "S" : "P") + it;
  if (!hasOwn$o(it, METADATA$1)) {
    if (!isExtensible$1(it)) return "F";
    if (!create4) return "E";
    setMetadata(it);
  }
  return it[METADATA$1].objectID;
};
var getWeakData$1 = function(it, create4) {
  if (!hasOwn$o(it, METADATA$1)) {
    if (!isExtensible$1(it)) return true;
    if (!create4) return false;
    setMetadata(it);
  }
  return it[METADATA$1].weakData;
};
var onFreeze$3 = function(it) {
  if (FREEZING$7 && REQUIRED && isExtensible$1(it) && !hasOwn$o(it, METADATA$1)) setMetadata(it);
  return it;
};
var enable = function() {
  meta.enable = function() {
  };
  REQUIRED = true;
  var getOwnPropertyNames5 = getOwnPropertyNamesModule.f;
  var splice3 = uncurryThis$1m([].splice);
  var test2 = {};
  test2[METADATA$1] = 1;
  if (getOwnPropertyNames5(test2).length) {
    getOwnPropertyNamesModule.f = function(it) {
      var result = getOwnPropertyNames5(it);
      for (var i = 0, length2 = result.length; i < length2; i++) {
        if (result[i] === METADATA$1) {
          splice3(result, i, 1);
          break;
        }
      }
      return result;
    };
    $$4w({ target: "Object", stat: true, forced: true }, {
      getOwnPropertyNames: getOwnPropertyNamesExternalModule.f
    });
  }
};
var meta = internalMetadata.exports = {
  enable,
  fastKey: fastKey$1,
  getWeakData: getWeakData$1,
  onFreeze: onFreeze$3
};
hiddenKeys[METADATA$1] = true;
var internalMetadataExports = internalMetadata.exports;
var $$4v = _export;
var globalThis$T = globalThis_1;
var uncurryThis$1l = functionUncurryThis;
var isForced$3 = isForced_1;
var defineBuiltIn$j = defineBuiltIn$u;
var InternalMetadataModule$1 = internalMetadataExports;
var iterate$z = iterate$H;
var anInstance$c = anInstance$f;
var isCallable$l = isCallable$I;
var isNullOrUndefined$f = isNullOrUndefined$j;
var isObject$v = isObject$O;
var fails$10 = fails$1z;
var checkCorrectnessOfIteration$2 = checkCorrectnessOfIteration$4;
var setToStringTag$7 = setToStringTag$e;
var inheritIfRequired$4 = inheritIfRequired$7;
var collection$4 = function(CONSTRUCTOR_NAME, wrapper2, common2) {
  var IS_MAP = CONSTRUCTOR_NAME.indexOf("Map") !== -1;
  var IS_WEAK = CONSTRUCTOR_NAME.indexOf("Weak") !== -1;
  var ADDER = IS_MAP ? "set" : "add";
  var NativeConstructor = globalThis$T[CONSTRUCTOR_NAME];
  var NativePrototype = NativeConstructor && NativeConstructor.prototype;
  var Constructor2 = NativeConstructor;
  var exported = {};
  var fixMethod = function(KEY) {
    var uncurriedNativeMethod = uncurryThis$1l(NativePrototype[KEY]);
    defineBuiltIn$j(
      NativePrototype,
      KEY,
      KEY === "add" ? function add2(value) {
        uncurriedNativeMethod(this, value === 0 ? 0 : value);
        return this;
      } : KEY === "delete" ? function(key) {
        return IS_WEAK && !isObject$v(key) ? false : uncurriedNativeMethod(this, key === 0 ? 0 : key);
      } : KEY === "get" ? function get3(key) {
        return IS_WEAK && !isObject$v(key) ? void 0 : uncurriedNativeMethod(this, key === 0 ? 0 : key);
      } : KEY === "has" ? function has4(key) {
        return IS_WEAK && !isObject$v(key) ? false : uncurriedNativeMethod(this, key === 0 ? 0 : key);
      } : function set4(key, value) {
        uncurriedNativeMethod(this, key === 0 ? 0 : key, value);
        return this;
      }
    );
  };
  var REPLACE2 = isForced$3(
    CONSTRUCTOR_NAME,
    !isCallable$l(NativeConstructor) || !(IS_WEAK || NativePrototype.forEach && !fails$10(function() {
      new NativeConstructor().entries().next();
    }))
  );
  if (REPLACE2) {
    Constructor2 = common2.getConstructor(wrapper2, CONSTRUCTOR_NAME, IS_MAP, ADDER);
    InternalMetadataModule$1.enable();
  } else if (isForced$3(CONSTRUCTOR_NAME, true)) {
    var instance = new Constructor2();
    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) !== instance;
    var THROWS_ON_PRIMITIVES = fails$10(function() {
      instance.has(1);
    });
    var ACCEPT_ITERABLES = checkCorrectnessOfIteration$2(function(iterable) {
      new NativeConstructor(iterable);
    });
    var BUGGY_ZERO = !IS_WEAK && fails$10(function() {
      var $instance = new NativeConstructor();
      var index = 5;
      while (index--) $instance[ADDER](index, index);
      return !$instance.has(-0);
    });
    if (!ACCEPT_ITERABLES) {
      Constructor2 = wrapper2(function(dummy, iterable) {
        anInstance$c(dummy, NativePrototype);
        var that = inheritIfRequired$4(new NativeConstructor(), dummy, Constructor2);
        if (!isNullOrUndefined$f(iterable)) iterate$z(iterable, that[ADDER], { that, AS_ENTRIES: IS_MAP });
        return that;
      });
      Constructor2.prototype = NativePrototype;
      NativePrototype.constructor = Constructor2;
    }
    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
      fixMethod("delete");
      fixMethod("has");
      IS_MAP && fixMethod("get");
    }
    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);
    if (IS_WEAK && NativePrototype.clear) delete NativePrototype.clear;
  }
  exported[CONSTRUCTOR_NAME] = Constructor2;
  $$4v({ global: true, constructor: true, forced: Constructor2 !== NativeConstructor }, exported);
  setToStringTag$7(Constructor2, CONSTRUCTOR_NAME);
  if (!IS_WEAK) common2.setStrong(Constructor2, CONSTRUCTOR_NAME, IS_MAP);
  return Constructor2;
};
var create$e = objectCreate$1;
var defineBuiltInAccessor$g = defineBuiltInAccessor$p;
var defineBuiltIns$8 = defineBuiltIns$b;
var bind$p = functionBindContext;
var anInstance$b = anInstance$f;
var isNullOrUndefined$e = isNullOrUndefined$j;
var iterate$y = iterate$H;
var defineIterator$1 = iteratorDefine;
var createIterResultObject$e = createIterResultObject$h;
var setSpecies$4 = setSpecies$7;
var DESCRIPTORS$B = descriptors$1;
var fastKey = internalMetadataExports.fastKey;
var InternalStateModule$h = internalState;
var setInternalState$i = InternalStateModule$h.set;
var internalStateGetterFor$1 = InternalStateModule$h.getterFor;
var collectionStrong$2 = {
  getConstructor: function(wrapper2, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
    var Constructor2 = wrapper2(function(that, iterable) {
      anInstance$b(that, Prototype2);
      setInternalState$i(that, {
        type: CONSTRUCTOR_NAME,
        index: create$e(null),
        first: null,
        last: null,
        size: 0
      });
      if (!DESCRIPTORS$B) that.size = 0;
      if (!isNullOrUndefined$e(iterable)) iterate$y(iterable, that[ADDER], { that, AS_ENTRIES: IS_MAP });
    });
    var Prototype2 = Constructor2.prototype;
    var getInternalState2 = internalStateGetterFor$1(CONSTRUCTOR_NAME);
    var define = function(that, key, value) {
      var state = getInternalState2(that);
      var entry = getEntry(that, key);
      var previous, index;
      if (entry) {
        entry.value = value;
      } else {
        state.last = entry = {
          index: index = fastKey(key, true),
          key,
          value,
          previous: previous = state.last,
          next: null,
          removed: false
        };
        if (!state.first) state.first = entry;
        if (previous) previous.next = entry;
        if (DESCRIPTORS$B) state.size++;
        else that.size++;
        if (index !== "F") state.index[index] = entry;
      }
      return that;
    };
    var getEntry = function(that, key) {
      var state = getInternalState2(that);
      var index = fastKey(key);
      var entry;
      if (index !== "F") return state.index[index];
      for (entry = state.first; entry; entry = entry.next) {
        if (entry.key === key) return entry;
      }
    };
    defineBuiltIns$8(Prototype2, {
      // `{ Map, Set }.prototype.clear()` methods
      // https://tc39.es/ecma262/#sec-map.prototype.clear
      // https://tc39.es/ecma262/#sec-set.prototype.clear
      clear: function clear2() {
        var that = this;
        var state = getInternalState2(that);
        var entry = state.first;
        while (entry) {
          entry.removed = true;
          if (entry.previous) entry.previous = entry.previous.next = null;
          entry = entry.next;
        }
        state.first = state.last = null;
        state.index = create$e(null);
        if (DESCRIPTORS$B) state.size = 0;
        else that.size = 0;
      },
      // `{ Map, Set }.prototype.delete(key)` methods
      // https://tc39.es/ecma262/#sec-map.prototype.delete
      // https://tc39.es/ecma262/#sec-set.prototype.delete
      "delete": function(key) {
        var that = this;
        var state = getInternalState2(that);
        var entry = getEntry(that, key);
        if (entry) {
          var next11 = entry.next;
          var prev2 = entry.previous;
          delete state.index[entry.index];
          entry.removed = true;
          if (prev2) prev2.next = next11;
          if (next11) next11.previous = prev2;
          if (state.first === entry) state.first = next11;
          if (state.last === entry) state.last = prev2;
          if (DESCRIPTORS$B) state.size--;
          else that.size--;
        }
        return !!entry;
      },
      // `{ Map, Set }.prototype.forEach(callbackfn, thisArg = undefined)` methods
      // https://tc39.es/ecma262/#sec-map.prototype.foreach
      // https://tc39.es/ecma262/#sec-set.prototype.foreach
      forEach: function forEach7(callbackfn) {
        var state = getInternalState2(this);
        var boundFunction = bind$p(callbackfn, arguments.length > 1 ? arguments[1] : void 0);
        var entry;
        while (entry = entry ? entry.next : state.first) {
          boundFunction(entry.value, entry.key, this);
          while (entry && entry.removed) entry = entry.previous;
        }
      },
      // `{ Map, Set}.prototype.has(key)` methods
      // https://tc39.es/ecma262/#sec-map.prototype.has
      // https://tc39.es/ecma262/#sec-set.prototype.has
      has: function has4(key) {
        return !!getEntry(this, key);
      }
    });
    defineBuiltIns$8(Prototype2, IS_MAP ? {
      // `Map.prototype.get(key)` method
      // https://tc39.es/ecma262/#sec-map.prototype.get
      get: function get3(key) {
        var entry = getEntry(this, key);
        return entry && entry.value;
      },
      // `Map.prototype.set(key, value)` method
      // https://tc39.es/ecma262/#sec-map.prototype.set
      set: function set4(key, value) {
        return define(this, key === 0 ? 0 : key, value);
      }
    } : {
      // `Set.prototype.add(value)` method
      // https://tc39.es/ecma262/#sec-set.prototype.add
      add: function add2(value) {
        return define(this, value = value === 0 ? 0 : value, value);
      }
    });
    if (DESCRIPTORS$B) defineBuiltInAccessor$g(Prototype2, "size", {
      configurable: true,
      get: function() {
        return getInternalState2(this).size;
      }
    });
    return Constructor2;
  },
  setStrong: function(Constructor2, CONSTRUCTOR_NAME, IS_MAP) {
    var ITERATOR_NAME = CONSTRUCTOR_NAME + " Iterator";
    var getInternalCollectionState = internalStateGetterFor$1(CONSTRUCTOR_NAME);
    var getInternalIteratorState2 = internalStateGetterFor$1(ITERATOR_NAME);
    defineIterator$1(Constructor2, CONSTRUCTOR_NAME, function(iterated, kind) {
      setInternalState$i(this, {
        type: ITERATOR_NAME,
        target: iterated,
        state: getInternalCollectionState(iterated),
        kind,
        last: null
      });
    }, function() {
      var state = getInternalIteratorState2(this);
      var kind = state.kind;
      var entry = state.last;
      while (entry && entry.removed) entry = entry.previous;
      if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {
        state.target = null;
        return createIterResultObject$e(void 0, true);
      }
      if (kind === "keys") return createIterResultObject$e(entry.key, false);
      if (kind === "values") return createIterResultObject$e(entry.value, false);
      return createIterResultObject$e([entry.key, entry.value], false);
    }, IS_MAP ? "entries" : "values", !IS_MAP, true);
    setSpecies$4(CONSTRUCTOR_NAME);
  }
};
var collection$3 = collection$4;
var collectionStrong$1 = collectionStrong$2;
collection$3("Map", function(init) {
  return function Map2() {
    return init(this, arguments.length ? arguments[0] : void 0);
  };
}, collectionStrong$1);
var uncurryThis$1k = functionUncurryThis;
var MapPrototype$1 = Map.prototype;
var mapHelpers = {
  // eslint-disable-next-line es/no-map -- safe
  Map,
  set: uncurryThis$1k(MapPrototype$1.set),
  get: uncurryThis$1k(MapPrototype$1.get),
  has: uncurryThis$1k(MapPrototype$1.has),
  remove: uncurryThis$1k(MapPrototype$1["delete"]),
  proto: MapPrototype$1
};
var $$4u = _export;
var uncurryThis$1j = functionUncurryThis;
var aCallable$y = aCallable$Q;
var requireObjectCoercible$k = requireObjectCoercible$q;
var iterate$x = iterate$H;
var MapHelpers$d = mapHelpers;
var fails$$ = fails$1z;
var Map$b = MapHelpers$d.Map;
var has$g = MapHelpers$d.has;
var get$8 = MapHelpers$d.get;
var set$d = MapHelpers$d.set;
var push$l = uncurryThis$1j([].push);
var DOES_NOT_WORK_WITH_PRIMITIVES$1 = fails$$(function() {
  return Map$b.groupBy("ab", function(it) {
    return it;
  }).get("a").length !== 1;
});
$$4u({ target: "Map", stat: true, forced: DOES_NOT_WORK_WITH_PRIMITIVES$1 }, {
  groupBy: function groupBy(items, callbackfn) {
    requireObjectCoercible$k(items);
    aCallable$y(callbackfn);
    var map7 = new Map$b();
    var k2 = 0;
    iterate$x(items, function(value) {
      var key = callbackfn(value, k2++);
      if (!has$g(map7, key)) set$d(map7, key, [value]);
      else push$l(get$8(map7, key), value);
    });
    return map7;
  }
});
var log$7 = Math.log;
var mathLog1p = Math.log1p || function log1p(x2) {
  var n2 = +x2;
  return n2 > -1e-8 && n2 < 1e-8 ? n2 - n2 * n2 / 2 : log$7(1 + n2);
};
var $$4t = _export;
var log1p$1 = mathLog1p;
var $acosh = Math.acosh;
var log$6 = Math.log;
var sqrt$2 = Math.sqrt;
var LN2$1 = Math.LN2;
var FORCED$s = !$acosh || Math.floor($acosh(Number.MAX_VALUE)) !== 710 || $acosh(Infinity) !== Infinity;
$$4t({ target: "Math", stat: true, forced: FORCED$s }, {
  acosh: function acosh(x2) {
    var n2 = +x2;
    return n2 < 1 ? NaN : n2 > 9490626562425156e-8 ? log$6(n2) + LN2$1 : log1p$1(n2 - 1 + sqrt$2(n2 - 1) * sqrt$2(n2 + 1));
  }
});
var $$4s = _export;
var $asinh = Math.asinh;
var log$5 = Math.log;
var sqrt$1 = Math.sqrt;
function asinh(x2) {
  var n2 = +x2;
  return !isFinite(n2) || n2 === 0 ? n2 : n2 < 0 ? -asinh(-n2) : log$5(n2 + sqrt$1(n2 * n2 + 1));
}
var FORCED$r = !($asinh && 1 / $asinh(0) > 0);
$$4s({ target: "Math", stat: true, forced: FORCED$r }, {
  asinh
});
var $$4r = _export;
var $atanh = Math.atanh;
var log$4 = Math.log;
var FORCED$q = !($atanh && 1 / $atanh(-0) < 0);
$$4r({ target: "Math", stat: true, forced: FORCED$q }, {
  atanh: function atanh(x2) {
    var n2 = +x2;
    return n2 === 0 ? n2 : log$4((1 + n2) / (1 - n2)) / 2;
  }
});
var $$4q = _export;
var sign$1 = mathSign;
var abs$8 = Math.abs;
var pow$5 = Math.pow;
$$4q({ target: "Math", stat: true }, {
  cbrt: function cbrt(x2) {
    var n2 = +x2;
    return sign$1(n2) * pow$5(abs$8(n2), 1 / 3);
  }
});
var $$4p = _export;
var floor$7 = Math.floor;
var log$3 = Math.log;
var LOG2E = Math.LOG2E;
$$4p({ target: "Math", stat: true }, {
  clz32: function clz32(x2) {
    var n2 = x2 >>> 0;
    return n2 ? 31 - floor$7(log$3(n2 + 0.5) * LOG2E) : 32;
  }
});
var $expm1 = Math.expm1;
var exp$2 = Math.exp;
var mathExpm1 = !$expm1 || $expm1(10) > 22025.465794806718 || $expm1(10) < 22025.465794806718 || $expm1(-2e-17) !== -2e-17 ? function expm1(x2) {
  var n2 = +x2;
  return n2 === 0 ? n2 : n2 > -1e-6 && n2 < 1e-6 ? n2 + n2 * n2 / 2 : exp$2(n2) - 1;
} : $expm1;
var $$4o = _export;
var expm1$3 = mathExpm1;
var $cosh = Math.cosh;
var abs$7 = Math.abs;
var E$1 = Math.E;
var FORCED$p = !$cosh || $cosh(710) === Infinity;
$$4o({ target: "Math", stat: true, forced: FORCED$p }, {
  cosh: function cosh(x2) {
    var t2 = expm1$3(abs$7(x2) - 1) + 1;
    return (t2 + 1 / (t2 * E$1 * E$1)) * (E$1 / 2);
  }
});
var $$4n = _export;
var expm1$2 = mathExpm1;
$$4n({ target: "Math", stat: true, forced: expm1$2 !== Math.expm1 }, { expm1: expm1$2 });
var $$4m = _export;
var fround$1 = mathFround;
$$4m({ target: "Math", stat: true }, { fround: fround$1 });
var $$4l = _export;
var $hypot = Math.hypot;
var abs$6 = Math.abs;
var sqrt = Math.sqrt;
var FORCED$o = !!$hypot && $hypot(Infinity, NaN) !== Infinity;
$$4l({ target: "Math", stat: true, arity: 2, forced: FORCED$o }, {
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  hypot: function hypot(value1, value2) {
    var sum = 0;
    var i = 0;
    var aLen = arguments.length;
    var larg = 0;
    var arg2, div;
    while (i < aLen) {
      arg2 = abs$6(arguments[i++]);
      if (larg < arg2) {
        div = larg / arg2;
        sum = sum * div * div + 1;
        larg = arg2;
      } else if (arg2 > 0) {
        div = arg2 / larg;
        sum += div * div;
      } else sum += arg2;
    }
    return larg === Infinity ? Infinity : larg * sqrt(sum);
  }
});
var $$4k = _export;
var fails$_ = fails$1z;
var $imul = Math.imul;
var FORCED$n = fails$_(function() {
  return $imul(4294967295, 5) !== -5 || $imul.length !== 2;
});
$$4k({ target: "Math", stat: true, forced: FORCED$n }, {
  imul: function imul(x2, y2) {
    var UINT16 = 65535;
    var xn = +x2;
    var yn = +y2;
    var xl = UINT16 & xn;
    var yl = UINT16 & yn;
    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
  }
});
var log$2 = Math.log;
var LOG10E = Math.LOG10E;
var mathLog10 = Math.log10 || function log10(x2) {
  return log$2(x2) * LOG10E;
};
var $$4j = _export;
var log10$1 = mathLog10;
$$4j({ target: "Math", stat: true }, {
  log10: log10$1
});
var $$4i = _export;
var log1p2 = mathLog1p;
$$4i({ target: "Math", stat: true }, { log1p: log1p2 });
var $$4h = _export;
var log$1 = Math.log;
var LN2 = Math.LN2;
$$4h({ target: "Math", stat: true }, {
  log2: function log2(x2) {
    return log$1(x2) / LN2;
  }
});
var $$4g = _export;
var sign2 = mathSign;
$$4g({ target: "Math", stat: true }, {
  sign: sign2
});
var $$4f = _export;
var fails$Z = fails$1z;
var expm1$1 = mathExpm1;
var abs$5 = Math.abs;
var exp$1 = Math.exp;
var E = Math.E;
var FORCED$m = fails$Z(function() {
  return Math.sinh(-2e-17) !== -2e-17;
});
$$4f({ target: "Math", stat: true, forced: FORCED$m }, {
  sinh: function sinh(x2) {
    var n2 = +x2;
    return abs$5(n2) < 1 ? (expm1$1(n2) - expm1$1(-n2)) / 2 : (exp$1(n2 - 1) - exp$1(-n2 - 1)) * (E / 2);
  }
});
var $$4e = _export;
var expm12 = mathExpm1;
var exp = Math.exp;
$$4e({ target: "Math", stat: true }, {
  tanh: function tanh(x2) {
    var n2 = +x2;
    var a = expm12(n2);
    var b2 = expm12(-n2);
    return a === Infinity ? 1 : b2 === Infinity ? -1 : (a - b2) / (exp(n2) + exp(-n2));
  }
});
var setToStringTag$6 = setToStringTag$e;
setToStringTag$6(Math, "Math", true);
var $$4d = _export;
var trunc2 = mathTrunc;
$$4d({ target: "Math", stat: true }, {
  trunc: trunc2
});
var uncurryThis$1i = functionUncurryThis;
var thisNumberValue$5 = uncurryThis$1i(1 .valueOf);
var whitespaces$6 = "	\n\v\f\r                　\u2028\u2029\uFEFF";
var uncurryThis$1h = functionUncurryThis;
var requireObjectCoercible$j = requireObjectCoercible$q;
var toString$B = toString$K;
var whitespaces$5 = whitespaces$6;
var replace$a = uncurryThis$1h("".replace);
var ltrim = RegExp("^[" + whitespaces$5 + "]+");
var rtrim = RegExp("(^|[^" + whitespaces$5 + "])[" + whitespaces$5 + "]+$");
var createMethod$3 = function(TYPE) {
  return function($this) {
    var string = toString$B(requireObjectCoercible$j($this));
    if (TYPE & 1) string = replace$a(string, ltrim, "");
    if (TYPE & 2) string = replace$a(string, rtrim, "$1");
    return string;
  };
};
var stringTrim = {
  // `String.prototype.{ trimLeft, trimStart }` methods
  // https://tc39.es/ecma262/#sec-string.prototype.trimstart
  start: createMethod$3(1),
  // `String.prototype.{ trimRight, trimEnd }` methods
  // https://tc39.es/ecma262/#sec-string.prototype.trimend
  end: createMethod$3(2),
  // `String.prototype.trim` method
  // https://tc39.es/ecma262/#sec-string.prototype.trim
  trim: createMethod$3(3)
};
var $$4c = _export;
var IS_PURE$b = isPure;
var DESCRIPTORS$A = descriptors$1;
var globalThis$S = globalThis_1;
var path = path$2;
var uncurryThis$1g = functionUncurryThis;
var isForced$2 = isForced_1;
var hasOwn$n = hasOwnProperty_1;
var inheritIfRequired$3 = inheritIfRequired$7;
var isPrototypeOf$5 = objectIsPrototypeOf;
var isSymbol$3 = isSymbol$8;
var toPrimitive$1 = toPrimitive$4;
var fails$Y = fails$1z;
var getOwnPropertyNames$4 = objectGetOwnPropertyNames.f;
var getOwnPropertyDescriptor$a = objectGetOwnPropertyDescriptor.f;
var defineProperty$9 = objectDefineProperty.f;
var thisNumberValue$4 = thisNumberValue$5;
var trim$5 = stringTrim.trim;
var NUMBER = "Number";
var NativeNumber = globalThis$S[NUMBER];
path[NUMBER];
var NumberPrototype = NativeNumber.prototype;
var TypeError$6 = globalThis$S.TypeError;
var stringSlice$i = uncurryThis$1g("".slice);
var charCodeAt$7 = uncurryThis$1g("".charCodeAt);
var toNumeric = function(value) {
  var primValue = toPrimitive$1(value, "number");
  return typeof primValue == "bigint" ? primValue : toNumber(primValue);
};
var toNumber = function(argument) {
  var it = toPrimitive$1(argument, "number");
  var first, third, radix, maxCode, digits, length2, index, code;
  if (isSymbol$3(it)) throw new TypeError$6("Cannot convert a Symbol value to a number");
  if (typeof it == "string" && it.length > 2) {
    it = trim$5(it);
    first = charCodeAt$7(it, 0);
    if (first === 43 || first === 45) {
      third = charCodeAt$7(it, 2);
      if (third === 88 || third === 120) return NaN;
    } else if (first === 48) {
      switch (charCodeAt$7(it, 1)) {
        case 66:
        case 98:
          radix = 2;
          maxCode = 49;
          break;
        case 79:
        case 111:
          radix = 8;
          maxCode = 55;
          break;
        default:
          return +it;
      }
      digits = stringSlice$i(it, 2);
      length2 = digits.length;
      for (index = 0; index < length2; index++) {
        code = charCodeAt$7(digits, index);
        if (code < 48 || code > maxCode) return NaN;
      }
      return parseInt(digits, radix);
    }
  }
  return +it;
};
var FORCED$l = isForced$2(NUMBER, !NativeNumber(" 0o1") || !NativeNumber("0b1") || NativeNumber("+0x1"));
var calledWithNew = function(dummy) {
  return isPrototypeOf$5(NumberPrototype, dummy) && fails$Y(function() {
    thisNumberValue$4(dummy);
  });
};
var NumberWrapper = function Number2(value) {
  var n2 = arguments.length < 1 ? 0 : NativeNumber(toNumeric(value));
  return calledWithNew(this) ? inheritIfRequired$3(Object(n2), this, NumberWrapper) : n2;
};
NumberWrapper.prototype = NumberPrototype;
if (FORCED$l && !IS_PURE$b) NumberPrototype.constructor = NumberWrapper;
$$4c({ global: true, constructor: true, wrap: true, forced: FORCED$l }, {
  Number: NumberWrapper
});
var copyConstructorProperties$1 = function(target, source) {
  for (var keys6 = DESCRIPTORS$A ? getOwnPropertyNames$4(source) : (
    // ES3:
    "MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,isFinite,isInteger,isNaN,isSafeInteger,parseFloat,parseInt,fromString,range".split(",")
  ), j = 0, key; keys6.length > j; j++) {
    if (hasOwn$n(source, key = keys6[j]) && !hasOwn$n(target, key)) {
      defineProperty$9(target, key, getOwnPropertyDescriptor$a(source, key));
    }
  }
};
if (FORCED$l || IS_PURE$b) copyConstructorProperties$1(path[NUMBER], NativeNumber);
var $$4b = _export;
$$4b({ target: "Number", stat: true, nonConfigurable: true, nonWritable: true }, {
  EPSILON: Math.pow(2, -52)
});
var globalThis$R = globalThis_1;
var globalIsFinite = globalThis$R.isFinite;
var numberIsFinite$2 = Number.isFinite || function isFinite2(it) {
  return typeof it == "number" && globalIsFinite(it);
};
var $$4a = _export;
var numberIsFinite$1 = numberIsFinite$2;
$$4a({ target: "Number", stat: true }, { isFinite: numberIsFinite$1 });
var isObject$u = isObject$O;
var floor$6 = Math.floor;
var isIntegralNumber$3 = Number.isInteger || function isInteger(it) {
  return !isObject$u(it) && isFinite(it) && floor$6(it) === it;
};
var $$49 = _export;
var isIntegralNumber$2 = isIntegralNumber$3;
$$49({ target: "Number", stat: true }, {
  isInteger: isIntegralNumber$2
});
var $$48 = _export;
$$48({ target: "Number", stat: true }, {
  isNaN: function isNaN2(number) {
    return number !== number;
  }
});
var $$47 = _export;
var isIntegralNumber$1 = isIntegralNumber$3;
var abs$4 = Math.abs;
$$47({ target: "Number", stat: true }, {
  isSafeInteger: function isSafeInteger(number) {
    return isIntegralNumber$1(number) && abs$4(number) <= 9007199254740991;
  }
});
var $$46 = _export;
$$46({ target: "Number", stat: true, nonConfigurable: true, nonWritable: true }, {
  MAX_SAFE_INTEGER: 9007199254740991
});
var $$45 = _export;
$$45({ target: "Number", stat: true, nonConfigurable: true, nonWritable: true }, {
  MIN_SAFE_INTEGER: -9007199254740991
});
var globalThis$Q = globalThis_1;
var fails$X = fails$1z;
var uncurryThis$1f = functionUncurryThis;
var toString$A = toString$K;
var trim$4 = stringTrim.trim;
var whitespaces$4 = whitespaces$6;
var charAt$k = uncurryThis$1f("".charAt);
var $parseFloat$1 = globalThis$Q.parseFloat;
var Symbol$6 = globalThis$Q.Symbol;
var ITERATOR$6 = Symbol$6 && Symbol$6.iterator;
var FORCED$k = 1 / $parseFloat$1(whitespaces$4 + "-0") !== -Infinity || ITERATOR$6 && !fails$X(function() {
  $parseFloat$1(Object(ITERATOR$6));
});
var numberParseFloat = FORCED$k ? function parseFloat2(string) {
  var trimmedString = trim$4(toString$A(string));
  var result = $parseFloat$1(trimmedString);
  return result === 0 && charAt$k(trimmedString, 0) === "-" ? -0 : result;
} : $parseFloat$1;
var $$44 = _export;
var parseFloat$1 = numberParseFloat;
$$44({ target: "Number", stat: true, forced: Number.parseFloat !== parseFloat$1 }, {
  parseFloat: parseFloat$1
});
var globalThis$P = globalThis_1;
var fails$W = fails$1z;
var uncurryThis$1e = functionUncurryThis;
var toString$z = toString$K;
var trim$3 = stringTrim.trim;
var whitespaces$3 = whitespaces$6;
var $parseInt$4 = globalThis$P.parseInt;
var Symbol$5 = globalThis$P.Symbol;
var ITERATOR$5 = Symbol$5 && Symbol$5.iterator;
var hex = /^[+-]?0x/i;
var exec$e = uncurryThis$1e(hex.exec);
var FORCED$j = $parseInt$4(whitespaces$3 + "08") !== 8 || $parseInt$4(whitespaces$3 + "0x16") !== 22 || ITERATOR$5 && !fails$W(function() {
  $parseInt$4(Object(ITERATOR$5));
});
var numberParseInt = FORCED$j ? function parseInt2(string, radix) {
  var S2 = trim$3(toString$z(string));
  return $parseInt$4(S2, radix >>> 0 || (exec$e(hex, S2) ? 16 : 10));
} : $parseInt$4;
var $$43 = _export;
var parseInt$3 = numberParseInt;
$$43({ target: "Number", stat: true, forced: Number.parseInt !== parseInt$3 }, {
  parseInt: parseInt$3
});
var $$42 = _export;
var uncurryThis$1d = functionUncurryThis;
var toIntegerOrInfinity$b = toIntegerOrInfinity$p;
var thisNumberValue$3 = thisNumberValue$5;
var $repeat$1 = stringRepeat;
var log102 = mathLog10;
var fails$V = fails$1z;
var $RangeError$8 = RangeError;
var $String$3 = String;
var $isFinite = isFinite;
var abs$3 = Math.abs;
var floor$5 = Math.floor;
var pow$4 = Math.pow;
var round$2 = Math.round;
var nativeToExponential = uncurryThis$1d(1 .toExponential);
var repeat$2 = uncurryThis$1d($repeat$1);
var stringSlice$h = uncurryThis$1d("".slice);
var ROUNDS_PROPERLY = nativeToExponential(-69e-12, 4) === "-6.9000e-11" && nativeToExponential(1.255, 2) === "1.25e+0" && nativeToExponential(12345, 3) === "1.235e+4" && nativeToExponential(25, 0) === "3e+1";
var throwsOnInfinityFraction = function() {
  return fails$V(function() {
    nativeToExponential(1, Infinity);
  }) && fails$V(function() {
    nativeToExponential(1, -Infinity);
  });
};
var properNonFiniteThisCheck = function() {
  return !fails$V(function() {
    nativeToExponential(Infinity, Infinity);
    nativeToExponential(NaN, Infinity);
  });
};
var FORCED$i = !ROUNDS_PROPERLY || !throwsOnInfinityFraction() || !properNonFiniteThisCheck();
$$42({ target: "Number", proto: true, forced: FORCED$i }, {
  toExponential: function toExponential(fractionDigits) {
    var x2 = thisNumberValue$3(this);
    if (fractionDigits === void 0) return nativeToExponential(x2);
    var f2 = toIntegerOrInfinity$b(fractionDigits);
    if (!$isFinite(x2)) return String(x2);
    if (f2 < 0 || f2 > 20) throw new $RangeError$8("Incorrect fraction digits");
    if (ROUNDS_PROPERLY) return nativeToExponential(x2, f2);
    var s = "";
    var m2, e2, c2, d2;
    if (x2 < 0) {
      s = "-";
      x2 = -x2;
    }
    if (x2 === 0) {
      e2 = 0;
      m2 = repeat$2("0", f2 + 1);
    } else {
      var l2 = log102(x2);
      e2 = floor$5(l2);
      var w2 = pow$4(10, e2 - f2);
      var n2 = round$2(x2 / w2);
      if (2 * x2 >= (2 * n2 + 1) * w2) {
        n2 += 1;
      }
      if (n2 >= pow$4(10, f2 + 1)) {
        n2 /= 10;
        e2 += 1;
      }
      m2 = $String$3(n2);
    }
    if (f2 !== 0) {
      m2 = stringSlice$h(m2, 0, 1) + "." + stringSlice$h(m2, 1);
    }
    if (e2 === 0) {
      c2 = "+";
      d2 = "0";
    } else {
      c2 = e2 > 0 ? "+" : "-";
      d2 = $String$3(abs$3(e2));
    }
    m2 += "e" + c2 + d2;
    return s + m2;
  }
});
var $$41 = _export;
var uncurryThis$1c = functionUncurryThis;
var toIntegerOrInfinity$a = toIntegerOrInfinity$p;
var thisNumberValue$2 = thisNumberValue$5;
var $repeat = stringRepeat;
var fails$U = fails$1z;
var $RangeError$7 = RangeError;
var $String$2 = String;
var floor$4 = Math.floor;
var repeat$1 = uncurryThis$1c($repeat);
var stringSlice$g = uncurryThis$1c("".slice);
var nativeToFixed = uncurryThis$1c(1 .toFixed);
var pow$3 = function(x2, n2, acc) {
  return n2 === 0 ? acc : n2 % 2 === 1 ? pow$3(x2, n2 - 1, acc * x2) : pow$3(x2 * x2, n2 / 2, acc);
};
var log = function(x2) {
  var n2 = 0;
  var x22 = x2;
  while (x22 >= 4096) {
    n2 += 12;
    x22 /= 4096;
  }
  while (x22 >= 2) {
    n2 += 1;
    x22 /= 2;
  }
  return n2;
};
var multiply = function(data2, n2, c2) {
  var index = -1;
  var c22 = c2;
  while (++index < 6) {
    c22 += n2 * data2[index];
    data2[index] = c22 % 1e7;
    c22 = floor$4(c22 / 1e7);
  }
};
var divide = function(data2, n2) {
  var index = 6;
  var c2 = 0;
  while (--index >= 0) {
    c2 += data2[index];
    data2[index] = floor$4(c2 / n2);
    c2 = c2 % n2 * 1e7;
  }
};
var dataToString = function(data2) {
  var index = 6;
  var s = "";
  while (--index >= 0) {
    if (s !== "" || index === 0 || data2[index] !== 0) {
      var t2 = $String$2(data2[index]);
      s = s === "" ? t2 : s + repeat$1("0", 7 - t2.length) + t2;
    }
  }
  return s;
};
var FORCED$h = fails$U(function() {
  return nativeToFixed(8e-5, 3) !== "0.000" || nativeToFixed(0.9, 0) !== "1" || nativeToFixed(1.255, 2) !== "1.25" || nativeToFixed(1000000000000000100, 0) !== "1000000000000000128";
}) || !fails$U(function() {
  nativeToFixed({});
});
$$41({ target: "Number", proto: true, forced: FORCED$h }, {
  toFixed: function toFixed(fractionDigits) {
    var number = thisNumberValue$2(this);
    var fractDigits = toIntegerOrInfinity$a(fractionDigits);
    var data2 = [0, 0, 0, 0, 0, 0];
    var sign3 = "";
    var result = "0";
    var e2, z2, j, k2;
    if (fractDigits < 0 || fractDigits > 20) throw new $RangeError$7("Incorrect fraction digits");
    if (number !== number) return "NaN";
    if (number <= -1e21 || number >= 1e21) return $String$2(number);
    if (number < 0) {
      sign3 = "-";
      number = -number;
    }
    if (number > 1e-21) {
      e2 = log(number * pow$3(2, 69, 1)) - 69;
      z2 = e2 < 0 ? number * pow$3(2, -e2, 1) : number / pow$3(2, e2, 1);
      z2 *= 4503599627370496;
      e2 = 52 - e2;
      if (e2 > 0) {
        multiply(data2, 0, z2);
        j = fractDigits;
        while (j >= 7) {
          multiply(data2, 1e7, 0);
          j -= 7;
        }
        multiply(data2, pow$3(10, j, 1), 0);
        j = e2 - 1;
        while (j >= 23) {
          divide(data2, 1 << 23);
          j -= 23;
        }
        divide(data2, 1 << j);
        multiply(data2, 1, 1);
        divide(data2, 2);
        result = dataToString(data2);
      } else {
        multiply(data2, 0, z2);
        multiply(data2, 1 << -e2, 0);
        result = dataToString(data2) + repeat$1("0", fractDigits);
      }
    }
    if (fractDigits > 0) {
      k2 = result.length;
      result = sign3 + (k2 <= fractDigits ? "0." + repeat$1("0", fractDigits - k2) + result : stringSlice$g(result, 0, k2 - fractDigits) + "." + stringSlice$g(result, k2 - fractDigits));
    } else {
      result = sign3 + result;
    }
    return result;
  }
});
var $$40 = _export;
var uncurryThis$1b = functionUncurryThis;
var fails$T = fails$1z;
var thisNumberValue$1 = thisNumberValue$5;
var nativeToPrecision = uncurryThis$1b(1 .toPrecision);
var FORCED$g = fails$T(function() {
  return nativeToPrecision(1, void 0) !== "1";
}) || !fails$T(function() {
  nativeToPrecision({});
});
$$40({ target: "Number", proto: true, forced: FORCED$g }, {
  toPrecision: function toPrecision(precision) {
    return precision === void 0 ? nativeToPrecision(thisNumberValue$1(this)) : nativeToPrecision(thisNumberValue$1(this), precision);
  }
});
var DESCRIPTORS$z = descriptors$1;
var uncurryThis$1a = functionUncurryThis;
var call$Z = functionCall;
var fails$S = fails$1z;
var objectKeys$3 = objectKeys$6;
var getOwnPropertySymbolsModule = objectGetOwnPropertySymbols;
var propertyIsEnumerableModule = objectPropertyIsEnumerable;
var toObject$k = toObject$E;
var IndexedObject$2 = indexedObject;
var $assign = Object.assign;
var defineProperty$8 = Object.defineProperty;
var concat$2 = uncurryThis$1a([].concat);
var objectAssign = !$assign || fails$S(function() {
  if (DESCRIPTORS$z && $assign({ b: 1 }, $assign(defineProperty$8({}, "a", {
    enumerable: true,
    get: function() {
      defineProperty$8(this, "b", {
        value: 3,
        enumerable: false
      });
    }
  }), { b: 2 })).b !== 1) return true;
  var A2 = {};
  var B2 = {};
  var symbol = Symbol("assign detection");
  var alphabet = "abcdefghijklmnopqrst";
  A2[symbol] = 7;
  alphabet.split("").forEach(function(chr) {
    B2[chr] = chr;
  });
  return $assign({}, A2)[symbol] !== 7 || objectKeys$3($assign({}, B2)).join("") !== alphabet;
}) ? function assign(target, source) {
  var T2 = toObject$k(target);
  var argumentsLength = arguments.length;
  var index = 1;
  var getOwnPropertySymbols2 = getOwnPropertySymbolsModule.f;
  var propertyIsEnumerable4 = propertyIsEnumerableModule.f;
  while (argumentsLength > index) {
    var S2 = IndexedObject$2(arguments[index++]);
    var keys6 = getOwnPropertySymbols2 ? concat$2(objectKeys$3(S2), getOwnPropertySymbols2(S2)) : objectKeys$3(S2);
    var length2 = keys6.length;
    var j = 0;
    var key;
    while (length2 > j) {
      key = keys6[j++];
      if (!DESCRIPTORS$z || call$Z(propertyIsEnumerable4, S2, key)) T2[key] = S2[key];
    }
  }
  return T2;
} : $assign;
var $$3$ = _export;
var assign$3 = objectAssign;
$$3$({ target: "Object", stat: true, arity: 2, forced: Object.assign !== assign$3 }, {
  assign: assign$3
});
var $$3_ = _export;
var DESCRIPTORS$y = descriptors$1;
var create$d = objectCreate$1;
$$3_({ target: "Object", stat: true, sham: !DESCRIPTORS$y }, {
  create: create$d
});
var globalThis$O = globalThis_1;
var fails$R = fails$1z;
var WEBKIT$3 = environmentWebkitVersion;
var objectPrototypeAccessorsForced = !fails$R(function() {
  if (WEBKIT$3 && WEBKIT$3 < 535) return;
  var key = Math.random();
  __defineSetter__.call(null, key, function() {
  });
  delete globalThis$O[key];
});
var $$3Z = _export;
var DESCRIPTORS$x = descriptors$1;
var FORCED$f = objectPrototypeAccessorsForced;
var aCallable$x = aCallable$Q;
var toObject$j = toObject$E;
var definePropertyModule$4 = objectDefineProperty;
if (DESCRIPTORS$x) {
  $$3Z({ target: "Object", proto: true, forced: FORCED$f }, {
    __defineGetter__: function __defineGetter__(P2, getter) {
      definePropertyModule$4.f(toObject$j(this), P2, { get: aCallable$x(getter), enumerable: true, configurable: true });
    }
  });
}
var $$3Y = _export;
var DESCRIPTORS$w = descriptors$1;
var defineProperties3 = objectDefineProperties.f;
$$3Y({ target: "Object", stat: true, forced: Object.defineProperties !== defineProperties3, sham: !DESCRIPTORS$w }, {
  defineProperties: defineProperties3
});
var $$3X = _export;
var DESCRIPTORS$v = descriptors$1;
var defineProperty$7 = objectDefineProperty.f;
$$3X({ target: "Object", stat: true, forced: Object.defineProperty !== defineProperty$7, sham: !DESCRIPTORS$v }, {
  defineProperty: defineProperty$7
});
var $$3W = _export;
var DESCRIPTORS$u = descriptors$1;
var FORCED$e = objectPrototypeAccessorsForced;
var aCallable$w = aCallable$Q;
var toObject$i = toObject$E;
var definePropertyModule$3 = objectDefineProperty;
if (DESCRIPTORS$u) {
  $$3W({ target: "Object", proto: true, forced: FORCED$e }, {
    __defineSetter__: function __defineSetter__2(P2, setter) {
      definePropertyModule$3.f(toObject$i(this), P2, { set: aCallable$w(setter), enumerable: true, configurable: true });
    }
  });
}
var DESCRIPTORS$t = descriptors$1;
var fails$Q = fails$1z;
var uncurryThis$19 = functionUncurryThis;
var objectGetPrototypeOf$1 = objectGetPrototypeOf$2;
var objectKeys$2 = objectKeys$6;
var toIndexedObject$5 = toIndexedObject$k;
var $propertyIsEnumerable = objectPropertyIsEnumerable.f;
var propertyIsEnumerable3 = uncurryThis$19($propertyIsEnumerable);
var push$k = uncurryThis$19([].push);
var IE_BUG = DESCRIPTORS$t && fails$Q(function() {
  var O2 = /* @__PURE__ */ Object.create(null);
  O2[2] = 2;
  return !propertyIsEnumerable3(O2, 2);
});
var createMethod$2 = function(TO_ENTRIES) {
  return function(it) {
    var O2 = toIndexedObject$5(it);
    var keys6 = objectKeys$2(O2);
    var IE_WORKAROUND = IE_BUG && objectGetPrototypeOf$1(O2) === null;
    var length2 = keys6.length;
    var i = 0;
    var result = [];
    var key;
    while (length2 > i) {
      key = keys6[i++];
      if (!DESCRIPTORS$t || (IE_WORKAROUND ? key in O2 : propertyIsEnumerable3(O2, key))) {
        push$k(result, TO_ENTRIES ? [key, O2[key]] : O2[key]);
      }
    }
    return result;
  };
};
var objectToArray = {
  // `Object.entries` method
  // https://tc39.es/ecma262/#sec-object.entries
  entries: createMethod$2(true),
  // `Object.values` method
  // https://tc39.es/ecma262/#sec-object.values
  values: createMethod$2(false)
};
var $$3V = _export;
var $entries = objectToArray.entries;
$$3V({ target: "Object", stat: true }, {
  entries: function entries(O2) {
    return $entries(O2);
  }
});
var $$3U = _export;
var FREEZING$6 = freezing;
var fails$P = fails$1z;
var isObject$t = isObject$O;
var onFreeze$2 = internalMetadataExports.onFreeze;
var $freeze = Object.freeze;
var FAILS_ON_PRIMITIVES$5 = fails$P(function() {
  $freeze(1);
});
$$3U({ target: "Object", stat: true, forced: FAILS_ON_PRIMITIVES$5, sham: !FREEZING$6 }, {
  freeze: function freeze(it) {
    return $freeze && isObject$t(it) ? $freeze(onFreeze$2(it)) : it;
  }
});
var $$3T = _export;
var iterate$w = iterate$H;
var createProperty$4 = createProperty$b;
$$3T({ target: "Object", stat: true }, {
  fromEntries: function fromEntries(iterable) {
    var obj = {};
    iterate$w(iterable, function(k2, v2) {
      createProperty$4(obj, k2, v2);
    }, { AS_ENTRIES: true });
    return obj;
  }
});
var $$3S = _export;
var fails$O = fails$1z;
var toIndexedObject$4 = toIndexedObject$k;
var nativeGetOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;
var DESCRIPTORS$s = descriptors$1;
var FORCED$d = !DESCRIPTORS$s || fails$O(function() {
  nativeGetOwnPropertyDescriptor$1(1);
});
$$3S({ target: "Object", stat: true, forced: FORCED$d, sham: !DESCRIPTORS$s }, {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor3(it, key) {
    return nativeGetOwnPropertyDescriptor$1(toIndexedObject$4(it), key);
  }
});
var $$3R = _export;
var DESCRIPTORS$r = descriptors$1;
var ownKeys$1 = ownKeys$3;
var toIndexedObject$3 = toIndexedObject$k;
var getOwnPropertyDescriptorModule$4 = objectGetOwnPropertyDescriptor;
var createProperty$3 = createProperty$b;
$$3R({ target: "Object", stat: true, sham: !DESCRIPTORS$r }, {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
    var O2 = toIndexedObject$3(object);
    var getOwnPropertyDescriptor7 = getOwnPropertyDescriptorModule$4.f;
    var keys6 = ownKeys$1(O2);
    var result = {};
    var index = 0;
    var key, descriptor;
    while (keys6.length > index) {
      descriptor = getOwnPropertyDescriptor7(O2, key = keys6[index++]);
      if (descriptor !== void 0) createProperty$3(result, key, descriptor);
    }
    return result;
  }
});
var $$3Q = _export;
var fails$N = fails$1z;
var getOwnPropertyNames$3 = objectGetOwnPropertyNamesExternal.f;
var FAILS_ON_PRIMITIVES$4 = fails$N(function() {
  return !Object.getOwnPropertyNames(1);
});
$$3Q({ target: "Object", stat: true, forced: FAILS_ON_PRIMITIVES$4 }, {
  getOwnPropertyNames: getOwnPropertyNames$3
});
var $$3P = _export;
var fails$M = fails$1z;
var toObject$h = toObject$E;
var nativeGetPrototypeOf = objectGetPrototypeOf$2;
var CORRECT_PROTOTYPE_GETTER$1 = correctPrototypeGetter;
var FAILS_ON_PRIMITIVES$3 = fails$M(function() {
  nativeGetPrototypeOf(1);
});
$$3P({ target: "Object", stat: true, forced: FAILS_ON_PRIMITIVES$3, sham: !CORRECT_PROTOTYPE_GETTER$1 }, {
  getPrototypeOf: function getPrototypeOf(it) {
    return nativeGetPrototypeOf(toObject$h(it));
  }
});
var $$3O = _export;
var getBuiltIn$C = getBuiltIn$O;
var uncurryThis$18 = functionUncurryThis;
var aCallable$v = aCallable$Q;
var requireObjectCoercible$i = requireObjectCoercible$q;
var toPropertyKey$5 = toPropertyKey$9;
var iterate$v = iterate$H;
var fails$L = fails$1z;
var nativeGroupBy = Object.groupBy;
var create$c = getBuiltIn$C("Object", "create");
var push$j = uncurryThis$18([].push);
var DOES_NOT_WORK_WITH_PRIMITIVES = !nativeGroupBy || fails$L(function() {
  return nativeGroupBy("ab", function(it) {
    return it;
  }).a.length !== 1;
});
$$3O({ target: "Object", stat: true, forced: DOES_NOT_WORK_WITH_PRIMITIVES }, {
  groupBy: function groupBy2(items, callbackfn) {
    requireObjectCoercible$i(items);
    aCallable$v(callbackfn);
    var obj = create$c(null);
    var k2 = 0;
    iterate$v(items, function(value) {
      var key = toPropertyKey$5(callbackfn(value, k2++));
      if (key in obj) push$j(obj[key], value);
      else obj[key] = [value];
    });
    return obj;
  }
});
var $$3N = _export;
var hasOwn$m = hasOwnProperty_1;
$$3N({ target: "Object", stat: true }, {
  hasOwn: hasOwn$m
});
var sameValue$1 = Object.is || function is(x2, y2) {
  return x2 === y2 ? x2 !== 0 || 1 / x2 === 1 / y2 : x2 !== x2 && y2 !== y2;
};
var $$3M = _export;
var is2 = sameValue$1;
$$3M({ target: "Object", stat: true }, {
  is: is2
});
var $$3L = _export;
var $isExtensible$1 = objectIsExtensible;
$$3L({ target: "Object", stat: true, forced: Object.isExtensible !== $isExtensible$1 }, {
  isExtensible: $isExtensible$1
});
var $$3K = _export;
var fails$K = fails$1z;
var isObject$s = isObject$O;
var classof$e = classofRaw$2;
var ARRAY_BUFFER_NON_EXTENSIBLE$1 = arrayBufferNonExtensible;
var $isFrozen = Object.isFrozen;
var FORCED$c = ARRAY_BUFFER_NON_EXTENSIBLE$1 || fails$K(function() {
  $isFrozen(1);
});
$$3K({ target: "Object", stat: true, forced: FORCED$c }, {
  isFrozen: function isFrozen(it) {
    if (!isObject$s(it)) return true;
    if (ARRAY_BUFFER_NON_EXTENSIBLE$1 && classof$e(it) === "ArrayBuffer") return true;
    return $isFrozen ? $isFrozen(it) : false;
  }
});
var $$3J = _export;
var fails$J = fails$1z;
var isObject$r = isObject$O;
var classof$d = classofRaw$2;
var ARRAY_BUFFER_NON_EXTENSIBLE = arrayBufferNonExtensible;
var $isSealed = Object.isSealed;
var FORCED$b = ARRAY_BUFFER_NON_EXTENSIBLE || fails$J(function() {
  $isSealed(1);
});
$$3J({ target: "Object", stat: true, forced: FORCED$b }, {
  isSealed: function isSealed(it) {
    if (!isObject$r(it)) return true;
    if (ARRAY_BUFFER_NON_EXTENSIBLE && classof$d(it) === "ArrayBuffer") return true;
    return $isSealed ? $isSealed(it) : false;
  }
});
var $$3I = _export;
var toObject$g = toObject$E;
var nativeKeys = objectKeys$6;
var fails$I = fails$1z;
var FAILS_ON_PRIMITIVES$2 = fails$I(function() {
  nativeKeys(1);
});
$$3I({ target: "Object", stat: true, forced: FAILS_ON_PRIMITIVES$2 }, {
  keys: function keys2(it) {
    return nativeKeys(toObject$g(it));
  }
});
var $$3H = _export;
var DESCRIPTORS$q = descriptors$1;
var FORCED$a = objectPrototypeAccessorsForced;
var toObject$f = toObject$E;
var toPropertyKey$4 = toPropertyKey$9;
var getPrototypeOf$b = objectGetPrototypeOf$2;
var getOwnPropertyDescriptor$9 = objectGetOwnPropertyDescriptor.f;
if (DESCRIPTORS$q) {
  $$3H({ target: "Object", proto: true, forced: FORCED$a }, {
    __lookupGetter__: function __lookupGetter__(P2) {
      var O2 = toObject$f(this);
      var key = toPropertyKey$4(P2);
      var desc;
      do {
        if (desc = getOwnPropertyDescriptor$9(O2, key)) return desc.get;
      } while (O2 = getPrototypeOf$b(O2));
    }
  });
}
var $$3G = _export;
var DESCRIPTORS$p = descriptors$1;
var FORCED$9 = objectPrototypeAccessorsForced;
var toObject$e = toObject$E;
var toPropertyKey$3 = toPropertyKey$9;
var getPrototypeOf$a = objectGetPrototypeOf$2;
var getOwnPropertyDescriptor$8 = objectGetOwnPropertyDescriptor.f;
if (DESCRIPTORS$p) {
  $$3G({ target: "Object", proto: true, forced: FORCED$9 }, {
    __lookupSetter__: function __lookupSetter__(P2) {
      var O2 = toObject$e(this);
      var key = toPropertyKey$3(P2);
      var desc;
      do {
        if (desc = getOwnPropertyDescriptor$8(O2, key)) return desc.set;
      } while (O2 = getPrototypeOf$a(O2));
    }
  });
}
var $$3F = _export;
var isObject$q = isObject$O;
var onFreeze$1 = internalMetadataExports.onFreeze;
var FREEZING$5 = freezing;
var fails$H = fails$1z;
var $preventExtensions = Object.preventExtensions;
var FAILS_ON_PRIMITIVES$1 = fails$H(function() {
  $preventExtensions(1);
});
$$3F({ target: "Object", stat: true, forced: FAILS_ON_PRIMITIVES$1, sham: !FREEZING$5 }, {
  preventExtensions: function preventExtensions(it) {
    return $preventExtensions && isObject$q(it) ? $preventExtensions(onFreeze$1(it)) : it;
  }
});
var DESCRIPTORS$o = descriptors$1;
var defineBuiltInAccessor$f = defineBuiltInAccessor$p;
var isObject$p = isObject$O;
var isPossiblePrototype = isPossiblePrototype$2;
var toObject$d = toObject$E;
var requireObjectCoercible$h = requireObjectCoercible$q;
var getPrototypeOf$9 = Object.getPrototypeOf;
var setPrototypeOf$4 = Object.setPrototypeOf;
var ObjectPrototype$1 = Object.prototype;
var PROTO = "__proto__";
if (DESCRIPTORS$o && getPrototypeOf$9 && setPrototypeOf$4 && !(PROTO in ObjectPrototype$1)) try {
  defineBuiltInAccessor$f(ObjectPrototype$1, PROTO, {
    configurable: true,
    get: function __proto__() {
      return getPrototypeOf$9(toObject$d(this));
    },
    set: function __proto__(proto) {
      var O2 = requireObjectCoercible$h(this);
      if (isPossiblePrototype(proto) && isObject$p(O2)) {
        setPrototypeOf$4(O2, proto);
      }
    }
  });
} catch (error2) {
}
var $$3E = _export;
var isObject$o = isObject$O;
var onFreeze = internalMetadataExports.onFreeze;
var FREEZING$4 = freezing;
var fails$G = fails$1z;
var $seal = Object.seal;
var FAILS_ON_PRIMITIVES = fails$G(function() {
  $seal(1);
});
$$3E({ target: "Object", stat: true, forced: FAILS_ON_PRIMITIVES, sham: !FREEZING$4 }, {
  seal: function seal(it) {
    return $seal && isObject$o(it) ? $seal(onFreeze(it)) : it;
  }
});
var $$3D = _export;
var setPrototypeOf$3 = objectSetPrototypeOf$1;
$$3D({ target: "Object", stat: true }, {
  setPrototypeOf: setPrototypeOf$3
});
var TO_STRING_TAG_SUPPORT$1 = toStringTagSupport;
var classof$c = classof$p;
var objectToString = TO_STRING_TAG_SUPPORT$1 ? {}.toString : function toString3() {
  return "[object " + classof$c(this) + "]";
};
var TO_STRING_TAG_SUPPORT = toStringTagSupport;
var defineBuiltIn$i = defineBuiltIn$u;
var toString$y = objectToString;
if (!TO_STRING_TAG_SUPPORT) {
  defineBuiltIn$i(Object.prototype, "toString", toString$y, { unsafe: true });
}
var $$3C = _export;
var $values = objectToArray.values;
$$3C({ target: "Object", stat: true }, {
  values: function values(O2) {
    return $values(O2);
  }
});
var $$3B = _export;
var $parseFloat = numberParseFloat;
$$3B({ global: true, forced: parseFloat !== $parseFloat }, {
  parseFloat: $parseFloat
});
var $$3A = _export;
var $parseInt$3 = numberParseInt;
$$3A({ global: true, forced: parseInt !== $parseInt$3 }, {
  parseInt: $parseInt$3
});
var isConstructor$5 = isConstructor$a;
var tryToString = tryToString$7;
var $TypeError$u = TypeError;
var aConstructor$4 = function(argument) {
  if (isConstructor$5(argument)) return argument;
  throw new $TypeError$u(tryToString(argument) + " is not a constructor");
};
var anObject$U = anObject$1i;
var aConstructor$3 = aConstructor$4;
var isNullOrUndefined$d = isNullOrUndefined$j;
var wellKnownSymbol$t = wellKnownSymbol$S;
var SPECIES$2 = wellKnownSymbol$t("species");
var speciesConstructor$4 = function(O2, defaultConstructor) {
  var C2 = anObject$U(O2).constructor;
  var S2;
  return C2 === void 0 || isNullOrUndefined$d(S2 = anObject$U(C2)[SPECIES$2]) ? defaultConstructor : aConstructor$3(S2);
};
var $TypeError$t = TypeError;
var validateArgumentsLength$c = function(passed, required) {
  if (passed < required) throw new $TypeError$t("Not enough arguments");
  return passed;
};
var userAgent$3 = environmentUserAgent;
var environmentIsIos = /(?:ipad|iphone|ipod).*applewebkit/i.test(userAgent$3);
var globalThis$N = globalThis_1;
var apply$9 = functionApply$1;
var bind$o = functionBindContext;
var isCallable$k = isCallable$I;
var hasOwn$l = hasOwnProperty_1;
var fails$F = fails$1z;
var html = html$2;
var arraySlice$4 = arraySlice$a;
var createElement = documentCreateElement$2;
var validateArgumentsLength$b = validateArgumentsLength$c;
var IS_IOS$1 = environmentIsIos;
var IS_NODE$2 = environmentIsNode;
var set$c = globalThis$N.setImmediate;
var clear = globalThis$N.clearImmediate;
var process$3 = globalThis$N.process;
var Dispatch = globalThis$N.Dispatch;
var Function$2 = globalThis$N.Function;
var MessageChannel$1 = globalThis$N.MessageChannel;
var String$1 = globalThis$N.String;
var counter = 0;
var queue$2 = {};
var ONREADYSTATECHANGE = "onreadystatechange";
var $location, defer, channel, port;
fails$F(function() {
  $location = globalThis$N.location;
});
var run = function(id2) {
  if (hasOwn$l(queue$2, id2)) {
    var fn = queue$2[id2];
    delete queue$2[id2];
    fn();
  }
};
var runner = function(id2) {
  return function() {
    run(id2);
  };
};
var eventListener = function(event) {
  run(event.data);
};
var globalPostMessageDefer = function(id2) {
  globalThis$N.postMessage(String$1(id2), $location.protocol + "//" + $location.host);
};
if (!set$c || !clear) {
  set$c = function setImmediate2(handler) {
    validateArgumentsLength$b(arguments.length, 1);
    var fn = isCallable$k(handler) ? handler : Function$2(handler);
    var args = arraySlice$4(arguments, 1);
    queue$2[++counter] = function() {
      apply$9(fn, void 0, args);
    };
    defer(counter);
    return counter;
  };
  clear = function clearImmediate2(id2) {
    delete queue$2[id2];
  };
  if (IS_NODE$2) {
    defer = function(id2) {
      process$3.nextTick(runner(id2));
    };
  } else if (Dispatch && Dispatch.now) {
    defer = function(id2) {
      Dispatch.now(runner(id2));
    };
  } else if (MessageChannel$1 && !IS_IOS$1) {
    channel = new MessageChannel$1();
    port = channel.port2;
    channel.port1.onmessage = eventListener;
    defer = bind$o(port.postMessage, port);
  } else if (globalThis$N.addEventListener && isCallable$k(globalThis$N.postMessage) && !globalThis$N.importScripts && $location && $location.protocol !== "file:" && !fails$F(globalPostMessageDefer)) {
    defer = globalPostMessageDefer;
    globalThis$N.addEventListener("message", eventListener, false);
  } else if (ONREADYSTATECHANGE in createElement("script")) {
    defer = function(id2) {
      html.appendChild(createElement("script"))[ONREADYSTATECHANGE] = function() {
        html.removeChild(this);
        run(id2);
      };
    };
  } else {
    defer = function(id2) {
      setTimeout(runner(id2), 0);
    };
  }
}
var task$1 = {
  set: set$c,
  clear
};
var globalThis$M = globalThis_1;
var DESCRIPTORS$n = descriptors$1;
var getOwnPropertyDescriptor$7 = Object.getOwnPropertyDescriptor;
var safeGetBuiltIn$2 = function(name) {
  if (!DESCRIPTORS$n) return globalThis$M[name];
  var descriptor = getOwnPropertyDescriptor$7(globalThis$M, name);
  return descriptor && descriptor.value;
};
var Queue$2 = function() {
  this.head = null;
  this.tail = null;
};
Queue$2.prototype = {
  add: function(item) {
    var entry = { item, next: null };
    var tail = this.tail;
    if (tail) tail.next = entry;
    else this.head = entry;
    this.tail = entry;
  },
  get: function() {
    var entry = this.head;
    if (entry) {
      var next11 = this.head = entry.next;
      if (next11 === null) this.tail = null;
      return entry.item;
    }
  }
};
var queue$1 = Queue$2;
var userAgent$2 = environmentUserAgent;
var environmentIsIosPebble = /ipad|iphone|ipod/i.test(userAgent$2) && typeof Pebble != "undefined";
var userAgent$1 = environmentUserAgent;
var environmentIsWebosWebkit = /web0s(?!.*chrome)/i.test(userAgent$1);
var globalThis$L = globalThis_1;
var safeGetBuiltIn$1 = safeGetBuiltIn$2;
var bind$n = functionBindContext;
var macrotask = task$1.set;
var Queue$1 = queue$1;
var IS_IOS = environmentIsIos;
var IS_IOS_PEBBLE = environmentIsIosPebble;
var IS_WEBOS_WEBKIT = environmentIsWebosWebkit;
var IS_NODE$1 = environmentIsNode;
var MutationObserver$1 = globalThis$L.MutationObserver || globalThis$L.WebKitMutationObserver;
var document$2 = globalThis$L.document;
var process$2 = globalThis$L.process;
var Promise$7 = globalThis$L.Promise;
var microtask$2 = safeGetBuiltIn$1("queueMicrotask");
var notify$1, toggle, node$2, promise, then;
if (!microtask$2) {
  var queue = new Queue$1();
  var flush = function() {
    var parent, fn;
    if (IS_NODE$1 && (parent = process$2.domain)) parent.exit();
    while (fn = queue.get()) try {
      fn();
    } catch (error2) {
      if (queue.head) notify$1();
      throw error2;
    }
    if (parent) parent.enter();
  };
  if (!IS_IOS && !IS_NODE$1 && !IS_WEBOS_WEBKIT && MutationObserver$1 && document$2) {
    toggle = true;
    node$2 = document$2.createTextNode("");
    new MutationObserver$1(flush).observe(node$2, { characterData: true });
    notify$1 = function() {
      node$2.data = toggle = !toggle;
    };
  } else if (!IS_IOS_PEBBLE && Promise$7 && Promise$7.resolve) {
    promise = Promise$7.resolve(void 0);
    promise.constructor = Promise$7;
    then = bind$n(promise.then, promise);
    notify$1 = function() {
      then(flush);
    };
  } else if (IS_NODE$1) {
    notify$1 = function() {
      process$2.nextTick(flush);
    };
  } else {
    macrotask = bind$n(macrotask, globalThis$L);
    notify$1 = function() {
      macrotask(flush);
    };
  }
  microtask$2 = function(fn) {
    if (!queue.head) notify$1();
    queue.add(fn);
  };
}
var microtask_1 = microtask$2;
var hostReportErrors$2 = function(a, b2) {
  try {
    arguments.length === 1 ? console.error(a) : console.error(a, b2);
  } catch (error2) {
  }
};
var perform$7 = function(exec2) {
  try {
    return { error: false, value: exec2() };
  } catch (error2) {
    return { error: true, value: error2 };
  }
};
var globalThis$K = globalThis_1;
var promiseNativeConstructor = globalThis$K.Promise;
var globalThis$J = globalThis_1;
var NativePromiseConstructor$4 = promiseNativeConstructor;
var isCallable$j = isCallable$I;
var isForced$1 = isForced_1;
var inspectSource$1 = inspectSource$4;
var wellKnownSymbol$s = wellKnownSymbol$S;
var ENVIRONMENT$1 = environment;
var V8_VERSION = environmentV8Version;
NativePromiseConstructor$4 && NativePromiseConstructor$4.prototype;
var SPECIES$1 = wellKnownSymbol$s("species");
var SUBCLASSING = false;
var NATIVE_PROMISE_REJECTION_EVENT$1 = isCallable$j(globalThis$J.PromiseRejectionEvent);
var FORCED_PROMISE_CONSTRUCTOR$5 = isForced$1("Promise", function() {
  var PROMISE_CONSTRUCTOR_SOURCE = inspectSource$1(NativePromiseConstructor$4);
  var GLOBAL_CORE_JS_PROMISE = PROMISE_CONSTRUCTOR_SOURCE !== String(NativePromiseConstructor$4);
  if (!GLOBAL_CORE_JS_PROMISE && V8_VERSION === 66) return true;
  if (!V8_VERSION || V8_VERSION < 51 || !/native code/.test(PROMISE_CONSTRUCTOR_SOURCE)) {
    var promise2 = new NativePromiseConstructor$4(function(resolve2) {
      resolve2(1);
    });
    var FakePromise = function(exec2) {
      exec2(function() {
      }, function() {
      });
    };
    var constructor = promise2.constructor = {};
    constructor[SPECIES$1] = FakePromise;
    SUBCLASSING = promise2.then(function() {
    }) instanceof FakePromise;
    if (!SUBCLASSING) return true;
  }
  return !GLOBAL_CORE_JS_PROMISE && (ENVIRONMENT$1 === "BROWSER" || ENVIRONMENT$1 === "DENO") && !NATIVE_PROMISE_REJECTION_EVENT$1;
});
var promiseConstructorDetection = {
  CONSTRUCTOR: FORCED_PROMISE_CONSTRUCTOR$5,
  REJECTION_EVENT: NATIVE_PROMISE_REJECTION_EVENT$1,
  SUBCLASSING
};
var newPromiseCapability$2 = {};
var aCallable$u = aCallable$Q;
var $TypeError$s = TypeError;
var PromiseCapability = function(C2) {
  var resolve2, reject2;
  this.promise = new C2(function($$resolve, $$reject) {
    if (resolve2 !== void 0 || reject2 !== void 0) throw new $TypeError$s("Bad Promise constructor");
    resolve2 = $$resolve;
    reject2 = $$reject;
  });
  this.resolve = aCallable$u(resolve2);
  this.reject = aCallable$u(reject2);
};
newPromiseCapability$2.f = function(C2) {
  return new PromiseCapability(C2);
};
var $$3z = _export;
var IS_NODE = environmentIsNode;
var globalThis$I = globalThis_1;
var call$Y = functionCall;
var defineBuiltIn$h = defineBuiltIn$u;
var setPrototypeOf$2 = objectSetPrototypeOf$1;
var setToStringTag$5 = setToStringTag$e;
var setSpecies$3 = setSpecies$7;
var aCallable$t = aCallable$Q;
var isCallable$i = isCallable$I;
var isObject$n = isObject$O;
var anInstance$a = anInstance$f;
var speciesConstructor$3 = speciesConstructor$4;
var task = task$1.set;
var microtask$1 = microtask_1;
var hostReportErrors$1 = hostReportErrors$2;
var perform$6 = perform$7;
var Queue = queue$1;
var InternalStateModule$g = internalState;
var NativePromiseConstructor$3 = promiseNativeConstructor;
var PromiseConstructorDetection = promiseConstructorDetection;
var newPromiseCapabilityModule$7 = newPromiseCapability$2;
var PROMISE = "Promise";
var FORCED_PROMISE_CONSTRUCTOR$4 = PromiseConstructorDetection.CONSTRUCTOR;
var NATIVE_PROMISE_REJECTION_EVENT = PromiseConstructorDetection.REJECTION_EVENT;
var NATIVE_PROMISE_SUBCLASSING = PromiseConstructorDetection.SUBCLASSING;
var getInternalPromiseState = InternalStateModule$g.getterFor(PROMISE);
var setInternalState$h = InternalStateModule$g.set;
var NativePromisePrototype$2 = NativePromiseConstructor$3 && NativePromiseConstructor$3.prototype;
var PromiseConstructor = NativePromiseConstructor$3;
var PromisePrototype = NativePromisePrototype$2;
var TypeError$5 = globalThis$I.TypeError;
var document$1 = globalThis$I.document;
var process$1 = globalThis$I.process;
var newPromiseCapability$1 = newPromiseCapabilityModule$7.f;
var newGenericPromiseCapability = newPromiseCapability$1;
var DISPATCH_EVENT = !!(document$1 && document$1.createEvent && globalThis$I.dispatchEvent);
var UNHANDLED_REJECTION = "unhandledrejection";
var REJECTION_HANDLED = "rejectionhandled";
var PENDING$2 = 0;
var FULFILLED = 1;
var REJECTED = 2;
var HANDLED = 1;
var UNHANDLED = 2;
var Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;
var isThenable$1 = function(it) {
  var then2;
  return isObject$n(it) && isCallable$i(then2 = it.then) ? then2 : false;
};
var callReaction = function(reaction, state) {
  var value = state.value;
  var ok2 = state.state === FULFILLED;
  var handler = ok2 ? reaction.ok : reaction.fail;
  var resolve2 = reaction.resolve;
  var reject2 = reaction.reject;
  var domain = reaction.domain;
  var result, then2, exited;
  try {
    if (handler) {
      if (!ok2) {
        if (state.rejection === UNHANDLED) onHandleUnhandled(state);
        state.rejection = HANDLED;
      }
      if (handler === true) result = value;
      else {
        if (domain) domain.enter();
        result = handler(value);
        if (domain) {
          domain.exit();
          exited = true;
        }
      }
      if (result === reaction.promise) {
        reject2(new TypeError$5("Promise-chain cycle"));
      } else if (then2 = isThenable$1(result)) {
        call$Y(then2, result, resolve2, reject2);
      } else resolve2(result);
    } else reject2(value);
  } catch (error2) {
    if (domain && !exited) domain.exit();
    reject2(error2);
  }
};
var notify = function(state, isReject) {
  if (state.notified) return;
  state.notified = true;
  microtask$1(function() {
    var reactions = state.reactions;
    var reaction;
    while (reaction = reactions.get()) {
      callReaction(reaction, state);
    }
    state.notified = false;
    if (isReject && !state.rejection) onUnhandled(state);
  });
};
var dispatchEvent = function(name, promise2, reason) {
  var event, handler;
  if (DISPATCH_EVENT) {
    event = document$1.createEvent("Event");
    event.promise = promise2;
    event.reason = reason;
    event.initEvent(name, false, true);
    globalThis$I.dispatchEvent(event);
  } else event = { promise: promise2, reason };
  if (!NATIVE_PROMISE_REJECTION_EVENT && (handler = globalThis$I["on" + name])) handler(event);
  else if (name === UNHANDLED_REJECTION) hostReportErrors$1("Unhandled promise rejection", reason);
};
var onUnhandled = function(state) {
  call$Y(task, globalThis$I, function() {
    var promise2 = state.facade;
    var value = state.value;
    var IS_UNHANDLED = isUnhandled(state);
    var result;
    if (IS_UNHANDLED) {
      result = perform$6(function() {
        if (IS_NODE) {
          process$1.emit("unhandledRejection", value, promise2);
        } else dispatchEvent(UNHANDLED_REJECTION, promise2, value);
      });
      state.rejection = IS_NODE || isUnhandled(state) ? UNHANDLED : HANDLED;
      if (result.error) throw result.value;
    }
  });
};
var isUnhandled = function(state) {
  return state.rejection !== HANDLED && !state.parent;
};
var onHandleUnhandled = function(state) {
  call$Y(task, globalThis$I, function() {
    var promise2 = state.facade;
    if (IS_NODE) {
      process$1.emit("rejectionHandled", promise2);
    } else dispatchEvent(REJECTION_HANDLED, promise2, state.value);
  });
};
var bind$m = function(fn, state, unwrap) {
  return function(value) {
    fn(state, value, unwrap);
  };
};
var internalReject = function(state, value, unwrap) {
  if (state.done) return;
  state.done = true;
  if (unwrap) state = unwrap;
  state.value = value;
  state.state = REJECTED;
  notify(state, true);
};
var internalResolve = function(state, value, unwrap) {
  if (state.done) return;
  state.done = true;
  if (unwrap) state = unwrap;
  try {
    if (state.facade === value) throw new TypeError$5("Promise can't be resolved itself");
    var then2 = isThenable$1(value);
    if (then2) {
      microtask$1(function() {
        var wrapper2 = { done: false };
        try {
          call$Y(
            then2,
            value,
            bind$m(internalResolve, wrapper2, state),
            bind$m(internalReject, wrapper2, state)
          );
        } catch (error2) {
          internalReject(wrapper2, error2, state);
        }
      });
    } else {
      state.value = value;
      state.state = FULFILLED;
      notify(state, false);
    }
  } catch (error2) {
    internalReject({ done: false }, error2, state);
  }
};
if (FORCED_PROMISE_CONSTRUCTOR$4) {
  PromiseConstructor = function Promise2(executor) {
    anInstance$a(this, PromisePrototype);
    aCallable$t(executor);
    call$Y(Internal, this);
    var state = getInternalPromiseState(this);
    try {
      executor(bind$m(internalResolve, state), bind$m(internalReject, state));
    } catch (error2) {
      internalReject(state, error2);
    }
  };
  PromisePrototype = PromiseConstructor.prototype;
  Internal = function Promise2(executor) {
    setInternalState$h(this, {
      type: PROMISE,
      done: false,
      notified: false,
      parent: false,
      reactions: new Queue(),
      rejection: false,
      state: PENDING$2,
      value: null
    });
  };
  Internal.prototype = defineBuiltIn$h(PromisePrototype, "then", function then2(onFulfilled, onRejected) {
    var state = getInternalPromiseState(this);
    var reaction = newPromiseCapability$1(speciesConstructor$3(this, PromiseConstructor));
    state.parent = true;
    reaction.ok = isCallable$i(onFulfilled) ? onFulfilled : true;
    reaction.fail = isCallable$i(onRejected) && onRejected;
    reaction.domain = IS_NODE ? process$1.domain : void 0;
    if (state.state === PENDING$2) state.reactions.add(reaction);
    else microtask$1(function() {
      callReaction(reaction, state);
    });
    return reaction.promise;
  });
  OwnPromiseCapability = function() {
    var promise2 = new Internal();
    var state = getInternalPromiseState(promise2);
    this.promise = promise2;
    this.resolve = bind$m(internalResolve, state);
    this.reject = bind$m(internalReject, state);
  };
  newPromiseCapabilityModule$7.f = newPromiseCapability$1 = function(C2) {
    return C2 === PromiseConstructor || C2 === PromiseWrapper ? new OwnPromiseCapability(C2) : newGenericPromiseCapability(C2);
  };
  if (isCallable$i(NativePromiseConstructor$3) && NativePromisePrototype$2 !== Object.prototype) {
    nativeThen = NativePromisePrototype$2.then;
    if (!NATIVE_PROMISE_SUBCLASSING) {
      defineBuiltIn$h(NativePromisePrototype$2, "then", function then2(onFulfilled, onRejected) {
        var that = this;
        return new PromiseConstructor(function(resolve2, reject2) {
          call$Y(nativeThen, that, resolve2, reject2);
        }).then(onFulfilled, onRejected);
      }, { unsafe: true });
    }
    try {
      delete NativePromisePrototype$2.constructor;
    } catch (error2) {
    }
    if (setPrototypeOf$2) {
      setPrototypeOf$2(NativePromisePrototype$2, PromisePrototype);
    }
  }
}
$$3z({ global: true, constructor: true, wrap: true, forced: FORCED_PROMISE_CONSTRUCTOR$4 }, {
  Promise: PromiseConstructor
});
setToStringTag$5(PromiseConstructor, PROMISE, false);
setSpecies$3(PROMISE);
var NativePromiseConstructor$2 = promiseNativeConstructor;
var checkCorrectnessOfIteration$1 = checkCorrectnessOfIteration$4;
var FORCED_PROMISE_CONSTRUCTOR$3 = promiseConstructorDetection.CONSTRUCTOR;
var promiseStaticsIncorrectIteration = FORCED_PROMISE_CONSTRUCTOR$3 || !checkCorrectnessOfIteration$1(function(iterable) {
  NativePromiseConstructor$2.all(iterable).then(void 0, function() {
  });
});
var $$3y = _export;
var call$X = functionCall;
var aCallable$s = aCallable$Q;
var newPromiseCapabilityModule$6 = newPromiseCapability$2;
var perform$5 = perform$7;
var iterate$u = iterate$H;
var PROMISE_STATICS_INCORRECT_ITERATION$3 = promiseStaticsIncorrectIteration;
$$3y({ target: "Promise", stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION$3 }, {
  all: function all(iterable) {
    var C2 = this;
    var capability = newPromiseCapabilityModule$6.f(C2);
    var resolve2 = capability.resolve;
    var reject2 = capability.reject;
    var result = perform$5(function() {
      var $promiseResolve = aCallable$s(C2.resolve);
      var values5 = [];
      var counter2 = 0;
      var remaining = 1;
      iterate$u(iterable, function(promise2) {
        var index = counter2++;
        var alreadyCalled = false;
        remaining++;
        call$X($promiseResolve, C2, promise2).then(function(value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values5[index] = value;
          --remaining || resolve2(values5);
        }, reject2);
      });
      --remaining || resolve2(values5);
    });
    if (result.error) reject2(result.value);
    return capability.promise;
  }
});
var $$3x = _export;
var FORCED_PROMISE_CONSTRUCTOR$2 = promiseConstructorDetection.CONSTRUCTOR;
var NativePromiseConstructor$1 = promiseNativeConstructor;
var getBuiltIn$B = getBuiltIn$O;
var isCallable$h = isCallable$I;
var defineBuiltIn$g = defineBuiltIn$u;
var NativePromisePrototype$1 = NativePromiseConstructor$1 && NativePromiseConstructor$1.prototype;
$$3x({ target: "Promise", proto: true, forced: FORCED_PROMISE_CONSTRUCTOR$2, real: true }, {
  "catch": function(onRejected) {
    return this.then(void 0, onRejected);
  }
});
if (isCallable$h(NativePromiseConstructor$1)) {
  var method$1 = getBuiltIn$B("Promise").prototype["catch"];
  if (NativePromisePrototype$1["catch"] !== method$1) {
    defineBuiltIn$g(NativePromisePrototype$1, "catch", method$1, { unsafe: true });
  }
}
var $$3w = _export;
var call$W = functionCall;
var aCallable$r = aCallable$Q;
var newPromiseCapabilityModule$5 = newPromiseCapability$2;
var perform$4 = perform$7;
var iterate$t = iterate$H;
var PROMISE_STATICS_INCORRECT_ITERATION$2 = promiseStaticsIncorrectIteration;
$$3w({ target: "Promise", stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION$2 }, {
  race: function race(iterable) {
    var C2 = this;
    var capability = newPromiseCapabilityModule$5.f(C2);
    var reject2 = capability.reject;
    var result = perform$4(function() {
      var $promiseResolve = aCallable$r(C2.resolve);
      iterate$t(iterable, function(promise2) {
        call$W($promiseResolve, C2, promise2).then(capability.resolve, reject2);
      });
    });
    if (result.error) reject2(result.value);
    return capability.promise;
  }
});
var $$3v = _export;
var newPromiseCapabilityModule$4 = newPromiseCapability$2;
var FORCED_PROMISE_CONSTRUCTOR$1 = promiseConstructorDetection.CONSTRUCTOR;
$$3v({ target: "Promise", stat: true, forced: FORCED_PROMISE_CONSTRUCTOR$1 }, {
  reject: function reject(r2) {
    var capability = newPromiseCapabilityModule$4.f(this);
    var capabilityReject = capability.reject;
    capabilityReject(r2);
    return capability.promise;
  }
});
var anObject$T = anObject$1i;
var isObject$m = isObject$O;
var newPromiseCapability = newPromiseCapability$2;
var promiseResolve$2 = function(C2, x2) {
  anObject$T(C2);
  if (isObject$m(x2) && x2.constructor === C2) return x2;
  var promiseCapability = newPromiseCapability.f(C2);
  var resolve2 = promiseCapability.resolve;
  resolve2(x2);
  return promiseCapability.promise;
};
var $$3u = _export;
var getBuiltIn$A = getBuiltIn$O;
var FORCED_PROMISE_CONSTRUCTOR = promiseConstructorDetection.CONSTRUCTOR;
var promiseResolve$1 = promiseResolve$2;
getBuiltIn$A("Promise");
$$3u({ target: "Promise", stat: true, forced: FORCED_PROMISE_CONSTRUCTOR }, {
  resolve: function resolve(x2) {
    return promiseResolve$1(this, x2);
  }
});
var $$3t = _export;
var call$V = functionCall;
var aCallable$q = aCallable$Q;
var newPromiseCapabilityModule$3 = newPromiseCapability$2;
var perform$3 = perform$7;
var iterate$s = iterate$H;
var PROMISE_STATICS_INCORRECT_ITERATION$1 = promiseStaticsIncorrectIteration;
$$3t({ target: "Promise", stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION$1 }, {
  allSettled: function allSettled(iterable) {
    var C2 = this;
    var capability = newPromiseCapabilityModule$3.f(C2);
    var resolve2 = capability.resolve;
    var reject2 = capability.reject;
    var result = perform$3(function() {
      var promiseResolve2 = aCallable$q(C2.resolve);
      var values5 = [];
      var counter2 = 0;
      var remaining = 1;
      iterate$s(iterable, function(promise2) {
        var index = counter2++;
        var alreadyCalled = false;
        remaining++;
        call$V(promiseResolve2, C2, promise2).then(function(value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values5[index] = { status: "fulfilled", value };
          --remaining || resolve2(values5);
        }, function(error2) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values5[index] = { status: "rejected", reason: error2 };
          --remaining || resolve2(values5);
        });
      });
      --remaining || resolve2(values5);
    });
    if (result.error) reject2(result.value);
    return capability.promise;
  }
});
var $$3s = _export;
var call$U = functionCall;
var aCallable$p = aCallable$Q;
var getBuiltIn$z = getBuiltIn$O;
var newPromiseCapabilityModule$2 = newPromiseCapability$2;
var perform$2 = perform$7;
var iterate$r = iterate$H;
var PROMISE_STATICS_INCORRECT_ITERATION = promiseStaticsIncorrectIteration;
var PROMISE_ANY_ERROR = "No one promise resolved";
$$3s({ target: "Promise", stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION }, {
  any: function any(iterable) {
    var C2 = this;
    var AggregateError2 = getBuiltIn$z("AggregateError");
    var capability = newPromiseCapabilityModule$2.f(C2);
    var resolve2 = capability.resolve;
    var reject2 = capability.reject;
    var result = perform$2(function() {
      var promiseResolve2 = aCallable$p(C2.resolve);
      var errors = [];
      var counter2 = 0;
      var remaining = 1;
      var alreadyResolved = false;
      iterate$r(iterable, function(promise2) {
        var index = counter2++;
        var alreadyRejected = false;
        remaining++;
        call$U(promiseResolve2, C2, promise2).then(function(value) {
          if (alreadyRejected || alreadyResolved) return;
          alreadyResolved = true;
          resolve2(value);
        }, function(error2) {
          if (alreadyRejected || alreadyResolved) return;
          alreadyRejected = true;
          errors[index] = error2;
          --remaining || reject2(new AggregateError2(errors, PROMISE_ANY_ERROR));
        });
      });
      --remaining || reject2(new AggregateError2(errors, PROMISE_ANY_ERROR));
    });
    if (result.error) reject2(result.value);
    return capability.promise;
  }
});
var $$3r = _export;
var NativePromiseConstructor = promiseNativeConstructor;
var fails$E = fails$1z;
var getBuiltIn$y = getBuiltIn$O;
var isCallable$g = isCallable$I;
var speciesConstructor$2 = speciesConstructor$4;
var promiseResolve = promiseResolve$2;
var defineBuiltIn$f = defineBuiltIn$u;
var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
var NON_GENERIC = !!NativePromiseConstructor && fails$E(function() {
  NativePromisePrototype["finally"].call({ then: function() {
  } }, function() {
  });
});
$$3r({ target: "Promise", proto: true, real: true, forced: NON_GENERIC }, {
  "finally": function(onFinally) {
    var C2 = speciesConstructor$2(this, getBuiltIn$y("Promise"));
    var isFunction2 = isCallable$g(onFinally);
    return this.then(
      isFunction2 ? function(x2) {
        return promiseResolve(C2, onFinally()).then(function() {
          return x2;
        });
      } : onFinally,
      isFunction2 ? function(e2) {
        return promiseResolve(C2, onFinally()).then(function() {
          throw e2;
        });
      } : onFinally
    );
  }
});
if (isCallable$g(NativePromiseConstructor)) {
  var method = getBuiltIn$y("Promise").prototype["finally"];
  if (NativePromisePrototype["finally"] !== method) {
    defineBuiltIn$f(NativePromisePrototype, "finally", method, { unsafe: true });
  }
}
var $$3q = _export;
var globalThis$H = globalThis_1;
var apply$8 = functionApply$1;
var slice$7 = arraySlice$a;
var newPromiseCapabilityModule$1 = newPromiseCapability$2;
var aCallable$o = aCallable$Q;
var perform$1 = perform$7;
var Promise$6 = globalThis$H.Promise;
var ACCEPT_ARGUMENTS = false;
var FORCED$8 = !Promise$6 || !Promise$6["try"] || perform$1(function() {
  Promise$6["try"](function(argument) {
    ACCEPT_ARGUMENTS = argument === 8;
  }, 8);
}).error || !ACCEPT_ARGUMENTS;
$$3q({ target: "Promise", stat: true, forced: FORCED$8 }, {
  "try": function(callbackfn) {
    var args = arguments.length > 1 ? slice$7(arguments, 1) : [];
    var promiseCapability = newPromiseCapabilityModule$1.f(this);
    var result = perform$1(function() {
      return apply$8(aCallable$o(callbackfn), void 0, args);
    });
    (result.error ? promiseCapability.reject : promiseCapability.resolve)(result.value);
    return promiseCapability.promise;
  }
});
var $$3p = _export;
var newPromiseCapabilityModule = newPromiseCapability$2;
$$3p({ target: "Promise", stat: true }, {
  withResolvers: function withResolvers() {
    var promiseCapability = newPromiseCapabilityModule.f(this);
    return {
      promise: promiseCapability.promise,
      resolve: promiseCapability.resolve,
      reject: promiseCapability.reject
    };
  }
});
var $$3o = _export;
var functionApply = functionApply$1;
var aCallable$n = aCallable$Q;
var anObject$S = anObject$1i;
var fails$D = fails$1z;
var OPTIONAL_ARGUMENTS_LIST = !fails$D(function() {
  Reflect.apply(function() {
  });
});
$$3o({ target: "Reflect", stat: true, forced: OPTIONAL_ARGUMENTS_LIST }, {
  apply: function apply(target, thisArgument, argumentsList) {
    return functionApply(aCallable$n(target), thisArgument, anObject$S(argumentsList));
  }
});
var $$3n = _export;
var getBuiltIn$x = getBuiltIn$O;
var apply$7 = functionApply$1;
var bind$l = functionBind;
var aConstructor$2 = aConstructor$4;
var anObject$R = anObject$1i;
var isObject$l = isObject$O;
var create$b = objectCreate$1;
var fails$C = fails$1z;
var nativeConstruct = getBuiltIn$x("Reflect", "construct");
var ObjectPrototype = Object.prototype;
var push$i = [].push;
var NEW_TARGET_BUG = fails$C(function() {
  function F2() {
  }
  return !(nativeConstruct(function() {
  }, [], F2) instanceof F2);
});
var ARGS_BUG = !fails$C(function() {
  nativeConstruct(function() {
  });
});
var FORCED$7 = NEW_TARGET_BUG || ARGS_BUG;
$$3n({ target: "Reflect", stat: true, forced: FORCED$7, sham: FORCED$7 }, {
  construct: function construct2(Target, args) {
    aConstructor$2(Target);
    anObject$R(args);
    var newTarget = arguments.length < 3 ? Target : aConstructor$2(arguments[2]);
    if (ARGS_BUG && !NEW_TARGET_BUG) return nativeConstruct(Target, args, newTarget);
    if (Target === newTarget) {
      switch (args.length) {
        case 0:
          return new Target();
        case 1:
          return new Target(args[0]);
        case 2:
          return new Target(args[0], args[1]);
        case 3:
          return new Target(args[0], args[1], args[2]);
        case 4:
          return new Target(args[0], args[1], args[2], args[3]);
      }
      var $args = [null];
      apply$7(push$i, $args, args);
      return new (apply$7(bind$l, Target, $args))();
    }
    var proto = newTarget.prototype;
    var instance = create$b(isObject$l(proto) ? proto : ObjectPrototype);
    var result = apply$7(Target, instance, args);
    return isObject$l(result) ? result : instance;
  }
});
var $$3m = _export;
var DESCRIPTORS$m = descriptors$1;
var anObject$Q = anObject$1i;
var toPropertyKey$2 = toPropertyKey$9;
var definePropertyModule$2 = objectDefineProperty;
var fails$B = fails$1z;
var ERROR_INSTEAD_OF_FALSE = fails$B(function() {
  Reflect.defineProperty(definePropertyModule$2.f({}, 1, { value: 1 }), 1, { value: 2 });
});
$$3m({ target: "Reflect", stat: true, forced: ERROR_INSTEAD_OF_FALSE, sham: !DESCRIPTORS$m }, {
  defineProperty: function defineProperty4(target, propertyKey, attributes) {
    anObject$Q(target);
    var key = toPropertyKey$2(propertyKey);
    anObject$Q(attributes);
    try {
      definePropertyModule$2.f(target, key, attributes);
      return true;
    } catch (error2) {
      return false;
    }
  }
});
var $$3l = _export;
var anObject$P = anObject$1i;
var getOwnPropertyDescriptor$6 = objectGetOwnPropertyDescriptor.f;
$$3l({ target: "Reflect", stat: true }, {
  deleteProperty: function deleteProperty(target, propertyKey) {
    var descriptor = getOwnPropertyDescriptor$6(anObject$P(target), propertyKey);
    return descriptor && !descriptor.configurable ? false : delete target[propertyKey];
  }
});
var hasOwn$k = hasOwnProperty_1;
var isDataDescriptor$2 = function(descriptor) {
  return descriptor !== void 0 && (hasOwn$k(descriptor, "value") || hasOwn$k(descriptor, "writable"));
};
var $$3k = _export;
var call$T = functionCall;
var isObject$k = isObject$O;
var anObject$O = anObject$1i;
var isDataDescriptor$1 = isDataDescriptor$2;
var getOwnPropertyDescriptorModule$3 = objectGetOwnPropertyDescriptor;
var getPrototypeOf$8 = objectGetPrototypeOf$2;
function get$7(target, propertyKey) {
  var receiver = arguments.length < 3 ? target : arguments[2];
  var descriptor, prototype2;
  if (anObject$O(target) === receiver) return target[propertyKey];
  descriptor = getOwnPropertyDescriptorModule$3.f(target, propertyKey);
  if (descriptor) return isDataDescriptor$1(descriptor) ? descriptor.value : descriptor.get === void 0 ? void 0 : call$T(descriptor.get, receiver);
  if (isObject$k(prototype2 = getPrototypeOf$8(target))) return get$7(prototype2, propertyKey, receiver);
}
$$3k({ target: "Reflect", stat: true }, {
  get: get$7
});
var $$3j = _export;
var DESCRIPTORS$l = descriptors$1;
var anObject$N = anObject$1i;
var getOwnPropertyDescriptorModule$2 = objectGetOwnPropertyDescriptor;
$$3j({ target: "Reflect", stat: true, sham: !DESCRIPTORS$l }, {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor4(target, propertyKey) {
    return getOwnPropertyDescriptorModule$2.f(anObject$N(target), propertyKey);
  }
});
var $$3i = _export;
var anObject$M = anObject$1i;
var objectGetPrototypeOf = objectGetPrototypeOf$2;
var CORRECT_PROTOTYPE_GETTER = correctPrototypeGetter;
$$3i({ target: "Reflect", stat: true, sham: !CORRECT_PROTOTYPE_GETTER }, {
  getPrototypeOf: function getPrototypeOf2(target) {
    return objectGetPrototypeOf(anObject$M(target));
  }
});
var $$3h = _export;
$$3h({ target: "Reflect", stat: true }, {
  has: function has(target, propertyKey) {
    return propertyKey in target;
  }
});
var $$3g = _export;
var anObject$L = anObject$1i;
var $isExtensible = objectIsExtensible;
$$3g({ target: "Reflect", stat: true }, {
  isExtensible: function isExtensible2(target) {
    anObject$L(target);
    return $isExtensible(target);
  }
});
var $$3f = _export;
var ownKeys2 = ownKeys$3;
$$3f({ target: "Reflect", stat: true }, {
  ownKeys: ownKeys2
});
var $$3e = _export;
var getBuiltIn$w = getBuiltIn$O;
var anObject$K = anObject$1i;
var FREEZING$3 = freezing;
$$3e({ target: "Reflect", stat: true, sham: !FREEZING$3 }, {
  preventExtensions: function preventExtensions2(target) {
    anObject$K(target);
    try {
      var objectPreventExtensions = getBuiltIn$w("Object", "preventExtensions");
      if (objectPreventExtensions) objectPreventExtensions(target);
      return true;
    } catch (error2) {
      return false;
    }
  }
});
var $$3d = _export;
var call$S = functionCall;
var anObject$J = anObject$1i;
var isObject$j = isObject$O;
var isDataDescriptor = isDataDescriptor$2;
var fails$A = fails$1z;
var definePropertyModule$1 = objectDefineProperty;
var getOwnPropertyDescriptorModule$1 = objectGetOwnPropertyDescriptor;
var getPrototypeOf$7 = objectGetPrototypeOf$2;
var createPropertyDescriptor$5 = createPropertyDescriptor$d;
function set$b(target, propertyKey, V2) {
  var receiver = arguments.length < 4 ? target : arguments[3];
  var ownDescriptor = getOwnPropertyDescriptorModule$1.f(anObject$J(target), propertyKey);
  var existingDescriptor, prototype2, setter;
  if (!ownDescriptor) {
    if (isObject$j(prototype2 = getPrototypeOf$7(target))) {
      return set$b(prototype2, propertyKey, V2, receiver);
    }
    ownDescriptor = createPropertyDescriptor$5(0);
  }
  if (isDataDescriptor(ownDescriptor)) {
    if (ownDescriptor.writable === false || !isObject$j(receiver)) return false;
    if (existingDescriptor = getOwnPropertyDescriptorModule$1.f(receiver, propertyKey)) {
      if (existingDescriptor.get || existingDescriptor.set || existingDescriptor.writable === false) return false;
      existingDescriptor.value = V2;
      definePropertyModule$1.f(receiver, propertyKey, existingDescriptor);
    } else definePropertyModule$1.f(receiver, propertyKey, createPropertyDescriptor$5(0, V2));
  } else {
    setter = ownDescriptor.set;
    if (setter === void 0) return false;
    call$S(setter, receiver, V2);
  }
  return true;
}
var MS_EDGE_BUG = fails$A(function() {
  var Constructor2 = function() {
  };
  var object = definePropertyModule$1.f(new Constructor2(), "a", { configurable: true });
  return Reflect.set(Constructor2.prototype, "a", 1, object) !== false;
});
$$3d({ target: "Reflect", stat: true, forced: MS_EDGE_BUG }, {
  set: set$b
});
var $$3c = _export;
var anObject$I = anObject$1i;
var aPossiblePrototype = aPossiblePrototype$2;
var objectSetPrototypeOf = objectSetPrototypeOf$1;
if (objectSetPrototypeOf) $$3c({ target: "Reflect", stat: true }, {
  setPrototypeOf: function setPrototypeOf(target, proto) {
    anObject$I(target);
    aPossiblePrototype(proto);
    try {
      objectSetPrototypeOf(target, proto);
      return true;
    } catch (error2) {
      return false;
    }
  }
});
var $$3b = _export;
var globalThis$G = globalThis_1;
var setToStringTag$4 = setToStringTag$e;
$$3b({ global: true }, { Reflect: {} });
setToStringTag$4(globalThis$G.Reflect, "Reflect", true);
var isObject$i = isObject$O;
var classof$b = classofRaw$2;
var wellKnownSymbol$r = wellKnownSymbol$S;
var MATCH$2 = wellKnownSymbol$r("match");
var isRegexp = function(it) {
  var isRegExp2;
  return isObject$i(it) && ((isRegExp2 = it[MATCH$2]) !== void 0 ? !!isRegExp2 : classof$b(it) === "RegExp");
};
var anObject$H = anObject$1i;
var regexpFlags$1 = function() {
  var that = anObject$H(this);
  var result = "";
  if (that.hasIndices) result += "d";
  if (that.global) result += "g";
  if (that.ignoreCase) result += "i";
  if (that.multiline) result += "m";
  if (that.dotAll) result += "s";
  if (that.unicode) result += "u";
  if (that.unicodeSets) result += "v";
  if (that.sticky) result += "y";
  return result;
};
var call$R = functionCall;
var hasOwn$j = hasOwnProperty_1;
var isPrototypeOf$4 = objectIsPrototypeOf;
var regExpFlags$1 = regexpFlags$1;
var RegExpPrototype$7 = RegExp.prototype;
var regexpGetFlags = function(R2) {
  var flags = R2.flags;
  return flags === void 0 && !("flags" in RegExpPrototype$7) && !hasOwn$j(R2, "flags") && isPrototypeOf$4(RegExpPrototype$7, R2) ? call$R(regExpFlags$1, R2) : flags;
};
var fails$z = fails$1z;
var globalThis$F = globalThis_1;
var $RegExp$2 = globalThis$F.RegExp;
var UNSUPPORTED_Y$3 = fails$z(function() {
  var re3 = $RegExp$2("a", "y");
  re3.lastIndex = 2;
  return re3.exec("abcd") !== null;
});
var MISSED_STICKY$2 = UNSUPPORTED_Y$3 || fails$z(function() {
  return !$RegExp$2("a", "y").sticky;
});
var BROKEN_CARET = UNSUPPORTED_Y$3 || fails$z(function() {
  var re3 = $RegExp$2("^r", "gy");
  re3.lastIndex = 2;
  return re3.exec("str") !== null;
});
var regexpStickyHelpers = {
  BROKEN_CARET,
  MISSED_STICKY: MISSED_STICKY$2,
  UNSUPPORTED_Y: UNSUPPORTED_Y$3
};
var fails$y = fails$1z;
var globalThis$E = globalThis_1;
var $RegExp$1 = globalThis$E.RegExp;
var regexpUnsupportedDotAll = fails$y(function() {
  var re3 = $RegExp$1(".", "s");
  return !(re3.dotAll && re3.test("\n") && re3.flags === "s");
});
var fails$x = fails$1z;
var globalThis$D = globalThis_1;
var $RegExp = globalThis$D.RegExp;
var regexpUnsupportedNcg = fails$x(function() {
  var re3 = $RegExp("(?<a>b)", "g");
  return re3.exec("b").groups.a !== "b" || "b".replace(re3, "$<a>c") !== "bc";
});
var DESCRIPTORS$k = descriptors$1;
var globalThis$C = globalThis_1;
var uncurryThis$17 = functionUncurryThis;
var isForced = isForced_1;
var inheritIfRequired$2 = inheritIfRequired$7;
var createNonEnumerableProperty$8 = createNonEnumerableProperty$j;
var create$a = objectCreate$1;
var getOwnPropertyNames$2 = objectGetOwnPropertyNames.f;
var isPrototypeOf$3 = objectIsPrototypeOf;
var isRegExp$4 = isRegexp;
var toString$x = toString$K;
var getRegExpFlags$4 = regexpGetFlags;
var stickyHelpers$2 = regexpStickyHelpers;
var proxyAccessor = proxyAccessor$2;
var defineBuiltIn$e = defineBuiltIn$u;
var fails$w = fails$1z;
var hasOwn$i = hasOwnProperty_1;
var enforceInternalState$2 = internalState.enforce;
var setSpecies$2 = setSpecies$7;
var wellKnownSymbol$q = wellKnownSymbol$S;
var UNSUPPORTED_DOT_ALL$2 = regexpUnsupportedDotAll;
var UNSUPPORTED_NCG$1 = regexpUnsupportedNcg;
var MATCH$1 = wellKnownSymbol$q("match");
var NativeRegExp = globalThis$C.RegExp;
var RegExpPrototype$6 = NativeRegExp.prototype;
var SyntaxError$4 = globalThis$C.SyntaxError;
var exec$d = uncurryThis$17(RegExpPrototype$6.exec);
var charAt$j = uncurryThis$17("".charAt);
var replace$9 = uncurryThis$17("".replace);
var stringIndexOf$4 = uncurryThis$17("".indexOf);
var stringSlice$f = uncurryThis$17("".slice);
var IS_NCG = /^\?<[^\s\d!#%&*+<=>@^][^\s!#%&*+<=>@^]*>/;
var re1 = /a/g;
var re2 = /a/g;
var CORRECT_NEW = new NativeRegExp(re1) !== re1;
var MISSED_STICKY$1 = stickyHelpers$2.MISSED_STICKY;
var UNSUPPORTED_Y$2 = stickyHelpers$2.UNSUPPORTED_Y;
var BASE_FORCED = DESCRIPTORS$k && (!CORRECT_NEW || MISSED_STICKY$1 || UNSUPPORTED_DOT_ALL$2 || UNSUPPORTED_NCG$1 || fails$w(function() {
  re2[MATCH$1] = false;
  return NativeRegExp(re1) !== re1 || NativeRegExp(re2) === re2 || String(NativeRegExp(re1, "i")) !== "/a/i";
}));
var handleDotAll = function(string) {
  var length2 = string.length;
  var index = 0;
  var result = "";
  var brackets = false;
  var chr;
  for (; index <= length2; index++) {
    chr = charAt$j(string, index);
    if (chr === "\\") {
      result += chr + charAt$j(string, ++index);
      continue;
    }
    if (!brackets && chr === ".") {
      result += "[\\s\\S]";
    } else {
      if (chr === "[") {
        brackets = true;
      } else if (chr === "]") {
        brackets = false;
      }
      result += chr;
    }
  }
  return result;
};
var handleNCG = function(string) {
  var length2 = string.length;
  var index = 0;
  var result = "";
  var named = [];
  var names = create$a(null);
  var brackets = false;
  var ncg = false;
  var groupid = 0;
  var groupname = "";
  var chr;
  for (; index <= length2; index++) {
    chr = charAt$j(string, index);
    if (chr === "\\") {
      chr += charAt$j(string, ++index);
    } else if (chr === "]") {
      brackets = false;
    } else if (!brackets) switch (true) {
      case chr === "[":
        brackets = true;
        break;
      case chr === "(":
        result += chr;
        if (stringSlice$f(string, index + 1, index + 3) === "?:") {
          continue;
        }
        if (exec$d(IS_NCG, stringSlice$f(string, index + 1))) {
          index += 2;
          ncg = true;
        }
        groupid++;
        continue;
      case (chr === ">" && ncg):
        if (groupname === "" || hasOwn$i(names, groupname)) {
          throw new SyntaxError$4("Invalid capture group name");
        }
        names[groupname] = true;
        named[named.length] = [groupname, groupid];
        ncg = false;
        groupname = "";
        continue;
    }
    if (ncg) groupname += chr;
    else result += chr;
  }
  return [result, named];
};
if (isForced("RegExp", BASE_FORCED)) {
  var RegExpWrapper = function RegExp2(pattern, flags) {
    var thisIsRegExp = isPrototypeOf$3(RegExpPrototype$6, this);
    var patternIsRegExp = isRegExp$4(pattern);
    var flagsAreUndefined = flags === void 0;
    var groups = [];
    var rawPattern = pattern;
    var rawFlags, dotAll, sticky, handled, result, state;
    if (!thisIsRegExp && patternIsRegExp && flagsAreUndefined && pattern.constructor === RegExpWrapper) {
      return pattern;
    }
    if (patternIsRegExp || isPrototypeOf$3(RegExpPrototype$6, pattern)) {
      pattern = pattern.source;
      if (flagsAreUndefined) flags = getRegExpFlags$4(rawPattern);
    }
    pattern = pattern === void 0 ? "" : toString$x(pattern);
    flags = flags === void 0 ? "" : toString$x(flags);
    rawPattern = pattern;
    if (UNSUPPORTED_DOT_ALL$2 && "dotAll" in re1) {
      dotAll = !!flags && stringIndexOf$4(flags, "s") > -1;
      if (dotAll) flags = replace$9(flags, /s/g, "");
    }
    rawFlags = flags;
    if (MISSED_STICKY$1 && "sticky" in re1) {
      sticky = !!flags && stringIndexOf$4(flags, "y") > -1;
      if (sticky && UNSUPPORTED_Y$2) flags = replace$9(flags, /y/g, "");
    }
    if (UNSUPPORTED_NCG$1) {
      handled = handleNCG(pattern);
      pattern = handled[0];
      groups = handled[1];
    }
    result = inheritIfRequired$2(NativeRegExp(pattern, flags), thisIsRegExp ? this : RegExpPrototype$6, RegExpWrapper);
    if (dotAll || sticky || groups.length) {
      state = enforceInternalState$2(result);
      if (dotAll) {
        state.dotAll = true;
        state.raw = RegExpWrapper(handleDotAll(pattern), rawFlags);
      }
      if (sticky) state.sticky = true;
      if (groups.length) state.groups = groups;
    }
    if (pattern !== rawPattern) try {
      createNonEnumerableProperty$8(result, "source", rawPattern === "" ? "(?:)" : rawPattern);
    } catch (error2) {
    }
    return result;
  };
  for (var keys$1 = getOwnPropertyNames$2(NativeRegExp), index = 0; keys$1.length > index; ) {
    proxyAccessor(RegExpWrapper, NativeRegExp, keys$1[index++]);
  }
  RegExpPrototype$6.constructor = RegExpWrapper;
  RegExpWrapper.prototype = RegExpPrototype$6;
  defineBuiltIn$e(globalThis$C, "RegExp", RegExpWrapper, { constructor: true });
}
setSpecies$2("RegExp");
var DESCRIPTORS$j = descriptors$1;
var UNSUPPORTED_DOT_ALL$1 = regexpUnsupportedDotAll;
var classof$a = classofRaw$2;
var defineBuiltInAccessor$e = defineBuiltInAccessor$p;
var getInternalState$c = internalState.get;
var RegExpPrototype$5 = RegExp.prototype;
var $TypeError$r = TypeError;
if (DESCRIPTORS$j && UNSUPPORTED_DOT_ALL$1) {
  defineBuiltInAccessor$e(RegExpPrototype$5, "dotAll", {
    configurable: true,
    get: function dotAll() {
      if (this === RegExpPrototype$5) return;
      if (classof$a(this) === "RegExp") {
        return !!getInternalState$c(this).dotAll;
      }
      throw new $TypeError$r("Incompatible receiver, RegExp required");
    }
  });
}
var call$Q = functionCall;
var uncurryThis$16 = functionUncurryThis;
var toString$w = toString$K;
var regexpFlags = regexpFlags$1;
var stickyHelpers$1 = regexpStickyHelpers;
var shared$3 = shared$a;
var create$9 = objectCreate$1;
var getInternalState$b = internalState.get;
var UNSUPPORTED_DOT_ALL = regexpUnsupportedDotAll;
var UNSUPPORTED_NCG = regexpUnsupportedNcg;
var nativeReplace = shared$3("native-string-replace", String.prototype.replace);
var nativeExec = RegExp.prototype.exec;
var patchedExec = nativeExec;
var charAt$i = uncurryThis$16("".charAt);
var indexOf$1 = uncurryThis$16("".indexOf);
var replace$8 = uncurryThis$16("".replace);
var stringSlice$e = uncurryThis$16("".slice);
var UPDATES_LAST_INDEX_WRONG = function() {
  var re12 = /a/;
  var re22 = /b*/g;
  call$Q(nativeExec, re12, "a");
  call$Q(nativeExec, re22, "a");
  return re12.lastIndex !== 0 || re22.lastIndex !== 0;
}();
var UNSUPPORTED_Y$1 = stickyHelpers$1.BROKEN_CARET;
var NPCG_INCLUDED = /()??/.exec("")[1] !== void 0;
var PATCH$1 = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y$1 || UNSUPPORTED_DOT_ALL || UNSUPPORTED_NCG;
if (PATCH$1) {
  patchedExec = function exec2(string) {
    var re3 = this;
    var state = getInternalState$b(re3);
    var str = toString$w(string);
    var raw3 = state.raw;
    var result, reCopy, lastIndex, match2, i, object, group2;
    if (raw3) {
      raw3.lastIndex = re3.lastIndex;
      result = call$Q(patchedExec, raw3, str);
      re3.lastIndex = raw3.lastIndex;
      return result;
    }
    var groups = state.groups;
    var sticky = UNSUPPORTED_Y$1 && re3.sticky;
    var flags = call$Q(regexpFlags, re3);
    var source = re3.source;
    var charsAdded = 0;
    var strCopy = str;
    if (sticky) {
      flags = replace$8(flags, "y", "");
      if (indexOf$1(flags, "g") === -1) {
        flags += "g";
      }
      strCopy = stringSlice$e(str, re3.lastIndex);
      if (re3.lastIndex > 0 && (!re3.multiline || re3.multiline && charAt$i(str, re3.lastIndex - 1) !== "\n")) {
        source = "(?: " + source + ")";
        strCopy = " " + strCopy;
        charsAdded++;
      }
      reCopy = new RegExp("^(?:" + source + ")", flags);
    }
    if (NPCG_INCLUDED) {
      reCopy = new RegExp("^" + source + "$(?!\\s)", flags);
    }
    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re3.lastIndex;
    match2 = call$Q(nativeExec, sticky ? reCopy : re3, strCopy);
    if (sticky) {
      if (match2) {
        match2.input = stringSlice$e(match2.input, charsAdded);
        match2[0] = stringSlice$e(match2[0], charsAdded);
        match2.index = re3.lastIndex;
        re3.lastIndex += match2[0].length;
      } else re3.lastIndex = 0;
    } else if (UPDATES_LAST_INDEX_WRONG && match2) {
      re3.lastIndex = re3.global ? match2.index + match2[0].length : lastIndex;
    }
    if (NPCG_INCLUDED && match2 && match2.length > 1) {
      call$Q(nativeReplace, match2[0], reCopy, function() {
        for (i = 1; i < arguments.length - 2; i++) {
          if (arguments[i] === void 0) match2[i] = void 0;
        }
      });
    }
    if (match2 && groups) {
      match2.groups = object = create$9(null);
      for (i = 0; i < groups.length; i++) {
        group2 = groups[i];
        object[group2[0]] = match2[group2[1]];
      }
    }
    return match2;
  };
}
var regexpExec$2 = patchedExec;
var $$3a = _export;
var exec$c = regexpExec$2;
$$3a({ target: "RegExp", proto: true, forced: /./.exec !== exec$c }, {
  exec: exec$c
});
var globalThis$B = globalThis_1;
var DESCRIPTORS$i = descriptors$1;
var defineBuiltInAccessor$d = defineBuiltInAccessor$p;
var regExpFlags = regexpFlags$1;
var fails$v = fails$1z;
var RegExp$1 = globalThis$B.RegExp;
var RegExpPrototype$4 = RegExp$1.prototype;
var FORCED$6 = DESCRIPTORS$i && fails$v(function() {
  var INDICES_SUPPORT = true;
  try {
    RegExp$1(".", "d");
  } catch (error2) {
    INDICES_SUPPORT = false;
  }
  var O2 = {};
  var calls = "";
  var expected = INDICES_SUPPORT ? "dgimsy" : "gimsy";
  var addGetter2 = function(key2, chr) {
    Object.defineProperty(O2, key2, { get: function() {
      calls += chr;
      return true;
    } });
  };
  var pairs = {
    dotAll: "s",
    global: "g",
    ignoreCase: "i",
    multiline: "m",
    sticky: "y"
  };
  if (INDICES_SUPPORT) pairs.hasIndices = "d";
  for (var key in pairs) addGetter2(key, pairs[key]);
  var result = Object.getOwnPropertyDescriptor(RegExpPrototype$4, "flags").get.call(O2);
  return result !== expected || calls !== expected;
});
if (FORCED$6) defineBuiltInAccessor$d(RegExpPrototype$4, "flags", {
  configurable: true,
  get: regExpFlags
});
var DESCRIPTORS$h = descriptors$1;
var MISSED_STICKY = regexpStickyHelpers.MISSED_STICKY;
var classof$9 = classofRaw$2;
var defineBuiltInAccessor$c = defineBuiltInAccessor$p;
var getInternalState$a = internalState.get;
var RegExpPrototype$3 = RegExp.prototype;
var $TypeError$q = TypeError;
if (DESCRIPTORS$h && MISSED_STICKY) {
  defineBuiltInAccessor$c(RegExpPrototype$3, "sticky", {
    configurable: true,
    get: function sticky() {
      if (this === RegExpPrototype$3) return;
      if (classof$9(this) === "RegExp") {
        return !!getInternalState$a(this).sticky;
      }
      throw new $TypeError$q("Incompatible receiver, RegExp required");
    }
  });
}
var $$39 = _export;
var call$P = functionCall;
var isCallable$f = isCallable$I;
var anObject$G = anObject$1i;
var toString$v = toString$K;
var DELEGATES_TO_EXEC = function() {
  var execCalled = false;
  var re3 = /[ac]/;
  re3.exec = function() {
    execCalled = true;
    return /./.exec.apply(this, arguments);
  };
  return re3.test("abc") === true && execCalled;
}();
var nativeTest = /./.test;
$$39({ target: "RegExp", proto: true, forced: !DELEGATES_TO_EXEC }, {
  test: function(S2) {
    var R2 = anObject$G(this);
    var string = toString$v(S2);
    var exec2 = R2.exec;
    if (!isCallable$f(exec2)) return call$P(nativeTest, R2, string);
    var result = call$P(exec2, R2, string);
    if (result === null) return false;
    anObject$G(result);
    return true;
  }
});
var PROPER_FUNCTION_NAME$1 = functionName.PROPER;
var defineBuiltIn$d = defineBuiltIn$u;
var anObject$F = anObject$1i;
var $toString$2 = toString$K;
var fails$u = fails$1z;
var getRegExpFlags$3 = regexpGetFlags;
var TO_STRING = "toString";
var RegExpPrototype$2 = RegExp.prototype;
var nativeToString = RegExpPrototype$2[TO_STRING];
var NOT_GENERIC = fails$u(function() {
  return nativeToString.call({ source: "a", flags: "b" }) !== "/a/b";
});
var INCORRECT_NAME = PROPER_FUNCTION_NAME$1 && nativeToString.name !== TO_STRING;
if (NOT_GENERIC || INCORRECT_NAME) {
  defineBuiltIn$d(RegExpPrototype$2, TO_STRING, function toString8() {
    var R2 = anObject$F(this);
    var pattern = $toString$2(R2.source);
    var flags = $toString$2(getRegExpFlags$3(R2));
    return "/" + pattern + "/" + flags;
  }, { unsafe: true });
}
var collection$2 = collection$4;
var collectionStrong = collectionStrong$2;
collection$2("Set", function(init) {
  return function Set2() {
    return init(this, arguments.length ? arguments[0] : void 0);
  };
}, collectionStrong);
var uncurryThis$15 = functionUncurryThis;
var SetPrototype$1 = Set.prototype;
var setHelpers = {
  // eslint-disable-next-line es/no-set -- safe
  Set,
  add: uncurryThis$15(SetPrototype$1.add),
  has: uncurryThis$15(SetPrototype$1.has),
  remove: uncurryThis$15(SetPrototype$1["delete"]),
  proto: SetPrototype$1
};
var has$f = setHelpers.has;
var aSet$g = function(it) {
  has$f(it);
  return it;
};
var call$O = functionCall;
var iterateSimple$8 = function(record, fn, ITERATOR_INSTEAD_OF_RECORD) {
  var iterator = ITERATOR_INSTEAD_OF_RECORD ? record : record.iterator;
  var next11 = record.next;
  var step, result;
  while (!(step = call$O(next11, iterator)).done) {
    result = fn(step.value);
    if (result !== void 0) return result;
  }
};
var uncurryThis$14 = functionUncurryThis;
var iterateSimple$7 = iterateSimple$8;
var SetHelpers$a = setHelpers;
var Set$7 = SetHelpers$a.Set;
var SetPrototype = SetHelpers$a.proto;
var forEach$6 = uncurryThis$14(SetPrototype.forEach);
var keys3 = uncurryThis$14(SetPrototype.keys);
var next$3 = keys3(new Set$7()).next;
var setIterate$1 = function(set4, fn, interruptible) {
  return interruptible ? iterateSimple$7({ iterator: keys3(set4), next: next$3 }, fn) : forEach$6(set4, fn);
};
var SetHelpers$9 = setHelpers;
var iterate$q = setIterate$1;
var Set$6 = SetHelpers$9.Set;
var add$7 = SetHelpers$9.add;
var setClone = function(set4) {
  var result = new Set$6();
  iterate$q(set4, function(it) {
    add$7(result, it);
  });
  return result;
};
var uncurryThisAccessor = functionUncurryThisAccessor;
var SetHelpers$8 = setHelpers;
var setSize = uncurryThisAccessor(SetHelpers$8.proto, "size", "get") || function(set4) {
  return set4.size;
};
var aCallable$m = aCallable$Q;
var anObject$E = anObject$1i;
var call$N = functionCall;
var toIntegerOrInfinity$9 = toIntegerOrInfinity$p;
var getIteratorDirect$b = getIteratorDirect$o;
var INVALID_SIZE = "Invalid size";
var $RangeError$6 = RangeError;
var $TypeError$p = TypeError;
var max$5 = Math.max;
var SetRecord = function(set4, intSize) {
  this.set = set4;
  this.size = max$5(intSize, 0);
  this.has = aCallable$m(set4.has);
  this.keys = aCallable$m(set4.keys);
};
SetRecord.prototype = {
  getIterator: function() {
    return getIteratorDirect$b(anObject$E(call$N(this.keys, this.set)));
  },
  includes: function(it) {
    return call$N(this.has, this.set, it);
  }
};
var getSetRecord$7 = function(obj) {
  anObject$E(obj);
  var numSize = +obj.size;
  if (numSize !== numSize) throw new $TypeError$p(INVALID_SIZE);
  var intSize = toIntegerOrInfinity$9(numSize);
  if (intSize < 0) throw new $RangeError$6(INVALID_SIZE);
  return new SetRecord(obj, intSize);
};
var aSet$f = aSet$g;
var SetHelpers$7 = setHelpers;
var clone$2 = setClone;
var size$4 = setSize;
var getSetRecord$6 = getSetRecord$7;
var iterateSet$2 = setIterate$1;
var iterateSimple$6 = iterateSimple$8;
var has$e = SetHelpers$7.has;
var remove$5 = SetHelpers$7.remove;
var setDifference = function difference(other) {
  var O2 = aSet$f(this);
  var otherRec = getSetRecord$6(other);
  var result = clone$2(O2);
  if (size$4(O2) <= otherRec.size) iterateSet$2(O2, function(e2) {
    if (otherRec.includes(e2)) remove$5(result, e2);
  });
  else iterateSimple$6(otherRec.getIterator(), function(e2) {
    if (has$e(O2, e2)) remove$5(result, e2);
  });
  return result;
};
var getBuiltIn$v = getBuiltIn$O;
var createSetLike = function(size3) {
  return {
    size: size3,
    has: function() {
      return false;
    },
    keys: function() {
      return {
        next: function() {
          return { done: true };
        }
      };
    }
  };
};
var setMethodAcceptSetLike$7 = function(name) {
  var Set2 = getBuiltIn$v("Set");
  try {
    new Set2()[name](createSetLike(0));
    try {
      new Set2()[name](createSetLike(-1));
      return false;
    } catch (error2) {
      return true;
    }
  } catch (error2) {
    return false;
  }
};
var $$38 = _export;
var difference2 = setDifference;
var setMethodAcceptSetLike$6 = setMethodAcceptSetLike$7;
$$38({ target: "Set", proto: true, real: true, forced: !setMethodAcceptSetLike$6("difference") }, {
  difference: difference2
});
var aSet$e = aSet$g;
var SetHelpers$6 = setHelpers;
var size$3 = setSize;
var getSetRecord$5 = getSetRecord$7;
var iterateSet$1 = setIterate$1;
var iterateSimple$5 = iterateSimple$8;
var Set$5 = SetHelpers$6.Set;
var add$6 = SetHelpers$6.add;
var has$d = SetHelpers$6.has;
var setIntersection = function intersection(other) {
  var O2 = aSet$e(this);
  var otherRec = getSetRecord$5(other);
  var result = new Set$5();
  if (size$3(O2) > otherRec.size) {
    iterateSimple$5(otherRec.getIterator(), function(e2) {
      if (has$d(O2, e2)) add$6(result, e2);
    });
  } else {
    iterateSet$1(O2, function(e2) {
      if (otherRec.includes(e2)) add$6(result, e2);
    });
  }
  return result;
};
var $$37 = _export;
var fails$t = fails$1z;
var intersection2 = setIntersection;
var setMethodAcceptSetLike$5 = setMethodAcceptSetLike$7;
var INCORRECT = !setMethodAcceptSetLike$5("intersection") || fails$t(function() {
  return String(Array.from((/* @__PURE__ */ new Set([1, 2, 3])).intersection(/* @__PURE__ */ new Set([3, 2])))) !== "3,2";
});
$$37({ target: "Set", proto: true, real: true, forced: INCORRECT }, {
  intersection: intersection2
});
var aSet$d = aSet$g;
var has$c = setHelpers.has;
var size$2 = setSize;
var getSetRecord$4 = getSetRecord$7;
var iterateSet = setIterate$1;
var iterateSimple$4 = iterateSimple$8;
var iteratorClose$2 = iteratorClose$8;
var setIsDisjointFrom = function isDisjointFrom(other) {
  var O2 = aSet$d(this);
  var otherRec = getSetRecord$4(other);
  if (size$2(O2) <= otherRec.size) return iterateSet(O2, function(e2) {
    if (otherRec.includes(e2)) return false;
  }, true) !== false;
  var iterator = otherRec.getIterator();
  return iterateSimple$4(iterator, function(e2) {
    if (has$c(O2, e2)) return iteratorClose$2(iterator, "normal", false);
  }) !== false;
};
var $$36 = _export;
var isDisjointFrom2 = setIsDisjointFrom;
var setMethodAcceptSetLike$4 = setMethodAcceptSetLike$7;
$$36({ target: "Set", proto: true, real: true, forced: !setMethodAcceptSetLike$4("isDisjointFrom") }, {
  isDisjointFrom: isDisjointFrom2
});
var aSet$c = aSet$g;
var size$1 = setSize;
var iterate$p = setIterate$1;
var getSetRecord$3 = getSetRecord$7;
var setIsSubsetOf = function isSubsetOf(other) {
  var O2 = aSet$c(this);
  var otherRec = getSetRecord$3(other);
  if (size$1(O2) > otherRec.size) return false;
  return iterate$p(O2, function(e2) {
    if (!otherRec.includes(e2)) return false;
  }, true) !== false;
};
var $$35 = _export;
var isSubsetOf2 = setIsSubsetOf;
var setMethodAcceptSetLike$3 = setMethodAcceptSetLike$7;
$$35({ target: "Set", proto: true, real: true, forced: !setMethodAcceptSetLike$3("isSubsetOf") }, {
  isSubsetOf: isSubsetOf2
});
var aSet$b = aSet$g;
var has$b = setHelpers.has;
var size = setSize;
var getSetRecord$2 = getSetRecord$7;
var iterateSimple$3 = iterateSimple$8;
var iteratorClose$1 = iteratorClose$8;
var setIsSupersetOf = function isSupersetOf(other) {
  var O2 = aSet$b(this);
  var otherRec = getSetRecord$2(other);
  if (size(O2) < otherRec.size) return false;
  var iterator = otherRec.getIterator();
  return iterateSimple$3(iterator, function(e2) {
    if (!has$b(O2, e2)) return iteratorClose$1(iterator, "normal", false);
  }) !== false;
};
var $$34 = _export;
var isSupersetOf2 = setIsSupersetOf;
var setMethodAcceptSetLike$2 = setMethodAcceptSetLike$7;
$$34({ target: "Set", proto: true, real: true, forced: !setMethodAcceptSetLike$2("isSupersetOf") }, {
  isSupersetOf: isSupersetOf2
});
var aSet$a = aSet$g;
var SetHelpers$5 = setHelpers;
var clone$1 = setClone;
var getSetRecord$1 = getSetRecord$7;
var iterateSimple$2 = iterateSimple$8;
var add$5 = SetHelpers$5.add;
var has$a = SetHelpers$5.has;
var remove$4 = SetHelpers$5.remove;
var setSymmetricDifference = function symmetricDifference(other) {
  var O2 = aSet$a(this);
  var keysIter = getSetRecord$1(other).getIterator();
  var result = clone$1(O2);
  iterateSimple$2(keysIter, function(e2) {
    if (has$a(O2, e2)) remove$4(result, e2);
    else add$5(result, e2);
  });
  return result;
};
var $$33 = _export;
var symmetricDifference2 = setSymmetricDifference;
var setMethodAcceptSetLike$1 = setMethodAcceptSetLike$7;
$$33({ target: "Set", proto: true, real: true, forced: !setMethodAcceptSetLike$1("symmetricDifference") }, {
  symmetricDifference: symmetricDifference2
});
var aSet$9 = aSet$g;
var add$4 = setHelpers.add;
var clone = setClone;
var getSetRecord = getSetRecord$7;
var iterateSimple$1 = iterateSimple$8;
var setUnion = function union(other) {
  var O2 = aSet$9(this);
  var keysIter = getSetRecord(other).getIterator();
  var result = clone(O2);
  iterateSimple$1(keysIter, function(it) {
    add$4(result, it);
  });
  return result;
};
var $$32 = _export;
var union2 = setUnion;
var setMethodAcceptSetLike = setMethodAcceptSetLike$7;
$$32({ target: "Set", proto: true, real: true, forced: !setMethodAcceptSetLike("union") }, {
  union: union2
});
var $$31 = _export;
var uncurryThis$13 = functionUncurryThis;
var requireObjectCoercible$g = requireObjectCoercible$q;
var toIntegerOrInfinity$8 = toIntegerOrInfinity$p;
var toString$u = toString$K;
var fails$s = fails$1z;
var charAt$h = uncurryThis$13("".charAt);
var FORCED$5 = fails$s(function() {
  return "𠮷".at(-2) !== "\uD842";
});
$$31({ target: "String", proto: true, forced: FORCED$5 }, {
  at: function at2(index) {
    var S2 = toString$u(requireObjectCoercible$g(this));
    var len = S2.length;
    var relativeIndex = toIntegerOrInfinity$8(index);
    var k2 = relativeIndex >= 0 ? relativeIndex : len + relativeIndex;
    return k2 < 0 || k2 >= len ? void 0 : charAt$h(S2, k2);
  }
});
var uncurryThis$12 = functionUncurryThis;
var toIntegerOrInfinity$7 = toIntegerOrInfinity$p;
var toString$t = toString$K;
var requireObjectCoercible$f = requireObjectCoercible$q;
var charAt$g = uncurryThis$12("".charAt);
var charCodeAt$6 = uncurryThis$12("".charCodeAt);
var stringSlice$d = uncurryThis$12("".slice);
var createMethod$1 = function(CONVERT_TO_STRING) {
  return function($this, pos) {
    var S2 = toString$t(requireObjectCoercible$f($this));
    var position2 = toIntegerOrInfinity$7(pos);
    var size3 = S2.length;
    var first, second;
    if (position2 < 0 || position2 >= size3) return CONVERT_TO_STRING ? "" : void 0;
    first = charCodeAt$6(S2, position2);
    return first < 55296 || first > 56319 || position2 + 1 === size3 || (second = charCodeAt$6(S2, position2 + 1)) < 56320 || second > 57343 ? CONVERT_TO_STRING ? charAt$g(S2, position2) : first : CONVERT_TO_STRING ? stringSlice$d(S2, position2, position2 + 2) : (first - 55296 << 10) + (second - 56320) + 65536;
  };
};
var stringMultibyte = {
  // `String.prototype.codePointAt` method
  // https://tc39.es/ecma262/#sec-string.prototype.codepointat
  codeAt: createMethod$1(false),
  // `String.prototype.at` method
  // https://github.com/mathiasbynens/String.prototype.at
  charAt: createMethod$1(true)
};
var $$30 = _export;
var codeAt$2 = stringMultibyte.codeAt;
$$30({ target: "String", proto: true }, {
  codePointAt: function codePointAt(pos) {
    return codeAt$2(this, pos);
  }
});
var isRegExp$3 = isRegexp;
var $TypeError$o = TypeError;
var notARegexp = function(it) {
  if (isRegExp$3(it)) {
    throw new $TypeError$o("The method doesn't accept regular expressions");
  }
  return it;
};
var wellKnownSymbol$p = wellKnownSymbol$S;
var MATCH = wellKnownSymbol$p("match");
var correctIsRegexpLogic = function(METHOD_NAME) {
  var regexp = /./;
  try {
    "/./"[METHOD_NAME](regexp);
  } catch (error1) {
    try {
      regexp[MATCH] = false;
      return "/./"[METHOD_NAME](regexp);
    } catch (error2) {
    }
  }
  return false;
};
var $$2$ = _export;
var uncurryThis$11 = functionUncurryThisClause;
var getOwnPropertyDescriptor$5 = objectGetOwnPropertyDescriptor.f;
var toLength$7 = toLength$d;
var toString$s = toString$K;
var notARegExp$2 = notARegexp;
var requireObjectCoercible$e = requireObjectCoercible$q;
var correctIsRegExpLogic$2 = correctIsRegexpLogic;
var slice$6 = uncurryThis$11("".slice);
var min$8 = Math.min;
var CORRECT_IS_REGEXP_LOGIC$1 = correctIsRegExpLogic$2("endsWith");
var MDN_POLYFILL_BUG$1 = !CORRECT_IS_REGEXP_LOGIC$1 && !!function() {
  var descriptor = getOwnPropertyDescriptor$5(String.prototype, "endsWith");
  return descriptor && !descriptor.writable;
}();
$$2$({ target: "String", proto: true, forced: !MDN_POLYFILL_BUG$1 && !CORRECT_IS_REGEXP_LOGIC$1 }, {
  endsWith: function endsWith(searchString) {
    var that = toString$s(requireObjectCoercible$e(this));
    notARegExp$2(searchString);
    var endPosition = arguments.length > 1 ? arguments[1] : void 0;
    var len = that.length;
    var end = endPosition === void 0 ? len : min$8(toLength$7(endPosition), len);
    var search = toString$s(searchString);
    return slice$6(that, end - search.length, end) === search;
  }
});
var $$2_ = _export;
var uncurryThis$10 = functionUncurryThis;
var toAbsoluteIndex$2 = toAbsoluteIndex$a;
var $RangeError$5 = RangeError;
var fromCharCode$6 = String.fromCharCode;
var $fromCodePoint = String.fromCodePoint;
var join$8 = uncurryThis$10([].join);
var INCORRECT_LENGTH = !!$fromCodePoint && $fromCodePoint.length !== 1;
$$2_({ target: "String", stat: true, arity: 1, forced: INCORRECT_LENGTH }, {
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  fromCodePoint: function fromCodePoint(x2) {
    var elements = [];
    var length2 = arguments.length;
    var i = 0;
    var code;
    while (length2 > i) {
      code = +arguments[i++];
      if (toAbsoluteIndex$2(code, 1114111) !== code) throw new $RangeError$5(code + " is not a valid code point");
      elements[i] = code < 65536 ? fromCharCode$6(code) : fromCharCode$6(((code -= 65536) >> 10) + 55296, code % 1024 + 56320);
    }
    return join$8(elements, "");
  }
});
var $$2Z = _export;
var uncurryThis$$ = functionUncurryThis;
var notARegExp$1 = notARegexp;
var requireObjectCoercible$d = requireObjectCoercible$q;
var toString$r = toString$K;
var correctIsRegExpLogic$1 = correctIsRegexpLogic;
var stringIndexOf$3 = uncurryThis$$("".indexOf);
$$2Z({ target: "String", proto: true, forced: !correctIsRegExpLogic$1("includes") }, {
  includes: function includes2(searchString) {
    return !!~stringIndexOf$3(
      toString$r(requireObjectCoercible$d(this)),
      toString$r(notARegExp$1(searchString)),
      arguments.length > 1 ? arguments[1] : void 0
    );
  }
});
var $$2Y = _export;
var uncurryThis$_ = functionUncurryThis;
var requireObjectCoercible$c = requireObjectCoercible$q;
var toString$q = toString$K;
var charCodeAt$5 = uncurryThis$_("".charCodeAt);
$$2Y({ target: "String", proto: true }, {
  isWellFormed: function isWellFormed() {
    var S2 = toString$q(requireObjectCoercible$c(this));
    var length2 = S2.length;
    for (var i = 0; i < length2; i++) {
      var charCode = charCodeAt$5(S2, i);
      if ((charCode & 63488) !== 55296) continue;
      if (charCode >= 56320 || ++i >= length2 || (charCodeAt$5(S2, i) & 64512) !== 56320) return false;
    }
    return true;
  }
});
var charAt$f = stringMultibyte.charAt;
var toString$p = toString$K;
var InternalStateModule$f = internalState;
var defineIterator = iteratorDefine;
var createIterResultObject$d = createIterResultObject$h;
var STRING_ITERATOR$1 = "String Iterator";
var setInternalState$g = InternalStateModule$f.set;
var getInternalState$9 = InternalStateModule$f.getterFor(STRING_ITERATOR$1);
defineIterator(String, "String", function(iterated) {
  setInternalState$g(this, {
    type: STRING_ITERATOR$1,
    string: toString$p(iterated),
    index: 0
  });
}, function next() {
  var state = getInternalState$9(this);
  var string = state.string;
  var index = state.index;
  var point;
  if (index >= string.length) return createIterResultObject$d(void 0, true);
  point = charAt$f(string, index);
  state.index += point.length;
  return createIterResultObject$d(point, false);
});
var call$M = functionCall;
var defineBuiltIn$c = defineBuiltIn$u;
var regexpExec$1 = regexpExec$2;
var fails$r = fails$1z;
var wellKnownSymbol$o = wellKnownSymbol$S;
var createNonEnumerableProperty$7 = createNonEnumerableProperty$j;
var SPECIES = wellKnownSymbol$o("species");
var RegExpPrototype$1 = RegExp.prototype;
var fixRegexpWellKnownSymbolLogic = function(KEY, exec2, FORCED2, SHAM) {
  var SYMBOL2 = wellKnownSymbol$o(KEY);
  var DELEGATES_TO_SYMBOL = !fails$r(function() {
    var O2 = {};
    O2[SYMBOL2] = function() {
      return 7;
    };
    return ""[KEY](O2) !== 7;
  });
  var DELEGATES_TO_EXEC2 = DELEGATES_TO_SYMBOL && !fails$r(function() {
    var execCalled = false;
    var re3 = /a/;
    if (KEY === "split") {
      re3 = {};
      re3.constructor = {};
      re3.constructor[SPECIES] = function() {
        return re3;
      };
      re3.flags = "";
      re3[SYMBOL2] = /./[SYMBOL2];
    }
    re3.exec = function() {
      execCalled = true;
      return null;
    };
    re3[SYMBOL2]("");
    return !execCalled;
  });
  if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC2 || FORCED2) {
    var nativeRegExpMethod = /./[SYMBOL2];
    var methods = exec2(SYMBOL2, ""[KEY], function(nativeMethod, regexp, str, arg2, forceStringMethod) {
      var $exec = regexp.exec;
      if ($exec === regexpExec$1 || $exec === RegExpPrototype$1.exec) {
        if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
          return { done: true, value: call$M(nativeRegExpMethod, regexp, str, arg2) };
        }
        return { done: true, value: call$M(nativeMethod, str, regexp, arg2) };
      }
      return { done: false };
    });
    defineBuiltIn$c(String.prototype, KEY, methods[0]);
    defineBuiltIn$c(RegExpPrototype$1, SYMBOL2, methods[1]);
  }
  if (SHAM) createNonEnumerableProperty$7(RegExpPrototype$1[SYMBOL2], "sham", true);
};
var charAt$e = stringMultibyte.charAt;
var advanceStringIndex$4 = function(S2, index, unicode) {
  return index + (unicode ? charAt$e(S2, index).length : 1);
};
var call$L = functionCall;
var anObject$D = anObject$1i;
var isCallable$e = isCallable$I;
var classof$8 = classofRaw$2;
var regexpExec = regexpExec$2;
var $TypeError$n = TypeError;
var regexpExecAbstract = function(R2, S2) {
  var exec2 = R2.exec;
  if (isCallable$e(exec2)) {
    var result = call$L(exec2, R2, S2);
    if (result !== null) anObject$D(result);
    return result;
  }
  if (classof$8(R2) === "RegExp") return call$L(regexpExec, R2, S2);
  throw new $TypeError$n("RegExp#exec called on incompatible receiver");
};
var call$K = functionCall;
var fixRegExpWellKnownSymbolLogic$3 = fixRegexpWellKnownSymbolLogic;
var anObject$C = anObject$1i;
var isNullOrUndefined$c = isNullOrUndefined$j;
var toLength$6 = toLength$d;
var toString$o = toString$K;
var requireObjectCoercible$b = requireObjectCoercible$q;
var getMethod$g = getMethod$l;
var advanceStringIndex$3 = advanceStringIndex$4;
var regExpExec$4 = regexpExecAbstract;
fixRegExpWellKnownSymbolLogic$3("match", function(MATCH2, nativeMatch, maybeCallNative) {
  return [
    // `String.prototype.match` method
    // https://tc39.es/ecma262/#sec-string.prototype.match
    function match2(regexp) {
      var O2 = requireObjectCoercible$b(this);
      var matcher = isNullOrUndefined$c(regexp) ? void 0 : getMethod$g(regexp, MATCH2);
      return matcher ? call$K(matcher, regexp, O2) : new RegExp(regexp)[MATCH2](toString$o(O2));
    },
    // `RegExp.prototype[@@match]` method
    // https://tc39.es/ecma262/#sec-regexp.prototype-@@match
    function(string) {
      var rx = anObject$C(this);
      var S2 = toString$o(string);
      var res = maybeCallNative(nativeMatch, rx, S2);
      if (res.done) return res.value;
      if (!rx.global) return regExpExec$4(rx, S2);
      var fullUnicode = rx.unicode;
      rx.lastIndex = 0;
      var A2 = [];
      var n2 = 0;
      var result;
      while ((result = regExpExec$4(rx, S2)) !== null) {
        var matchStr = toString$o(result[0]);
        A2[n2] = matchStr;
        if (matchStr === "") rx.lastIndex = advanceStringIndex$3(S2, toLength$6(rx.lastIndex), fullUnicode);
        n2++;
      }
      return n2 === 0 ? null : A2;
    }
  ];
});
var $$2X = _export;
var call$J = functionCall;
var uncurryThis$Z = functionUncurryThisClause;
var createIteratorConstructor$5 = iteratorCreateConstructor;
var createIterResultObject$c = createIterResultObject$h;
var requireObjectCoercible$a = requireObjectCoercible$q;
var toLength$5 = toLength$d;
var toString$n = toString$K;
var anObject$B = anObject$1i;
var isNullOrUndefined$b = isNullOrUndefined$j;
var isRegExp$2 = isRegexp;
var getRegExpFlags$2 = regexpGetFlags;
var getMethod$f = getMethod$l;
var defineBuiltIn$b = defineBuiltIn$u;
var fails$q = fails$1z;
var wellKnownSymbol$n = wellKnownSymbol$S;
var speciesConstructor$1 = speciesConstructor$4;
var advanceStringIndex$2 = advanceStringIndex$4;
var regExpExec$3 = regexpExecAbstract;
var InternalStateModule$e = internalState;
var MATCH_ALL = wellKnownSymbol$n("matchAll");
var REGEXP_STRING = "RegExp String";
var REGEXP_STRING_ITERATOR = REGEXP_STRING + " Iterator";
var setInternalState$f = InternalStateModule$e.set;
var getInternalState$8 = InternalStateModule$e.getterFor(REGEXP_STRING_ITERATOR);
var RegExpPrototype = RegExp.prototype;
var $TypeError$m = TypeError;
var stringIndexOf$2 = uncurryThis$Z("".indexOf);
var nativeMatchAll = uncurryThis$Z("".matchAll);
var WORKS_WITH_NON_GLOBAL_REGEX = !!nativeMatchAll && !fails$q(function() {
  nativeMatchAll("a", /./);
});
var $RegExpStringIterator = createIteratorConstructor$5(function RegExpStringIterator(regexp, string, $global, fullUnicode) {
  setInternalState$f(this, {
    type: REGEXP_STRING_ITERATOR,
    regexp,
    string,
    global: $global,
    unicode: fullUnicode,
    done: false
  });
}, REGEXP_STRING, function next2() {
  var state = getInternalState$8(this);
  if (state.done) return createIterResultObject$c(void 0, true);
  var R2 = state.regexp;
  var S2 = state.string;
  var match2 = regExpExec$3(R2, S2);
  if (match2 === null) {
    state.done = true;
    return createIterResultObject$c(void 0, true);
  }
  if (state.global) {
    if (toString$n(match2[0]) === "") R2.lastIndex = advanceStringIndex$2(S2, toLength$5(R2.lastIndex), state.unicode);
    return createIterResultObject$c(match2, false);
  }
  state.done = true;
  return createIterResultObject$c(match2, false);
});
var $matchAll = function(string) {
  var R2 = anObject$B(this);
  var S2 = toString$n(string);
  var C2 = speciesConstructor$1(R2, RegExp);
  var flags = toString$n(getRegExpFlags$2(R2));
  var matcher, $global, fullUnicode;
  matcher = new C2(C2 === RegExp ? R2.source : R2, flags);
  $global = !!~stringIndexOf$2(flags, "g");
  fullUnicode = !!~stringIndexOf$2(flags, "u");
  matcher.lastIndex = toLength$5(R2.lastIndex);
  return new $RegExpStringIterator(matcher, S2, $global, fullUnicode);
};
$$2X({ target: "String", proto: true, forced: WORKS_WITH_NON_GLOBAL_REGEX }, {
  matchAll: function matchAll(regexp) {
    var O2 = requireObjectCoercible$a(this);
    var flags, S2, matcher, rx;
    if (!isNullOrUndefined$b(regexp)) {
      if (isRegExp$2(regexp)) {
        flags = toString$n(requireObjectCoercible$a(getRegExpFlags$2(regexp)));
        if (!~stringIndexOf$2(flags, "g")) throw new $TypeError$m("`.matchAll` does not allow non-global regexes");
      }
      if (WORKS_WITH_NON_GLOBAL_REGEX) return nativeMatchAll(O2, regexp);
      matcher = getMethod$f(regexp, MATCH_ALL);
      if (matcher) return call$J(matcher, regexp, O2);
    } else if (WORKS_WITH_NON_GLOBAL_REGEX) return nativeMatchAll(O2, regexp);
    S2 = toString$n(O2);
    rx = new RegExp(regexp, "g");
    return rx[MATCH_ALL](S2);
  }
});
MATCH_ALL in RegExpPrototype || defineBuiltIn$b(RegExpPrototype, MATCH_ALL, $matchAll);
var userAgent = environmentUserAgent;
var stringPadWebkitBug = /Version\/10(?:\.\d+){1,2}(?: [\w./]+)?(?: Mobile\/\w+)? Safari\//.test(userAgent);
var $$2W = _export;
var $padEnd = stringPad.end;
var WEBKIT_BUG$1 = stringPadWebkitBug;
$$2W({ target: "String", proto: true, forced: WEBKIT_BUG$1 }, {
  padEnd: function padEnd(maxLength) {
    return $padEnd(this, maxLength, arguments.length > 1 ? arguments[1] : void 0);
  }
});
var $$2V = _export;
var $padStart = stringPad.start;
var WEBKIT_BUG = stringPadWebkitBug;
$$2V({ target: "String", proto: true, forced: WEBKIT_BUG }, {
  padStart: function padStart(maxLength) {
    return $padStart(this, maxLength, arguments.length > 1 ? arguments[1] : void 0);
  }
});
var $$2U = _export;
var uncurryThis$Y = functionUncurryThis;
var toIndexedObject$2 = toIndexedObject$k;
var toObject$c = toObject$E;
var toString$m = toString$K;
var lengthOfArrayLike$d = lengthOfArrayLike$B;
var push$h = uncurryThis$Y([].push);
var join$7 = uncurryThis$Y([].join);
$$2U({ target: "String", stat: true }, {
  raw: function raw2(template) {
    var rawTemplate = toIndexedObject$2(toObject$c(template).raw);
    var literalSegments = lengthOfArrayLike$d(rawTemplate);
    if (!literalSegments) return "";
    var argumentsLength = arguments.length;
    var elements = [];
    var i = 0;
    while (true) {
      push$h(elements, toString$m(rawTemplate[i++]));
      if (i === literalSegments) return join$7(elements, "");
      if (i < argumentsLength) push$h(elements, toString$m(arguments[i]));
    }
  }
});
var $$2T = _export;
var repeat2 = stringRepeat;
$$2T({ target: "String", proto: true }, {
  repeat: repeat2
});
var uncurryThis$X = functionUncurryThis;
var toObject$b = toObject$E;
var floor$3 = Math.floor;
var charAt$d = uncurryThis$X("".charAt);
var replace$7 = uncurryThis$X("".replace);
var stringSlice$c = uncurryThis$X("".slice);
var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d{1,2}|<[^>]*>)/g;
var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d{1,2})/g;
var getSubstitution$2 = function(matched, str, position2, captures, namedCaptures, replacement2) {
  var tailPos = position2 + matched.length;
  var m2 = captures.length;
  var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
  if (namedCaptures !== void 0) {
    namedCaptures = toObject$b(namedCaptures);
    symbols = SUBSTITUTION_SYMBOLS;
  }
  return replace$7(replacement2, symbols, function(match2, ch2) {
    var capture;
    switch (charAt$d(ch2, 0)) {
      case "$":
        return "$";
      case "&":
        return matched;
      case "`":
        return stringSlice$c(str, 0, position2);
      case "'":
        return stringSlice$c(str, tailPos);
      case "<":
        capture = namedCaptures[stringSlice$c(ch2, 1, -1)];
        break;
      default:
        var n2 = +ch2;
        if (n2 === 0) return match2;
        if (n2 > m2) {
          var f2 = floor$3(n2 / 10);
          if (f2 === 0) return match2;
          if (f2 <= m2) return captures[f2 - 1] === void 0 ? charAt$d(ch2, 1) : captures[f2 - 1] + charAt$d(ch2, 1);
          return match2;
        }
        capture = captures[n2 - 1];
    }
    return capture === void 0 ? "" : capture;
  });
};
var apply$6 = functionApply$1;
var call$I = functionCall;
var uncurryThis$W = functionUncurryThis;
var fixRegExpWellKnownSymbolLogic$2 = fixRegexpWellKnownSymbolLogic;
var fails$p = fails$1z;
var anObject$A = anObject$1i;
var isCallable$d = isCallable$I;
var isNullOrUndefined$a = isNullOrUndefined$j;
var toIntegerOrInfinity$6 = toIntegerOrInfinity$p;
var toLength$4 = toLength$d;
var toString$l = toString$K;
var requireObjectCoercible$9 = requireObjectCoercible$q;
var advanceStringIndex$1 = advanceStringIndex$4;
var getMethod$e = getMethod$l;
var getSubstitution$1 = getSubstitution$2;
var regExpExec$2 = regexpExecAbstract;
var wellKnownSymbol$m = wellKnownSymbol$S;
var REPLACE$1 = wellKnownSymbol$m("replace");
var max$4 = Math.max;
var min$7 = Math.min;
var concat$1 = uncurryThis$W([].concat);
var push$g = uncurryThis$W([].push);
var stringIndexOf$1 = uncurryThis$W("".indexOf);
var stringSlice$b = uncurryThis$W("".slice);
var maybeToString = function(it) {
  return it === void 0 ? it : String(it);
};
var REPLACE_KEEPS_$0 = function() {
  return "a".replace(/./, "$0") === "$0";
}();
var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = function() {
  if (/./[REPLACE$1]) {
    return /./[REPLACE$1]("a", "$0") === "";
  }
  return false;
}();
var REPLACE_SUPPORTS_NAMED_GROUPS = !fails$p(function() {
  var re3 = /./;
  re3.exec = function() {
    var result = [];
    result.groups = { a: "7" };
    return result;
  };
  return "".replace(re3, "$<a>") !== "7";
});
fixRegExpWellKnownSymbolLogic$2("replace", function(_, nativeReplace2, maybeCallNative) {
  var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? "$" : "$0";
  return [
    // `String.prototype.replace` method
    // https://tc39.es/ecma262/#sec-string.prototype.replace
    function replace2(searchValue, replaceValue) {
      var O2 = requireObjectCoercible$9(this);
      var replacer2 = isNullOrUndefined$a(searchValue) ? void 0 : getMethod$e(searchValue, REPLACE$1);
      return replacer2 ? call$I(replacer2, searchValue, O2, replaceValue) : call$I(nativeReplace2, toString$l(O2), searchValue, replaceValue);
    },
    // `RegExp.prototype[@@replace]` method
    // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
    function(string, replaceValue) {
      var rx = anObject$A(this);
      var S2 = toString$l(string);
      if (typeof replaceValue == "string" && stringIndexOf$1(replaceValue, UNSAFE_SUBSTITUTE) === -1 && stringIndexOf$1(replaceValue, "$<") === -1) {
        var res = maybeCallNative(nativeReplace2, rx, S2, replaceValue);
        if (res.done) return res.value;
      }
      var functionalReplace = isCallable$d(replaceValue);
      if (!functionalReplace) replaceValue = toString$l(replaceValue);
      var global2 = rx.global;
      var fullUnicode;
      if (global2) {
        fullUnicode = rx.unicode;
        rx.lastIndex = 0;
      }
      var results = [];
      var result;
      while (true) {
        result = regExpExec$2(rx, S2);
        if (result === null) break;
        push$g(results, result);
        if (!global2) break;
        var matchStr = toString$l(result[0]);
        if (matchStr === "") rx.lastIndex = advanceStringIndex$1(S2, toLength$4(rx.lastIndex), fullUnicode);
      }
      var accumulatedResult = "";
      var nextSourcePosition = 0;
      for (var i = 0; i < results.length; i++) {
        result = results[i];
        var matched = toString$l(result[0]);
        var position2 = max$4(min$7(toIntegerOrInfinity$6(result.index), S2.length), 0);
        var captures = [];
        var replacement2;
        for (var j = 1; j < result.length; j++) push$g(captures, maybeToString(result[j]));
        var namedCaptures = result.groups;
        if (functionalReplace) {
          var replacerArgs = concat$1([matched], captures, position2, S2);
          if (namedCaptures !== void 0) push$g(replacerArgs, namedCaptures);
          replacement2 = toString$l(apply$6(replaceValue, void 0, replacerArgs));
        } else {
          replacement2 = getSubstitution$1(matched, S2, position2, captures, namedCaptures, replaceValue);
        }
        if (position2 >= nextSourcePosition) {
          accumulatedResult += stringSlice$b(S2, nextSourcePosition, position2) + replacement2;
          nextSourcePosition = position2 + matched.length;
        }
      }
      return accumulatedResult + stringSlice$b(S2, nextSourcePosition);
    }
  ];
}, !REPLACE_SUPPORTS_NAMED_GROUPS || !REPLACE_KEEPS_$0 || REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE);
var $$2S = _export;
var call$H = functionCall;
var uncurryThis$V = functionUncurryThis;
var requireObjectCoercible$8 = requireObjectCoercible$q;
var isCallable$c = isCallable$I;
var isNullOrUndefined$9 = isNullOrUndefined$j;
var isRegExp$1 = isRegexp;
var toString$k = toString$K;
var getMethod$d = getMethod$l;
var getRegExpFlags$1 = regexpGetFlags;
var getSubstitution = getSubstitution$2;
var wellKnownSymbol$l = wellKnownSymbol$S;
var REPLACE = wellKnownSymbol$l("replace");
var $TypeError$l = TypeError;
var indexOf2 = uncurryThis$V("".indexOf);
uncurryThis$V("".replace);
var stringSlice$a = uncurryThis$V("".slice);
var max$3 = Math.max;
$$2S({ target: "String", proto: true }, {
  replaceAll: function replaceAll(searchValue, replaceValue) {
    var O2 = requireObjectCoercible$8(this);
    var IS_REG_EXP, flags, replacer2, string, searchString, functionalReplace, searchLength, advanceBy, position2, replacement2;
    var endOfLastMatch = 0;
    var result = "";
    if (!isNullOrUndefined$9(searchValue)) {
      IS_REG_EXP = isRegExp$1(searchValue);
      if (IS_REG_EXP) {
        flags = toString$k(requireObjectCoercible$8(getRegExpFlags$1(searchValue)));
        if (!~indexOf2(flags, "g")) throw new $TypeError$l("`.replaceAll` does not allow non-global regexes");
      }
      replacer2 = getMethod$d(searchValue, REPLACE);
      if (replacer2) return call$H(replacer2, searchValue, O2, replaceValue);
    }
    string = toString$k(O2);
    searchString = toString$k(searchValue);
    functionalReplace = isCallable$c(replaceValue);
    if (!functionalReplace) replaceValue = toString$k(replaceValue);
    searchLength = searchString.length;
    advanceBy = max$3(1, searchLength);
    position2 = indexOf2(string, searchString);
    while (position2 !== -1) {
      replacement2 = functionalReplace ? toString$k(replaceValue(searchString, position2, string)) : getSubstitution(searchString, string, position2, [], void 0, replaceValue);
      result += stringSlice$a(string, endOfLastMatch, position2) + replacement2;
      endOfLastMatch = position2 + searchLength;
      position2 = position2 + advanceBy > string.length ? -1 : indexOf2(string, searchString, position2 + advanceBy);
    }
    if (endOfLastMatch < string.length) {
      result += stringSlice$a(string, endOfLastMatch);
    }
    return result;
  }
});
var call$G = functionCall;
var fixRegExpWellKnownSymbolLogic$1 = fixRegexpWellKnownSymbolLogic;
var anObject$z = anObject$1i;
var isNullOrUndefined$8 = isNullOrUndefined$j;
var requireObjectCoercible$7 = requireObjectCoercible$q;
var sameValue = sameValue$1;
var toString$j = toString$K;
var getMethod$c = getMethod$l;
var regExpExec$1 = regexpExecAbstract;
fixRegExpWellKnownSymbolLogic$1("search", function(SEARCH, nativeSearch, maybeCallNative) {
  return [
    // `String.prototype.search` method
    // https://tc39.es/ecma262/#sec-string.prototype.search
    function search(regexp) {
      var O2 = requireObjectCoercible$7(this);
      var searcher = isNullOrUndefined$8(regexp) ? void 0 : getMethod$c(regexp, SEARCH);
      return searcher ? call$G(searcher, regexp, O2) : new RegExp(regexp)[SEARCH](toString$j(O2));
    },
    // `RegExp.prototype[@@search]` method
    // https://tc39.es/ecma262/#sec-regexp.prototype-@@search
    function(string) {
      var rx = anObject$z(this);
      var S2 = toString$j(string);
      var res = maybeCallNative(nativeSearch, rx, S2);
      if (res.done) return res.value;
      var previousLastIndex = rx.lastIndex;
      if (!sameValue(previousLastIndex, 0)) rx.lastIndex = 0;
      var result = regExpExec$1(rx, S2);
      if (!sameValue(rx.lastIndex, previousLastIndex)) rx.lastIndex = previousLastIndex;
      return result === null ? -1 : result.index;
    }
  ];
});
var call$F = functionCall;
var uncurryThis$U = functionUncurryThis;
var fixRegExpWellKnownSymbolLogic = fixRegexpWellKnownSymbolLogic;
var anObject$y = anObject$1i;
var isNullOrUndefined$7 = isNullOrUndefined$j;
var requireObjectCoercible$6 = requireObjectCoercible$q;
var speciesConstructor = speciesConstructor$4;
var advanceStringIndex = advanceStringIndex$4;
var toLength$3 = toLength$d;
var toString$i = toString$K;
var getMethod$b = getMethod$l;
var regExpExec = regexpExecAbstract;
var stickyHelpers = regexpStickyHelpers;
var fails$o = fails$1z;
var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y;
var MAX_UINT32 = 4294967295;
var min$6 = Math.min;
var push$f = uncurryThis$U([].push);
var stringSlice$9 = uncurryThis$U("".slice);
var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails$o(function() {
  var re3 = /(?:)/;
  var originalExec = re3.exec;
  re3.exec = function() {
    return originalExec.apply(this, arguments);
  };
  var result = "ab".split(re3);
  return result.length !== 2 || result[0] !== "a" || result[1] !== "b";
});
var BUGGY = "abbc".split(/(b)*/)[1] === "c" || // eslint-disable-next-line regexp/no-empty-group -- required for testing
"test".split(/(?:)/, -1).length !== 4 || "ab".split(/(?:ab)*/).length !== 2 || ".".split(/(.?)(.?)/).length !== 4 || // eslint-disable-next-line regexp/no-empty-capturing-group, regexp/no-empty-group -- required for testing
".".split(/()()/).length > 1 || "".split(/.?/).length;
fixRegExpWellKnownSymbolLogic("split", function(SPLIT, nativeSplit, maybeCallNative) {
  var internalSplit = "0".split(void 0, 0).length ? function(separator, limit) {
    return separator === void 0 && limit === 0 ? [] : call$F(nativeSplit, this, separator, limit);
  } : nativeSplit;
  return [
    // `String.prototype.split` method
    // https://tc39.es/ecma262/#sec-string.prototype.split
    function split2(separator, limit) {
      var O2 = requireObjectCoercible$6(this);
      var splitter = isNullOrUndefined$7(separator) ? void 0 : getMethod$b(separator, SPLIT);
      return splitter ? call$F(splitter, separator, O2, limit) : call$F(internalSplit, toString$i(O2), separator, limit);
    },
    // `RegExp.prototype[@@split]` method
    // https://tc39.es/ecma262/#sec-regexp.prototype-@@split
    //
    // NOTE: This cannot be properly polyfilled in engines that don't support
    // the 'y' flag.
    function(string, limit) {
      var rx = anObject$y(this);
      var S2 = toString$i(string);
      if (!BUGGY) {
        var res = maybeCallNative(internalSplit, rx, S2, limit, internalSplit !== nativeSplit);
        if (res.done) return res.value;
      }
      var C2 = speciesConstructor(rx, RegExp);
      var unicodeMatching = rx.unicode;
      var flags = (rx.ignoreCase ? "i" : "") + (rx.multiline ? "m" : "") + (rx.unicode ? "u" : "") + (UNSUPPORTED_Y ? "g" : "y");
      var splitter = new C2(UNSUPPORTED_Y ? "^(?:" + rx.source + ")" : rx, flags);
      var lim = limit === void 0 ? MAX_UINT32 : limit >>> 0;
      if (lim === 0) return [];
      if (S2.length === 0) return regExpExec(splitter, S2) === null ? [S2] : [];
      var p2 = 0;
      var q2 = 0;
      var A2 = [];
      while (q2 < S2.length) {
        splitter.lastIndex = UNSUPPORTED_Y ? 0 : q2;
        var z2 = regExpExec(splitter, UNSUPPORTED_Y ? stringSlice$9(S2, q2) : S2);
        var e2;
        if (z2 === null || (e2 = min$6(toLength$3(splitter.lastIndex + (UNSUPPORTED_Y ? q2 : 0)), S2.length)) === p2) {
          q2 = advanceStringIndex(S2, q2, unicodeMatching);
        } else {
          push$f(A2, stringSlice$9(S2, p2, q2));
          if (A2.length === lim) return A2;
          for (var i = 1; i <= z2.length - 1; i++) {
            push$f(A2, z2[i]);
            if (A2.length === lim) return A2;
          }
          q2 = p2 = e2;
        }
      }
      push$f(A2, stringSlice$9(S2, p2));
      return A2;
    }
  ];
}, BUGGY || !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC, UNSUPPORTED_Y);
var $$2R = _export;
var uncurryThis$T = functionUncurryThisClause;
var getOwnPropertyDescriptor$4 = objectGetOwnPropertyDescriptor.f;
var toLength$2 = toLength$d;
var toString$h = toString$K;
var notARegExp = notARegexp;
var requireObjectCoercible$5 = requireObjectCoercible$q;
var correctIsRegExpLogic = correctIsRegexpLogic;
var stringSlice$8 = uncurryThis$T("".slice);
var min$5 = Math.min;
var CORRECT_IS_REGEXP_LOGIC = correctIsRegExpLogic("startsWith");
var MDN_POLYFILL_BUG = !CORRECT_IS_REGEXP_LOGIC && !!function() {
  var descriptor = getOwnPropertyDescriptor$4(String.prototype, "startsWith");
  return descriptor && !descriptor.writable;
}();
$$2R({ target: "String", proto: true, forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC }, {
  startsWith: function startsWith(searchString) {
    var that = toString$h(requireObjectCoercible$5(this));
    notARegExp(searchString);
    var index = toLength$2(min$5(arguments.length > 1 ? arguments[1] : void 0, that.length));
    var search = toString$h(searchString);
    return stringSlice$8(that, index, index + search.length) === search;
  }
});
var $$2Q = _export;
var uncurryThis$S = functionUncurryThis;
var requireObjectCoercible$4 = requireObjectCoercible$q;
var toIntegerOrInfinity$5 = toIntegerOrInfinity$p;
var toString$g = toString$K;
var stringSlice$7 = uncurryThis$S("".slice);
var max$2 = Math.max;
var min$4 = Math.min;
var FORCED$4 = !"".substr || "ab".substr(-1) !== "b";
$$2Q({ target: "String", proto: true, forced: FORCED$4 }, {
  substr: function substr(start, length2) {
    var that = toString$g(requireObjectCoercible$4(this));
    var size3 = that.length;
    var intStart = toIntegerOrInfinity$5(start);
    var intLength, intEnd;
    if (intStart === Infinity) intStart = 0;
    if (intStart < 0) intStart = max$2(size3 + intStart, 0);
    intLength = length2 === void 0 ? size3 : toIntegerOrInfinity$5(length2);
    if (intLength <= 0 || intLength === Infinity) return "";
    intEnd = min$4(intStart + intLength, size3);
    return intStart >= intEnd ? "" : stringSlice$7(that, intStart, intEnd);
  }
});
var $$2P = _export;
var call$E = functionCall;
var uncurryThis$R = functionUncurryThis;
var requireObjectCoercible$3 = requireObjectCoercible$q;
var toString$f = toString$K;
var fails$n = fails$1z;
var $Array$4 = Array;
var charAt$c = uncurryThis$R("".charAt);
var charCodeAt$4 = uncurryThis$R("".charCodeAt);
var join$6 = uncurryThis$R([].join);
var $toWellFormed = "".toWellFormed;
var REPLACEMENT_CHARACTER = "�";
var TO_STRING_CONVERSION_BUG = $toWellFormed && fails$n(function() {
  return call$E($toWellFormed, 1) !== "1";
});
$$2P({ target: "String", proto: true, forced: TO_STRING_CONVERSION_BUG }, {
  toWellFormed: function toWellFormed() {
    var S2 = toString$f(requireObjectCoercible$3(this));
    if (TO_STRING_CONVERSION_BUG) return call$E($toWellFormed, S2);
    var length2 = S2.length;
    var result = $Array$4(length2);
    for (var i = 0; i < length2; i++) {
      var charCode = charCodeAt$4(S2, i);
      if ((charCode & 63488) !== 55296) result[i] = charAt$c(S2, i);
      else if (charCode >= 56320 || i + 1 >= length2 || (charCodeAt$4(S2, i + 1) & 64512) !== 56320) result[i] = REPLACEMENT_CHARACTER;
      else {
        result[i] = charAt$c(S2, i);
        result[++i] = charAt$c(S2, i);
      }
    }
    return join$6(result, "");
  }
});
var PROPER_FUNCTION_NAME = functionName.PROPER;
var fails$m = fails$1z;
var whitespaces$2 = whitespaces$6;
var non = "​᠎";
var stringTrimForced = function(METHOD_NAME) {
  return fails$m(function() {
    return !!whitespaces$2[METHOD_NAME]() || non[METHOD_NAME]() !== non || PROPER_FUNCTION_NAME && whitespaces$2[METHOD_NAME].name !== METHOD_NAME;
  });
};
var $$2O = _export;
var $trim = stringTrim.trim;
var forcedStringTrimMethod$2 = stringTrimForced;
$$2O({ target: "String", proto: true, forced: forcedStringTrimMethod$2("trim") }, {
  trim: function trim() {
    return $trim(this);
  }
});
var $trimEnd = stringTrim.end;
var forcedStringTrimMethod$1 = stringTrimForced;
var stringTrimEnd = forcedStringTrimMethod$1("trimEnd") ? function trimEnd() {
  return $trimEnd(this);
} : "".trimEnd;
var $$2N = _export;
var trimEnd$1 = stringTrimEnd;
$$2N({ target: "String", proto: true, name: "trimEnd", forced: "".trimRight !== trimEnd$1 }, {
  trimRight: trimEnd$1
});
var $$2M = _export;
var trimEnd2 = stringTrimEnd;
$$2M({ target: "String", proto: true, name: "trimEnd", forced: "".trimEnd !== trimEnd2 }, {
  trimEnd: trimEnd2
});
var $trimStart = stringTrim.start;
var forcedStringTrimMethod = stringTrimForced;
var stringTrimStart = forcedStringTrimMethod("trimStart") ? function trimStart() {
  return $trimStart(this);
} : "".trimStart;
var $$2L = _export;
var trimStart$1 = stringTrimStart;
$$2L({ target: "String", proto: true, name: "trimStart", forced: "".trimLeft !== trimStart$1 }, {
  trimLeft: trimStart$1
});
var $$2K = _export;
var trimStart2 = stringTrimStart;
$$2K({ target: "String", proto: true, name: "trimStart", forced: "".trimStart !== trimStart2 }, {
  trimStart: trimStart2
});
var uncurryThis$Q = functionUncurryThis;
var requireObjectCoercible$2 = requireObjectCoercible$q;
var toString$e = toString$K;
var quot = /"/g;
var replace$6 = uncurryThis$Q("".replace);
var createHtml = function(string, tag, attribute, value) {
  var S2 = toString$e(requireObjectCoercible$2(string));
  var p1 = "<" + tag;
  if (attribute !== "") p1 += " " + attribute + '="' + replace$6(toString$e(value), quot, "&quot;") + '"';
  return p1 + ">" + S2 + "</" + tag + ">";
};
var fails$l = fails$1z;
var stringHtmlForced = function(METHOD_NAME) {
  return fails$l(function() {
    var test2 = ""[METHOD_NAME]('"');
    return test2 !== test2.toLowerCase() || test2.split('"').length > 3;
  });
};
var $$2J = _export;
var createHTML$c = createHtml;
var forcedStringHTMLMethod$c = stringHtmlForced;
$$2J({ target: "String", proto: true, forced: forcedStringHTMLMethod$c("anchor") }, {
  anchor: function anchor(name) {
    return createHTML$c(this, "a", "name", name);
  }
});
var $$2I = _export;
var createHTML$b = createHtml;
var forcedStringHTMLMethod$b = stringHtmlForced;
$$2I({ target: "String", proto: true, forced: forcedStringHTMLMethod$b("big") }, {
  big: function big() {
    return createHTML$b(this, "big", "", "");
  }
});
var $$2H = _export;
var createHTML$a = createHtml;
var forcedStringHTMLMethod$a = stringHtmlForced;
$$2H({ target: "String", proto: true, forced: forcedStringHTMLMethod$a("blink") }, {
  blink: function blink() {
    return createHTML$a(this, "blink", "", "");
  }
});
var $$2G = _export;
var createHTML$9 = createHtml;
var forcedStringHTMLMethod$9 = stringHtmlForced;
$$2G({ target: "String", proto: true, forced: forcedStringHTMLMethod$9("bold") }, {
  bold: function bold() {
    return createHTML$9(this, "b", "", "");
  }
});
var $$2F = _export;
var createHTML$8 = createHtml;
var forcedStringHTMLMethod$8 = stringHtmlForced;
$$2F({ target: "String", proto: true, forced: forcedStringHTMLMethod$8("fixed") }, {
  fixed: function fixed() {
    return createHTML$8(this, "tt", "", "");
  }
});
var $$2E = _export;
var createHTML$7 = createHtml;
var forcedStringHTMLMethod$7 = stringHtmlForced;
$$2E({ target: "String", proto: true, forced: forcedStringHTMLMethod$7("fontcolor") }, {
  fontcolor: function fontcolor(color2) {
    return createHTML$7(this, "font", "color", color2);
  }
});
var $$2D = _export;
var createHTML$6 = createHtml;
var forcedStringHTMLMethod$6 = stringHtmlForced;
$$2D({ target: "String", proto: true, forced: forcedStringHTMLMethod$6("fontsize") }, {
  fontsize: function fontsize(size3) {
    return createHTML$6(this, "font", "size", size3);
  }
});
var $$2C = _export;
var createHTML$5 = createHtml;
var forcedStringHTMLMethod$5 = stringHtmlForced;
$$2C({ target: "String", proto: true, forced: forcedStringHTMLMethod$5("italics") }, {
  italics: function italics() {
    return createHTML$5(this, "i", "", "");
  }
});
var $$2B = _export;
var createHTML$4 = createHtml;
var forcedStringHTMLMethod$4 = stringHtmlForced;
$$2B({ target: "String", proto: true, forced: forcedStringHTMLMethod$4("link") }, {
  link: function link(url) {
    return createHTML$4(this, "a", "href", url);
  }
});
var $$2A = _export;
var createHTML$3 = createHtml;
var forcedStringHTMLMethod$3 = stringHtmlForced;
$$2A({ target: "String", proto: true, forced: forcedStringHTMLMethod$3("small") }, {
  small: function small() {
    return createHTML$3(this, "small", "", "");
  }
});
var $$2z = _export;
var createHTML$2 = createHtml;
var forcedStringHTMLMethod$2 = stringHtmlForced;
$$2z({ target: "String", proto: true, forced: forcedStringHTMLMethod$2("strike") }, {
  strike: function strike() {
    return createHTML$2(this, "strike", "", "");
  }
});
var $$2y = _export;
var createHTML$1 = createHtml;
var forcedStringHTMLMethod$1 = stringHtmlForced;
$$2y({ target: "String", proto: true, forced: forcedStringHTMLMethod$1("sub") }, {
  sub: function sub() {
    return createHTML$1(this, "sub", "", "");
  }
});
var $$2x = _export;
var createHTML = createHtml;
var forcedStringHTMLMethod = stringHtmlForced;
$$2x({ target: "String", proto: true, forced: forcedStringHTMLMethod("sup") }, {
  sup: function sup() {
    return createHTML(this, "sup", "", "");
  }
});
var typedArrayConstructor = { exports: {} };
var globalThis$A = globalThis_1;
var fails$k = fails$1z;
var checkCorrectnessOfIteration = checkCorrectnessOfIteration$4;
var NATIVE_ARRAY_BUFFER_VIEWS$1 = arrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;
var ArrayBuffer$2 = globalThis$A.ArrayBuffer;
var Int8Array$3 = globalThis$A.Int8Array;
var typedArrayConstructorsRequireWrappers = !NATIVE_ARRAY_BUFFER_VIEWS$1 || !fails$k(function() {
  Int8Array$3(1);
}) || !fails$k(function() {
  new Int8Array$3(-1);
}) || !checkCorrectnessOfIteration(function(iterable) {
  new Int8Array$3();
  new Int8Array$3(null);
  new Int8Array$3(1.5);
  new Int8Array$3(iterable);
}, true) || fails$k(function() {
  return new Int8Array$3(new ArrayBuffer$2(2), 1, void 0).length !== 1;
});
var toPositiveInteger$2 = toPositiveInteger$5;
var $RangeError$4 = RangeError;
var toOffset$2 = function(it, BYTES) {
  var offset = toPositiveInteger$2(it);
  if (offset % BYTES) throw new $RangeError$4("Wrong offset");
  return offset;
};
var round$1 = Math.round;
var toUint8Clamped$2 = function(it) {
  var value = round$1(it);
  return value < 0 ? 0 : value > 255 ? 255 : value & 255;
};
var classof$7 = classof$p;
var isBigIntArray$3 = function(it) {
  var klass = classof$7(it);
  return klass === "BigInt64Array" || klass === "BigUint64Array";
};
var toPrimitive = toPrimitive$4;
var $TypeError$k = TypeError;
var toBigInt$4 = function(argument) {
  var prim = toPrimitive(argument, "number");
  if (typeof prim == "number") throw new $TypeError$k("Can't convert number to bigint");
  return BigInt(prim);
};
var bind$k = functionBindContext;
var call$D = functionCall;
var aConstructor$1 = aConstructor$4;
var toObject$a = toObject$E;
var lengthOfArrayLike$c = lengthOfArrayLike$B;
var getIterator$4 = getIterator$7;
var getIteratorMethod$4 = getIteratorMethod$9;
var isArrayIteratorMethod = isArrayIteratorMethod$3;
var isBigIntArray$2 = isBigIntArray$3;
var aTypedArrayConstructor$2 = arrayBufferViewCore.aTypedArrayConstructor;
var toBigInt$3 = toBigInt$4;
var typedArrayFrom$2 = function from3(source) {
  var C2 = aConstructor$1(this);
  var O2 = toObject$a(source);
  var argumentsLength = arguments.length;
  var mapfn = argumentsLength > 1 ? arguments[1] : void 0;
  var mapping = mapfn !== void 0;
  var iteratorMethod = getIteratorMethod$4(O2);
  var i, length2, result, thisIsBigIntArray, value, step, iterator, next11;
  if (iteratorMethod && !isArrayIteratorMethod(iteratorMethod)) {
    iterator = getIterator$4(O2, iteratorMethod);
    next11 = iterator.next;
    O2 = [];
    while (!(step = call$D(next11, iterator)).done) {
      O2.push(step.value);
    }
  }
  if (mapping && argumentsLength > 2) {
    mapfn = bind$k(mapfn, arguments[2]);
  }
  length2 = lengthOfArrayLike$c(O2);
  result = new (aTypedArrayConstructor$2(C2))(length2);
  thisIsBigIntArray = isBigIntArray$2(result);
  for (i = 0; length2 > i; i++) {
    value = mapping ? mapfn(O2[i], i) : O2[i];
    result[i] = thisIsBigIntArray ? toBigInt$3(value) : +value;
  }
  return result;
};
var $$2w = _export;
var globalThis$z = globalThis_1;
var call$C = functionCall;
var DESCRIPTORS$g = descriptors$1;
var TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS$2 = typedArrayConstructorsRequireWrappers;
var ArrayBufferViewCore$z = arrayBufferViewCore;
var ArrayBufferModule = arrayBuffer;
var anInstance$9 = anInstance$f;
var createPropertyDescriptor$4 = createPropertyDescriptor$d;
var createNonEnumerableProperty$6 = createNonEnumerableProperty$j;
var isIntegralNumber = isIntegralNumber$3;
var toLength$1 = toLength$d;
var toIndex$2 = toIndex$5;
var toOffset$1 = toOffset$2;
var toUint8Clamped$1 = toUint8Clamped$2;
var toPropertyKey$1 = toPropertyKey$9;
var hasOwn$h = hasOwnProperty_1;
var classof$6 = classof$p;
var isObject$h = isObject$O;
var isSymbol$2 = isSymbol$8;
var create$8 = objectCreate$1;
var isPrototypeOf$2 = objectIsPrototypeOf;
var setPrototypeOf$1 = objectSetPrototypeOf$1;
var getOwnPropertyNames$1 = objectGetOwnPropertyNames.f;
var typedArrayFrom$1 = typedArrayFrom$2;
var forEach$5 = arrayIteration.forEach;
var setSpecies$1 = setSpecies$7;
var defineBuiltInAccessor$b = defineBuiltInAccessor$p;
var definePropertyModule = objectDefineProperty;
var getOwnPropertyDescriptorModule = objectGetOwnPropertyDescriptor;
var arrayFromConstructorAndList$6 = arrayFromConstructorAndList$8;
var InternalStateModule$d = internalState;
var inheritIfRequired$1 = inheritIfRequired$7;
var getInternalState$7 = InternalStateModule$d.get;
var setInternalState$e = InternalStateModule$d.set;
var enforceInternalState$1 = InternalStateModule$d.enforce;
var nativeDefineProperty = definePropertyModule.f;
var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
var RangeError$2 = globalThis$z.RangeError;
var ArrayBuffer$1 = ArrayBufferModule.ArrayBuffer;
var ArrayBufferPrototype = ArrayBuffer$1.prototype;
var DataView$1 = ArrayBufferModule.DataView;
var NATIVE_ARRAY_BUFFER_VIEWS = ArrayBufferViewCore$z.NATIVE_ARRAY_BUFFER_VIEWS;
var TYPED_ARRAY_TAG = ArrayBufferViewCore$z.TYPED_ARRAY_TAG;
var TypedArray = ArrayBufferViewCore$z.TypedArray;
var TypedArrayPrototype$1 = ArrayBufferViewCore$z.TypedArrayPrototype;
var isTypedArray$1 = ArrayBufferViewCore$z.isTypedArray;
var BYTES_PER_ELEMENT = "BYTES_PER_ELEMENT";
var WRONG_LENGTH = "Wrong length";
var addGetter$1 = function(it, key) {
  defineBuiltInAccessor$b(it, key, {
    configurable: true,
    get: function() {
      return getInternalState$7(this)[key];
    }
  });
};
var isArrayBuffer$1 = function(it) {
  var klass;
  return isPrototypeOf$2(ArrayBufferPrototype, it) || (klass = classof$6(it)) === "ArrayBuffer" || klass === "SharedArrayBuffer";
};
var isTypedArrayIndex = function(target, key) {
  return isTypedArray$1(target) && !isSymbol$2(key) && key in target && isIntegralNumber(+key) && key >= 0;
};
var wrappedGetOwnPropertyDescriptor = function getOwnPropertyDescriptor5(target, key) {
  key = toPropertyKey$1(key);
  return isTypedArrayIndex(target, key) ? createPropertyDescriptor$4(2, target[key]) : nativeGetOwnPropertyDescriptor(target, key);
};
var wrappedDefineProperty = function defineProperty5(target, key, descriptor) {
  key = toPropertyKey$1(key);
  if (isTypedArrayIndex(target, key) && isObject$h(descriptor) && hasOwn$h(descriptor, "value") && !hasOwn$h(descriptor, "get") && !hasOwn$h(descriptor, "set") && !descriptor.configurable && (!hasOwn$h(descriptor, "writable") || descriptor.writable) && (!hasOwn$h(descriptor, "enumerable") || descriptor.enumerable)) {
    target[key] = descriptor.value;
    return target;
  }
  return nativeDefineProperty(target, key, descriptor);
};
if (DESCRIPTORS$g) {
  if (!NATIVE_ARRAY_BUFFER_VIEWS) {
    getOwnPropertyDescriptorModule.f = wrappedGetOwnPropertyDescriptor;
    definePropertyModule.f = wrappedDefineProperty;
    addGetter$1(TypedArrayPrototype$1, "buffer");
    addGetter$1(TypedArrayPrototype$1, "byteOffset");
    addGetter$1(TypedArrayPrototype$1, "byteLength");
    addGetter$1(TypedArrayPrototype$1, "length");
  }
  $$2w({ target: "Object", stat: true, forced: !NATIVE_ARRAY_BUFFER_VIEWS }, {
    getOwnPropertyDescriptor: wrappedGetOwnPropertyDescriptor,
    defineProperty: wrappedDefineProperty
  });
  typedArrayConstructor.exports = function(TYPE, wrapper2, CLAMPED) {
    var BYTES = TYPE.match(/\d+/)[0] / 8;
    var CONSTRUCTOR_NAME = TYPE + (CLAMPED ? "Clamped" : "") + "Array";
    var GETTER = "get" + TYPE;
    var SETTER = "set" + TYPE;
    var NativeTypedArrayConstructor = globalThis$z[CONSTRUCTOR_NAME];
    var TypedArrayConstructor = NativeTypedArrayConstructor;
    var TypedArrayConstructorPrototype = TypedArrayConstructor && TypedArrayConstructor.prototype;
    var exported = {};
    var getter = function(that, index) {
      var data2 = getInternalState$7(that);
      return data2.view[GETTER](index * BYTES + data2.byteOffset, true);
    };
    var setter = function(that, index, value) {
      var data2 = getInternalState$7(that);
      data2.view[SETTER](index * BYTES + data2.byteOffset, CLAMPED ? toUint8Clamped$1(value) : value, true);
    };
    var addElement = function(that, index) {
      nativeDefineProperty(that, index, {
        get: function() {
          return getter(this, index);
        },
        set: function(value) {
          return setter(this, index, value);
        },
        enumerable: true
      });
    };
    if (!NATIVE_ARRAY_BUFFER_VIEWS) {
      TypedArrayConstructor = wrapper2(function(that, data2, offset, $length) {
        anInstance$9(that, TypedArrayConstructorPrototype);
        var index = 0;
        var byteOffset = 0;
        var buffer2, byteLength, length2;
        if (!isObject$h(data2)) {
          length2 = toIndex$2(data2);
          byteLength = length2 * BYTES;
          buffer2 = new ArrayBuffer$1(byteLength);
        } else if (isArrayBuffer$1(data2)) {
          buffer2 = data2;
          byteOffset = toOffset$1(offset, BYTES);
          var $len = data2.byteLength;
          if ($length === void 0) {
            if ($len % BYTES) throw new RangeError$2(WRONG_LENGTH);
            byteLength = $len - byteOffset;
            if (byteLength < 0) throw new RangeError$2(WRONG_LENGTH);
          } else {
            byteLength = toLength$1($length) * BYTES;
            if (byteLength + byteOffset > $len) throw new RangeError$2(WRONG_LENGTH);
          }
          length2 = byteLength / BYTES;
        } else if (isTypedArray$1(data2)) {
          return arrayFromConstructorAndList$6(TypedArrayConstructor, data2);
        } else {
          return call$C(typedArrayFrom$1, TypedArrayConstructor, data2);
        }
        setInternalState$e(that, {
          buffer: buffer2,
          byteOffset,
          byteLength,
          length: length2,
          view: new DataView$1(buffer2)
        });
        while (index < length2) addElement(that, index++);
      });
      if (setPrototypeOf$1) setPrototypeOf$1(TypedArrayConstructor, TypedArray);
      TypedArrayConstructorPrototype = TypedArrayConstructor.prototype = create$8(TypedArrayPrototype$1);
    } else if (TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS$2) {
      TypedArrayConstructor = wrapper2(function(dummy, data2, typedArrayOffset, $length) {
        anInstance$9(dummy, TypedArrayConstructorPrototype);
        return inheritIfRequired$1(function() {
          if (!isObject$h(data2)) return new NativeTypedArrayConstructor(toIndex$2(data2));
          if (isArrayBuffer$1(data2)) return $length !== void 0 ? new NativeTypedArrayConstructor(data2, toOffset$1(typedArrayOffset, BYTES), $length) : typedArrayOffset !== void 0 ? new NativeTypedArrayConstructor(data2, toOffset$1(typedArrayOffset, BYTES)) : new NativeTypedArrayConstructor(data2);
          if (isTypedArray$1(data2)) return arrayFromConstructorAndList$6(TypedArrayConstructor, data2);
          return call$C(typedArrayFrom$1, TypedArrayConstructor, data2);
        }(), dummy, TypedArrayConstructor);
      });
      if (setPrototypeOf$1) setPrototypeOf$1(TypedArrayConstructor, TypedArray);
      forEach$5(getOwnPropertyNames$1(NativeTypedArrayConstructor), function(key) {
        if (!(key in TypedArrayConstructor)) {
          createNonEnumerableProperty$6(TypedArrayConstructor, key, NativeTypedArrayConstructor[key]);
        }
      });
      TypedArrayConstructor.prototype = TypedArrayConstructorPrototype;
    }
    if (TypedArrayConstructorPrototype.constructor !== TypedArrayConstructor) {
      createNonEnumerableProperty$6(TypedArrayConstructorPrototype, "constructor", TypedArrayConstructor);
    }
    enforceInternalState$1(TypedArrayConstructorPrototype).TypedArrayConstructor = TypedArrayConstructor;
    if (TYPED_ARRAY_TAG) {
      createNonEnumerableProperty$6(TypedArrayConstructorPrototype, TYPED_ARRAY_TAG, CONSTRUCTOR_NAME);
    }
    var FORCED2 = TypedArrayConstructor !== NativeTypedArrayConstructor;
    exported[CONSTRUCTOR_NAME] = TypedArrayConstructor;
    $$2w({ global: true, constructor: true, forced: FORCED2, sham: !NATIVE_ARRAY_BUFFER_VIEWS }, exported);
    if (!(BYTES_PER_ELEMENT in TypedArrayConstructor)) {
      createNonEnumerableProperty$6(TypedArrayConstructor, BYTES_PER_ELEMENT, BYTES);
    }
    if (!(BYTES_PER_ELEMENT in TypedArrayConstructorPrototype)) {
      createNonEnumerableProperty$6(TypedArrayConstructorPrototype, BYTES_PER_ELEMENT, BYTES);
    }
    setSpecies$1(CONSTRUCTOR_NAME);
  };
} else typedArrayConstructor.exports = function() {
};
var typedArrayConstructorExports = typedArrayConstructor.exports;
var createTypedArrayConstructor$8 = typedArrayConstructorExports;
createTypedArrayConstructor$8("Float32", function(init) {
  return function Float32Array(data2, byteOffset, length2) {
    return init(this, data2, byteOffset, length2);
  };
});
var createTypedArrayConstructor$7 = typedArrayConstructorExports;
createTypedArrayConstructor$7("Float64", function(init) {
  return function Float64Array(data2, byteOffset, length2) {
    return init(this, data2, byteOffset, length2);
  };
});
var createTypedArrayConstructor$6 = typedArrayConstructorExports;
createTypedArrayConstructor$6("Int8", function(init) {
  return function Int8Array2(data2, byteOffset, length2) {
    return init(this, data2, byteOffset, length2);
  };
});
var createTypedArrayConstructor$5 = typedArrayConstructorExports;
createTypedArrayConstructor$5("Int16", function(init) {
  return function Int16Array(data2, byteOffset, length2) {
    return init(this, data2, byteOffset, length2);
  };
});
var createTypedArrayConstructor$4 = typedArrayConstructorExports;
createTypedArrayConstructor$4("Int32", function(init) {
  return function Int32Array(data2, byteOffset, length2) {
    return init(this, data2, byteOffset, length2);
  };
});
var createTypedArrayConstructor$3 = typedArrayConstructorExports;
createTypedArrayConstructor$3("Uint8", function(init) {
  return function Uint8Array2(data2, byteOffset, length2) {
    return init(this, data2, byteOffset, length2);
  };
});
var createTypedArrayConstructor$2 = typedArrayConstructorExports;
createTypedArrayConstructor$2("Uint8", function(init) {
  return function Uint8ClampedArray2(data2, byteOffset, length2) {
    return init(this, data2, byteOffset, length2);
  };
}, true);
var createTypedArrayConstructor$1 = typedArrayConstructorExports;
createTypedArrayConstructor$1("Uint16", function(init) {
  return function Uint16Array2(data2, byteOffset, length2) {
    return init(this, data2, byteOffset, length2);
  };
});
var createTypedArrayConstructor = typedArrayConstructorExports;
createTypedArrayConstructor("Uint32", function(init) {
  return function Uint32Array(data2, byteOffset, length2) {
    return init(this, data2, byteOffset, length2);
  };
});
var ArrayBufferViewCore$y = arrayBufferViewCore;
var lengthOfArrayLike$b = lengthOfArrayLike$B;
var toIntegerOrInfinity$4 = toIntegerOrInfinity$p;
var aTypedArray$w = ArrayBufferViewCore$y.aTypedArray;
var exportTypedArrayMethod$x = ArrayBufferViewCore$y.exportTypedArrayMethod;
exportTypedArrayMethod$x("at", function at3(index) {
  var O2 = aTypedArray$w(this);
  var len = lengthOfArrayLike$b(O2);
  var relativeIndex = toIntegerOrInfinity$4(index);
  var k2 = relativeIndex >= 0 ? relativeIndex : len + relativeIndex;
  return k2 < 0 || k2 >= len ? void 0 : O2[k2];
});
var uncurryThis$P = functionUncurryThis;
var ArrayBufferViewCore$x = arrayBufferViewCore;
var $ArrayCopyWithin = arrayCopyWithin;
var u$ArrayCopyWithin = uncurryThis$P($ArrayCopyWithin);
var aTypedArray$v = ArrayBufferViewCore$x.aTypedArray;
var exportTypedArrayMethod$w = ArrayBufferViewCore$x.exportTypedArrayMethod;
exportTypedArrayMethod$w("copyWithin", function copyWithin3(target, start) {
  return u$ArrayCopyWithin(aTypedArray$v(this), target, start, arguments.length > 2 ? arguments[2] : void 0);
});
var ArrayBufferViewCore$w = arrayBufferViewCore;
var $every$1 = arrayIteration.every;
var aTypedArray$u = ArrayBufferViewCore$w.aTypedArray;
var exportTypedArrayMethod$v = ArrayBufferViewCore$w.exportTypedArrayMethod;
exportTypedArrayMethod$v("every", function every3(callbackfn) {
  return $every$1(aTypedArray$u(this), callbackfn, arguments.length > 1 ? arguments[1] : void 0);
});
var ArrayBufferViewCore$v = arrayBufferViewCore;
var $fill = arrayFill$1;
var toBigInt$2 = toBigInt$4;
var classof$5 = classof$p;
var call$B = functionCall;
var uncurryThis$O = functionUncurryThis;
var fails$j = fails$1z;
var aTypedArray$t = ArrayBufferViewCore$v.aTypedArray;
var exportTypedArrayMethod$u = ArrayBufferViewCore$v.exportTypedArrayMethod;
var slice$5 = uncurryThis$O("".slice);
var CONVERSION_BUG = fails$j(function() {
  var count = 0;
  new Int8Array(2).fill({ valueOf: function() {
    return count++;
  } });
  return count !== 1;
});
exportTypedArrayMethod$u("fill", function fill3(value) {
  var length2 = arguments.length;
  aTypedArray$t(this);
  var actualValue = slice$5(classof$5(this), 0, 3) === "Big" ? toBigInt$2(value) : +value;
  return call$B($fill, this, actualValue, length2 > 1 ? arguments[1] : void 0, length2 > 2 ? arguments[2] : void 0);
}, CONVERSION_BUG);
var arrayFromConstructorAndList$5 = arrayFromConstructorAndList$8;
var getTypedArrayConstructor$9 = arrayBufferViewCore.getTypedArrayConstructor;
var typedArrayFromSameTypeAndList = function(instance, list) {
  return arrayFromConstructorAndList$5(getTypedArrayConstructor$9(instance), list);
};
var ArrayBufferViewCore$u = arrayBufferViewCore;
var $filter = arrayIteration.filter;
var fromSameTypeAndList$2 = typedArrayFromSameTypeAndList;
var aTypedArray$s = ArrayBufferViewCore$u.aTypedArray;
var exportTypedArrayMethod$t = ArrayBufferViewCore$u.exportTypedArrayMethod;
exportTypedArrayMethod$t("filter", function filter3(callbackfn) {
  var list = $filter(aTypedArray$s(this), callbackfn, arguments.length > 1 ? arguments[1] : void 0);
  return fromSameTypeAndList$2(this, list);
});
var ArrayBufferViewCore$t = arrayBufferViewCore;
var $find$1 = arrayIteration.find;
var aTypedArray$r = ArrayBufferViewCore$t.aTypedArray;
var exportTypedArrayMethod$s = ArrayBufferViewCore$t.exportTypedArrayMethod;
exportTypedArrayMethod$s("find", function find3(predicate) {
  return $find$1(aTypedArray$r(this), predicate, arguments.length > 1 ? arguments[1] : void 0);
});
var ArrayBufferViewCore$s = arrayBufferViewCore;
var $findIndex = arrayIteration.findIndex;
var aTypedArray$q = ArrayBufferViewCore$s.aTypedArray;
var exportTypedArrayMethod$r = ArrayBufferViewCore$s.exportTypedArrayMethod;
exportTypedArrayMethod$r("findIndex", function findIndex2(predicate) {
  return $findIndex(aTypedArray$q(this), predicate, arguments.length > 1 ? arguments[1] : void 0);
});
var ArrayBufferViewCore$r = arrayBufferViewCore;
var $findLast = arrayIterationFromLast.findLast;
var aTypedArray$p = ArrayBufferViewCore$r.aTypedArray;
var exportTypedArrayMethod$q = ArrayBufferViewCore$r.exportTypedArrayMethod;
exportTypedArrayMethod$q("findLast", function findLast2(predicate) {
  return $findLast(aTypedArray$p(this), predicate, arguments.length > 1 ? arguments[1] : void 0);
});
var ArrayBufferViewCore$q = arrayBufferViewCore;
var $findLastIndex = arrayIterationFromLast.findLastIndex;
var aTypedArray$o = ArrayBufferViewCore$q.aTypedArray;
var exportTypedArrayMethod$p = ArrayBufferViewCore$q.exportTypedArrayMethod;
exportTypedArrayMethod$p("findLastIndex", function findLastIndex2(predicate) {
  return $findLastIndex(aTypedArray$o(this), predicate, arguments.length > 1 ? arguments[1] : void 0);
});
var ArrayBufferViewCore$p = arrayBufferViewCore;
var $forEach$1 = arrayIteration.forEach;
var aTypedArray$n = ArrayBufferViewCore$p.aTypedArray;
var exportTypedArrayMethod$o = ArrayBufferViewCore$p.exportTypedArrayMethod;
exportTypedArrayMethod$o("forEach", function forEach3(callbackfn) {
  $forEach$1(aTypedArray$n(this), callbackfn, arguments.length > 1 ? arguments[1] : void 0);
});
var TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS$1 = typedArrayConstructorsRequireWrappers;
var exportTypedArrayStaticMethod$2 = arrayBufferViewCore.exportTypedArrayStaticMethod;
var typedArrayFrom = typedArrayFrom$2;
exportTypedArrayStaticMethod$2("from", typedArrayFrom, TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS$1);
var ArrayBufferViewCore$o = arrayBufferViewCore;
var $includes = arrayIncludes.includes;
var aTypedArray$m = ArrayBufferViewCore$o.aTypedArray;
var exportTypedArrayMethod$n = ArrayBufferViewCore$o.exportTypedArrayMethod;
exportTypedArrayMethod$n("includes", function includes3(searchElement) {
  return $includes(aTypedArray$m(this), searchElement, arguments.length > 1 ? arguments[1] : void 0);
});
var ArrayBufferViewCore$n = arrayBufferViewCore;
var $indexOf = arrayIncludes.indexOf;
var aTypedArray$l = ArrayBufferViewCore$n.aTypedArray;
var exportTypedArrayMethod$m = ArrayBufferViewCore$n.exportTypedArrayMethod;
exportTypedArrayMethod$m("indexOf", function indexOf3(searchElement) {
  return $indexOf(aTypedArray$l(this), searchElement, arguments.length > 1 ? arguments[1] : void 0);
});
var globalThis$y = globalThis_1;
var fails$i = fails$1z;
var uncurryThis$N = functionUncurryThis;
var ArrayBufferViewCore$m = arrayBufferViewCore;
var ArrayIterators = es_array_iterator;
var wellKnownSymbol$k = wellKnownSymbol$S;
var ITERATOR$4 = wellKnownSymbol$k("iterator");
var Uint8Array$5 = globalThis$y.Uint8Array;
var arrayValues = uncurryThis$N(ArrayIterators.values);
var arrayKeys = uncurryThis$N(ArrayIterators.keys);
var arrayEntries = uncurryThis$N(ArrayIterators.entries);
var aTypedArray$k = ArrayBufferViewCore$m.aTypedArray;
var exportTypedArrayMethod$l = ArrayBufferViewCore$m.exportTypedArrayMethod;
var TypedArrayPrototype = Uint8Array$5 && Uint8Array$5.prototype;
var GENERIC = !fails$i(function() {
  TypedArrayPrototype[ITERATOR$4].call([1]);
});
var ITERATOR_IS_VALUES = !!TypedArrayPrototype && TypedArrayPrototype.values && TypedArrayPrototype[ITERATOR$4] === TypedArrayPrototype.values && TypedArrayPrototype.values.name === "values";
var typedArrayValues = function values2() {
  return arrayValues(aTypedArray$k(this));
};
exportTypedArrayMethod$l("entries", function entries2() {
  return arrayEntries(aTypedArray$k(this));
}, GENERIC);
exportTypedArrayMethod$l("keys", function keys4() {
  return arrayKeys(aTypedArray$k(this));
}, GENERIC);
exportTypedArrayMethod$l("values", typedArrayValues, GENERIC || !ITERATOR_IS_VALUES, { name: "values" });
exportTypedArrayMethod$l(ITERATOR$4, typedArrayValues, GENERIC || !ITERATOR_IS_VALUES, { name: "values" });
var ArrayBufferViewCore$l = arrayBufferViewCore;
var uncurryThis$M = functionUncurryThis;
var aTypedArray$j = ArrayBufferViewCore$l.aTypedArray;
var exportTypedArrayMethod$k = ArrayBufferViewCore$l.exportTypedArrayMethod;
var $join = uncurryThis$M([].join);
exportTypedArrayMethod$k("join", function join2(separator) {
  return $join(aTypedArray$j(this), separator);
});
var ArrayBufferViewCore$k = arrayBufferViewCore;
var apply$5 = functionApply$1;
var $lastIndexOf = arrayLastIndexOf;
var aTypedArray$i = ArrayBufferViewCore$k.aTypedArray;
var exportTypedArrayMethod$j = ArrayBufferViewCore$k.exportTypedArrayMethod;
exportTypedArrayMethod$j("lastIndexOf", function lastIndexOf3(searchElement) {
  var length2 = arguments.length;
  return apply$5($lastIndexOf, aTypedArray$i(this), length2 > 1 ? [searchElement, arguments[1]] : [searchElement]);
});
var ArrayBufferViewCore$j = arrayBufferViewCore;
var $map = arrayIteration.map;
var aTypedArray$h = ArrayBufferViewCore$j.aTypedArray;
var getTypedArrayConstructor$8 = ArrayBufferViewCore$j.getTypedArrayConstructor;
var exportTypedArrayMethod$i = ArrayBufferViewCore$j.exportTypedArrayMethod;
exportTypedArrayMethod$i("map", function map3(mapfn) {
  return $map(aTypedArray$h(this), mapfn, arguments.length > 1 ? arguments[1] : void 0, function(O2, length2) {
    return new (getTypedArrayConstructor$8(O2))(length2);
  });
});
var ArrayBufferViewCore$i = arrayBufferViewCore;
var TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS = typedArrayConstructorsRequireWrappers;
var aTypedArrayConstructor$1 = ArrayBufferViewCore$i.aTypedArrayConstructor;
var exportTypedArrayStaticMethod$1 = ArrayBufferViewCore$i.exportTypedArrayStaticMethod;
exportTypedArrayStaticMethod$1("of", function of3() {
  var index = 0;
  var length2 = arguments.length;
  var result = new (aTypedArrayConstructor$1(this))(length2);
  while (length2 > index) result[index] = arguments[index++];
  return result;
}, TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS);
var ArrayBufferViewCore$h = arrayBufferViewCore;
var $reduce = arrayReduce.left;
var aTypedArray$g = ArrayBufferViewCore$h.aTypedArray;
var exportTypedArrayMethod$h = ArrayBufferViewCore$h.exportTypedArrayMethod;
exportTypedArrayMethod$h("reduce", function reduce3(callbackfn) {
  var length2 = arguments.length;
  return $reduce(aTypedArray$g(this), callbackfn, length2, length2 > 1 ? arguments[1] : void 0);
});
var ArrayBufferViewCore$g = arrayBufferViewCore;
var $reduceRight = arrayReduce.right;
var aTypedArray$f = ArrayBufferViewCore$g.aTypedArray;
var exportTypedArrayMethod$g = ArrayBufferViewCore$g.exportTypedArrayMethod;
exportTypedArrayMethod$g("reduceRight", function reduceRight2(callbackfn) {
  var length2 = arguments.length;
  return $reduceRight(aTypedArray$f(this), callbackfn, length2, length2 > 1 ? arguments[1] : void 0);
});
var ArrayBufferViewCore$f = arrayBufferViewCore;
var aTypedArray$e = ArrayBufferViewCore$f.aTypedArray;
var exportTypedArrayMethod$f = ArrayBufferViewCore$f.exportTypedArrayMethod;
var floor$2 = Math.floor;
exportTypedArrayMethod$f("reverse", function reverse3() {
  var that = this;
  var length2 = aTypedArray$e(that).length;
  var middle = floor$2(length2 / 2);
  var index = 0;
  var value;
  while (index < middle) {
    value = that[index];
    that[index++] = that[--length2];
    that[length2] = value;
  }
  return that;
});
var globalThis$x = globalThis_1;
var call$A = functionCall;
var ArrayBufferViewCore$e = arrayBufferViewCore;
var lengthOfArrayLike$a = lengthOfArrayLike$B;
var toOffset = toOffset$2;
var toIndexedObject$1 = toObject$E;
var fails$h = fails$1z;
var RangeError$1 = globalThis$x.RangeError;
var Int8Array$2 = globalThis$x.Int8Array;
var Int8ArrayPrototype = Int8Array$2 && Int8Array$2.prototype;
var $set = Int8ArrayPrototype && Int8ArrayPrototype.set;
var aTypedArray$d = ArrayBufferViewCore$e.aTypedArray;
var exportTypedArrayMethod$e = ArrayBufferViewCore$e.exportTypedArrayMethod;
var WORKS_WITH_OBJECTS_AND_GENERIC_ON_TYPED_ARRAYS = !fails$h(function() {
  var array = new Uint8ClampedArray(2);
  call$A($set, array, { length: 1, 0: 3 }, 1);
  return array[1] !== 3;
});
var TO_OBJECT_BUG = WORKS_WITH_OBJECTS_AND_GENERIC_ON_TYPED_ARRAYS && ArrayBufferViewCore$e.NATIVE_ARRAY_BUFFER_VIEWS && fails$h(function() {
  var array = new Int8Array$2(2);
  array.set(1);
  array.set("2", 1);
  return array[0] !== 0 || array[1] !== 2;
});
exportTypedArrayMethod$e("set", function set(arrayLike) {
  aTypedArray$d(this);
  var offset = toOffset(arguments.length > 1 ? arguments[1] : void 0, 1);
  var src = toIndexedObject$1(arrayLike);
  if (WORKS_WITH_OBJECTS_AND_GENERIC_ON_TYPED_ARRAYS) return call$A($set, this, src, offset);
  var length2 = this.length;
  var len = lengthOfArrayLike$a(src);
  var index = 0;
  if (len + offset > length2) throw new RangeError$1("Wrong length");
  while (index < len) this[offset + index] = src[index++];
}, !WORKS_WITH_OBJECTS_AND_GENERIC_ON_TYPED_ARRAYS || TO_OBJECT_BUG);
var ArrayBufferViewCore$d = arrayBufferViewCore;
var fails$g = fails$1z;
var arraySlice$3 = arraySlice$a;
var aTypedArray$c = ArrayBufferViewCore$d.aTypedArray;
var getTypedArrayConstructor$7 = ArrayBufferViewCore$d.getTypedArrayConstructor;
var exportTypedArrayMethod$d = ArrayBufferViewCore$d.exportTypedArrayMethod;
var FORCED$3 = fails$g(function() {
  new Int8Array(1).slice();
});
exportTypedArrayMethod$d("slice", function slice3(start, end) {
  var list = arraySlice$3(aTypedArray$c(this), start, end);
  var C2 = getTypedArrayConstructor$7(this);
  var index = 0;
  var length2 = list.length;
  var result = new C2(length2);
  while (length2 > index) result[index] = list[index++];
  return result;
}, FORCED$3);
var ArrayBufferViewCore$c = arrayBufferViewCore;
var $some$1 = arrayIteration.some;
var aTypedArray$b = ArrayBufferViewCore$c.aTypedArray;
var exportTypedArrayMethod$c = ArrayBufferViewCore$c.exportTypedArrayMethod;
exportTypedArrayMethod$c("some", function some3(callbackfn) {
  return $some$1(aTypedArray$b(this), callbackfn, arguments.length > 1 ? arguments[1] : void 0);
});
var globalThis$w = globalThis_1;
var uncurryThis$L = functionUncurryThisClause;
var fails$f = fails$1z;
var aCallable$l = aCallable$Q;
var internalSort = arraySort$1;
var ArrayBufferViewCore$b = arrayBufferViewCore;
var FF = environmentFfVersion;
var IE_OR_EDGE = environmentIsIeOrEdge;
var V8 = environmentV8Version;
var WEBKIT$2 = environmentWebkitVersion;
var aTypedArray$a = ArrayBufferViewCore$b.aTypedArray;
var exportTypedArrayMethod$b = ArrayBufferViewCore$b.exportTypedArrayMethod;
var Uint16Array = globalThis$w.Uint16Array;
var nativeSort = Uint16Array && uncurryThis$L(Uint16Array.prototype.sort);
var ACCEPT_INCORRECT_ARGUMENTS = !!nativeSort && !(fails$f(function() {
  nativeSort(new Uint16Array(2), null);
}) && fails$f(function() {
  nativeSort(new Uint16Array(2), {});
}));
var STABLE_SORT = !!nativeSort && !fails$f(function() {
  if (V8) return V8 < 74;
  if (FF) return FF < 67;
  if (IE_OR_EDGE) return true;
  if (WEBKIT$2) return WEBKIT$2 < 602;
  var array = new Uint16Array(516);
  var expected = Array(516);
  var index, mod;
  for (index = 0; index < 516; index++) {
    mod = index % 4;
    array[index] = 515 - index;
    expected[index] = index - 2 * mod + 3;
  }
  nativeSort(array, function(a, b2) {
    return (a / 4 | 0) - (b2 / 4 | 0);
  });
  for (index = 0; index < 516; index++) {
    if (array[index] !== expected[index]) return true;
  }
});
var getSortCompare = function(comparefn) {
  return function(x2, y2) {
    if (comparefn !== void 0) return +comparefn(x2, y2) || 0;
    if (y2 !== y2) return -1;
    if (x2 !== x2) return 1;
    if (x2 === 0 && y2 === 0) return 1 / x2 > 0 && 1 / y2 < 0 ? 1 : -1;
    return x2 > y2;
  };
};
exportTypedArrayMethod$b("sort", function sort2(comparefn) {
  if (comparefn !== void 0) aCallable$l(comparefn);
  if (STABLE_SORT) return nativeSort(this, comparefn);
  return internalSort(aTypedArray$a(this), getSortCompare(comparefn));
}, !STABLE_SORT || ACCEPT_INCORRECT_ARGUMENTS);
var ArrayBufferViewCore$a = arrayBufferViewCore;
var toLength = toLength$d;
var toAbsoluteIndex$1 = toAbsoluteIndex$a;
var aTypedArray$9 = ArrayBufferViewCore$a.aTypedArray;
var getTypedArrayConstructor$6 = ArrayBufferViewCore$a.getTypedArrayConstructor;
var exportTypedArrayMethod$a = ArrayBufferViewCore$a.exportTypedArrayMethod;
exportTypedArrayMethod$a("subarray", function subarray(begin, end) {
  var O2 = aTypedArray$9(this);
  var length2 = O2.length;
  var beginIndex = toAbsoluteIndex$1(begin, length2);
  var C2 = getTypedArrayConstructor$6(O2);
  return new C2(
    O2.buffer,
    O2.byteOffset + beginIndex * O2.BYTES_PER_ELEMENT,
    toLength((end === void 0 ? length2 : toAbsoluteIndex$1(end, length2)) - beginIndex)
  );
});
var globalThis$v = globalThis_1;
var apply$4 = functionApply$1;
var ArrayBufferViewCore$9 = arrayBufferViewCore;
var fails$e = fails$1z;
var arraySlice$2 = arraySlice$a;
var Int8Array$1 = globalThis$v.Int8Array;
var aTypedArray$8 = ArrayBufferViewCore$9.aTypedArray;
var exportTypedArrayMethod$9 = ArrayBufferViewCore$9.exportTypedArrayMethod;
var $toLocaleString = [].toLocaleString;
var TO_LOCALE_STRING_BUG = !!Int8Array$1 && fails$e(function() {
  $toLocaleString.call(new Int8Array$1(1));
});
var FORCED$2 = fails$e(function() {
  return [1, 2].toLocaleString() !== new Int8Array$1([1, 2]).toLocaleString();
}) || !fails$e(function() {
  Int8Array$1.prototype.toLocaleString.call([1, 2]);
});
exportTypedArrayMethod$9("toLocaleString", function toLocaleString() {
  return apply$4(
    $toLocaleString,
    TO_LOCALE_STRING_BUG ? arraySlice$2(aTypedArray$8(this)) : aTypedArray$8(this),
    arraySlice$2(arguments)
  );
}, FORCED$2);
var arrayToReversed = arrayToReversed$2;
var ArrayBufferViewCore$8 = arrayBufferViewCore;
var aTypedArray$7 = ArrayBufferViewCore$8.aTypedArray;
var exportTypedArrayMethod$8 = ArrayBufferViewCore$8.exportTypedArrayMethod;
var getTypedArrayConstructor$5 = ArrayBufferViewCore$8.getTypedArrayConstructor;
exportTypedArrayMethod$8("toReversed", function toReversed2() {
  return arrayToReversed(aTypedArray$7(this), getTypedArrayConstructor$5(this));
});
var ArrayBufferViewCore$7 = arrayBufferViewCore;
var uncurryThis$K = functionUncurryThis;
var aCallable$k = aCallable$Q;
var arrayFromConstructorAndList$4 = arrayFromConstructorAndList$8;
var aTypedArray$6 = ArrayBufferViewCore$7.aTypedArray;
var getTypedArrayConstructor$4 = ArrayBufferViewCore$7.getTypedArrayConstructor;
var exportTypedArrayMethod$7 = ArrayBufferViewCore$7.exportTypedArrayMethod;
var sort3 = uncurryThis$K(ArrayBufferViewCore$7.TypedArrayPrototype.sort);
exportTypedArrayMethod$7("toSorted", function toSorted2(compareFn) {
  if (compareFn !== void 0) aCallable$k(compareFn);
  var O2 = aTypedArray$6(this);
  var A2 = arrayFromConstructorAndList$4(getTypedArrayConstructor$4(O2), O2);
  return sort3(A2, compareFn);
});
var exportTypedArrayMethod$6 = arrayBufferViewCore.exportTypedArrayMethod;
var fails$d = fails$1z;
var globalThis$u = globalThis_1;
var uncurryThis$J = functionUncurryThis;
var Uint8Array$4 = globalThis$u.Uint8Array;
var Uint8ArrayPrototype = Uint8Array$4 && Uint8Array$4.prototype || {};
var arrayToString = [].toString;
var join$5 = uncurryThis$J([].join);
if (fails$d(function() {
  arrayToString.call({});
})) {
  arrayToString = function toString8() {
    return join$5(this);
  };
}
var IS_NOT_ARRAY_METHOD = Uint8ArrayPrototype.toString !== arrayToString;
exportTypedArrayMethod$6("toString", arrayToString, IS_NOT_ARRAY_METHOD);
var arrayWith = arrayWith$2;
var ArrayBufferViewCore$6 = arrayBufferViewCore;
var isBigIntArray$1 = isBigIntArray$3;
var toIntegerOrInfinity$3 = toIntegerOrInfinity$p;
var toBigInt$1 = toBigInt$4;
var aTypedArray$5 = ArrayBufferViewCore$6.aTypedArray;
var getTypedArrayConstructor$3 = ArrayBufferViewCore$6.getTypedArrayConstructor;
var exportTypedArrayMethod$5 = ArrayBufferViewCore$6.exportTypedArrayMethod;
var PROPER_ORDER$1 = !!function() {
  try {
    new Int8Array(1)["with"](2, { valueOf: function() {
      throw 8;
    } });
  } catch (error2) {
    return error2 === 8;
  }
}();
exportTypedArrayMethod$5("with", { "with": function(index, value) {
  var O2 = aTypedArray$5(this);
  var relativeIndex = toIntegerOrInfinity$3(index);
  var actualValue = isBigIntArray$1(O2) ? toBigInt$1(value) : +value;
  return arrayWith(O2, getTypedArrayConstructor$3(O2), relativeIndex, actualValue);
} }["with"], !PROPER_ORDER$1);
var $$2v = _export;
var uncurryThis$I = functionUncurryThis;
var toString$d = toString$K;
var fromCharCode$5 = String.fromCharCode;
var charAt$b = uncurryThis$I("".charAt);
var exec$b = uncurryThis$I(/./.exec);
var stringSlice$6 = uncurryThis$I("".slice);
var hex2 = /^[\da-f]{2}$/i;
var hex4 = /^[\da-f]{4}$/i;
$$2v({ global: true }, {
  unescape: function unescape2(string) {
    var str = toString$d(string);
    var result = "";
    var length2 = str.length;
    var index = 0;
    var chr, part;
    while (index < length2) {
      chr = charAt$b(str, index++);
      if (chr === "%") {
        if (charAt$b(str, index) === "u") {
          part = stringSlice$6(str, index + 1, index + 5);
          if (exec$b(hex4, part)) {
            result += fromCharCode$5(parseInt(part, 16));
            index += 5;
            continue;
          }
        } else {
          part = stringSlice$6(str, index, index + 2);
          if (exec$b(hex2, part)) {
            result += fromCharCode$5(parseInt(part, 16));
            index += 2;
            continue;
          }
        }
      }
      result += chr;
    }
    return result;
  }
});
var uncurryThis$H = functionUncurryThis;
var defineBuiltIns$7 = defineBuiltIns$b;
var getWeakData = internalMetadataExports.getWeakData;
var anInstance$8 = anInstance$f;
var anObject$x = anObject$1i;
var isNullOrUndefined$6 = isNullOrUndefined$j;
var isObject$g = isObject$O;
var iterate$o = iterate$H;
var ArrayIterationModule = arrayIteration;
var hasOwn$g = hasOwnProperty_1;
var InternalStateModule$c = internalState;
var setInternalState$d = InternalStateModule$c.set;
var internalStateGetterFor = InternalStateModule$c.getterFor;
var find$1 = ArrayIterationModule.find;
var findIndex3 = ArrayIterationModule.findIndex;
var splice$1 = uncurryThis$H([].splice);
var id = 0;
var uncaughtFrozenStore = function(state) {
  return state.frozen || (state.frozen = new UncaughtFrozenStore());
};
var UncaughtFrozenStore = function() {
  this.entries = [];
};
var findUncaughtFrozen = function(store2, key) {
  return find$1(store2.entries, function(it) {
    return it[0] === key;
  });
};
UncaughtFrozenStore.prototype = {
  get: function(key) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) return entry[1];
  },
  has: function(key) {
    return !!findUncaughtFrozen(this, key);
  },
  set: function(key, value) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) entry[1] = value;
    else this.entries.push([key, value]);
  },
  "delete": function(key) {
    var index = findIndex3(this.entries, function(it) {
      return it[0] === key;
    });
    if (~index) splice$1(this.entries, index, 1);
    return !!~index;
  }
};
var collectionWeak$2 = {
  getConstructor: function(wrapper2, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
    var Constructor2 = wrapper2(function(that, iterable) {
      anInstance$8(that, Prototype2);
      setInternalState$d(that, {
        type: CONSTRUCTOR_NAME,
        id: id++,
        frozen: null
      });
      if (!isNullOrUndefined$6(iterable)) iterate$o(iterable, that[ADDER], { that, AS_ENTRIES: IS_MAP });
    });
    var Prototype2 = Constructor2.prototype;
    var getInternalState2 = internalStateGetterFor(CONSTRUCTOR_NAME);
    var define = function(that, key, value) {
      var state = getInternalState2(that);
      var data2 = getWeakData(anObject$x(key), true);
      if (data2 === true) uncaughtFrozenStore(state).set(key, value);
      else data2[state.id] = value;
      return that;
    };
    defineBuiltIns$7(Prototype2, {
      // `{ WeakMap, WeakSet }.prototype.delete(key)` methods
      // https://tc39.es/ecma262/#sec-weakmap.prototype.delete
      // https://tc39.es/ecma262/#sec-weakset.prototype.delete
      "delete": function(key) {
        var state = getInternalState2(this);
        if (!isObject$g(key)) return false;
        var data2 = getWeakData(key);
        if (data2 === true) return uncaughtFrozenStore(state)["delete"](key);
        return data2 && hasOwn$g(data2, state.id) && delete data2[state.id];
      },
      // `{ WeakMap, WeakSet }.prototype.has(key)` methods
      // https://tc39.es/ecma262/#sec-weakmap.prototype.has
      // https://tc39.es/ecma262/#sec-weakset.prototype.has
      has: function has4(key) {
        var state = getInternalState2(this);
        if (!isObject$g(key)) return false;
        var data2 = getWeakData(key);
        if (data2 === true) return uncaughtFrozenStore(state).has(key);
        return data2 && hasOwn$g(data2, state.id);
      }
    });
    defineBuiltIns$7(Prototype2, IS_MAP ? {
      // `WeakMap.prototype.get(key)` method
      // https://tc39.es/ecma262/#sec-weakmap.prototype.get
      get: function get3(key) {
        var state = getInternalState2(this);
        if (isObject$g(key)) {
          var data2 = getWeakData(key);
          if (data2 === true) return uncaughtFrozenStore(state).get(key);
          if (data2) return data2[state.id];
        }
      },
      // `WeakMap.prototype.set(key, value)` method
      // https://tc39.es/ecma262/#sec-weakmap.prototype.set
      set: function set4(key, value) {
        return define(this, key, value);
      }
    } : {
      // `WeakSet.prototype.add(value)` method
      // https://tc39.es/ecma262/#sec-weakset.prototype.add
      add: function add2(value) {
        return define(this, value, true);
      }
    });
    return Constructor2;
  }
};
var FREEZING$2 = freezing;
var globalThis$t = globalThis_1;
var uncurryThis$G = functionUncurryThis;
var defineBuiltIns$6 = defineBuiltIns$b;
var InternalMetadataModule = internalMetadataExports;
var collection$1 = collection$4;
var collectionWeak$1 = collectionWeak$2;
var isObject$f = isObject$O;
var enforceInternalState = internalState.enforce;
var fails$c = fails$1z;
var NATIVE_WEAK_MAP = weakMapBasicDetection;
var $Object$3 = Object;
var isArray$3 = Array.isArray;
var isExtensible3 = $Object$3.isExtensible;
var isFrozen$2 = $Object$3.isFrozen;
var isSealed2 = $Object$3.isSealed;
var freeze$2 = $Object$3.freeze;
var seal2 = $Object$3.seal;
var IS_IE11 = !globalThis$t.ActiveXObject && "ActiveXObject" in globalThis$t;
var InternalWeakMap;
var wrapper$1 = function(init) {
  return function WeakMap2() {
    return init(this, arguments.length ? arguments[0] : void 0);
  };
};
var $WeakMap = collection$1("WeakMap", wrapper$1, collectionWeak$1);
var WeakMapPrototype$1 = $WeakMap.prototype;
var nativeSet = uncurryThis$G(WeakMapPrototype$1.set);
var hasMSEdgeFreezingBug = function() {
  return FREEZING$2 && fails$c(function() {
    var frozenArray = freeze$2([]);
    nativeSet(new $WeakMap(), frozenArray, 1);
    return !isFrozen$2(frozenArray);
  });
};
if (NATIVE_WEAK_MAP) {
  if (IS_IE11) {
    InternalWeakMap = collectionWeak$1.getConstructor(wrapper$1, "WeakMap", true);
    InternalMetadataModule.enable();
    var nativeDelete = uncurryThis$G(WeakMapPrototype$1["delete"]);
    var nativeHas = uncurryThis$G(WeakMapPrototype$1.has);
    var nativeGet = uncurryThis$G(WeakMapPrototype$1.get);
    defineBuiltIns$6(WeakMapPrototype$1, {
      "delete": function(key) {
        if (isObject$f(key) && !isExtensible3(key)) {
          var state = enforceInternalState(this);
          if (!state.frozen) state.frozen = new InternalWeakMap();
          return nativeDelete(this, key) || state.frozen["delete"](key);
        }
        return nativeDelete(this, key);
      },
      has: function has4(key) {
        if (isObject$f(key) && !isExtensible3(key)) {
          var state = enforceInternalState(this);
          if (!state.frozen) state.frozen = new InternalWeakMap();
          return nativeHas(this, key) || state.frozen.has(key);
        }
        return nativeHas(this, key);
      },
      get: function get3(key) {
        if (isObject$f(key) && !isExtensible3(key)) {
          var state = enforceInternalState(this);
          if (!state.frozen) state.frozen = new InternalWeakMap();
          return nativeHas(this, key) ? nativeGet(this, key) : state.frozen.get(key);
        }
        return nativeGet(this, key);
      },
      set: function set4(key, value) {
        if (isObject$f(key) && !isExtensible3(key)) {
          var state = enforceInternalState(this);
          if (!state.frozen) state.frozen = new InternalWeakMap();
          nativeHas(this, key) ? nativeSet(this, key, value) : state.frozen.set(key, value);
        } else nativeSet(this, key, value);
        return this;
      }
    });
  } else if (hasMSEdgeFreezingBug()) {
    defineBuiltIns$6(WeakMapPrototype$1, {
      set: function set4(key, value) {
        var arrayIntegrityLevel;
        if (isArray$3(key)) {
          if (isFrozen$2(key)) arrayIntegrityLevel = freeze$2;
          else if (isSealed2(key)) arrayIntegrityLevel = seal2;
        }
        nativeSet(this, key, value);
        if (arrayIntegrityLevel) arrayIntegrityLevel(key);
        return this;
      }
    });
  }
}
var collection = collection$4;
var collectionWeak = collectionWeak$2;
collection("WeakSet", function(init) {
  return function WeakSet2() {
    return init(this, arguments.length ? arguments[0] : void 0);
  };
}, collectionWeak);
var $$2u = _export;
var globalThis$s = globalThis_1;
var isPrototypeOf$1 = objectIsPrototypeOf;
var getPrototypeOf$6 = objectGetPrototypeOf$2;
var setPrototypeOf2 = objectSetPrototypeOf$1;
var copyConstructorProperties = copyConstructorProperties$7;
var create$7 = objectCreate$1;
var createNonEnumerableProperty$5 = createNonEnumerableProperty$j;
var createPropertyDescriptor$3 = createPropertyDescriptor$d;
var installErrorStack = errorStackInstall;
var normalizeStringArgument$2 = normalizeStringArgument$6;
var wellKnownSymbol$j = wellKnownSymbol$S;
var fails$b = fails$1z;
var IS_PURE$a = isPure;
var NativeSuppressedError = globalThis$s.SuppressedError;
var TO_STRING_TAG$4 = wellKnownSymbol$j("toStringTag");
var $Error = Error;
var WRONG_ARITY$4 = !!NativeSuppressedError && NativeSuppressedError.length !== 3;
var EXTRA_ARGS_SUPPORT = !!NativeSuppressedError && fails$b(function() {
  return new NativeSuppressedError(1, 2, 3, { cause: 4 }).cause === 4;
});
var PATCH = WRONG_ARITY$4 || EXTRA_ARGS_SUPPORT;
var $SuppressedError = function SuppressedError2(error2, suppressed, message) {
  var isInstance = isPrototypeOf$1(SuppressedErrorPrototype, this);
  var that;
  if (setPrototypeOf2) {
    that = PATCH && (!isInstance || getPrototypeOf$6(this) === SuppressedErrorPrototype) ? new NativeSuppressedError() : setPrototypeOf2(new $Error(), isInstance ? getPrototypeOf$6(this) : SuppressedErrorPrototype);
  } else {
    that = isInstance ? this : create$7(SuppressedErrorPrototype);
    createNonEnumerableProperty$5(that, TO_STRING_TAG$4, "Error");
  }
  if (message !== void 0) createNonEnumerableProperty$5(that, "message", normalizeStringArgument$2(message));
  installErrorStack(that, $SuppressedError, that.stack, 1);
  createNonEnumerableProperty$5(that, "error", error2);
  createNonEnumerableProperty$5(that, "suppressed", suppressed);
  return that;
};
if (setPrototypeOf2) setPrototypeOf2($SuppressedError, $Error);
else copyConstructorProperties($SuppressedError, $Error, { name: true });
var SuppressedErrorPrototype = $SuppressedError.prototype = PATCH ? NativeSuppressedError.prototype : create$7($Error.prototype, {
  constructor: createPropertyDescriptor$3(1, $SuppressedError),
  message: createPropertyDescriptor$3(1, ""),
  name: createPropertyDescriptor$3(1, "SuppressedError")
});
if (PATCH && !IS_PURE$a) SuppressedErrorPrototype.constructor = $SuppressedError;
$$2u({ global: true, constructor: true, arity: 3, forced: PATCH }, {
  SuppressedError: $SuppressedError
});
var globalThis$r = globalThis_1;
var shared$2 = sharedStoreExports;
var isCallable$b = isCallable$I;
var getPrototypeOf$5 = objectGetPrototypeOf$2;
var defineBuiltIn$a = defineBuiltIn$u;
var wellKnownSymbol$i = wellKnownSymbol$S;
var USE_FUNCTION_CONSTRUCTOR = "USE_FUNCTION_CONSTRUCTOR";
var ASYNC_ITERATOR$3 = wellKnownSymbol$i("asyncIterator");
var AsyncIterator = globalThis$r.AsyncIterator;
var PassedAsyncIteratorPrototype = shared$2.AsyncIteratorPrototype;
var AsyncIteratorPrototype$5, prototype$2;
if (PassedAsyncIteratorPrototype) {
  AsyncIteratorPrototype$5 = PassedAsyncIteratorPrototype;
} else if (isCallable$b(AsyncIterator)) {
  AsyncIteratorPrototype$5 = AsyncIterator.prototype;
} else if (shared$2[USE_FUNCTION_CONSTRUCTOR] || globalThis$r[USE_FUNCTION_CONSTRUCTOR]) {
  try {
    prototype$2 = getPrototypeOf$5(getPrototypeOf$5(getPrototypeOf$5(Function("return async function*(){}()")())));
    if (getPrototypeOf$5(prototype$2) === Object.prototype) AsyncIteratorPrototype$5 = prototype$2;
  } catch (error2) {
  }
}
if (!AsyncIteratorPrototype$5) AsyncIteratorPrototype$5 = {};
if (!isCallable$b(AsyncIteratorPrototype$5[ASYNC_ITERATOR$3])) {
  defineBuiltIn$a(AsyncIteratorPrototype$5, ASYNC_ITERATOR$3, function() {
    return this;
  });
}
var asyncIteratorPrototype = AsyncIteratorPrototype$5;
var call$z = functionCall;
var anObject$w = anObject$1i;
var create$6 = objectCreate$1;
var getMethod$a = getMethod$l;
var defineBuiltIns$5 = defineBuiltIns$b;
var InternalStateModule$b = internalState;
var getBuiltIn$u = getBuiltIn$O;
var AsyncIteratorPrototype$4 = asyncIteratorPrototype;
var createIterResultObject$b = createIterResultObject$h;
var Promise$5 = getBuiltIn$u("Promise");
var ASYNC_FROM_SYNC_ITERATOR = "AsyncFromSyncIterator";
var setInternalState$c = InternalStateModule$b.set;
var getInternalState$6 = InternalStateModule$b.getterFor(ASYNC_FROM_SYNC_ITERATOR);
var asyncFromSyncIteratorContinuation = function(result, resolve2, reject2) {
  var done = result.done;
  Promise$5.resolve(result.value).then(function(value) {
    resolve2(createIterResultObject$b(value, done));
  }, reject2);
};
var AsyncFromSyncIterator$4 = function AsyncIterator2(iteratorRecord) {
  iteratorRecord.type = ASYNC_FROM_SYNC_ITERATOR;
  setInternalState$c(this, iteratorRecord);
};
AsyncFromSyncIterator$4.prototype = defineBuiltIns$5(create$6(AsyncIteratorPrototype$4), {
  next: function next3() {
    var state = getInternalState$6(this);
    return new Promise$5(function(resolve2, reject2) {
      var result = anObject$w(call$z(state.next, state.iterator));
      asyncFromSyncIteratorContinuation(result, resolve2, reject2);
    });
  },
  "return": function() {
    var iterator = getInternalState$6(this).iterator;
    return new Promise$5(function(resolve2, reject2) {
      var $return = getMethod$a(iterator, "return");
      if ($return === void 0) return resolve2(createIterResultObject$b(void 0, true));
      var result = anObject$w(call$z($return, iterator));
      asyncFromSyncIteratorContinuation(result, resolve2, reject2);
    });
  }
});
var asyncFromSyncIterator = AsyncFromSyncIterator$4;
var call$y = functionCall;
var AsyncFromSyncIterator$3 = asyncFromSyncIterator;
var anObject$v = anObject$1i;
var getIterator$3 = getIterator$7;
var getIteratorDirect$a = getIteratorDirect$o;
var getMethod$9 = getMethod$l;
var wellKnownSymbol$h = wellKnownSymbol$S;
var ASYNC_ITERATOR$2 = wellKnownSymbol$h("asyncIterator");
var getAsyncIterator$1 = function(it, usingIterator) {
  var method = arguments.length < 2 ? getMethod$9(it, ASYNC_ITERATOR$2) : usingIterator;
  return method ? anObject$v(call$y(method, it)) : new AsyncFromSyncIterator$3(getIteratorDirect$a(getIterator$3(it)));
};
var call$x = functionCall;
var getBuiltIn$t = getBuiltIn$O;
var getMethod$8 = getMethod$l;
var asyncIteratorClose = function(iterator, method, argument, reject2) {
  try {
    var returnMethod = getMethod$8(iterator, "return");
    if (returnMethod) {
      return getBuiltIn$t("Promise").resolve(call$x(returnMethod, iterator)).then(function() {
        method(argument);
      }, function(error2) {
        reject2(error2);
      });
    }
  } catch (error2) {
    return reject2(error2);
  }
  method(argument);
};
var call$w = functionCall;
var aCallable$j = aCallable$Q;
var anObject$u = anObject$1i;
var isObject$e = isObject$O;
var doesNotExceedSafeInteger = doesNotExceedSafeInteger$7;
var getBuiltIn$s = getBuiltIn$O;
var getIteratorDirect$9 = getIteratorDirect$o;
var closeAsyncIteration$4 = asyncIteratorClose;
var createMethod = function(TYPE) {
  var IS_TO_ARRAY = TYPE === 0;
  var IS_FOR_EACH = TYPE === 1;
  var IS_EVERY = TYPE === 2;
  var IS_SOME = TYPE === 3;
  return function(object, fn, target) {
    anObject$u(object);
    var MAPPING = fn !== void 0;
    if (MAPPING || !IS_TO_ARRAY) aCallable$j(fn);
    var record = getIteratorDirect$9(object);
    var Promise2 = getBuiltIn$s("Promise");
    var iterator = record.iterator;
    var next11 = record.next;
    var counter2 = 0;
    return new Promise2(function(resolve2, reject2) {
      var ifAbruptCloseAsyncIterator = function(error2) {
        closeAsyncIteration$4(iterator, reject2, error2, reject2);
      };
      var loop = function() {
        try {
          if (MAPPING) try {
            doesNotExceedSafeInteger(counter2);
          } catch (error5) {
            ifAbruptCloseAsyncIterator(error5);
          }
          Promise2.resolve(anObject$u(call$w(next11, iterator))).then(function(step) {
            try {
              if (anObject$u(step).done) {
                if (IS_TO_ARRAY) {
                  target.length = counter2;
                  resolve2(target);
                } else resolve2(IS_SOME ? false : IS_EVERY || void 0);
              } else {
                var value = step.value;
                try {
                  if (MAPPING) {
                    var result = fn(value, counter2);
                    var handler = function($result) {
                      if (IS_FOR_EACH) {
                        loop();
                      } else if (IS_EVERY) {
                        $result ? loop() : closeAsyncIteration$4(iterator, resolve2, false, reject2);
                      } else if (IS_TO_ARRAY) {
                        try {
                          target[counter2++] = $result;
                          loop();
                        } catch (error4) {
                          ifAbruptCloseAsyncIterator(error4);
                        }
                      } else {
                        $result ? closeAsyncIteration$4(iterator, resolve2, IS_SOME || value, reject2) : loop();
                      }
                    };
                    if (isObject$e(result)) Promise2.resolve(result).then(handler, ifAbruptCloseAsyncIterator);
                    else handler(result);
                  } else {
                    target[counter2++] = value;
                    loop();
                  }
                } catch (error3) {
                  ifAbruptCloseAsyncIterator(error3);
                }
              }
            } catch (error2) {
              reject2(error2);
            }
          }, reject2);
        } catch (error2) {
          reject2(error2);
        }
      };
      loop();
    });
  };
};
var asyncIteratorIteration = {
  toArray: createMethod(0),
  forEach: createMethod(1),
  every: createMethod(2),
  some: createMethod(3),
  find: createMethod(4)
};
var bind$j = functionBindContext;
var uncurryThis$F = functionUncurryThis;
var toObject$9 = toObject$E;
var isConstructor$4 = isConstructor$a;
var getAsyncIterator = getAsyncIterator$1;
var getIterator$2 = getIterator$7;
var getIteratorDirect$8 = getIteratorDirect$o;
var getIteratorMethod$3 = getIteratorMethod$9;
var getMethod$7 = getMethod$l;
var getBuiltIn$r = getBuiltIn$O;
var getBuiltInPrototypeMethod = getBuiltInPrototypeMethod$2;
var wellKnownSymbol$g = wellKnownSymbol$S;
var AsyncFromSyncIterator$2 = asyncFromSyncIterator;
var toArray$1 = asyncIteratorIteration.toArray;
var ASYNC_ITERATOR$1 = wellKnownSymbol$g("asyncIterator");
var arrayIterator = uncurryThis$F(getBuiltInPrototypeMethod("Array", "values"));
var arrayIteratorNext = uncurryThis$F(arrayIterator([]).next);
var safeArrayIterator = function() {
  return new SafeArrayIterator(this);
};
var SafeArrayIterator = function(O2) {
  this.iterator = arrayIterator(O2);
};
SafeArrayIterator.prototype.next = function() {
  return arrayIteratorNext(this.iterator);
};
var arrayFromAsync$1 = function fromAsync(asyncItems) {
  var C2 = this;
  var argumentsLength = arguments.length;
  var mapfn = argumentsLength > 1 ? arguments[1] : void 0;
  var thisArg = argumentsLength > 2 ? arguments[2] : void 0;
  return new (getBuiltIn$r("Promise"))(function(resolve2) {
    var O2 = toObject$9(asyncItems);
    if (mapfn !== void 0) mapfn = bind$j(mapfn, thisArg);
    var usingAsyncIterator = getMethod$7(O2, ASYNC_ITERATOR$1);
    var usingSyncIterator = usingAsyncIterator ? void 0 : getIteratorMethod$3(O2) || safeArrayIterator;
    var A2 = isConstructor$4(C2) ? new C2() : [];
    var iterator = usingAsyncIterator ? getAsyncIterator(O2, usingAsyncIterator) : new AsyncFromSyncIterator$2(getIteratorDirect$8(getIterator$2(O2, usingSyncIterator)));
    resolve2(toArray$1(iterator, mapfn, A2));
  });
};
var $$2t = _export;
var fromAsync2 = arrayFromAsync$1;
var fails$a = fails$1z;
var nativeFromAsync = Array.fromAsync;
var INCORRECT_CONSTRUCTURING = !nativeFromAsync || fails$a(function() {
  var counter2 = 0;
  nativeFromAsync.call(function() {
    counter2++;
    return [];
  }, { length: 0 });
  return counter2 !== 1;
});
$$2t({ target: "Array", stat: true, forced: INCORRECT_CONSTRUCTURING }, {
  fromAsync: fromAsync2
});
var $$2s = _export;
var $filterReject$3 = arrayIteration.filterReject;
var addToUnscopables$8 = addToUnscopables$n;
$$2s({ target: "Array", proto: true, forced: true }, {
  filterOut: function filterOut(callbackfn) {
    return $filterReject$3(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
  }
});
addToUnscopables$8("filterOut");
var $$2r = _export;
var $filterReject$2 = arrayIteration.filterReject;
var addToUnscopables$7 = addToUnscopables$n;
$$2r({ target: "Array", proto: true, forced: true }, {
  filterReject: function filterReject(callbackfn) {
    return $filterReject$2(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
  }
});
addToUnscopables$7("filterReject");
var bind$i = functionBindContext;
var uncurryThis$E = functionUncurryThis;
var IndexedObject$1 = indexedObject;
var toObject$8 = toObject$E;
var toPropertyKey = toPropertyKey$9;
var lengthOfArrayLike$9 = lengthOfArrayLike$B;
var objectCreate = objectCreate$1;
var arrayFromConstructorAndList$3 = arrayFromConstructorAndList$8;
var $Array$3 = Array;
var push$e = uncurryThis$E([].push);
var arrayGroup = function($this, callbackfn, that, specificConstructor) {
  var O2 = toObject$8($this);
  var self2 = IndexedObject$1(O2);
  var boundFunction = bind$i(callbackfn, that);
  var target = objectCreate(null);
  var length2 = lengthOfArrayLike$9(self2);
  var index = 0;
  var Constructor2, key, value;
  for (; length2 > index; index++) {
    value = self2[index];
    key = toPropertyKey(boundFunction(value, index, O2));
    if (key in target) push$e(target[key], value);
    else target[key] = [value];
  }
  if (specificConstructor) {
    Constructor2 = specificConstructor(O2);
    if (Constructor2 !== $Array$3) {
      for (key in target) target[key] = arrayFromConstructorAndList$3(Constructor2, target[key]);
    }
  }
  return target;
};
var $$2q = _export;
var $group$2 = arrayGroup;
var addToUnscopables$6 = addToUnscopables$n;
$$2q({ target: "Array", proto: true }, {
  group: function group(callbackfn) {
    var thisArg = arguments.length > 1 ? arguments[1] : void 0;
    return $group$2(this, callbackfn, thisArg);
  }
});
addToUnscopables$6("group");
var $$2p = _export;
var $group$1 = arrayGroup;
var arrayMethodIsStrict$1 = arrayMethodIsStrict$b;
var addToUnscopables$5 = addToUnscopables$n;
$$2p({ target: "Array", proto: true, forced: !arrayMethodIsStrict$1("groupBy") }, {
  groupBy: function groupBy3(callbackfn) {
    var thisArg = arguments.length > 1 ? arguments[1] : void 0;
    return $group$1(this, callbackfn, thisArg);
  }
});
addToUnscopables$5("groupBy");
var bind$h = functionBindContext;
var uncurryThis$D = functionUncurryThis;
var IndexedObject = indexedObject;
var toObject$7 = toObject$E;
var lengthOfArrayLike$8 = lengthOfArrayLike$B;
var MapHelpers$c = mapHelpers;
var Map$a = MapHelpers$c.Map;
var mapGet$1 = MapHelpers$c.get;
var mapHas$2 = MapHelpers$c.has;
var mapSet$2 = MapHelpers$c.set;
var push$d = uncurryThis$D([].push);
var arrayGroupToMap = function groupToMap(callbackfn) {
  var O2 = toObject$7(this);
  var self2 = IndexedObject(O2);
  var boundFunction = bind$h(callbackfn, arguments.length > 1 ? arguments[1] : void 0);
  var map7 = new Map$a();
  var length2 = lengthOfArrayLike$8(self2);
  var index = 0;
  var key, value;
  for (; length2 > index; index++) {
    value = self2[index];
    key = boundFunction(value, index, O2);
    if (mapHas$2(map7, key)) push$d(mapGet$1(map7, key), value);
    else mapSet$2(map7, key, [value]);
  }
  return map7;
};
var $$2o = _export;
var arrayMethodIsStrict = arrayMethodIsStrict$b;
var addToUnscopables$4 = addToUnscopables$n;
var $groupToMap$1 = arrayGroupToMap;
$$2o({ target: "Array", proto: true, name: "groupToMap", forced: !arrayMethodIsStrict("groupByToMap") }, {
  groupByToMap: $groupToMap$1
});
addToUnscopables$4("groupByToMap");
var $$2n = _export;
var addToUnscopables$3 = addToUnscopables$n;
var $groupToMap = arrayGroupToMap;
var IS_PURE$9 = isPure;
$$2n({ target: "Array", proto: true, forced: IS_PURE$9 }, {
  groupToMap: $groupToMap
});
addToUnscopables$3("groupToMap");
var $$2m = _export;
var isArray$2 = isArray$c;
var isFrozen$1 = Object.isFrozen;
var isFrozenStringArray = function(array, allowUndefined) {
  if (!isFrozen$1 || !isArray$2(array) || !isFrozen$1(array)) return false;
  var index = 0;
  var length2 = array.length;
  var element;
  while (index < length2) {
    element = array[index++];
    if (!(typeof element == "string" || allowUndefined && element === void 0)) {
      return false;
    }
  }
  return length2 !== 0;
};
$$2m({ target: "Array", stat: true, sham: true, forced: true }, {
  isTemplateObject: function isTemplateObject(value) {
    if (!isFrozenStringArray(value, true)) return false;
    var raw3 = value.raw;
    return raw3.length === value.length && isFrozenStringArray(raw3, false);
  }
});
var DESCRIPTORS$f = descriptors$1;
var addToUnscopables$2 = addToUnscopables$n;
var toObject$6 = toObject$E;
var lengthOfArrayLike$7 = lengthOfArrayLike$B;
var defineBuiltInAccessor$a = defineBuiltInAccessor$p;
if (DESCRIPTORS$f) {
  defineBuiltInAccessor$a(Array.prototype, "lastIndex", {
    configurable: true,
    get: function lastIndex() {
      var O2 = toObject$6(this);
      var len = lengthOfArrayLike$7(O2);
      return len === 0 ? 0 : len - 1;
    }
  });
  addToUnscopables$2("lastIndex");
}
var DESCRIPTORS$e = descriptors$1;
var addToUnscopables$1 = addToUnscopables$n;
var toObject$5 = toObject$E;
var lengthOfArrayLike$6 = lengthOfArrayLike$B;
var defineBuiltInAccessor$9 = defineBuiltInAccessor$p;
if (DESCRIPTORS$e) {
  defineBuiltInAccessor$9(Array.prototype, "lastItem", {
    configurable: true,
    get: function lastItem() {
      var O2 = toObject$5(this);
      var len = lengthOfArrayLike$6(O2);
      return len === 0 ? void 0 : O2[len - 1];
    },
    set: function lastItem(value) {
      var O2 = toObject$5(this);
      var len = lengthOfArrayLike$6(O2);
      return O2[len === 0 ? 0 : len - 1] = value;
    }
  });
  addToUnscopables$1("lastItem");
}
var uncurryThis$C = functionUncurryThis;
var iterateSimple = iterateSimple$8;
var MapHelpers$b = mapHelpers;
var Map$9 = MapHelpers$b.Map;
var MapPrototype = MapHelpers$b.proto;
var forEach$4 = uncurryThis$C(MapPrototype.forEach);
var entries3 = uncurryThis$C(MapPrototype.entries);
var next$2 = entries3(new Map$9()).next;
var mapIterate = function(map7, fn, interruptible) {
  return interruptible ? iterateSimple({ iterator: entries3(map7), next: next$2 }, function(entry) {
    return fn(entry[1], entry[0]);
  }) : forEach$4(map7, fn);
};
var uncurryThis$B = functionUncurryThis;
var aCallable$i = aCallable$Q;
var isNullOrUndefined$5 = isNullOrUndefined$j;
var lengthOfArrayLike$5 = lengthOfArrayLike$B;
var toObject$4 = toObject$E;
var MapHelpers$a = mapHelpers;
var iterate$n = mapIterate;
var Map$8 = MapHelpers$a.Map;
var mapHas$1 = MapHelpers$a.has;
var mapSet$1 = MapHelpers$a.set;
var push$c = uncurryThis$B([].push);
var arrayUniqueBy$2 = function uniqueBy(resolver) {
  var that = toObject$4(this);
  var length2 = lengthOfArrayLike$5(that);
  var result = [];
  var map7 = new Map$8();
  var resolverFunction = !isNullOrUndefined$5(resolver) ? aCallable$i(resolver) : function(value) {
    return value;
  };
  var index, item, key;
  for (index = 0; index < length2; index++) {
    item = that[index];
    key = resolverFunction(item);
    if (!mapHas$1(map7, key)) mapSet$1(map7, key, item);
  }
  iterate$n(map7, function(value) {
    push$c(result, value);
  });
  return result;
};
var $$2l = _export;
var addToUnscopables = addToUnscopables$n;
var uniqueBy2 = arrayUniqueBy$2;
$$2l({ target: "Array", proto: true, forced: true }, {
  uniqueBy: uniqueBy2
});
addToUnscopables("uniqueBy");
var call$v = functionCall;
var uncurryThis$A = functionUncurryThis;
var bind$g = functionBindContext;
var anObject$t = anObject$1i;
var aCallable$h = aCallable$Q;
var isNullOrUndefined$4 = isNullOrUndefined$j;
var getMethod$6 = getMethod$l;
var wellKnownSymbol$f = wellKnownSymbol$S;
var ASYNC_DISPOSE$2 = wellKnownSymbol$f("asyncDispose");
var DISPOSE$2 = wellKnownSymbol$f("dispose");
var push$b = uncurryThis$A([].push);
var getDisposeMethod = function(V2, hint) {
  if (hint === "async-dispose") {
    var method = getMethod$6(V2, ASYNC_DISPOSE$2);
    if (method !== void 0) return method;
    method = getMethod$6(V2, DISPOSE$2);
    if (method === void 0) return method;
    return function() {
      call$v(method, this);
    };
  }
  return getMethod$6(V2, DISPOSE$2);
};
var createDisposableResource = function(V2, hint, method) {
  if (arguments.length < 3 && !isNullOrUndefined$4(V2)) {
    method = aCallable$h(getDisposeMethod(anObject$t(V2), hint));
  }
  return method === void 0 ? function() {
    return void 0;
  } : bind$g(method, V2);
};
var addDisposableResource$2 = function(disposable, V2, hint, method) {
  var resource;
  if (arguments.length < 4) {
    if (isNullOrUndefined$4(V2) && hint === "sync-dispose") return;
    resource = createDisposableResource(V2, hint);
  } else {
    resource = createDisposableResource(void 0, hint, method);
  }
  push$b(disposable.stack, resource);
};
var $$2k = _export;
var DESCRIPTORS$d = descriptors$1;
var getBuiltIn$q = getBuiltIn$O;
var aCallable$g = aCallable$Q;
var anInstance$7 = anInstance$f;
var defineBuiltIn$9 = defineBuiltIn$u;
var defineBuiltIns$4 = defineBuiltIns$b;
var defineBuiltInAccessor$8 = defineBuiltInAccessor$p;
var wellKnownSymbol$e = wellKnownSymbol$S;
var InternalStateModule$a = internalState;
var addDisposableResource$1 = addDisposableResource$2;
var Promise$4 = getBuiltIn$q("Promise");
var SuppressedError$2 = getBuiltIn$q("SuppressedError");
var $ReferenceError$1 = ReferenceError;
var ASYNC_DISPOSE$1 = wellKnownSymbol$e("asyncDispose");
var TO_STRING_TAG$3 = wellKnownSymbol$e("toStringTag");
var ASYNC_DISPOSABLE_STACK = "AsyncDisposableStack";
var setInternalState$b = InternalStateModule$a.set;
var getAsyncDisposableStackInternalState = InternalStateModule$a.getterFor(ASYNC_DISPOSABLE_STACK);
var HINT$1 = "async-dispose";
var DISPOSED$1 = "disposed";
var PENDING$1 = "pending";
var getPendingAsyncDisposableStackInternalState = function(stack) {
  var internalState2 = getAsyncDisposableStackInternalState(stack);
  if (internalState2.state === DISPOSED$1) throw new $ReferenceError$1(ASYNC_DISPOSABLE_STACK + " already disposed");
  return internalState2;
};
var $AsyncDisposableStack = function AsyncDisposableStack() {
  setInternalState$b(anInstance$7(this, AsyncDisposableStackPrototype), {
    type: ASYNC_DISPOSABLE_STACK,
    state: PENDING$1,
    stack: []
  });
  if (!DESCRIPTORS$d) this.disposed = false;
};
var AsyncDisposableStackPrototype = $AsyncDisposableStack.prototype;
defineBuiltIns$4(AsyncDisposableStackPrototype, {
  disposeAsync: function disposeAsync() {
    var asyncDisposableStack = this;
    return new Promise$4(function(resolve2, reject2) {
      var internalState2 = getAsyncDisposableStackInternalState(asyncDisposableStack);
      if (internalState2.state === DISPOSED$1) return resolve2(void 0);
      internalState2.state = DISPOSED$1;
      if (!DESCRIPTORS$d) asyncDisposableStack.disposed = true;
      var stack = internalState2.stack;
      var i = stack.length;
      var thrown = false;
      var suppressed;
      var handleError = function(result) {
        if (thrown) {
          suppressed = new SuppressedError$2(result, suppressed);
        } else {
          thrown = true;
          suppressed = result;
        }
        loop();
      };
      var loop = function() {
        if (i) {
          var disposeMethod = stack[--i];
          stack[i] = null;
          try {
            Promise$4.resolve(disposeMethod()).then(loop, handleError);
          } catch (error2) {
            handleError(error2);
          }
        } else {
          internalState2.stack = null;
          thrown ? reject2(suppressed) : resolve2(void 0);
        }
      };
      loop();
    });
  },
  use: function use(value) {
    addDisposableResource$1(getPendingAsyncDisposableStackInternalState(this), value, HINT$1);
    return value;
  },
  adopt: function adopt(value, onDispose) {
    var internalState2 = getPendingAsyncDisposableStackInternalState(this);
    aCallable$g(onDispose);
    addDisposableResource$1(internalState2, void 0, HINT$1, function() {
      return onDispose(value);
    });
    return value;
  },
  defer: function defer2(onDispose) {
    var internalState2 = getPendingAsyncDisposableStackInternalState(this);
    aCallable$g(onDispose);
    addDisposableResource$1(internalState2, void 0, HINT$1, onDispose);
  },
  move: function move() {
    var internalState2 = getPendingAsyncDisposableStackInternalState(this);
    var newAsyncDisposableStack = new $AsyncDisposableStack();
    getAsyncDisposableStackInternalState(newAsyncDisposableStack).stack = internalState2.stack;
    internalState2.stack = [];
    internalState2.state = DISPOSED$1;
    if (!DESCRIPTORS$d) this.disposed = true;
    return newAsyncDisposableStack;
  }
});
if (DESCRIPTORS$d) defineBuiltInAccessor$8(AsyncDisposableStackPrototype, "disposed", {
  configurable: true,
  get: function disposed() {
    return getAsyncDisposableStackInternalState(this).state === DISPOSED$1;
  }
});
defineBuiltIn$9(AsyncDisposableStackPrototype, ASYNC_DISPOSE$1, AsyncDisposableStackPrototype.disposeAsync, { name: "disposeAsync" });
defineBuiltIn$9(AsyncDisposableStackPrototype, TO_STRING_TAG$3, ASYNC_DISPOSABLE_STACK, { nonWritable: true });
$$2k({ global: true, constructor: true }, {
  AsyncDisposableStack: $AsyncDisposableStack
});
var $$2j = _export;
var anInstance$6 = anInstance$f;
var getPrototypeOf$4 = objectGetPrototypeOf$2;
var createNonEnumerableProperty$4 = createNonEnumerableProperty$j;
var hasOwn$f = hasOwnProperty_1;
var wellKnownSymbol$d = wellKnownSymbol$S;
var AsyncIteratorPrototype$3 = asyncIteratorPrototype;
var IS_PURE$8 = isPure;
var TO_STRING_TAG$2 = wellKnownSymbol$d("toStringTag");
var $TypeError$j = TypeError;
var AsyncIteratorConstructor = function AsyncIterator3() {
  anInstance$6(this, AsyncIteratorPrototype$3);
  if (getPrototypeOf$4(this) === AsyncIteratorPrototype$3) throw new $TypeError$j("Abstract class AsyncIterator not directly constructable");
};
AsyncIteratorConstructor.prototype = AsyncIteratorPrototype$3;
if (!hasOwn$f(AsyncIteratorPrototype$3, TO_STRING_TAG$2)) {
  createNonEnumerableProperty$4(AsyncIteratorPrototype$3, TO_STRING_TAG$2, "AsyncIterator");
}
if (!hasOwn$f(AsyncIteratorPrototype$3, "constructor") || AsyncIteratorPrototype$3.constructor === Object) {
  createNonEnumerableProperty$4(AsyncIteratorPrototype$3, "constructor", AsyncIteratorConstructor);
}
$$2j({ global: true, constructor: true, forced: IS_PURE$8 }, {
  AsyncIterator: AsyncIteratorConstructor
});
var call$u = functionCall;
var perform = perform$7;
var anObject$s = anObject$1i;
var create$5 = objectCreate$1;
var createNonEnumerableProperty$3 = createNonEnumerableProperty$j;
var defineBuiltIns$3 = defineBuiltIns$b;
var wellKnownSymbol$c = wellKnownSymbol$S;
var InternalStateModule$9 = internalState;
var getBuiltIn$p = getBuiltIn$O;
var getMethod$5 = getMethod$l;
var AsyncIteratorPrototype$2 = asyncIteratorPrototype;
var createIterResultObject$a = createIterResultObject$h;
var iteratorClose = iteratorClose$8;
var Promise$3 = getBuiltIn$p("Promise");
var TO_STRING_TAG$1 = wellKnownSymbol$c("toStringTag");
var ASYNC_ITERATOR_HELPER = "AsyncIteratorHelper";
var WRAP_FOR_VALID_ASYNC_ITERATOR = "WrapForValidAsyncIterator";
var setInternalState$a = InternalStateModule$9.set;
var createAsyncIteratorProxyPrototype = function(IS_ITERATOR) {
  var IS_GENERATOR = !IS_ITERATOR;
  var getInternalState2 = InternalStateModule$9.getterFor(IS_ITERATOR ? WRAP_FOR_VALID_ASYNC_ITERATOR : ASYNC_ITERATOR_HELPER);
  var getStateOrEarlyExit = function(that) {
    var stateCompletion = perform(function() {
      return getInternalState2(that);
    });
    var stateError = stateCompletion.error;
    var state = stateCompletion.value;
    if (stateError || IS_GENERATOR && state.done) {
      return { exit: true, value: stateError ? Promise$3.reject(state) : Promise$3.resolve(createIterResultObject$a(void 0, true)) };
    }
    return { exit: false, value: state };
  };
  return defineBuiltIns$3(create$5(AsyncIteratorPrototype$2), {
    next: function next11() {
      var stateCompletion = getStateOrEarlyExit(this);
      var state = stateCompletion.value;
      if (stateCompletion.exit) return state;
      var handlerCompletion = perform(function() {
        return anObject$s(state.nextHandler(Promise$3));
      });
      var handlerError = handlerCompletion.error;
      var value = handlerCompletion.value;
      if (handlerError) state.done = true;
      return handlerError ? Promise$3.reject(value) : Promise$3.resolve(value);
    },
    "return": function() {
      var stateCompletion = getStateOrEarlyExit(this);
      var state = stateCompletion.value;
      if (stateCompletion.exit) return state;
      state.done = true;
      var iterator = state.iterator;
      var returnMethod, result;
      var completion = perform(function() {
        if (state.inner) try {
          iteratorClose(state.inner.iterator, "normal");
        } catch (error2) {
          return iteratorClose(iterator, "throw", error2);
        }
        return getMethod$5(iterator, "return");
      });
      returnMethod = result = completion.value;
      if (completion.error) return Promise$3.reject(result);
      if (returnMethod === void 0) return Promise$3.resolve(createIterResultObject$a(void 0, true));
      completion = perform(function() {
        return call$u(returnMethod, iterator);
      });
      result = completion.value;
      if (completion.error) return Promise$3.reject(result);
      return IS_ITERATOR ? Promise$3.resolve(result) : Promise$3.resolve(result).then(function(resolved) {
        anObject$s(resolved);
        return createIterResultObject$a(void 0, true);
      });
    }
  });
};
var WrapForValidAsyncIteratorPrototype = createAsyncIteratorProxyPrototype(true);
var AsyncIteratorHelperPrototype = createAsyncIteratorProxyPrototype(false);
createNonEnumerableProperty$3(AsyncIteratorHelperPrototype, TO_STRING_TAG$1, "Async Iterator Helper");
var asyncIteratorCreateProxy = function(nextHandler, IS_ITERATOR) {
  var AsyncIteratorProxy2 = function AsyncIterator4(record, state) {
    if (state) {
      state.iterator = record.iterator;
      state.next = record.next;
    } else state = record;
    state.type = IS_ITERATOR ? WRAP_FOR_VALID_ASYNC_ITERATOR : ASYNC_ITERATOR_HELPER;
    state.nextHandler = nextHandler;
    state.counter = 0;
    state.done = false;
    setInternalState$a(this, state);
  };
  AsyncIteratorProxy2.prototype = IS_ITERATOR ? WrapForValidAsyncIteratorPrototype : AsyncIteratorHelperPrototype;
  return AsyncIteratorProxy2;
};
var call$t = functionCall;
var aCallable$f = aCallable$Q;
var anObject$r = anObject$1i;
var isObject$d = isObject$O;
var getIteratorDirect$7 = getIteratorDirect$o;
var createAsyncIteratorProxy$5 = asyncIteratorCreateProxy;
var createIterResultObject$9 = createIterResultObject$h;
var closeAsyncIteration$3 = asyncIteratorClose;
var AsyncIteratorProxy$4 = createAsyncIteratorProxy$5(function(Promise2) {
  var state = this;
  var iterator = state.iterator;
  var mapper = state.mapper;
  return new Promise2(function(resolve2, reject2) {
    var doneAndReject = function(error2) {
      state.done = true;
      reject2(error2);
    };
    var ifAbruptCloseAsyncIterator = function(error2) {
      closeAsyncIteration$3(iterator, doneAndReject, error2, doneAndReject);
    };
    Promise2.resolve(anObject$r(call$t(state.next, iterator))).then(function(step) {
      try {
        if (anObject$r(step).done) {
          state.done = true;
          resolve2(createIterResultObject$9(void 0, true));
        } else {
          var value = step.value;
          try {
            var result = mapper(value, state.counter++);
            var handler = function(mapped) {
              resolve2(createIterResultObject$9(mapped, false));
            };
            if (isObject$d(result)) Promise2.resolve(result).then(handler, ifAbruptCloseAsyncIterator);
            else handler(result);
          } catch (error2) {
            ifAbruptCloseAsyncIterator(error2);
          }
        }
      } catch (error2) {
        doneAndReject(error2);
      }
    }, doneAndReject);
  });
});
var asyncIteratorMap = function map4(mapper) {
  anObject$r(this);
  aCallable$f(mapper);
  return new AsyncIteratorProxy$4(getIteratorDirect$7(this), {
    mapper
  });
};
var call$s = functionCall;
var map$2 = asyncIteratorMap;
var callback$1 = function(value, counter2) {
  return [counter2, value];
};
var asyncIteratorIndexed = function indexed() {
  return call$s(map$2, this, callback$1);
};
var $$2i = _export;
var indexed$3 = asyncIteratorIndexed;
$$2i({ target: "AsyncIterator", name: "indexed", proto: true, real: true, forced: true }, {
  asIndexedPairs: indexed$3
});
var call$r = functionCall;
var defineBuiltIn$8 = defineBuiltIn$u;
var getBuiltIn$o = getBuiltIn$O;
var getMethod$4 = getMethod$l;
var hasOwn$e = hasOwnProperty_1;
var wellKnownSymbol$b = wellKnownSymbol$S;
var AsyncIteratorPrototype$1 = asyncIteratorPrototype;
var ASYNC_DISPOSE = wellKnownSymbol$b("asyncDispose");
var Promise$2 = getBuiltIn$o("Promise");
if (!hasOwn$e(AsyncIteratorPrototype$1, ASYNC_DISPOSE)) {
  defineBuiltIn$8(AsyncIteratorPrototype$1, ASYNC_DISPOSE, function() {
    var O2 = this;
    return new Promise$2(function(resolve2, reject2) {
      var $return = getMethod$4(O2, "return");
      if ($return) {
        Promise$2.resolve(call$r($return, O2)).then(function() {
          resolve2(void 0);
        }, reject2);
      } else resolve2(void 0);
    });
  });
}
var $$2h = _export;
var call$q = functionCall;
var anObject$q = anObject$1i;
var getIteratorDirect$6 = getIteratorDirect$o;
var notANaN$1 = notANan;
var toPositiveInteger$1 = toPositiveInteger$5;
var createAsyncIteratorProxy$4 = asyncIteratorCreateProxy;
var createIterResultObject$8 = createIterResultObject$h;
var IS_PURE$7 = isPure;
var AsyncIteratorProxy$3 = createAsyncIteratorProxy$4(function(Promise2) {
  var state = this;
  return new Promise2(function(resolve2, reject2) {
    var doneAndReject = function(error2) {
      state.done = true;
      reject2(error2);
    };
    var loop = function() {
      try {
        Promise2.resolve(anObject$q(call$q(state.next, state.iterator))).then(function(step) {
          try {
            if (anObject$q(step).done) {
              state.done = true;
              resolve2(createIterResultObject$8(void 0, true));
            } else if (state.remaining) {
              state.remaining--;
              loop();
            } else resolve2(createIterResultObject$8(step.value, false));
          } catch (err) {
            doneAndReject(err);
          }
        }, doneAndReject);
      } catch (error2) {
        doneAndReject(error2);
      }
    };
    loop();
  });
});
$$2h({ target: "AsyncIterator", proto: true, real: true, forced: IS_PURE$7 }, {
  drop: function drop2(limit) {
    anObject$q(this);
    var remaining = toPositiveInteger$1(notANaN$1(+limit));
    return new AsyncIteratorProxy$3(getIteratorDirect$6(this), {
      remaining
    });
  }
});
var $$2g = _export;
var $every = asyncIteratorIteration.every;
$$2g({ target: "AsyncIterator", proto: true, real: true }, {
  every: function every4(predicate) {
    return $every(this, predicate);
  }
});
var $$2f = _export;
var call$p = functionCall;
var aCallable$e = aCallable$Q;
var anObject$p = anObject$1i;
var isObject$c = isObject$O;
var getIteratorDirect$5 = getIteratorDirect$o;
var createAsyncIteratorProxy$3 = asyncIteratorCreateProxy;
var createIterResultObject$7 = createIterResultObject$h;
var closeAsyncIteration$2 = asyncIteratorClose;
var IS_PURE$6 = isPure;
var AsyncIteratorProxy$2 = createAsyncIteratorProxy$3(function(Promise2) {
  var state = this;
  var iterator = state.iterator;
  var predicate = state.predicate;
  return new Promise2(function(resolve2, reject2) {
    var doneAndReject = function(error2) {
      state.done = true;
      reject2(error2);
    };
    var ifAbruptCloseAsyncIterator = function(error2) {
      closeAsyncIteration$2(iterator, doneAndReject, error2, doneAndReject);
    };
    var loop = function() {
      try {
        Promise2.resolve(anObject$p(call$p(state.next, iterator))).then(function(step) {
          try {
            if (anObject$p(step).done) {
              state.done = true;
              resolve2(createIterResultObject$7(void 0, true));
            } else {
              var value = step.value;
              try {
                var result = predicate(value, state.counter++);
                var handler = function(selected) {
                  selected ? resolve2(createIterResultObject$7(value, false)) : loop();
                };
                if (isObject$c(result)) Promise2.resolve(result).then(handler, ifAbruptCloseAsyncIterator);
                else handler(result);
              } catch (error3) {
                ifAbruptCloseAsyncIterator(error3);
              }
            }
          } catch (error2) {
            doneAndReject(error2);
          }
        }, doneAndReject);
      } catch (error2) {
        doneAndReject(error2);
      }
    };
    loop();
  });
});
$$2f({ target: "AsyncIterator", proto: true, real: true, forced: IS_PURE$6 }, {
  filter: function filter4(predicate) {
    anObject$p(this);
    aCallable$e(predicate);
    return new AsyncIteratorProxy$2(getIteratorDirect$5(this), {
      predicate
    });
  }
});
var $$2e = _export;
var $find = asyncIteratorIteration.find;
$$2e({ target: "AsyncIterator", proto: true, real: true }, {
  find: function find4(predicate) {
    return $find(this, predicate);
  }
});
var call$o = functionCall;
var isCallable$a = isCallable$I;
var anObject$o = anObject$1i;
var getIteratorDirect$4 = getIteratorDirect$o;
var getIteratorMethod$2 = getIteratorMethod$9;
var getMethod$3 = getMethod$l;
var wellKnownSymbol$a = wellKnownSymbol$S;
var AsyncFromSyncIterator$1 = asyncFromSyncIterator;
var ASYNC_ITERATOR = wellKnownSymbol$a("asyncIterator");
var getAsyncIteratorFlattenable$2 = function(obj) {
  var object = anObject$o(obj);
  var alreadyAsync = true;
  var method = getMethod$3(object, ASYNC_ITERATOR);
  var iterator;
  if (!isCallable$a(method)) {
    method = getIteratorMethod$2(object);
    alreadyAsync = false;
  }
  if (method !== void 0) {
    iterator = call$o(method, object);
  } else {
    iterator = object;
    alreadyAsync = true;
  }
  anObject$o(iterator);
  return getIteratorDirect$4(alreadyAsync ? iterator : new AsyncFromSyncIterator$1(getIteratorDirect$4(iterator)));
};
var $$2d = _export;
var call$n = functionCall;
var aCallable$d = aCallable$Q;
var anObject$n = anObject$1i;
var isObject$b = isObject$O;
var getIteratorDirect$3 = getIteratorDirect$o;
var createAsyncIteratorProxy$2 = asyncIteratorCreateProxy;
var createIterResultObject$6 = createIterResultObject$h;
var getAsyncIteratorFlattenable$1 = getAsyncIteratorFlattenable$2;
var closeAsyncIteration$1 = asyncIteratorClose;
var IS_PURE$5 = isPure;
var AsyncIteratorProxy$1 = createAsyncIteratorProxy$2(function(Promise2) {
  var state = this;
  var iterator = state.iterator;
  var mapper = state.mapper;
  return new Promise2(function(resolve2, reject2) {
    var doneAndReject = function(error2) {
      state.done = true;
      reject2(error2);
    };
    var ifAbruptCloseAsyncIterator = function(error2) {
      closeAsyncIteration$1(iterator, doneAndReject, error2, doneAndReject);
    };
    var outerLoop = function() {
      try {
        Promise2.resolve(anObject$n(call$n(state.next, iterator))).then(function(step) {
          try {
            if (anObject$n(step).done) {
              state.done = true;
              resolve2(createIterResultObject$6(void 0, true));
            } else {
              var value = step.value;
              try {
                var result = mapper(value, state.counter++);
                var handler = function(mapped) {
                  try {
                    state.inner = getAsyncIteratorFlattenable$1(mapped);
                    innerLoop();
                  } catch (error4) {
                    ifAbruptCloseAsyncIterator(error4);
                  }
                };
                if (isObject$b(result)) Promise2.resolve(result).then(handler, ifAbruptCloseAsyncIterator);
                else handler(result);
              } catch (error3) {
                ifAbruptCloseAsyncIterator(error3);
              }
            }
          } catch (error2) {
            doneAndReject(error2);
          }
        }, doneAndReject);
      } catch (error2) {
        doneAndReject(error2);
      }
    };
    var innerLoop = function() {
      var inner = state.inner;
      if (inner) {
        try {
          Promise2.resolve(anObject$n(call$n(inner.next, inner.iterator))).then(function(result) {
            try {
              if (anObject$n(result).done) {
                state.inner = null;
                outerLoop();
              } else resolve2(createIterResultObject$6(result.value, false));
            } catch (error1) {
              ifAbruptCloseAsyncIterator(error1);
            }
          }, ifAbruptCloseAsyncIterator);
        } catch (error2) {
          ifAbruptCloseAsyncIterator(error2);
        }
      } else outerLoop();
    };
    innerLoop();
  });
});
$$2d({ target: "AsyncIterator", proto: true, real: true, forced: IS_PURE$5 }, {
  flatMap: function flatMap3(mapper) {
    anObject$n(this);
    aCallable$d(mapper);
    return new AsyncIteratorProxy$1(getIteratorDirect$3(this), {
      mapper,
      inner: null
    });
  }
});
var $$2c = _export;
var $forEach = asyncIteratorIteration.forEach;
$$2c({ target: "AsyncIterator", proto: true, real: true }, {
  forEach: function forEach4(fn) {
    return $forEach(this, fn);
  }
});
var call$m = functionCall;
var createAsyncIteratorProxy$1 = asyncIteratorCreateProxy;
var asyncIteratorWrap = createAsyncIteratorProxy$1(function() {
  return call$m(this.next, this.iterator);
}, true);
var $$2b = _export;
var toObject$3 = toObject$E;
var isPrototypeOf = objectIsPrototypeOf;
var getAsyncIteratorFlattenable = getAsyncIteratorFlattenable$2;
var AsyncIteratorPrototype = asyncIteratorPrototype;
var WrapAsyncIterator$1 = asyncIteratorWrap;
var IS_PURE$4 = isPure;
$$2b({ target: "AsyncIterator", stat: true, forced: IS_PURE$4 }, {
  from: function from4(O2) {
    var iteratorRecord = getAsyncIteratorFlattenable(typeof O2 == "string" ? toObject$3(O2) : O2);
    return isPrototypeOf(AsyncIteratorPrototype, iteratorRecord.iterator) ? iteratorRecord.iterator : new WrapAsyncIterator$1(iteratorRecord);
  }
});
var $$2a = _export;
var indexed$2 = asyncIteratorIndexed;
$$2a({ target: "AsyncIterator", proto: true, real: true, forced: true }, {
  indexed: indexed$2
});
var $$29 = _export;
var map$1 = asyncIteratorMap;
var IS_PURE$3 = isPure;
$$29({ target: "AsyncIterator", proto: true, real: true, forced: IS_PURE$3 }, {
  map: map$1
});
var $$28 = _export;
var call$l = functionCall;
var aCallable$c = aCallable$Q;
var anObject$m = anObject$1i;
var isObject$a = isObject$O;
var getBuiltIn$n = getBuiltIn$O;
var getIteratorDirect$2 = getIteratorDirect$o;
var closeAsyncIteration = asyncIteratorClose;
var Promise$1 = getBuiltIn$n("Promise");
var $TypeError$i = TypeError;
$$28({ target: "AsyncIterator", proto: true, real: true }, {
  reduce: function reduce4(reducer) {
    anObject$m(this);
    aCallable$c(reducer);
    var record = getIteratorDirect$2(this);
    var iterator = record.iterator;
    var next11 = record.next;
    var noInitial = arguments.length < 2;
    var accumulator = noInitial ? void 0 : arguments[1];
    var counter2 = 0;
    return new Promise$1(function(resolve2, reject2) {
      var ifAbruptCloseAsyncIterator = function(error2) {
        closeAsyncIteration(iterator, reject2, error2, reject2);
      };
      var loop = function() {
        try {
          Promise$1.resolve(anObject$m(call$l(next11, iterator))).then(function(step) {
            try {
              if (anObject$m(step).done) {
                noInitial ? reject2(new $TypeError$i("Reduce of empty iterator with no initial value")) : resolve2(accumulator);
              } else {
                var value = step.value;
                if (noInitial) {
                  noInitial = false;
                  accumulator = value;
                  loop();
                } else try {
                  var result = reducer(accumulator, value, counter2);
                  var handler = function($result) {
                    accumulator = $result;
                    loop();
                  };
                  if (isObject$a(result)) Promise$1.resolve(result).then(handler, ifAbruptCloseAsyncIterator);
                  else handler(result);
                } catch (error3) {
                  ifAbruptCloseAsyncIterator(error3);
                }
              }
              counter2++;
            } catch (error2) {
              reject2(error2);
            }
          }, reject2);
        } catch (error2) {
          reject2(error2);
        }
      };
      loop();
    });
  }
});
var $$27 = _export;
var $some = asyncIteratorIteration.some;
$$27({ target: "AsyncIterator", proto: true, real: true }, {
  some: function some4(predicate) {
    return $some(this, predicate);
  }
});
var $$26 = _export;
var call$k = functionCall;
var anObject$l = anObject$1i;
var getIteratorDirect$1 = getIteratorDirect$o;
var notANaN = notANan;
var toPositiveInteger = toPositiveInteger$5;
var createAsyncIteratorProxy = asyncIteratorCreateProxy;
var createIterResultObject$5 = createIterResultObject$h;
var IS_PURE$2 = isPure;
var AsyncIteratorProxy = createAsyncIteratorProxy(function(Promise2) {
  var state = this;
  var iterator = state.iterator;
  var returnMethod;
  if (!state.remaining--) {
    var resultDone = createIterResultObject$5(void 0, true);
    state.done = true;
    returnMethod = iterator["return"];
    if (returnMethod !== void 0) {
      return Promise2.resolve(call$k(returnMethod, iterator, void 0)).then(function() {
        return resultDone;
      });
    }
    return resultDone;
  }
  return Promise2.resolve(call$k(state.next, iterator)).then(function(step) {
    if (anObject$l(step).done) {
      state.done = true;
      return createIterResultObject$5(void 0, true);
    }
    return createIterResultObject$5(step.value, false);
  }).then(null, function(error2) {
    state.done = true;
    throw error2;
  });
});
$$26({ target: "AsyncIterator", proto: true, real: true, forced: IS_PURE$2 }, {
  take: function take2(limit) {
    anObject$l(this);
    var remaining = toPositiveInteger(notANaN(+limit));
    return new AsyncIteratorProxy(getIteratorDirect$1(this), {
      remaining
    });
  }
});
var $$25 = _export;
var $toArray = asyncIteratorIteration.toArray;
$$25({ target: "AsyncIterator", proto: true, real: true }, {
  toArray: function toArray2() {
    return $toArray(this, void 0, []);
  }
});
var InternalStateModule$8 = internalState;
var createIteratorConstructor$4 = iteratorCreateConstructor;
var createIterResultObject$4 = createIterResultObject$h;
var isNullOrUndefined$3 = isNullOrUndefined$j;
var isObject$9 = isObject$O;
var defineBuiltInAccessor$7 = defineBuiltInAccessor$p;
var DESCRIPTORS$c = descriptors$1;
var INCORRECT_RANGE = "Incorrect Iterator.range arguments";
var NUMERIC_RANGE_ITERATOR = "NumericRangeIterator";
var setInternalState$9 = InternalStateModule$8.set;
var getInternalState$5 = InternalStateModule$8.getterFor(NUMERIC_RANGE_ITERATOR);
var $RangeError$3 = RangeError;
var $TypeError$h = TypeError;
var $RangeIterator = createIteratorConstructor$4(function NumericRangeIterator(start, end, option, type, zero, one) {
  if (typeof start != type || end !== Infinity && end !== -Infinity && typeof end != type) {
    throw new $TypeError$h(INCORRECT_RANGE);
  }
  if (start === Infinity || start === -Infinity) {
    throw new $RangeError$3(INCORRECT_RANGE);
  }
  var ifIncrease = end > start;
  var inclusiveEnd = false;
  var step;
  if (option === void 0) {
    step = void 0;
  } else if (isObject$9(option)) {
    step = option.step;
    inclusiveEnd = !!option.inclusive;
  } else if (typeof option == type) {
    step = option;
  } else {
    throw new $TypeError$h(INCORRECT_RANGE);
  }
  if (isNullOrUndefined$3(step)) {
    step = ifIncrease ? one : -one;
  }
  if (typeof step != type) {
    throw new $TypeError$h(INCORRECT_RANGE);
  }
  if (step === Infinity || step === -Infinity || step === zero && start !== end) {
    throw new $RangeError$3(INCORRECT_RANGE);
  }
  var hitsEnd = start !== start || end !== end || step !== step || end > start !== step > zero;
  setInternalState$9(this, {
    type: NUMERIC_RANGE_ITERATOR,
    start,
    end,
    step,
    inclusive: inclusiveEnd,
    hitsEnd,
    currentCount: zero,
    zero
  });
  if (!DESCRIPTORS$c) {
    this.start = start;
    this.end = end;
    this.step = step;
    this.inclusive = inclusiveEnd;
  }
}, NUMERIC_RANGE_ITERATOR, function next4() {
  var state = getInternalState$5(this);
  if (state.hitsEnd) return createIterResultObject$4(void 0, true);
  var start = state.start;
  var end = state.end;
  var step = state.step;
  var currentYieldingValue = start + step * state.currentCount++;
  if (currentYieldingValue === end) state.hitsEnd = true;
  var inclusiveEnd = state.inclusive;
  var endCondition;
  if (end > start) {
    endCondition = inclusiveEnd ? currentYieldingValue > end : currentYieldingValue >= end;
  } else {
    endCondition = inclusiveEnd ? end > currentYieldingValue : end >= currentYieldingValue;
  }
  if (endCondition) {
    state.hitsEnd = true;
    return createIterResultObject$4(void 0, true);
  }
  return createIterResultObject$4(currentYieldingValue, false);
});
var addGetter = function(key) {
  defineBuiltInAccessor$7($RangeIterator.prototype, key, {
    get: function() {
      return getInternalState$5(this)[key];
    },
    set: function() {
    },
    configurable: true,
    enumerable: false
  });
};
if (DESCRIPTORS$c) {
  addGetter("start");
  addGetter("end");
  addGetter("inclusive");
  addGetter("step");
}
var numericRangeIterator = $RangeIterator;
var $$24 = _export;
var NumericRangeIterator$2 = numericRangeIterator;
if (typeof BigInt == "function") {
  $$24({ target: "BigInt", stat: true, forced: true }, {
    range: function range3(start, end, option) {
      return new NumericRangeIterator$2(start, end, option, "bigint", BigInt(0), BigInt(1));
    }
  });
}
var getBuiltIn$m = getBuiltIn$O;
var create$4 = objectCreate$1;
var isObject$8 = isObject$O;
var $Object$2 = Object;
var $TypeError$g = TypeError;
var Map$7 = getBuiltIn$m("Map");
var WeakMap$2 = getBuiltIn$m("WeakMap");
var Node$1 = function() {
  this.object = null;
  this.symbol = null;
  this.primitives = null;
  this.objectsByIndex = create$4(null);
};
Node$1.prototype.get = function(key, initializer2) {
  return this[key] || (this[key] = initializer2());
};
Node$1.prototype.next = function(i, it, IS_OBJECT) {
  var store2 = IS_OBJECT ? this.objectsByIndex[i] || (this.objectsByIndex[i] = new WeakMap$2()) : this.primitives || (this.primitives = new Map$7());
  var entry = store2.get(it);
  if (!entry) store2.set(it, entry = new Node$1());
  return entry;
};
var root = new Node$1();
var compositeKey = function() {
  var active = root;
  var length2 = arguments.length;
  var i, it;
  for (i = 0; i < length2; i++) {
    if (isObject$8(it = arguments[i])) active = active.next(i, it, true);
  }
  if (this === $Object$2 && active === root) throw new $TypeError$g("Composite keys must contain a non-primitive component");
  for (i = 0; i < length2; i++) {
    if (!isObject$8(it = arguments[i])) active = active.next(i, it, false);
  }
  return active;
};
var $$23 = _export;
var apply$3 = functionApply$1;
var getCompositeKeyNode$1 = compositeKey;
var getBuiltIn$l = getBuiltIn$O;
var create$3 = objectCreate$1;
var $Object$1 = Object;
var initializer = function() {
  var freeze3 = getBuiltIn$l("Object", "freeze");
  return freeze3 ? freeze3(create$3(null)) : create$3(null);
};
$$23({ global: true, forced: true }, {
  compositeKey: function compositeKey2() {
    return apply$3(getCompositeKeyNode$1, $Object$1, arguments).get("object", initializer);
  }
});
var $$22 = _export;
var getCompositeKeyNode = compositeKey;
var getBuiltIn$k = getBuiltIn$O;
var apply$2 = functionApply$1;
$$22({ global: true, forced: true }, {
  compositeSymbol: function compositeSymbol() {
    if (arguments.length === 1 && typeof arguments[0] == "string") return getBuiltIn$k("Symbol")["for"](arguments[0]);
    return apply$2(getCompositeKeyNode, null, arguments).get("symbol", getBuiltIn$k("Symbol"));
  }
});
var $$21 = _export;
var uncurryThis$z = functionUncurryThis;
var unpackIEEE754 = ieee754.unpack;
var getUint16 = uncurryThis$z(DataView.prototype.getUint16);
$$21({ target: "DataView", proto: true }, {
  getFloat16: function getFloat16(byteOffset) {
    var uint16 = getUint16(this, byteOffset, arguments.length > 1 ? arguments[1] : false);
    return unpackIEEE754([uint16 & 255, uint16 >> 8 & 255], 10);
  }
});
var $$20 = _export;
var uncurryThis$y = functionUncurryThis;
var getUint8 = uncurryThis$y(DataView.prototype.getUint8);
$$20({ target: "DataView", proto: true, forced: true }, {
  getUint8Clamped: function getUint8Clamped(byteOffset) {
    return getUint8(this, byteOffset);
  }
});
var classof$4 = classof$p;
var $TypeError$f = TypeError;
var aDataView$2 = function(argument) {
  if (classof$4(argument) === "DataView") return argument;
  throw new $TypeError$f("Argument is not a DataView");
};
var floatRound = mathFloatRound;
var FLOAT16_EPSILON = 9765625e-10;
var FLOAT16_MAX_VALUE = 65504;
var FLOAT16_MIN_VALUE = 6103515625e-14;
var mathF16round = Math.f16round || function f16round(x2) {
  return floatRound(x2, FLOAT16_EPSILON, FLOAT16_MAX_VALUE, FLOAT16_MIN_VALUE);
};
var $$1$ = _export;
var uncurryThis$x = functionUncurryThis;
var aDataView$1 = aDataView$2;
var toIndex$1 = toIndex$5;
var packIEEE754 = ieee754.pack;
var f16round$1 = mathF16round;
var setUint16 = uncurryThis$x(DataView.prototype.setUint16);
$$1$({ target: "DataView", proto: true }, {
  setFloat16: function setFloat16(byteOffset, value) {
    aDataView$1(this);
    var offset = toIndex$1(byteOffset);
    var bytes = packIEEE754(f16round$1(value), 10, 2);
    return setUint16(this, offset, bytes[1] << 8 | bytes[0], arguments.length > 2 ? arguments[2] : false);
  }
});
var $$1_ = _export;
var uncurryThis$w = functionUncurryThis;
var aDataView = aDataView$2;
var toIndex = toIndex$5;
var toUint8Clamped = toUint8Clamped$2;
var setUint8 = uncurryThis$w(DataView.prototype.setUint8);
$$1_({ target: "DataView", proto: true, forced: true }, {
  setUint8Clamped: function setUint8Clamped(byteOffset, value) {
    aDataView(this);
    var offset = toIndex(byteOffset);
    return setUint8(this, offset, toUint8Clamped(value));
  }
});
var $$1Z = _export;
var DESCRIPTORS$b = descriptors$1;
var getBuiltIn$j = getBuiltIn$O;
var aCallable$b = aCallable$Q;
var anInstance$5 = anInstance$f;
var defineBuiltIn$7 = defineBuiltIn$u;
var defineBuiltIns$2 = defineBuiltIns$b;
var defineBuiltInAccessor$6 = defineBuiltInAccessor$p;
var wellKnownSymbol$9 = wellKnownSymbol$S;
var InternalStateModule$7 = internalState;
var addDisposableResource = addDisposableResource$2;
var SuppressedError$1 = getBuiltIn$j("SuppressedError");
var $ReferenceError = ReferenceError;
var DISPOSE$1 = wellKnownSymbol$9("dispose");
var TO_STRING_TAG = wellKnownSymbol$9("toStringTag");
var DISPOSABLE_STACK = "DisposableStack";
var setInternalState$8 = InternalStateModule$7.set;
var getDisposableStackInternalState = InternalStateModule$7.getterFor(DISPOSABLE_STACK);
var HINT = "sync-dispose";
var DISPOSED = "disposed";
var PENDING = "pending";
var getPendingDisposableStackInternalState = function(stack) {
  var internalState2 = getDisposableStackInternalState(stack);
  if (internalState2.state === DISPOSED) throw new $ReferenceError(DISPOSABLE_STACK + " already disposed");
  return internalState2;
};
var $DisposableStack = function DisposableStack() {
  setInternalState$8(anInstance$5(this, DisposableStackPrototype), {
    type: DISPOSABLE_STACK,
    state: PENDING,
    stack: []
  });
  if (!DESCRIPTORS$b) this.disposed = false;
};
var DisposableStackPrototype = $DisposableStack.prototype;
defineBuiltIns$2(DisposableStackPrototype, {
  dispose: function dispose() {
    var internalState2 = getDisposableStackInternalState(this);
    if (internalState2.state === DISPOSED) return;
    internalState2.state = DISPOSED;
    if (!DESCRIPTORS$b) this.disposed = true;
    var stack = internalState2.stack;
    var i = stack.length;
    var thrown = false;
    var suppressed;
    while (i) {
      var disposeMethod = stack[--i];
      stack[i] = null;
      try {
        disposeMethod();
      } catch (errorResult) {
        if (thrown) {
          suppressed = new SuppressedError$1(errorResult, suppressed);
        } else {
          thrown = true;
          suppressed = errorResult;
        }
      }
    }
    internalState2.stack = null;
    if (thrown) throw suppressed;
  },
  use: function use2(value) {
    addDisposableResource(getPendingDisposableStackInternalState(this), value, HINT);
    return value;
  },
  adopt: function adopt2(value, onDispose) {
    var internalState2 = getPendingDisposableStackInternalState(this);
    aCallable$b(onDispose);
    addDisposableResource(internalState2, void 0, HINT, function() {
      onDispose(value);
    });
    return value;
  },
  defer: function defer3(onDispose) {
    var internalState2 = getPendingDisposableStackInternalState(this);
    aCallable$b(onDispose);
    addDisposableResource(internalState2, void 0, HINT, onDispose);
  },
  move: function move2() {
    var internalState2 = getPendingDisposableStackInternalState(this);
    var newDisposableStack = new $DisposableStack();
    getDisposableStackInternalState(newDisposableStack).stack = internalState2.stack;
    internalState2.stack = [];
    internalState2.state = DISPOSED;
    if (!DESCRIPTORS$b) this.disposed = true;
    return newDisposableStack;
  }
});
if (DESCRIPTORS$b) defineBuiltInAccessor$6(DisposableStackPrototype, "disposed", {
  configurable: true,
  get: function disposed2() {
    return getDisposableStackInternalState(this).state === DISPOSED;
  }
});
defineBuiltIn$7(DisposableStackPrototype, DISPOSE$1, DisposableStackPrototype.dispose, { name: "dispose" });
defineBuiltIn$7(DisposableStackPrototype, TO_STRING_TAG, DISPOSABLE_STACK, { nonWritable: true });
$$1Z({ global: true, constructor: true }, {
  DisposableStack: $DisposableStack
});
var uncurryThis$v = functionUncurryThis;
var aCallable$a = aCallable$Q;
var functionDemethodize = function demethodize() {
  return uncurryThis$v(aCallable$a(this));
};
var $$1Y = _export;
var demethodize$1 = functionDemethodize;
$$1Y({ target: "Function", proto: true, forced: true }, {
  demethodize: demethodize$1
});
var $$1X = _export;
var uncurryThis$u = functionUncurryThis;
var $isCallable = isCallable$I;
var inspectSource = inspectSource$4;
var hasOwn$d = hasOwnProperty_1;
var DESCRIPTORS$a = descriptors$1;
var getOwnPropertyDescriptor$3 = Object.getOwnPropertyDescriptor;
var classRegExp = /^\s*class\b/;
var exec$a = uncurryThis$u(classRegExp.exec);
var isClassConstructor = function(argument) {
  try {
    if (!DESCRIPTORS$a || !exec$a(classRegExp, inspectSource(argument))) return false;
  } catch (error2) {
  }
  var prototype2 = getOwnPropertyDescriptor$3(argument, "prototype");
  return !!prototype2 && hasOwn$d(prototype2, "writable") && !prototype2.writable;
};
$$1X({ target: "Function", stat: true, sham: true, forced: true }, {
  isCallable: function isCallable(argument) {
    return $isCallable(argument) && !isClassConstructor(argument);
  }
});
var $$1W = _export;
var isConstructor$3 = isConstructor$a;
$$1W({ target: "Function", stat: true, forced: true }, {
  isConstructor: isConstructor$3
});
var wellKnownSymbol$8 = wellKnownSymbol$S;
var defineProperty$6 = objectDefineProperty.f;
var METADATA = wellKnownSymbol$8("metadata");
var FunctionPrototype = Function.prototype;
if (FunctionPrototype[METADATA] === void 0) {
  defineProperty$6(FunctionPrototype, METADATA, {
    value: null
  });
}
var $$1V = _export;
var demethodize2 = functionDemethodize;
$$1V({ target: "Function", proto: true, forced: true, name: "demethodize" }, {
  unThis: demethodize2
});
var call$j = functionCall;
var map5 = iteratorMap;
var callback = function(value, counter2) {
  return [counter2, value];
};
var iteratorIndexed = function indexed2() {
  return call$j(map5, this, callback);
};
var $$1U = _export;
var indexed$1 = iteratorIndexed;
$$1U({ target: "Iterator", name: "indexed", proto: true, real: true, forced: true }, {
  asIndexedPairs: indexed$1
});
var $$1T = _export;
var call$i = functionCall;
var aCallable$9 = aCallable$Q;
var anObject$k = anObject$1i;
var getIteratorMethod$1 = getIteratorMethod$9;
var createIteratorProxy = iteratorCreateProxy;
var $Array$2 = Array;
var IteratorProxy = createIteratorProxy(function() {
  while (true) {
    var iterator = this.iterator;
    if (!iterator) {
      var iterableIndex = this.nextIterableIndex++;
      var iterables = this.iterables;
      if (iterableIndex >= iterables.length) {
        this.done = true;
        return;
      }
      var entry = iterables[iterableIndex];
      this.iterables[iterableIndex] = null;
      iterator = this.iterator = call$i(entry.method, entry.iterable);
      this.next = iterator.next;
    }
    var result = anObject$k(call$i(this.next, iterator));
    if (result.done) {
      this.iterator = null;
      this.next = null;
      continue;
    }
    return result.value;
  }
});
$$1T({ target: "Iterator", stat: true, forced: true }, {
  concat: function concat2() {
    var length2 = arguments.length;
    var iterables = $Array$2(length2);
    for (var index = 0; index < length2; index++) {
      var item = anObject$k(arguments[index]);
      iterables[index] = {
        iterable: item,
        method: aCallable$9(getIteratorMethod$1(item))
      };
    }
    return new IteratorProxy({
      iterables,
      nextIterableIndex: 0,
      iterator: null,
      next: null
    });
  }
});
var call$h = functionCall;
var defineBuiltIn$6 = defineBuiltIn$u;
var getMethod$2 = getMethod$l;
var hasOwn$c = hasOwnProperty_1;
var wellKnownSymbol$7 = wellKnownSymbol$S;
var IteratorPrototype = iteratorsCore.IteratorPrototype;
var DISPOSE = wellKnownSymbol$7("dispose");
if (!hasOwn$c(IteratorPrototype, DISPOSE)) {
  defineBuiltIn$6(IteratorPrototype, DISPOSE, function() {
    var $return = getMethod$2(this, "return");
    if ($return) call$h($return, this);
  });
}
var $$1S = _export;
var indexed3 = iteratorIndexed;
$$1S({ target: "Iterator", proto: true, real: true, forced: true }, {
  indexed: indexed3
});
var $$1R = _export;
var NumericRangeIterator$1 = numericRangeIterator;
var $TypeError$e = TypeError;
$$1R({ target: "Iterator", stat: true, forced: true }, {
  range: function range(start, end, option) {
    if (typeof start == "number") return new NumericRangeIterator$1(start, end, option, "number", 0, 1);
    if (typeof start == "bigint") return new NumericRangeIterator$1(start, end, option, "bigint", BigInt(0), BigInt(1));
    throw new $TypeError$e("Incorrect Iterator.range arguments");
  }
});
var $$1Q = _export;
var anObject$j = anObject$1i;
var AsyncFromSyncIterator = asyncFromSyncIterator;
var WrapAsyncIterator = asyncIteratorWrap;
var getIteratorDirect = getIteratorDirect$o;
var IS_PURE$1 = isPure;
$$1Q({ target: "Iterator", proto: true, real: true, forced: IS_PURE$1 }, {
  toAsync: function toAsync() {
    return new WrapAsyncIterator(getIteratorDirect(new AsyncFromSyncIterator(getIteratorDirect(anObject$j(this)))));
  }
});
var fails$9 = fails$1z;
var nativeRawJson = !fails$9(function() {
  var unsafeInt = "9007199254740993";
  var raw3 = JSON.rawJSON(unsafeInt);
  return !JSON.isRawJSON(raw3) || JSON.stringify(raw3) !== unsafeInt;
});
var isObject$7 = isObject$O;
var getInternalState$4 = internalState.get;
var isRawJson = function isRawJSON(O2) {
  if (!isObject$7(O2)) return false;
  var state = getInternalState$4(O2);
  return !!state && state.type === "RawJSON";
};
var $$1P = _export;
var NATIVE_RAW_JSON$1 = nativeRawJson;
var isRawJSON$1 = isRawJson;
$$1P({ target: "JSON", stat: true, forced: !NATIVE_RAW_JSON$1 }, {
  isRawJSON: isRawJSON$1
});
var uncurryThis$t = functionUncurryThis;
var hasOwn$b = hasOwnProperty_1;
var $SyntaxError$2 = SyntaxError;
var $parseInt$2 = parseInt;
var fromCharCode$4 = String.fromCharCode;
var at$3 = uncurryThis$t("".charAt);
var slice$4 = uncurryThis$t("".slice);
var exec$9 = uncurryThis$t(/./.exec);
var codePoints = {
  '\\"': '"',
  "\\\\": "\\",
  "\\/": "/",
  "\\b": "\b",
  "\\f": "\f",
  "\\n": "\n",
  "\\r": "\r",
  "\\t": "	"
};
var IS_4_HEX_DIGITS = /^[\da-f]{4}$/i;
var IS_C0_CONTROL_CODE = /^[\u0000-\u001F]$/;
var parseJsonString = function(source, i) {
  var unterminated = true;
  var value = "";
  while (i < source.length) {
    var chr = at$3(source, i);
    if (chr === "\\") {
      var twoChars = slice$4(source, i, i + 2);
      if (hasOwn$b(codePoints, twoChars)) {
        value += codePoints[twoChars];
        i += 2;
      } else if (twoChars === "\\u") {
        i += 2;
        var fourHexDigits = slice$4(source, i, i + 4);
        if (!exec$9(IS_4_HEX_DIGITS, fourHexDigits)) throw new $SyntaxError$2("Bad Unicode escape at: " + i);
        value += fromCharCode$4($parseInt$2(fourHexDigits, 16));
        i += 4;
      } else throw new $SyntaxError$2('Unknown escape sequence: "' + twoChars + '"');
    } else if (chr === '"') {
      unterminated = false;
      i++;
      break;
    } else {
      if (exec$9(IS_C0_CONTROL_CODE, chr)) throw new $SyntaxError$2("Bad control character in string literal at: " + i);
      value += chr;
      i++;
    }
  }
  if (unterminated) throw new $SyntaxError$2("Unterminated string at: " + i);
  return { value, end: i };
};
var $$1O = _export;
var DESCRIPTORS$9 = descriptors$1;
var globalThis$q = globalThis_1;
var getBuiltIn$i = getBuiltIn$O;
var uncurryThis$s = functionUncurryThis;
var call$g = functionCall;
var isCallable$9 = isCallable$I;
var isObject$6 = isObject$O;
var isArray$1 = isArray$c;
var hasOwn$a = hasOwnProperty_1;
var toString$c = toString$K;
var lengthOfArrayLike$4 = lengthOfArrayLike$B;
var createProperty$2 = createProperty$b;
var fails$8 = fails$1z;
var parseJSONString$1 = parseJsonString;
var NATIVE_SYMBOL = symbolConstructorDetection;
var JSON$1 = globalThis$q.JSON;
var Number$1 = globalThis$q.Number;
var SyntaxError$3 = globalThis$q.SyntaxError;
var nativeParse = JSON$1 && JSON$1.parse;
var enumerableOwnProperties = getBuiltIn$i("Object", "keys");
var getOwnPropertyDescriptor$2 = Object.getOwnPropertyDescriptor;
var at$2 = uncurryThis$s("".charAt);
var slice$3 = uncurryThis$s("".slice);
var exec$8 = uncurryThis$s(/./.exec);
var push$a = uncurryThis$s([].push);
var IS_DIGIT = /^\d$/;
var IS_NON_ZERO_DIGIT = /^[1-9]$/;
var IS_NUMBER_START = /^[\d-]$/;
var IS_WHITESPACE = /^[\t\n\r ]$/;
var PRIMITIVE = 0;
var OBJECT = 1;
var $parse = function(source, reviver) {
  source = toString$c(source);
  var context = new Context(source, 0);
  var root2 = context.parse();
  var value = root2.value;
  var endIndex = context.skip(IS_WHITESPACE, root2.end);
  if (endIndex < source.length) {
    throw new SyntaxError$3('Unexpected extra character: "' + at$2(source, endIndex) + '" after the parsed data at: ' + endIndex);
  }
  return isCallable$9(reviver) ? internalize({ "": value }, "", reviver, root2) : value;
};
var internalize = function(holder, name, reviver, node2) {
  var val = holder[name];
  var unmodified = node2 && val === node2.value;
  var context = unmodified && typeof node2.source == "string" ? { source: node2.source } : {};
  var elementRecordsLen, keys6, len, i, P2;
  if (isObject$6(val)) {
    var nodeIsArray = isArray$1(val);
    var nodes = unmodified ? node2.nodes : nodeIsArray ? [] : {};
    if (nodeIsArray) {
      elementRecordsLen = nodes.length;
      len = lengthOfArrayLike$4(val);
      for (i = 0; i < len; i++) {
        internalizeProperty(val, i, internalize(val, "" + i, reviver, i < elementRecordsLen ? nodes[i] : void 0));
      }
    } else {
      keys6 = enumerableOwnProperties(val);
      len = lengthOfArrayLike$4(keys6);
      for (i = 0; i < len; i++) {
        P2 = keys6[i];
        internalizeProperty(val, P2, internalize(val, P2, reviver, hasOwn$a(nodes, P2) ? nodes[P2] : void 0));
      }
    }
  }
  return call$g(reviver, holder, name, val, context);
};
var internalizeProperty = function(object, key, value) {
  if (DESCRIPTORS$9) {
    var descriptor = getOwnPropertyDescriptor$2(object, key);
    if (descriptor && !descriptor.configurable) return;
  }
  if (value === void 0) delete object[key];
  else createProperty$2(object, key, value);
};
var Node = function(value, end, source, nodes) {
  this.value = value;
  this.end = end;
  this.source = source;
  this.nodes = nodes;
};
var Context = function(source, index) {
  this.source = source;
  this.index = index;
};
Context.prototype = {
  fork: function(nextIndex) {
    return new Context(this.source, nextIndex);
  },
  parse: function() {
    var source = this.source;
    var i = this.skip(IS_WHITESPACE, this.index);
    var fork = this.fork(i);
    var chr = at$2(source, i);
    if (exec$8(IS_NUMBER_START, chr)) return fork.number();
    switch (chr) {
      case "{":
        return fork.object();
      case "[":
        return fork.array();
      case '"':
        return fork.string();
      case "t":
        return fork.keyword(true);
      case "f":
        return fork.keyword(false);
      case "n":
        return fork.keyword(null);
    }
    throw new SyntaxError$3('Unexpected character: "' + chr + '" at: ' + i);
  },
  node: function(type, value, start, end, nodes) {
    return new Node(value, end, type ? null : slice$3(this.source, start, end), nodes);
  },
  object: function() {
    var source = this.source;
    var i = this.index + 1;
    var expectKeypair = false;
    var object = {};
    var nodes = {};
    while (i < source.length) {
      i = this.until(['"', "}"], i);
      if (at$2(source, i) === "}" && !expectKeypair) {
        i++;
        break;
      }
      var result = this.fork(i).string();
      var key = result.value;
      i = result.end;
      i = this.until([":"], i) + 1;
      i = this.skip(IS_WHITESPACE, i);
      result = this.fork(i).parse();
      createProperty$2(nodes, key, result);
      createProperty$2(object, key, result.value);
      i = this.until([",", "}"], result.end);
      var chr = at$2(source, i);
      if (chr === ",") {
        expectKeypair = true;
        i++;
      } else if (chr === "}") {
        i++;
        break;
      }
    }
    return this.node(OBJECT, object, this.index, i, nodes);
  },
  array: function() {
    var source = this.source;
    var i = this.index + 1;
    var expectElement = false;
    var array = [];
    var nodes = [];
    while (i < source.length) {
      i = this.skip(IS_WHITESPACE, i);
      if (at$2(source, i) === "]" && !expectElement) {
        i++;
        break;
      }
      var result = this.fork(i).parse();
      push$a(nodes, result);
      push$a(array, result.value);
      i = this.until([",", "]"], result.end);
      if (at$2(source, i) === ",") {
        expectElement = true;
        i++;
      } else if (at$2(source, i) === "]") {
        i++;
        break;
      }
    }
    return this.node(OBJECT, array, this.index, i, nodes);
  },
  string: function() {
    var index = this.index;
    var parsed = parseJSONString$1(this.source, this.index + 1);
    return this.node(PRIMITIVE, parsed.value, index, parsed.end);
  },
  number: function() {
    var source = this.source;
    var startIndex = this.index;
    var i = startIndex;
    if (at$2(source, i) === "-") i++;
    if (at$2(source, i) === "0") i++;
    else if (exec$8(IS_NON_ZERO_DIGIT, at$2(source, i))) i = this.skip(IS_DIGIT, i + 1);
    else throw new SyntaxError$3("Failed to parse number at: " + i);
    if (at$2(source, i) === ".") i = this.skip(IS_DIGIT, i + 1);
    if (at$2(source, i) === "e" || at$2(source, i) === "E") {
      i++;
      if (at$2(source, i) === "+" || at$2(source, i) === "-") i++;
      var exponentStartIndex = i;
      i = this.skip(IS_DIGIT, i);
      if (exponentStartIndex === i) throw new SyntaxError$3("Failed to parse number's exponent value at: " + i);
    }
    return this.node(PRIMITIVE, Number$1(slice$3(source, startIndex, i)), startIndex, i);
  },
  keyword: function(value) {
    var keyword = "" + value;
    var index = this.index;
    var endIndex = index + keyword.length;
    if (slice$3(this.source, index, endIndex) !== keyword) throw new SyntaxError$3("Failed to parse value at: " + index);
    return this.node(PRIMITIVE, value, index, endIndex);
  },
  skip: function(regex, i) {
    var source = this.source;
    for (; i < source.length; i++) if (!exec$8(regex, at$2(source, i))) break;
    return i;
  },
  until: function(array, i) {
    i = this.skip(IS_WHITESPACE, i);
    var chr = at$2(this.source, i);
    for (var j = 0; j < array.length; j++) if (array[j] === chr) return i;
    throw new SyntaxError$3('Unexpected character: "' + chr + '" at: ' + i);
  }
};
var NO_SOURCE_SUPPORT = fails$8(function() {
  var unsafeInt = "9007199254740993";
  var source;
  nativeParse(unsafeInt, function(key, value, context) {
    source = context.source;
  });
  return source !== unsafeInt;
});
var PROPER_BASE_PARSE = NATIVE_SYMBOL && !fails$8(function() {
  return 1 / nativeParse("-0 	") !== -Infinity;
});
$$1O({ target: "JSON", stat: true, forced: NO_SOURCE_SUPPORT }, {
  parse: function parse(text, reviver) {
    return PROPER_BASE_PARSE && !isCallable$9(reviver) ? nativeParse(text) : $parse(text, reviver);
  }
});
var $$1N = _export;
var FREEZING$1 = freezing;
var NATIVE_RAW_JSON = nativeRawJson;
var getBuiltIn$h = getBuiltIn$O;
var call$f = functionCall;
var uncurryThis$r = functionUncurryThis;
var isCallable$8 = isCallable$I;
var isRawJSON2 = isRawJson;
var toString$b = toString$K;
var createProperty$1 = createProperty$b;
var parseJSONString = parseJsonString;
var getReplacerFunction = getJsonReplacerFunction;
var uid$1 = uid$7;
var setInternalState$7 = internalState.set;
var $String$1 = String;
var $SyntaxError$1 = SyntaxError;
var parse$3 = getBuiltIn$h("JSON", "parse");
var $stringify = getBuiltIn$h("JSON", "stringify");
var create$2 = getBuiltIn$h("Object", "create");
var freeze$1 = getBuiltIn$h("Object", "freeze");
var at$1 = uncurryThis$r("".charAt);
var slice$2 = uncurryThis$r("".slice);
var push$9 = uncurryThis$r([].push);
var MARK = uid$1();
var MARK_LENGTH = MARK.length;
var ERROR_MESSAGE = "Unacceptable as raw JSON";
var isWhitespace = function(it) {
  return it === " " || it === "	" || it === "\n" || it === "\r";
};
$$1N({ target: "JSON", stat: true, forced: !NATIVE_RAW_JSON }, {
  rawJSON: function rawJSON(text) {
    var jsonString = toString$b(text);
    if (jsonString === "" || isWhitespace(at$1(jsonString, 0)) || isWhitespace(at$1(jsonString, jsonString.length - 1))) {
      throw new $SyntaxError$1(ERROR_MESSAGE);
    }
    var parsed = parse$3(jsonString);
    if (typeof parsed == "object" && parsed !== null) throw new $SyntaxError$1(ERROR_MESSAGE);
    var obj = create$2(null);
    setInternalState$7(obj, { type: "RawJSON" });
    createProperty$1(obj, "rawJSON", jsonString);
    return FREEZING$1 ? freeze$1(obj) : obj;
  }
});
if ($stringify) $$1N({ target: "JSON", stat: true, arity: 3, forced: !NATIVE_RAW_JSON }, {
  stringify: function stringify(text, replacer2, space) {
    var replacerFunction = getReplacerFunction(replacer2);
    var rawStrings = [];
    var json = $stringify(text, function(key, value) {
      var v2 = isCallable$8(replacerFunction) ? call$f(replacerFunction, this, $String$1(key), value) : value;
      return isRawJSON2(v2) ? MARK + (push$9(rawStrings, v2.rawJSON) - 1) : v2;
    }, space);
    if (typeof json != "string") return json;
    var result = "";
    var length2 = json.length;
    for (var i = 0; i < length2; i++) {
      var chr = at$1(json, i);
      if (chr === '"') {
        var end = parseJSONString(json, ++i).end - 1;
        var string = slice$2(json, i, end);
        result += slice$2(string, 0, MARK_LENGTH) === MARK ? rawStrings[slice$2(string, MARK_LENGTH)] : '"' + string + '"';
        i = end;
      } else result += chr;
    }
    return result;
  }
});
var has$9 = mapHelpers.has;
var aMap$g = function(it) {
  has$9(it);
  return it;
};
var $$1M = _export;
var aMap$f = aMap$g;
var remove$3 = mapHelpers.remove;
$$1M({ target: "Map", proto: true, real: true, forced: true }, {
  deleteAll: function deleteAll() {
    var collection2 = aMap$f(this);
    var allDeleted = true;
    var wasDeleted;
    for (var k2 = 0, len = arguments.length; k2 < len; k2++) {
      wasDeleted = remove$3(collection2, arguments[k2]);
      allDeleted = allDeleted && wasDeleted;
    }
    return !!allDeleted;
  }
});
var $$1L = _export;
var aMap$e = aMap$g;
var MapHelpers$9 = mapHelpers;
var get$6 = MapHelpers$9.get;
var has$8 = MapHelpers$9.has;
var set$a = MapHelpers$9.set;
$$1L({ target: "Map", proto: true, real: true, forced: true }, {
  emplace: function emplace(key, handler) {
    var map7 = aMap$e(this);
    var value, inserted;
    if (has$8(map7, key)) {
      value = get$6(map7, key);
      if ("update" in handler) {
        value = handler.update(value, key, map7);
        set$a(map7, key, value);
      }
      return value;
    }
    inserted = handler.insert(key, map7);
    set$a(map7, key, inserted);
    return inserted;
  }
});
var $$1K = _export;
var bind$f = functionBindContext;
var aMap$d = aMap$g;
var iterate$m = mapIterate;
$$1K({ target: "Map", proto: true, real: true, forced: true }, {
  every: function every5(callbackfn) {
    var map7 = aMap$d(this);
    var boundFunction = bind$f(callbackfn, arguments.length > 1 ? arguments[1] : void 0);
    return iterate$m(map7, function(value, key) {
      if (!boundFunction(value, key, map7)) return false;
    }, true) !== false;
  }
});
var $$1J = _export;
var bind$e = functionBindContext;
var aMap$c = aMap$g;
var MapHelpers$8 = mapHelpers;
var iterate$l = mapIterate;
var Map$6 = MapHelpers$8.Map;
var set$9 = MapHelpers$8.set;
$$1J({ target: "Map", proto: true, real: true, forced: true }, {
  filter: function filter5(callbackfn) {
    var map7 = aMap$c(this);
    var boundFunction = bind$e(callbackfn, arguments.length > 1 ? arguments[1] : void 0);
    var newMap = new Map$6();
    iterate$l(map7, function(value, key) {
      if (boundFunction(value, key, map7)) set$9(newMap, key, value);
    });
    return newMap;
  }
});
var $$1I = _export;
var bind$d = functionBindContext;
var aMap$b = aMap$g;
var iterate$k = mapIterate;
$$1I({ target: "Map", proto: true, real: true, forced: true }, {
  find: function find5(callbackfn) {
    var map7 = aMap$b(this);
    var boundFunction = bind$d(callbackfn, arguments.length > 1 ? arguments[1] : void 0);
    var result = iterate$k(map7, function(value, key) {
      if (boundFunction(value, key, map7)) return { value };
    }, true);
    return result && result.value;
  }
});
var $$1H = _export;
var bind$c = functionBindContext;
var aMap$a = aMap$g;
var iterate$j = mapIterate;
$$1H({ target: "Map", proto: true, real: true, forced: true }, {
  findKey: function findKey(callbackfn) {
    var map7 = aMap$a(this);
    var boundFunction = bind$c(callbackfn, arguments.length > 1 ? arguments[1] : void 0);
    var result = iterate$j(map7, function(value, key) {
      if (boundFunction(value, key, map7)) return { key };
    }, true);
    return result && result.key;
  }
});
var bind$b = functionBindContext;
var anObject$i = anObject$1i;
var toObject$2 = toObject$E;
var iterate$i = iterate$H;
var collectionFrom = function(C2, adder, ENTRY) {
  return function from7(source) {
    var O2 = toObject$2(source);
    var length2 = arguments.length;
    var mapFn = length2 > 1 ? arguments[1] : void 0;
    var mapping = mapFn !== void 0;
    var boundFunction = mapping ? bind$b(mapFn, length2 > 2 ? arguments[2] : void 0) : void 0;
    var result = new C2();
    var n2 = 0;
    iterate$i(O2, function(nextItem) {
      var entry = mapping ? boundFunction(nextItem, n2++) : nextItem;
      if (ENTRY) adder(result, anObject$i(entry)[0], entry[1]);
      else adder(result, entry);
    });
    return result;
  };
};
var $$1G = _export;
var MapHelpers$7 = mapHelpers;
var createCollectionFrom$3 = collectionFrom;
$$1G({ target: "Map", stat: true, forced: true }, {
  from: createCollectionFrom$3(MapHelpers$7.Map, MapHelpers$7.set, true)
});
var $$1F = _export;
var aMap$9 = aMap$g;
var MapHelpers$6 = mapHelpers;
var get$5 = MapHelpers$6.get;
var has$7 = MapHelpers$6.has;
var set$8 = MapHelpers$6.set;
$$1F({ target: "Map", proto: true, real: true, forced: true }, {
  getOrInsert: function getOrInsert(key, value) {
    if (has$7(aMap$9(this), key)) return get$5(this, key);
    set$8(this, key, value);
    return value;
  }
});
var $$1E = _export;
var aCallable$8 = aCallable$Q;
var aMap$8 = aMap$g;
var MapHelpers$5 = mapHelpers;
var get$4 = MapHelpers$5.get;
var has$6 = MapHelpers$5.has;
var set$7 = MapHelpers$5.set;
$$1E({ target: "Map", proto: true, real: true, forced: true }, {
  getOrInsertComputed: function getOrInsertComputed(key, callbackfn) {
    aMap$8(this);
    aCallable$8(callbackfn);
    if (has$6(this, key)) return get$4(this, key);
    if (key === 0 && 1 / key === -Infinity) key = 0;
    var value = callbackfn(key);
    set$7(this, key, value);
    return value;
  }
});
var sameValueZero$1 = function(x2, y2) {
  return x2 === y2 || x2 !== x2 && y2 !== y2;
};
var $$1D = _export;
var sameValueZero = sameValueZero$1;
var aMap$7 = aMap$g;
var iterate$h = mapIterate;
$$1D({ target: "Map", proto: true, real: true, forced: true }, {
  includes: function includes4(searchElement) {
    return iterate$h(aMap$7(this), function(value) {
      if (sameValueZero(value, searchElement)) return true;
    }, true) === true;
  }
});
var $$1C = _export;
var call$e = functionCall;
var iterate$g = iterate$H;
var isCallable$7 = isCallable$I;
var aCallable$7 = aCallable$Q;
var Map$5 = mapHelpers.Map;
$$1C({ target: "Map", stat: true, forced: true }, {
  keyBy: function keyBy(iterable, keyDerivative) {
    var C2 = isCallable$7(this) ? this : Map$5;
    var newMap = new C2();
    aCallable$7(keyDerivative);
    var setter = aCallable$7(newMap.set);
    iterate$g(iterable, function(element) {
      call$e(setter, newMap, keyDerivative(element), element);
    });
    return newMap;
  }
});
var $$1B = _export;
var aMap$6 = aMap$g;
var iterate$f = mapIterate;
$$1B({ target: "Map", proto: true, real: true, forced: true }, {
  keyOf: function keyOf(searchElement) {
    var result = iterate$f(aMap$6(this), function(value, key) {
      if (value === searchElement) return { key };
    }, true);
    return result && result.key;
  }
});
var $$1A = _export;
var bind$a = functionBindContext;
var aMap$5 = aMap$g;
var MapHelpers$4 = mapHelpers;
var iterate$e = mapIterate;
var Map$4 = MapHelpers$4.Map;
var set$6 = MapHelpers$4.set;
$$1A({ target: "Map", proto: true, real: true, forced: true }, {
  mapKeys: function mapKeys(callbackfn) {
    var map7 = aMap$5(this);
    var boundFunction = bind$a(callbackfn, arguments.length > 1 ? arguments[1] : void 0);
    var newMap = new Map$4();
    iterate$e(map7, function(value, key) {
      set$6(newMap, boundFunction(value, key, map7), value);
    });
    return newMap;
  }
});
var $$1z = _export;
var bind$9 = functionBindContext;
var aMap$4 = aMap$g;
var MapHelpers$3 = mapHelpers;
var iterate$d = mapIterate;
var Map$3 = MapHelpers$3.Map;
var set$5 = MapHelpers$3.set;
$$1z({ target: "Map", proto: true, real: true, forced: true }, {
  mapValues: function mapValues(callbackfn) {
    var map7 = aMap$4(this);
    var boundFunction = bind$9(callbackfn, arguments.length > 1 ? arguments[1] : void 0);
    var newMap = new Map$3();
    iterate$d(map7, function(value, key) {
      set$5(newMap, key, boundFunction(value, key, map7));
    });
    return newMap;
  }
});
var $$1y = _export;
var aMap$3 = aMap$g;
var iterate$c = iterate$H;
var set$4 = mapHelpers.set;
$$1y({ target: "Map", proto: true, real: true, arity: 1, forced: true }, {
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  merge: function merge(iterable) {
    var map7 = aMap$3(this);
    var argumentsLength = arguments.length;
    var i = 0;
    while (i < argumentsLength) {
      iterate$c(arguments[i++], function(key, value) {
        set$4(map7, key, value);
      }, { AS_ENTRIES: true });
    }
    return map7;
  }
});
var anObject$h = anObject$1i;
var collectionOf = function(C2, adder, ENTRY) {
  return function of5() {
    var result = new C2();
    var length2 = arguments.length;
    for (var index = 0; index < length2; index++) {
      var entry = arguments[index];
      if (ENTRY) adder(result, anObject$h(entry)[0], entry[1]);
      else adder(result, entry);
    }
    return result;
  };
};
var $$1x = _export;
var MapHelpers$2 = mapHelpers;
var createCollectionOf$3 = collectionOf;
$$1x({ target: "Map", stat: true, forced: true }, {
  of: createCollectionOf$3(MapHelpers$2.Map, MapHelpers$2.set, true)
});
var $$1w = _export;
var aCallable$6 = aCallable$Q;
var aMap$2 = aMap$g;
var iterate$b = mapIterate;
var $TypeError$d = TypeError;
$$1w({ target: "Map", proto: true, real: true, forced: true }, {
  reduce: function reduce5(callbackfn) {
    var map7 = aMap$2(this);
    var noInitial = arguments.length < 2;
    var accumulator = noInitial ? void 0 : arguments[1];
    aCallable$6(callbackfn);
    iterate$b(map7, function(value, key) {
      if (noInitial) {
        noInitial = false;
        accumulator = value;
      } else {
        accumulator = callbackfn(accumulator, value, key, map7);
      }
    });
    if (noInitial) throw new $TypeError$d("Reduce of empty map with no initial value");
    return accumulator;
  }
});
var $$1v = _export;
var bind$8 = functionBindContext;
var aMap$1 = aMap$g;
var iterate$a = mapIterate;
$$1v({ target: "Map", proto: true, real: true, forced: true }, {
  some: function some5(callbackfn) {
    var map7 = aMap$1(this);
    var boundFunction = bind$8(callbackfn, arguments.length > 1 ? arguments[1] : void 0);
    return iterate$a(map7, function(value, key) {
      if (boundFunction(value, key, map7)) return true;
    }, true) === true;
  }
});
var $$1u = _export;
var aCallable$5 = aCallable$Q;
var aMap = aMap$g;
var MapHelpers$1 = mapHelpers;
var $TypeError$c = TypeError;
var get$3 = MapHelpers$1.get;
var has$5 = MapHelpers$1.has;
var set$3 = MapHelpers$1.set;
$$1u({ target: "Map", proto: true, real: true, forced: true }, {
  update: function update(key, callback2) {
    var map7 = aMap(this);
    var length2 = arguments.length;
    aCallable$5(callback2);
    var isPresentInMap = has$5(map7, key);
    if (!isPresentInMap && length2 < 3) {
      throw new $TypeError$c("Updating absent value");
    }
    var value = isPresentInMap ? get$3(map7, key) : aCallable$5(length2 > 2 ? arguments[2] : void 0)(key, map7);
    set$3(map7, key, callback2(value, key, map7));
    return map7;
  }
});
var call$d = functionCall;
var aCallable$4 = aCallable$Q;
var isCallable$6 = isCallable$I;
var anObject$g = anObject$1i;
var $TypeError$b = TypeError;
var mapUpsert = function upsert(key, updateFn) {
  var map7 = anObject$g(this);
  var get3 = aCallable$4(map7.get);
  var has4 = aCallable$4(map7.has);
  var set4 = aCallable$4(map7.set);
  var insertFn = arguments.length > 2 ? arguments[2] : void 0;
  var value;
  if (!isCallable$6(updateFn) && !isCallable$6(insertFn)) {
    throw new $TypeError$b("At least one callback required");
  }
  if (call$d(has4, map7, key)) {
    value = call$d(get3, map7, key);
    if (isCallable$6(updateFn)) {
      value = updateFn(value);
      call$d(set4, map7, key, value);
    }
  } else if (isCallable$6(insertFn)) {
    value = insertFn();
    call$d(set4, map7, key, value);
  }
  return value;
};
var $$1t = _export;
var upsert$2 = mapUpsert;
$$1t({ target: "Map", proto: true, real: true, name: "upsert", forced: true }, {
  updateOrInsert: upsert$2
});
var $$1s = _export;
var upsert$1 = mapUpsert;
$$1s({ target: "Map", proto: true, real: true, forced: true }, {
  upsert: upsert$1
});
var $$1r = _export;
var min$3 = Math.min;
var max$1 = Math.max;
$$1r({ target: "Math", stat: true, forced: true }, {
  clamp: function clamp(x2, lower, upper) {
    return min$3(upper, max$1(lower, x2));
  }
});
var $$1q = _export;
$$1q({ target: "Math", stat: true, nonConfigurable: true, nonWritable: true }, {
  DEG_PER_RAD: Math.PI / 180
});
var $$1p = _export;
var RAD_PER_DEG = 180 / Math.PI;
$$1p({ target: "Math", stat: true, forced: true }, {
  degrees: function degrees(radians2) {
    return radians2 * RAD_PER_DEG;
  }
});
var mathScale = Math.scale || function scale(x2, inLow, inHigh, outLow, outHigh) {
  var nx = +x2;
  var nInLow = +inLow;
  var nInHigh = +inHigh;
  var nOutLow = +outLow;
  var nOutHigh = +outHigh;
  if (nx !== nx || nInLow !== nInLow || nInHigh !== nInHigh || nOutLow !== nOutLow || nOutHigh !== nOutHigh) return NaN;
  if (nx === Infinity || nx === -Infinity) return nx;
  return (nx - nInLow) * (nOutHigh - nOutLow) / (nInHigh - nInLow) + nOutLow;
};
var $$1o = _export;
var scale$1 = mathScale;
var fround2 = mathFround;
$$1o({ target: "Math", stat: true, forced: true }, {
  fscale: function fscale(x2, inLow, inHigh, outLow, outHigh) {
    return fround2(scale$1(x2, inLow, inHigh, outLow, outHigh));
  }
});
var $$1n = _export;
var f16round2 = mathF16round;
$$1n({ target: "Math", stat: true }, { f16round: f16round2 });
var $$1m = _export;
$$1m({ target: "Math", stat: true, forced: true }, {
  iaddh: function iaddh(x0, x1, y0, y1) {
    var $x0 = x0 >>> 0;
    var $x1 = x1 >>> 0;
    var $y0 = y0 >>> 0;
    return $x1 + (y1 >>> 0) + (($x0 & $y0 | ($x0 | $y0) & ~($x0 + $y0 >>> 0)) >>> 31) | 0;
  }
});
var $$1l = _export;
$$1l({ target: "Math", stat: true, forced: true }, {
  imulh: function imulh(u2, v2) {
    var UINT16 = 65535;
    var $u = +u2;
    var $v = +v2;
    var u0 = $u & UINT16;
    var v0 = $v & UINT16;
    var u1 = $u >> 16;
    var v1 = $v >> 16;
    var t2 = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
    return u1 * v1 + (t2 >> 16) + ((u0 * v1 >>> 0) + (t2 & UINT16) >> 16);
  }
});
var $$1k = _export;
$$1k({ target: "Math", stat: true, forced: true }, {
  isubh: function isubh(x0, x1, y0, y1) {
    var $x0 = x0 >>> 0;
    var $x1 = x1 >>> 0;
    var $y0 = y0 >>> 0;
    return $x1 - (y1 >>> 0) - ((~$x0 & $y0 | ~($x0 ^ $y0) & $x0 - $y0 >>> 0) >>> 31) | 0;
  }
});
var $$1j = _export;
$$1j({ target: "Math", stat: true, nonConfigurable: true, nonWritable: true }, {
  RAD_PER_DEG: 180 / Math.PI
});
var $$1i = _export;
var DEG_PER_RAD = Math.PI / 180;
$$1i({ target: "Math", stat: true, forced: true }, {
  radians: function radians(degrees2) {
    return degrees2 * DEG_PER_RAD;
  }
});
var $$1h = _export;
var scale2 = mathScale;
$$1h({ target: "Math", stat: true, forced: true }, {
  scale: scale2
});
var $$1g = _export;
var anObject$f = anObject$1i;
var numberIsFinite = numberIsFinite$2;
var createIteratorConstructor$3 = iteratorCreateConstructor;
var createIterResultObject$3 = createIterResultObject$h;
var InternalStateModule$6 = internalState;
var SEEDED_RANDOM = "Seeded Random";
var SEEDED_RANDOM_GENERATOR = SEEDED_RANDOM + " Generator";
var SEED_TYPE_ERROR = 'Math.seededPRNG() argument should have a "seed" field with a finite value.';
var setInternalState$6 = InternalStateModule$6.set;
var getInternalState$3 = InternalStateModule$6.getterFor(SEEDED_RANDOM_GENERATOR);
var $TypeError$a = TypeError;
var $SeededRandomGenerator = createIteratorConstructor$3(function SeededRandomGenerator(seed) {
  setInternalState$6(this, {
    type: SEEDED_RANDOM_GENERATOR,
    seed: seed % 2147483647
  });
}, SEEDED_RANDOM, function next5() {
  var state = getInternalState$3(this);
  var seed = state.seed = (state.seed * 1103515245 + 12345) % 2147483647;
  return createIterResultObject$3((seed & 1073741823) / 1073741823, false);
});
$$1g({ target: "Math", stat: true, forced: true }, {
  seededPRNG: function seededPRNG(it) {
    var seed = anObject$f(it).seed;
    if (!numberIsFinite(seed)) throw new $TypeError$a(SEED_TYPE_ERROR);
    return new $SeededRandomGenerator(seed);
  }
});
var $$1f = _export;
$$1f({ target: "Math", stat: true, forced: true }, {
  signbit: function signbit(x2) {
    var n2 = +x2;
    return n2 === n2 && n2 === 0 ? 1 / n2 === -Infinity : n2 < 0;
  }
});
var $$1e = _export;
var uncurryThis$q = functionUncurryThis;
var iterate$9 = iterate$H;
var $RangeError$2 = RangeError;
var $TypeError$9 = TypeError;
var $Infinity = Infinity;
var $NaN = NaN;
var abs$2 = Math.abs;
var pow$2 = Math.pow;
var push$8 = uncurryThis$q([].push);
var POW_2_1023 = pow$2(2, 1023);
var MAX_SAFE_INTEGER = pow$2(2, 53) - 1;
var MAX_DOUBLE = Number.MAX_VALUE;
var MAX_ULP = pow$2(2, 971);
var NOT_A_NUMBER = {};
var MINUS_INFINITY = {};
var PLUS_INFINITY = {};
var MINUS_ZERO = {};
var FINITE = {};
var twosum = function(x2, y2) {
  var hi2 = x2 + y2;
  var lo = y2 - (hi2 - x2);
  return { hi: hi2, lo };
};
$$1e({ target: "Math", stat: true }, {
  // eslint-disable-next-line max-statements -- ok
  sumPrecise: function sumPrecise(items) {
    var numbers = [];
    var count = 0;
    var state = MINUS_ZERO;
    iterate$9(items, function(n3) {
      if (++count >= MAX_SAFE_INTEGER) throw new $RangeError$2("Maximum allowed index exceeded");
      if (typeof n3 != "number") throw new $TypeError$9("Value is not a number");
      if (state !== NOT_A_NUMBER) {
        if (n3 !== n3) state = NOT_A_NUMBER;
        else if (n3 === $Infinity) state = state === MINUS_INFINITY ? NOT_A_NUMBER : PLUS_INFINITY;
        else if (n3 === -$Infinity) state = state === PLUS_INFINITY ? NOT_A_NUMBER : MINUS_INFINITY;
        else if ((n3 !== 0 || 1 / n3 === $Infinity) && (state === MINUS_ZERO || state === FINITE)) {
          state = FINITE;
          push$8(numbers, n3);
        }
      }
    });
    switch (state) {
      case NOT_A_NUMBER:
        return $NaN;
      case MINUS_INFINITY:
        return -$Infinity;
      case PLUS_INFINITY:
        return $Infinity;
      case MINUS_ZERO:
        return -0;
    }
    var partials = [];
    var overflow = 0;
    var x2, y2, sum, hi2, lo, tmp;
    for (var i = 0; i < numbers.length; i++) {
      x2 = numbers[i];
      var actuallyUsedPartials = 0;
      for (var j = 0; j < partials.length; j++) {
        y2 = partials[j];
        if (abs$2(x2) < abs$2(y2)) {
          tmp = x2;
          x2 = y2;
          y2 = tmp;
        }
        sum = twosum(x2, y2);
        hi2 = sum.hi;
        lo = sum.lo;
        if (abs$2(hi2) === $Infinity) {
          var sign3 = hi2 === $Infinity ? 1 : -1;
          overflow += sign3;
          x2 = x2 - sign3 * POW_2_1023 - sign3 * POW_2_1023;
          if (abs$2(x2) < abs$2(y2)) {
            tmp = x2;
            x2 = y2;
            y2 = tmp;
          }
          sum = twosum(x2, y2);
          hi2 = sum.hi;
          lo = sum.lo;
        }
        if (lo !== 0) partials[actuallyUsedPartials++] = lo;
        x2 = hi2;
      }
      partials.length = actuallyUsedPartials;
      if (x2 !== 0) push$8(partials, x2);
    }
    var n2 = partials.length - 1;
    hi2 = 0;
    lo = 0;
    if (overflow !== 0) {
      var next11 = n2 >= 0 ? partials[n2] : 0;
      n2--;
      if (abs$2(overflow) > 1 || overflow > 0 && next11 > 0 || overflow < 0 && next11 < 0) {
        return overflow > 0 ? $Infinity : -$Infinity;
      }
      sum = twosum(overflow * POW_2_1023, next11 / 2);
      hi2 = sum.hi;
      lo = sum.lo;
      lo *= 2;
      if (abs$2(2 * hi2) === $Infinity) {
        if (hi2 > 0) {
          return hi2 === POW_2_1023 && lo === -(MAX_ULP / 2) && n2 >= 0 && partials[n2] < 0 ? MAX_DOUBLE : $Infinity;
        }
        return hi2 === -POW_2_1023 && lo === MAX_ULP / 2 && n2 >= 0 && partials[n2] > 0 ? -MAX_DOUBLE : -$Infinity;
      }
      if (lo !== 0) {
        partials[++n2] = lo;
        lo = 0;
      }
      hi2 *= 2;
    }
    while (n2 >= 0) {
      sum = twosum(hi2, partials[n2--]);
      hi2 = sum.hi;
      lo = sum.lo;
      if (lo !== 0) break;
    }
    if (n2 >= 0 && (lo < 0 && partials[n2] < 0 || lo > 0 && partials[n2] > 0)) {
      y2 = lo * 2;
      x2 = hi2 + y2;
      if (y2 === x2 - hi2) hi2 = x2;
    }
    return hi2;
  }
});
var $$1d = _export;
$$1d({ target: "Math", stat: true, forced: true }, {
  umulh: function umulh(u2, v2) {
    var UINT16 = 65535;
    var $u = +u2;
    var $v = +v2;
    var u0 = $u & UINT16;
    var v0 = $v & UINT16;
    var u1 = $u >>> 16;
    var v1 = $v >>> 16;
    var t2 = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
    return u1 * v1 + (t2 >>> 16) + ((u0 * v1 >>> 0) + (t2 & UINT16) >>> 16);
  }
});
var $$1c = _export;
var uncurryThis$p = functionUncurryThis;
var toIntegerOrInfinity$2 = toIntegerOrInfinity$p;
var INVALID_NUMBER_REPRESENTATION = "Invalid number representation";
var INVALID_RADIX = "Invalid radix";
var $RangeError$1 = RangeError;
var $SyntaxError = SyntaxError;
var $TypeError$8 = TypeError;
var $parseInt$1 = parseInt;
var pow$1 = Math.pow;
var valid = /^[\d.a-z]+$/;
var charAt$a = uncurryThis$p("".charAt);
var exec$7 = uncurryThis$p(valid.exec);
var numberToString$3 = uncurryThis$p(1 .toString);
var stringSlice$5 = uncurryThis$p("".slice);
var split$4 = uncurryThis$p("".split);
$$1c({ target: "Number", stat: true, forced: true }, {
  fromString: function fromString(string, radix) {
    var sign3 = 1;
    if (typeof string != "string") throw new $TypeError$8(INVALID_NUMBER_REPRESENTATION);
    if (!string.length) throw new $SyntaxError(INVALID_NUMBER_REPRESENTATION);
    if (charAt$a(string, 0) === "-") {
      sign3 = -1;
      string = stringSlice$5(string, 1);
      if (!string.length) throw new $SyntaxError(INVALID_NUMBER_REPRESENTATION);
    }
    var R2 = radix === void 0 ? 10 : toIntegerOrInfinity$2(radix);
    if (R2 < 2 || R2 > 36) throw new $RangeError$1(INVALID_RADIX);
    if (!exec$7(valid, string)) throw new $SyntaxError(INVALID_NUMBER_REPRESENTATION);
    var parts = split$4(string, ".");
    var mathNum = $parseInt$1(parts[0], R2);
    if (parts.length > 1) mathNum += $parseInt$1(parts[1], R2) / pow$1(R2, parts[1].length);
    if (R2 === 10 && numberToString$3(mathNum, R2) !== string) throw new $SyntaxError(INVALID_NUMBER_REPRESENTATION);
    return sign3 * mathNum;
  }
});
var $$1b = _export;
var NumericRangeIterator2 = numericRangeIterator;
$$1b({ target: "Number", stat: true, forced: true }, {
  range: function range2(start, end, option) {
    return new NumericRangeIterator2(start, end, option, "number", 0, 1);
  }
});
var InternalStateModule$5 = internalState;
var createIteratorConstructor$2 = iteratorCreateConstructor;
var createIterResultObject$2 = createIterResultObject$h;
var hasOwn$9 = hasOwnProperty_1;
var objectKeys$1 = objectKeys$6;
var toObject$1 = toObject$E;
var OBJECT_ITERATOR = "Object Iterator";
var setInternalState$5 = InternalStateModule$5.set;
var getInternalState$2 = InternalStateModule$5.getterFor(OBJECT_ITERATOR);
var objectIterator = createIteratorConstructor$2(function ObjectIterator(source, mode) {
  var object = toObject$1(source);
  setInternalState$5(this, {
    type: OBJECT_ITERATOR,
    mode,
    object,
    keys: objectKeys$1(object),
    index: 0
  });
}, "Object", function next6() {
  var state = getInternalState$2(this);
  var keys6 = state.keys;
  while (true) {
    if (keys6 === null || state.index >= keys6.length) {
      state.object = state.keys = null;
      return createIterResultObject$2(void 0, true);
    }
    var key = keys6[state.index++];
    var object = state.object;
    if (!hasOwn$9(object, key)) continue;
    switch (state.mode) {
      case "keys":
        return createIterResultObject$2(key, false);
      case "values":
        return createIterResultObject$2(object[key], false);
    }
    return createIterResultObject$2([key, object[key]], false);
  }
});
var $$1a = _export;
var ObjectIterator$2 = objectIterator;
$$1a({ target: "Object", stat: true, forced: true }, {
  iterateEntries: function iterateEntries(object) {
    return new ObjectIterator$2(object, "entries");
  }
});
var $$19 = _export;
var ObjectIterator$1 = objectIterator;
$$19({ target: "Object", stat: true, forced: true }, {
  iterateKeys: function iterateKeys(object) {
    return new ObjectIterator$1(object, "keys");
  }
});
var $$18 = _export;
var ObjectIterator2 = objectIterator;
$$18({ target: "Object", stat: true, forced: true }, {
  iterateValues: function iterateValues(object) {
    return new ObjectIterator2(object, "values");
  }
});
var $$17 = _export;
var call$c = functionCall;
var DESCRIPTORS$8 = descriptors$1;
var setSpecies = setSpecies$7;
var aCallable$3 = aCallable$Q;
var anObject$e = anObject$1i;
var anInstance$4 = anInstance$f;
var isCallable$5 = isCallable$I;
var isNullOrUndefined$2 = isNullOrUndefined$j;
var isObject$5 = isObject$O;
var getMethod$1 = getMethod$l;
var defineBuiltIn$5 = defineBuiltIn$u;
var defineBuiltIns$1 = defineBuiltIns$b;
var defineBuiltInAccessor$5 = defineBuiltInAccessor$p;
var hostReportErrors = hostReportErrors$2;
var wellKnownSymbol$6 = wellKnownSymbol$S;
var InternalStateModule$4 = internalState;
var $$OBSERVABLE$1 = wellKnownSymbol$6("observable");
var OBSERVABLE = "Observable";
var SUBSCRIPTION = "Subscription";
var SUBSCRIPTION_OBSERVER = "SubscriptionObserver";
var getterFor$1 = InternalStateModule$4.getterFor;
var setInternalState$4 = InternalStateModule$4.set;
var getObservableInternalState = getterFor$1(OBSERVABLE);
var getSubscriptionInternalState = getterFor$1(SUBSCRIPTION);
var getSubscriptionObserverInternalState = getterFor$1(SUBSCRIPTION_OBSERVER);
var SubscriptionState = function(observer) {
  this.observer = anObject$e(observer);
  this.cleanup = null;
  this.subscriptionObserver = null;
};
SubscriptionState.prototype = {
  type: SUBSCRIPTION,
  clean: function() {
    var cleanup = this.cleanup;
    if (cleanup) {
      this.cleanup = null;
      try {
        cleanup();
      } catch (error2) {
        hostReportErrors(error2);
      }
    }
  },
  close: function() {
    if (!DESCRIPTORS$8) {
      var subscription = this.facade;
      var subscriptionObserver = this.subscriptionObserver;
      subscription.closed = true;
      if (subscriptionObserver) subscriptionObserver.closed = true;
    }
    this.observer = null;
  },
  isClosed: function() {
    return this.observer === null;
  }
};
var Subscription = function(observer, subscriber) {
  var subscriptionState = setInternalState$4(this, new SubscriptionState(observer));
  var start;
  if (!DESCRIPTORS$8) this.closed = false;
  try {
    if (start = getMethod$1(observer, "start")) call$c(start, observer, this);
  } catch (error2) {
    hostReportErrors(error2);
  }
  if (subscriptionState.isClosed()) return;
  var subscriptionObserver = subscriptionState.subscriptionObserver = new SubscriptionObserver(subscriptionState);
  try {
    var cleanup = subscriber(subscriptionObserver);
    var subscription = cleanup;
    if (!isNullOrUndefined$2(cleanup)) subscriptionState.cleanup = isCallable$5(cleanup.unsubscribe) ? function() {
      subscription.unsubscribe();
    } : aCallable$3(cleanup);
  } catch (error2) {
    subscriptionObserver.error(error2);
    return;
  }
  if (subscriptionState.isClosed()) subscriptionState.clean();
};
Subscription.prototype = defineBuiltIns$1({}, {
  unsubscribe: function unsubscribe() {
    var subscriptionState = getSubscriptionInternalState(this);
    if (!subscriptionState.isClosed()) {
      subscriptionState.close();
      subscriptionState.clean();
    }
  }
});
if (DESCRIPTORS$8) defineBuiltInAccessor$5(Subscription.prototype, "closed", {
  configurable: true,
  get: function closed() {
    return getSubscriptionInternalState(this).isClosed();
  }
});
var SubscriptionObserver = function(subscriptionState) {
  setInternalState$4(this, {
    type: SUBSCRIPTION_OBSERVER,
    subscriptionState
  });
  if (!DESCRIPTORS$8) this.closed = false;
};
SubscriptionObserver.prototype = defineBuiltIns$1({}, {
  next: function next7(value) {
    var subscriptionState = getSubscriptionObserverInternalState(this).subscriptionState;
    if (!subscriptionState.isClosed()) {
      var observer = subscriptionState.observer;
      try {
        var nextMethod = getMethod$1(observer, "next");
        if (nextMethod) call$c(nextMethod, observer, value);
      } catch (error2) {
        hostReportErrors(error2);
      }
    }
  },
  error: function error(value) {
    var subscriptionState = getSubscriptionObserverInternalState(this).subscriptionState;
    if (!subscriptionState.isClosed()) {
      var observer = subscriptionState.observer;
      subscriptionState.close();
      try {
        var errorMethod = getMethod$1(observer, "error");
        if (errorMethod) call$c(errorMethod, observer, value);
        else hostReportErrors(value);
      } catch (err) {
        hostReportErrors(err);
      }
      subscriptionState.clean();
    }
  },
  complete: function complete() {
    var subscriptionState = getSubscriptionObserverInternalState(this).subscriptionState;
    if (!subscriptionState.isClosed()) {
      var observer = subscriptionState.observer;
      subscriptionState.close();
      try {
        var completeMethod = getMethod$1(observer, "complete");
        if (completeMethod) call$c(completeMethod, observer);
      } catch (error2) {
        hostReportErrors(error2);
      }
      subscriptionState.clean();
    }
  }
});
if (DESCRIPTORS$8) defineBuiltInAccessor$5(SubscriptionObserver.prototype, "closed", {
  configurable: true,
  get: function closed2() {
    return getSubscriptionObserverInternalState(this).subscriptionState.isClosed();
  }
});
var $Observable = function Observable(subscriber) {
  anInstance$4(this, ObservablePrototype);
  setInternalState$4(this, {
    type: OBSERVABLE,
    subscriber: aCallable$3(subscriber)
  });
};
var ObservablePrototype = $Observable.prototype;
defineBuiltIns$1(ObservablePrototype, {
  subscribe: function subscribe(observer) {
    var length2 = arguments.length;
    return new Subscription(isCallable$5(observer) ? {
      next: observer,
      error: length2 > 1 ? arguments[1] : void 0,
      complete: length2 > 2 ? arguments[2] : void 0
    } : isObject$5(observer) ? observer : {}, getObservableInternalState(this).subscriber);
  }
});
defineBuiltIn$5(ObservablePrototype, $$OBSERVABLE$1, function() {
  return this;
});
$$17({ global: true, constructor: true, forced: true }, {
  Observable: $Observable
});
setSpecies(OBSERVABLE);
var $$16 = _export;
var getBuiltIn$g = getBuiltIn$O;
var call$b = functionCall;
var anObject$d = anObject$1i;
var isConstructor$2 = isConstructor$a;
var getIterator$1 = getIterator$7;
var getMethod = getMethod$l;
var iterate$8 = iterate$H;
var wellKnownSymbol$5 = wellKnownSymbol$S;
var $$OBSERVABLE = wellKnownSymbol$5("observable");
$$16({ target: "Observable", stat: true, forced: true }, {
  from: function from5(x2) {
    var C2 = isConstructor$2(this) ? this : getBuiltIn$g("Observable");
    var observableMethod = getMethod(anObject$d(x2), $$OBSERVABLE);
    if (observableMethod) {
      var observable = anObject$d(call$b(observableMethod, x2));
      return observable.constructor === C2 ? observable : new C2(function(observer) {
        return observable.subscribe(observer);
      });
    }
    var iterator = getIterator$1(x2);
    return new C2(function(observer) {
      iterate$8(iterator, function(it, stop) {
        observer.next(it);
        if (observer.closed) return stop();
      }, { IS_ITERATOR: true, INTERRUPTED: true });
      observer.complete();
    });
  }
});
var $$15 = _export;
var getBuiltIn$f = getBuiltIn$O;
var isConstructor$1 = isConstructor$a;
var Array$2 = getBuiltIn$f("Array");
$$15({ target: "Observable", stat: true, forced: true }, {
  of: function of4() {
    var C2 = isConstructor$1(this) ? this : getBuiltIn$f("Observable");
    var length2 = arguments.length;
    var items = Array$2(length2);
    var index = 0;
    while (index < length2) items[index] = arguments[index++];
    return new C2(function(observer) {
      for (var i = 0; i < length2; i++) {
        observer.next(items[i]);
        if (observer.closed) return;
      }
      observer.complete();
    });
  }
});
var getBuiltIn$e = getBuiltIn$O;
var uncurryThis$o = functionUncurryThis;
var shared$1 = shared$a;
var Map$2 = getBuiltIn$e("Map");
var WeakMap$1 = getBuiltIn$e("WeakMap");
var push$7 = uncurryThis$o([].push);
var metadata = shared$1("metadata");
var store$2 = metadata.store || (metadata.store = new WeakMap$1());
var getOrCreateMetadataMap$1 = function(target, targetKey, create4) {
  var targetMetadata = store$2.get(target);
  if (!targetMetadata) {
    if (!create4) return;
    store$2.set(target, targetMetadata = new Map$2());
  }
  var keyMetadata = targetMetadata.get(targetKey);
  if (!keyMetadata) {
    if (!create4) return;
    targetMetadata.set(targetKey, keyMetadata = new Map$2());
  }
  return keyMetadata;
};
var ordinaryHasOwnMetadata$3 = function(MetadataKey, O2, P2) {
  var metadataMap = getOrCreateMetadataMap$1(O2, P2, false);
  return metadataMap === void 0 ? false : metadataMap.has(MetadataKey);
};
var ordinaryGetOwnMetadata$2 = function(MetadataKey, O2, P2) {
  var metadataMap = getOrCreateMetadataMap$1(O2, P2, false);
  return metadataMap === void 0 ? void 0 : metadataMap.get(MetadataKey);
};
var ordinaryDefineOwnMetadata$2 = function(MetadataKey, MetadataValue, O2, P2) {
  getOrCreateMetadataMap$1(O2, P2, true).set(MetadataKey, MetadataValue);
};
var ordinaryOwnMetadataKeys$2 = function(target, targetKey) {
  var metadataMap = getOrCreateMetadataMap$1(target, targetKey, false);
  var keys6 = [];
  if (metadataMap) metadataMap.forEach(function(_, key) {
    push$7(keys6, key);
  });
  return keys6;
};
var toMetadataKey$9 = function(it) {
  return it === void 0 || typeof it == "symbol" ? it : String(it);
};
var reflectMetadata = {
  store: store$2,
  getMap: getOrCreateMetadataMap$1,
  has: ordinaryHasOwnMetadata$3,
  get: ordinaryGetOwnMetadata$2,
  set: ordinaryDefineOwnMetadata$2,
  keys: ordinaryOwnMetadataKeys$2,
  toKey: toMetadataKey$9
};
var $$14 = _export;
var ReflectMetadataModule$8 = reflectMetadata;
var anObject$c = anObject$1i;
var toMetadataKey$8 = ReflectMetadataModule$8.toKey;
var ordinaryDefineOwnMetadata$1 = ReflectMetadataModule$8.set;
$$14({ target: "Reflect", stat: true }, {
  defineMetadata: function defineMetadata(metadataKey, metadataValue, target) {
    var targetKey = arguments.length < 4 ? void 0 : toMetadataKey$8(arguments[3]);
    ordinaryDefineOwnMetadata$1(metadataKey, metadataValue, anObject$c(target), targetKey);
  }
});
var $$13 = _export;
var ReflectMetadataModule$7 = reflectMetadata;
var anObject$b = anObject$1i;
var toMetadataKey$7 = ReflectMetadataModule$7.toKey;
var getOrCreateMetadataMap = ReflectMetadataModule$7.getMap;
var store$1 = ReflectMetadataModule$7.store;
$$13({ target: "Reflect", stat: true }, {
  deleteMetadata: function deleteMetadata(metadataKey, target) {
    var targetKey = arguments.length < 3 ? void 0 : toMetadataKey$7(arguments[2]);
    var metadataMap = getOrCreateMetadataMap(anObject$b(target), targetKey, false);
    if (metadataMap === void 0 || !metadataMap["delete"](metadataKey)) return false;
    if (metadataMap.size) return true;
    var targetMetadata = store$1.get(target);
    targetMetadata["delete"](targetKey);
    return !!targetMetadata.size || store$1["delete"](target);
  }
});
var $$12 = _export;
var ReflectMetadataModule$6 = reflectMetadata;
var anObject$a = anObject$1i;
var getPrototypeOf$3 = objectGetPrototypeOf$2;
var ordinaryHasOwnMetadata$2 = ReflectMetadataModule$6.has;
var ordinaryGetOwnMetadata$1 = ReflectMetadataModule$6.get;
var toMetadataKey$6 = ReflectMetadataModule$6.toKey;
var ordinaryGetMetadata = function(MetadataKey, O2, P2) {
  var hasOwn3 = ordinaryHasOwnMetadata$2(MetadataKey, O2, P2);
  if (hasOwn3) return ordinaryGetOwnMetadata$1(MetadataKey, O2, P2);
  var parent = getPrototypeOf$3(O2);
  return parent !== null ? ordinaryGetMetadata(MetadataKey, parent, P2) : void 0;
};
$$12({ target: "Reflect", stat: true }, {
  getMetadata: function getMetadata(metadataKey, target) {
    var targetKey = arguments.length < 3 ? void 0 : toMetadataKey$6(arguments[2]);
    return ordinaryGetMetadata(metadataKey, anObject$a(target), targetKey);
  }
});
var $$11 = _export;
var uncurryThis$n = functionUncurryThis;
var ReflectMetadataModule$5 = reflectMetadata;
var anObject$9 = anObject$1i;
var getPrototypeOf$2 = objectGetPrototypeOf$2;
var $arrayUniqueBy$1 = arrayUniqueBy$2;
var arrayUniqueBy$1 = uncurryThis$n($arrayUniqueBy$1);
var concat3 = uncurryThis$n([].concat);
var ordinaryOwnMetadataKeys$1 = ReflectMetadataModule$5.keys;
var toMetadataKey$5 = ReflectMetadataModule$5.toKey;
var ordinaryMetadataKeys = function(O2, P2) {
  var oKeys = ordinaryOwnMetadataKeys$1(O2, P2);
  var parent = getPrototypeOf$2(O2);
  if (parent === null) return oKeys;
  var pKeys = ordinaryMetadataKeys(parent, P2);
  return pKeys.length ? oKeys.length ? arrayUniqueBy$1(concat3(oKeys, pKeys)) : pKeys : oKeys;
};
$$11({ target: "Reflect", stat: true }, {
  getMetadataKeys: function getMetadataKeys(target) {
    var targetKey = arguments.length < 2 ? void 0 : toMetadataKey$5(arguments[1]);
    return ordinaryMetadataKeys(anObject$9(target), targetKey);
  }
});
var $$10 = _export;
var ReflectMetadataModule$4 = reflectMetadata;
var anObject$8 = anObject$1i;
var ordinaryGetOwnMetadata = ReflectMetadataModule$4.get;
var toMetadataKey$4 = ReflectMetadataModule$4.toKey;
$$10({ target: "Reflect", stat: true }, {
  getOwnMetadata: function getOwnMetadata(metadataKey, target) {
    var targetKey = arguments.length < 3 ? void 0 : toMetadataKey$4(arguments[2]);
    return ordinaryGetOwnMetadata(metadataKey, anObject$8(target), targetKey);
  }
});
var $$$ = _export;
var ReflectMetadataModule$3 = reflectMetadata;
var anObject$7 = anObject$1i;
var ordinaryOwnMetadataKeys = ReflectMetadataModule$3.keys;
var toMetadataKey$3 = ReflectMetadataModule$3.toKey;
$$$({ target: "Reflect", stat: true }, {
  getOwnMetadataKeys: function getOwnMetadataKeys(target) {
    var targetKey = arguments.length < 2 ? void 0 : toMetadataKey$3(arguments[1]);
    return ordinaryOwnMetadataKeys(anObject$7(target), targetKey);
  }
});
var $$_ = _export;
var ReflectMetadataModule$2 = reflectMetadata;
var anObject$6 = anObject$1i;
var getPrototypeOf$1 = objectGetPrototypeOf$2;
var ordinaryHasOwnMetadata$1 = ReflectMetadataModule$2.has;
var toMetadataKey$2 = ReflectMetadataModule$2.toKey;
var ordinaryHasMetadata = function(MetadataKey, O2, P2) {
  var hasOwn3 = ordinaryHasOwnMetadata$1(MetadataKey, O2, P2);
  if (hasOwn3) return true;
  var parent = getPrototypeOf$1(O2);
  return parent !== null ? ordinaryHasMetadata(MetadataKey, parent, P2) : false;
};
$$_({ target: "Reflect", stat: true }, {
  hasMetadata: function hasMetadata(metadataKey, target) {
    var targetKey = arguments.length < 3 ? void 0 : toMetadataKey$2(arguments[2]);
    return ordinaryHasMetadata(metadataKey, anObject$6(target), targetKey);
  }
});
var $$Z = _export;
var ReflectMetadataModule$1 = reflectMetadata;
var anObject$5 = anObject$1i;
var ordinaryHasOwnMetadata = ReflectMetadataModule$1.has;
var toMetadataKey$1 = ReflectMetadataModule$1.toKey;
$$Z({ target: "Reflect", stat: true }, {
  hasOwnMetadata: function hasOwnMetadata(metadataKey, target) {
    var targetKey = arguments.length < 3 ? void 0 : toMetadataKey$1(arguments[2]);
    return ordinaryHasOwnMetadata(metadataKey, anObject$5(target), targetKey);
  }
});
var $$Y = _export;
var ReflectMetadataModule = reflectMetadata;
var anObject$4 = anObject$1i;
var toMetadataKey = ReflectMetadataModule.toKey;
var ordinaryDefineOwnMetadata = ReflectMetadataModule.set;
$$Y({ target: "Reflect", stat: true }, {
  metadata: function metadata2(metadataKey, metadataValue) {
    return function decorator(target, key) {
      ordinaryDefineOwnMetadata(metadataKey, metadataValue, anObject$4(target), toMetadataKey(key));
    };
  }
});
var $TypeError$7 = TypeError;
var aString$4 = function(argument) {
  if (typeof argument == "string") return argument;
  throw new $TypeError$7("Argument is not a string");
};
var $$X = _export;
var uncurryThis$m = functionUncurryThis;
var aString$3 = aString$4;
var hasOwn$8 = hasOwnProperty_1;
var padStart2 = stringPad.start;
var WHITESPACES = whitespaces$6;
var $Array$1 = Array;
var $escape = RegExp.escape;
var charAt$9 = uncurryThis$m("".charAt);
var charCodeAt$3 = uncurryThis$m("".charCodeAt);
var numberToString$2 = uncurryThis$m(1.1.toString);
var join$4 = uncurryThis$m([].join);
var FIRST_DIGIT_OR_ASCII = /^[0-9a-z]/i;
var SYNTAX_SOLIDUS = /^[$()*+./?[\\\]^{|}]/;
var OTHER_PUNCTUATORS_AND_WHITESPACES = RegExp("^[!\"#%&',\\-:;<=>@`~" + WHITESPACES + "]");
var exec$6 = uncurryThis$m(FIRST_DIGIT_OR_ASCII.exec);
var ControlEscape = {
  "	": "t",
  "\n": "n",
  "\v": "v",
  "\f": "f",
  "\r": "r"
};
var escapeChar = function(chr) {
  var hex3 = numberToString$2(charCodeAt$3(chr, 0), 16);
  return hex3.length < 3 ? "\\x" + padStart2(hex3, 2, "0") : "\\u" + padStart2(hex3, 4, "0");
};
var FORCED$1 = !$escape || $escape("ab") !== "\\x61b";
$$X({ target: "RegExp", stat: true, forced: FORCED$1 }, {
  escape: function escape3(S2) {
    aString$3(S2);
    var length2 = S2.length;
    var result = $Array$1(length2);
    for (var i = 0; i < length2; i++) {
      var chr = charAt$9(S2, i);
      if (i === 0 && exec$6(FIRST_DIGIT_OR_ASCII, chr)) {
        result[i] = escapeChar(chr);
      } else if (hasOwn$8(ControlEscape, chr)) {
        result[i] = "\\" + ControlEscape[chr];
      } else if (exec$6(SYNTAX_SOLIDUS, chr)) {
        result[i] = "\\" + chr;
      } else if (exec$6(OTHER_PUNCTUATORS_AND_WHITESPACES, chr)) {
        result[i] = escapeChar(chr);
      } else {
        var charCode = charCodeAt$3(chr, 0);
        if ((charCode & 63488) !== 55296) result[i] = chr;
        else if (charCode >= 56320 || i + 1 >= length2 || (charCodeAt$3(S2, i + 1) & 64512) !== 56320) result[i] = escapeChar(chr);
        else {
          result[i] = chr;
          result[++i] = charAt$9(S2, i);
        }
      }
    }
    return join$4(result, "");
  }
});
var $$W = _export;
var aSet$8 = aSet$g;
var add$3 = setHelpers.add;
$$W({ target: "Set", proto: true, real: true, forced: true }, {
  addAll: function addAll() {
    var set4 = aSet$8(this);
    for (var k2 = 0, len = arguments.length; k2 < len; k2++) {
      add$3(set4, arguments[k2]);
    }
    return set4;
  }
});
var $$V = _export;
var aSet$7 = aSet$g;
var remove$2 = setHelpers.remove;
$$V({ target: "Set", proto: true, real: true, forced: true }, {
  deleteAll: function deleteAll2() {
    var collection2 = aSet$7(this);
    var allDeleted = true;
    var wasDeleted;
    for (var k2 = 0, len = arguments.length; k2 < len; k2++) {
      wasDeleted = remove$2(collection2, arguments[k2]);
      allDeleted = allDeleted && wasDeleted;
    }
    return !!allDeleted;
  }
});
var classof$3 = classof$p;
var hasOwn$7 = hasOwnProperty_1;
var isNullOrUndefined$1 = isNullOrUndefined$j;
var wellKnownSymbol$4 = wellKnownSymbol$S;
var Iterators = iterators;
var ITERATOR$3 = wellKnownSymbol$4("iterator");
var $Object = Object;
var isIterable$1 = function(it) {
  if (isNullOrUndefined$1(it)) return false;
  var O2 = $Object(it);
  return O2[ITERATOR$3] !== void 0 || "@@iterator" in O2 || hasOwn$7(Iterators, classof$3(O2));
};
var getBuiltIn$d = getBuiltIn$O;
var isCallable$4 = isCallable$I;
var isIterable = isIterable$1;
var isObject$4 = isObject$O;
var Set$4 = getBuiltIn$d("Set");
var isSetLike = function(it) {
  return isObject$4(it) && typeof it.size == "number" && isCallable$4(it.has) && isCallable$4(it.keys);
};
var toSetLike$7 = function(it) {
  if (isSetLike(it)) return it;
  return isIterable(it) ? new Set$4(it) : it;
};
var $$U = _export;
var call$a = functionCall;
var toSetLike$6 = toSetLike$7;
var $difference = setDifference;
$$U({ target: "Set", proto: true, real: true, forced: true }, {
  difference: function difference3(other) {
    return call$a($difference, this, toSetLike$6(other));
  }
});
var $$T = _export;
var bind$7 = functionBindContext;
var aSet$6 = aSet$g;
var iterate$7 = setIterate$1;
$$T({ target: "Set", proto: true, real: true, forced: true }, {
  every: function every6(callbackfn) {
    var set4 = aSet$6(this);
    var boundFunction = bind$7(callbackfn, arguments.length > 1 ? arguments[1] : void 0);
    return iterate$7(set4, function(value) {
      if (!boundFunction(value, value, set4)) return false;
    }, true) !== false;
  }
});
var $$S = _export;
var bind$6 = functionBindContext;
var aSet$5 = aSet$g;
var SetHelpers$4 = setHelpers;
var iterate$6 = setIterate$1;
var Set$3 = SetHelpers$4.Set;
var add$2 = SetHelpers$4.add;
$$S({ target: "Set", proto: true, real: true, forced: true }, {
  filter: function filter6(callbackfn) {
    var set4 = aSet$5(this);
    var boundFunction = bind$6(callbackfn, arguments.length > 1 ? arguments[1] : void 0);
    var newSet = new Set$3();
    iterate$6(set4, function(value) {
      if (boundFunction(value, value, set4)) add$2(newSet, value);
    });
    return newSet;
  }
});
var $$R = _export;
var bind$5 = functionBindContext;
var aSet$4 = aSet$g;
var iterate$5 = setIterate$1;
$$R({ target: "Set", proto: true, real: true, forced: true }, {
  find: function find6(callbackfn) {
    var set4 = aSet$4(this);
    var boundFunction = bind$5(callbackfn, arguments.length > 1 ? arguments[1] : void 0);
    var result = iterate$5(set4, function(value) {
      if (boundFunction(value, value, set4)) return { value };
    }, true);
    return result && result.value;
  }
});
var $$Q = _export;
var SetHelpers$3 = setHelpers;
var createCollectionFrom$2 = collectionFrom;
$$Q({ target: "Set", stat: true, forced: true }, {
  from: createCollectionFrom$2(SetHelpers$3.Set, SetHelpers$3.add, false)
});
var $$P = _export;
var call$9 = functionCall;
var toSetLike$5 = toSetLike$7;
var $intersection = setIntersection;
$$P({ target: "Set", proto: true, real: true, forced: true }, {
  intersection: function intersection3(other) {
    return call$9($intersection, this, toSetLike$5(other));
  }
});
var $$O = _export;
var call$8 = functionCall;
var toSetLike$4 = toSetLike$7;
var $isDisjointFrom = setIsDisjointFrom;
$$O({ target: "Set", proto: true, real: true, forced: true }, {
  isDisjointFrom: function isDisjointFrom3(other) {
    return call$8($isDisjointFrom, this, toSetLike$4(other));
  }
});
var $$N = _export;
var call$7 = functionCall;
var toSetLike$3 = toSetLike$7;
var $isSubsetOf = setIsSubsetOf;
$$N({ target: "Set", proto: true, real: true, forced: true }, {
  isSubsetOf: function isSubsetOf3(other) {
    return call$7($isSubsetOf, this, toSetLike$3(other));
  }
});
var $$M = _export;
var call$6 = functionCall;
var toSetLike$2 = toSetLike$7;
var $isSupersetOf = setIsSupersetOf;
$$M({ target: "Set", proto: true, real: true, forced: true }, {
  isSupersetOf: function isSupersetOf3(other) {
    return call$6($isSupersetOf, this, toSetLike$2(other));
  }
});
var $$L = _export;
var uncurryThis$l = functionUncurryThis;
var aSet$3 = aSet$g;
var iterate$4 = setIterate$1;
var toString$a = toString$K;
var arrayJoin = uncurryThis$l([].join);
var push$6 = uncurryThis$l([].push);
$$L({ target: "Set", proto: true, real: true, forced: true }, {
  join: function join3(separator) {
    var set4 = aSet$3(this);
    var sep = separator === void 0 ? "," : toString$a(separator);
    var array = [];
    iterate$4(set4, function(value) {
      push$6(array, value);
    });
    return arrayJoin(array, sep);
  }
});
var $$K = _export;
var bind$4 = functionBindContext;
var aSet$2 = aSet$g;
var SetHelpers$2 = setHelpers;
var iterate$3 = setIterate$1;
var Set$2 = SetHelpers$2.Set;
var add$1 = SetHelpers$2.add;
$$K({ target: "Set", proto: true, real: true, forced: true }, {
  map: function map6(callbackfn) {
    var set4 = aSet$2(this);
    var boundFunction = bind$4(callbackfn, arguments.length > 1 ? arguments[1] : void 0);
    var newSet = new Set$2();
    iterate$3(set4, function(value) {
      add$1(newSet, boundFunction(value, value, set4));
    });
    return newSet;
  }
});
var $$J = _export;
var SetHelpers$1 = setHelpers;
var createCollectionOf$2 = collectionOf;
$$J({ target: "Set", stat: true, forced: true }, {
  of: createCollectionOf$2(SetHelpers$1.Set, SetHelpers$1.add, false)
});
var $$I = _export;
var aCallable$2 = aCallable$Q;
var aSet$1 = aSet$g;
var iterate$2 = setIterate$1;
var $TypeError$6 = TypeError;
$$I({ target: "Set", proto: true, real: true, forced: true }, {
  reduce: function reduce6(callbackfn) {
    var set4 = aSet$1(this);
    var noInitial = arguments.length < 2;
    var accumulator = noInitial ? void 0 : arguments[1];
    aCallable$2(callbackfn);
    iterate$2(set4, function(value) {
      if (noInitial) {
        noInitial = false;
        accumulator = value;
      } else {
        accumulator = callbackfn(accumulator, value, value, set4);
      }
    });
    if (noInitial) throw new $TypeError$6("Reduce of empty set with no initial value");
    return accumulator;
  }
});
var $$H = _export;
var bind$3 = functionBindContext;
var aSet = aSet$g;
var iterate$1 = setIterate$1;
$$H({ target: "Set", proto: true, real: true, forced: true }, {
  some: function some6(callbackfn) {
    var set4 = aSet(this);
    var boundFunction = bind$3(callbackfn, arguments.length > 1 ? arguments[1] : void 0);
    return iterate$1(set4, function(value) {
      if (boundFunction(value, value, set4)) return true;
    }, true) === true;
  }
});
var $$G = _export;
var call$5 = functionCall;
var toSetLike$1 = toSetLike$7;
var $symmetricDifference = setSymmetricDifference;
$$G({ target: "Set", proto: true, real: true, forced: true }, {
  symmetricDifference: function symmetricDifference3(other) {
    return call$5($symmetricDifference, this, toSetLike$1(other));
  }
});
var $$F = _export;
var call$4 = functionCall;
var toSetLike = toSetLike$7;
var $union = setUnion;
$$F({ target: "Set", proto: true, real: true, forced: true }, {
  union: function union3(other) {
    return call$4($union, this, toSetLike(other));
  }
});
var $$E = _export;
var charAt$8 = stringMultibyte.charAt;
var requireObjectCoercible$1 = requireObjectCoercible$q;
var toIntegerOrInfinity$1 = toIntegerOrInfinity$p;
var toString$9 = toString$K;
$$E({ target: "String", proto: true, forced: true }, {
  at: function at4(index) {
    var S2 = toString$9(requireObjectCoercible$1(this));
    var len = S2.length;
    var relativeIndex = toIntegerOrInfinity$1(index);
    var k2 = relativeIndex >= 0 ? relativeIndex : len + relativeIndex;
    return k2 < 0 || k2 >= len ? void 0 : charAt$8(S2, k2);
  }
});
var uncurryThis$k = functionUncurryThis;
var toIndexedObject = toIndexedObject$k;
var toString$8 = toString$K;
var lengthOfArrayLike$3 = lengthOfArrayLike$B;
var $TypeError$5 = TypeError;
var push$5 = uncurryThis$k([].push);
var join$3 = uncurryThis$k([].join);
var stringCooked = function cooked(template) {
  var cookedTemplate = toIndexedObject(template);
  var literalSegments = lengthOfArrayLike$3(cookedTemplate);
  if (!literalSegments) return "";
  var argumentsLength = arguments.length;
  var elements = [];
  var i = 0;
  while (true) {
    var nextVal = cookedTemplate[i++];
    if (nextVal === void 0) throw new $TypeError$5("Incorrect template");
    push$5(elements, toString$8(nextVal));
    if (i === literalSegments) return join$3(elements, "");
    if (i < argumentsLength) push$5(elements, toString$8(arguments[i]));
  }
};
var $$D = _export;
var cooked$1 = stringCooked;
$$D({ target: "String", stat: true, forced: true }, {
  cooked: cooked$1
});
var $$C = _export;
var createIteratorConstructor$1 = iteratorCreateConstructor;
var createIterResultObject$1 = createIterResultObject$h;
var requireObjectCoercible = requireObjectCoercible$q;
var toString$7 = toString$K;
var InternalStateModule$3 = internalState;
var StringMultibyteModule = stringMultibyte;
var codeAt$1 = StringMultibyteModule.codeAt;
var charAt$7 = StringMultibyteModule.charAt;
var STRING_ITERATOR = "String Iterator";
var setInternalState$3 = InternalStateModule$3.set;
var getInternalState$1 = InternalStateModule$3.getterFor(STRING_ITERATOR);
var $StringIterator = createIteratorConstructor$1(function StringIterator(string) {
  setInternalState$3(this, {
    type: STRING_ITERATOR,
    string,
    index: 0
  });
}, "String", function next8() {
  var state = getInternalState$1(this);
  var string = state.string;
  var index = state.index;
  var point;
  if (index >= string.length) return createIterResultObject$1(void 0, true);
  point = charAt$7(string, index);
  state.index += point.length;
  return createIterResultObject$1({ codePoint: codeAt$1(point, 0), position: index }, false);
});
$$C({ target: "String", proto: true, forced: true }, {
  codePoints: function codePoints2() {
    return new $StringIterator(toString$7(requireObjectCoercible(this)));
  }
});
var uncurryThis$j = functionUncurryThis;
var WeakMapPrototype = WeakMap.prototype;
var weakMapHelpers = {
  // eslint-disable-next-line es/no-weak-map -- safe
  WeakMap,
  set: uncurryThis$j(WeakMapPrototype.set),
  get: uncurryThis$j(WeakMapPrototype.get),
  has: uncurryThis$j(WeakMapPrototype.has),
  remove: uncurryThis$j(WeakMapPrototype["delete"])
};
var getBuiltIn$c = getBuiltIn$O;
var uncurryThis$i = functionUncurryThis;
var fromCharCode$3 = String.fromCharCode;
var fromCodePoint$1 = getBuiltIn$c("String", "fromCodePoint");
var charAt$6 = uncurryThis$i("".charAt);
var charCodeAt$2 = uncurryThis$i("".charCodeAt);
var stringIndexOf = uncurryThis$i("".indexOf);
var stringSlice$4 = uncurryThis$i("".slice);
var ZERO_CODE = 48;
var NINE_CODE = 57;
var LOWER_A_CODE = 97;
var LOWER_F_CODE = 102;
var UPPER_A_CODE = 65;
var UPPER_F_CODE = 70;
var isDigit = function(str, index) {
  var c2 = charCodeAt$2(str, index);
  return c2 >= ZERO_CODE && c2 <= NINE_CODE;
};
var parseHex = function(str, index, end) {
  if (end >= str.length) return -1;
  var n2 = 0;
  for (; index < end; index++) {
    var c2 = hexToInt(charCodeAt$2(str, index));
    if (c2 === -1) return -1;
    n2 = n2 * 16 + c2;
  }
  return n2;
};
var hexToInt = function(c2) {
  if (c2 >= ZERO_CODE && c2 <= NINE_CODE) return c2 - ZERO_CODE;
  if (c2 >= LOWER_A_CODE && c2 <= LOWER_F_CODE) return c2 - LOWER_A_CODE + 10;
  if (c2 >= UPPER_A_CODE && c2 <= UPPER_F_CODE) return c2 - UPPER_A_CODE + 10;
  return -1;
};
var stringParse = function(raw3) {
  var out = "";
  var start = 0;
  var i = 0;
  var n2;
  while ((i = stringIndexOf(raw3, "\\", i)) > -1) {
    out += stringSlice$4(raw3, start, i);
    if (++i === raw3.length) return;
    var next11 = charAt$6(raw3, i++);
    switch (next11) {
      case "b":
        out += "\b";
        break;
      case "t":
        out += "	";
        break;
      case "n":
        out += "\n";
        break;
      case "v":
        out += "\v";
        break;
      case "f":
        out += "\f";
        break;
      case "r":
        out += "\r";
        break;
      case "\r":
        if (i < raw3.length && charAt$6(raw3, i) === "\n") ++i;
      case "\n":
      case "\u2028":
      case "\u2029":
        break;
      case "0":
        if (isDigit(raw3, i)) return;
        out += "\0";
        break;
      case "x":
        n2 = parseHex(raw3, i, i + 2);
        if (n2 === -1) return;
        i += 2;
        out += fromCharCode$3(n2);
        break;
      case "u":
        if (i < raw3.length && charAt$6(raw3, i) === "{") {
          var end = stringIndexOf(raw3, "}", ++i);
          if (end === -1) return;
          n2 = parseHex(raw3, i, end);
          i = end + 1;
        } else {
          n2 = parseHex(raw3, i, i + 4);
          i += 4;
        }
        if (n2 === -1 || n2 > 1114111) return;
        out += fromCodePoint$1(n2);
        break;
      default:
        if (isDigit(next11, 0)) return;
        out += next11;
    }
    start = i;
  }
  return out + stringSlice$4(raw3, start);
};
var FREEZING = freezing;
var $$B = _export;
var makeBuiltIn = makeBuiltInExports;
var uncurryThis$h = functionUncurryThis;
var apply$1 = functionApply$1;
var anObject$3 = anObject$1i;
var toObject = toObject$E;
var isCallable$3 = isCallable$I;
var lengthOfArrayLike$2 = lengthOfArrayLike$B;
var defineProperty$5 = objectDefineProperty.f;
var createArrayFromList = arraySlice$a;
var WeakMapHelpers$5 = weakMapHelpers;
var cooked2 = stringCooked;
var parse$2 = stringParse;
var whitespaces$1 = whitespaces$6;
var DedentMap = new WeakMapHelpers$5.WeakMap();
var weakMapGet = WeakMapHelpers$5.get;
var weakMapHas = WeakMapHelpers$5.has;
var weakMapSet = WeakMapHelpers$5.set;
var $Array = Array;
var $TypeError$4 = TypeError;
var freeze2 = Object.freeze || Object;
var isFrozen2 = Object.isFrozen;
var min$2 = Math.min;
var charAt$5 = uncurryThis$h("".charAt);
var stringSlice$3 = uncurryThis$h("".slice);
var split$3 = uncurryThis$h("".split);
var exec$5 = uncurryThis$h(/./.exec);
var NEW_LINE = /([\n\u2028\u2029]|\r\n?)/g;
var LEADING_WHITESPACE = RegExp("^[" + whitespaces$1 + "]*");
var NON_WHITESPACE = RegExp("[^" + whitespaces$1 + "]");
var INVALID_TAG = "Invalid tag";
var INVALID_OPENING_LINE = "Invalid opening line";
var INVALID_CLOSING_LINE = "Invalid closing line";
var dedentTemplateStringsArray = function(template) {
  var rawInput = template.raw;
  if (FREEZING && !isFrozen2(rawInput)) throw new $TypeError$4("Raw template should be frozen");
  if (weakMapHas(DedentMap, rawInput)) return weakMapGet(DedentMap, rawInput);
  var raw3 = dedentStringsArray(rawInput);
  var cookedArr = cookStrings(raw3);
  defineProperty$5(cookedArr, "raw", {
    value: freeze2(raw3)
  });
  freeze2(cookedArr);
  weakMapSet(DedentMap, rawInput, cookedArr);
  return cookedArr;
};
var dedentStringsArray = function(template) {
  var t2 = toObject(template);
  var length2 = lengthOfArrayLike$2(t2);
  var blocks = $Array(length2);
  var dedented = $Array(length2);
  var i = 0;
  var lines, common2, quasi, k2;
  if (!length2) throw new $TypeError$4(INVALID_TAG);
  for (; i < length2; i++) {
    var element = t2[i];
    if (typeof element == "string") blocks[i] = split$3(element, NEW_LINE);
    else throw new $TypeError$4(INVALID_TAG);
  }
  for (i = 0; i < length2; i++) {
    var lastSplit = i + 1 === length2;
    lines = blocks[i];
    if (i === 0) {
      if (lines.length === 1 || lines[0].length > 0) {
        throw new $TypeError$4(INVALID_OPENING_LINE);
      }
      lines[1] = "";
    }
    if (lastSplit) {
      if (lines.length === 1 || exec$5(NON_WHITESPACE, lines[lines.length - 1])) {
        throw new $TypeError$4(INVALID_CLOSING_LINE);
      }
      lines[lines.length - 2] = "";
      lines[lines.length - 1] = "";
    }
    for (var j = 2; j < lines.length; j += 2) {
      var text = lines[j];
      var lineContainsTemplateExpression = j + 1 === lines.length && !lastSplit;
      var leading = exec$5(LEADING_WHITESPACE, text)[0];
      if (!lineContainsTemplateExpression && leading.length === text.length) {
        lines[j] = "";
        continue;
      }
      common2 = commonLeadingIndentation(leading, common2);
    }
  }
  var count = common2 ? common2.length : 0;
  for (i = 0; i < length2; i++) {
    lines = blocks[i];
    quasi = lines[0];
    k2 = 1;
    for (; k2 < lines.length; k2 += 2) {
      quasi += lines[k2] + stringSlice$3(lines[k2 + 1], count);
    }
    dedented[i] = quasi;
  }
  return dedented;
};
var commonLeadingIndentation = function(a, b2) {
  if (b2 === void 0 || a === b2) return a;
  var i = 0;
  for (var len = min$2(a.length, b2.length); i < len; i++) {
    if (charAt$5(a, i) !== charAt$5(b2, i)) break;
  }
  return stringSlice$3(a, 0, i);
};
var cookStrings = function(raw3) {
  var i = 0;
  var length2 = raw3.length;
  var result = $Array(length2);
  for (; i < length2; i++) {
    result[i] = parse$2(raw3[i]);
  }
  return result;
};
var makeDedentTag = function(tag) {
  return makeBuiltIn(function(template) {
    var args = createArrayFromList(arguments);
    args[0] = dedentTemplateStringsArray(anObject$3(template));
    return apply$1(tag, this, args);
  }, "");
};
var cookedDedentTag = makeDedentTag(cooked2);
$$B({ target: "String", stat: true, forced: true }, {
  dedent: function dedent(templateOrFn) {
    anObject$3(templateOrFn);
    if (isCallable$3(templateOrFn)) return makeDedentTag(templateOrFn);
    return apply$1(cookedDedentTag, this, arguments);
  }
});
var globalThis$p = globalThis_1;
var defineWellKnownSymbol$8 = wellKnownSymbolDefine;
var defineProperty$4 = objectDefineProperty.f;
var getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;
var Symbol$4 = globalThis$p.Symbol;
defineWellKnownSymbol$8("asyncDispose");
if (Symbol$4) {
  var descriptor$4 = getOwnPropertyDescriptor$1(Symbol$4, "asyncDispose");
  if (descriptor$4.enumerable && descriptor$4.configurable && descriptor$4.writable) {
    defineProperty$4(Symbol$4, "asyncDispose", { value: descriptor$4.value, enumerable: false, configurable: false, writable: false });
  }
}
var defineWellKnownSymbol$7 = wellKnownSymbolDefine;
defineWellKnownSymbol$7("customMatcher");
var globalThis$o = globalThis_1;
var defineWellKnownSymbol$6 = wellKnownSymbolDefine;
var defineProperty$3 = objectDefineProperty.f;
var getOwnPropertyDescriptor6 = objectGetOwnPropertyDescriptor.f;
var Symbol$3 = globalThis$o.Symbol;
defineWellKnownSymbol$6("dispose");
if (Symbol$3) {
  var descriptor$3 = getOwnPropertyDescriptor6(Symbol$3, "dispose");
  if (descriptor$3.enumerable && descriptor$3.configurable && descriptor$3.writable) {
    defineProperty$3(Symbol$3, "dispose", { value: descriptor$3.value, enumerable: false, configurable: false, writable: false });
  }
}
var getBuiltIn$b = getBuiltIn$O;
var uncurryThis$g = functionUncurryThis;
var Symbol$2 = getBuiltIn$b("Symbol");
var keyFor2 = Symbol$2.keyFor;
var thisSymbolValue$1 = uncurryThis$g(Symbol$2.prototype.valueOf);
var symbolIsRegistered = Symbol$2.isRegisteredSymbol || function isRegisteredSymbol(value) {
  try {
    return keyFor2(thisSymbolValue$1(value)) !== void 0;
  } catch (error2) {
    return false;
  }
};
var $$A = _export;
var isRegisteredSymbol$1 = symbolIsRegistered;
$$A({ target: "Symbol", stat: true }, {
  isRegisteredSymbol: isRegisteredSymbol$1
});
var $$z = _export;
var isRegisteredSymbol2 = symbolIsRegistered;
$$z({ target: "Symbol", stat: true, name: "isRegisteredSymbol" }, {
  isRegistered: isRegisteredSymbol2
});
var shared = shared$a;
var getBuiltIn$a = getBuiltIn$O;
var uncurryThis$f = functionUncurryThis;
var isSymbol$1 = isSymbol$8;
var wellKnownSymbol$3 = wellKnownSymbol$S;
var Symbol$1 = getBuiltIn$a("Symbol");
var $isWellKnownSymbol = Symbol$1.isWellKnownSymbol;
var getOwnPropertyNames4 = getBuiltIn$a("Object", "getOwnPropertyNames");
var thisSymbolValue = uncurryThis$f(Symbol$1.prototype.valueOf);
var WellKnownSymbolsStore = shared("wks");
for (var i = 0, symbolKeys = getOwnPropertyNames4(Symbol$1), symbolKeysLength = symbolKeys.length; i < symbolKeysLength; i++) {
  try {
    var symbolKey = symbolKeys[i];
    if (isSymbol$1(Symbol$1[symbolKey])) wellKnownSymbol$3(symbolKey);
  } catch (error2) {
  }
}
var symbolIsWellKnown = function isWellKnownSymbol(value) {
  if ($isWellKnownSymbol && $isWellKnownSymbol(value)) return true;
  try {
    var symbol = thisSymbolValue(value);
    for (var j = 0, keys6 = getOwnPropertyNames4(WellKnownSymbolsStore), keysLength = keys6.length; j < keysLength; j++) {
      if (WellKnownSymbolsStore[keys6[j]] == symbol) return true;
    }
  } catch (error2) {
  }
  return false;
};
var $$y = _export;
var isWellKnownSymbol$1 = symbolIsWellKnown;
$$y({ target: "Symbol", stat: true, forced: true }, {
  isWellKnownSymbol: isWellKnownSymbol$1
});
var $$x = _export;
var isWellKnownSymbol2 = symbolIsWellKnown;
$$x({ target: "Symbol", stat: true, name: "isWellKnownSymbol", forced: true }, {
  isWellKnown: isWellKnownSymbol2
});
var defineWellKnownSymbol$5 = wellKnownSymbolDefine;
defineWellKnownSymbol$5("matcher");
var defineWellKnownSymbol$4 = wellKnownSymbolDefine;
defineWellKnownSymbol$4("metadata");
var defineWellKnownSymbol$3 = wellKnownSymbolDefine;
defineWellKnownSymbol$3("metadataKey");
var defineWellKnownSymbol$2 = wellKnownSymbolDefine;
defineWellKnownSymbol$2("observable");
var defineWellKnownSymbol$1 = wellKnownSymbolDefine;
defineWellKnownSymbol$1("patternMatch");
var defineWellKnownSymbol = wellKnownSymbolDefine;
defineWellKnownSymbol("replaceAll");
var getBuiltIn$9 = getBuiltIn$O;
var aConstructor = aConstructor$4;
var arrayFromAsync = arrayFromAsync$1;
var ArrayBufferViewCore$5 = arrayBufferViewCore;
var arrayFromConstructorAndList$2 = arrayFromConstructorAndList$8;
var aTypedArrayConstructor = ArrayBufferViewCore$5.aTypedArrayConstructor;
var exportTypedArrayStaticMethod = ArrayBufferViewCore$5.exportTypedArrayStaticMethod;
exportTypedArrayStaticMethod("fromAsync", function fromAsync3(asyncItems) {
  var C2 = this;
  var argumentsLength = arguments.length;
  var mapfn = argumentsLength > 1 ? arguments[1] : void 0;
  var thisArg = argumentsLength > 2 ? arguments[2] : void 0;
  return new (getBuiltIn$9("Promise"))(function(resolve2) {
    aConstructor(C2);
    resolve2(arrayFromAsync(asyncItems, mapfn, thisArg));
  }).then(function(list) {
    return arrayFromConstructorAndList$2(aTypedArrayConstructor(C2), list);
  });
}, true);
var ArrayBufferViewCore$4 = arrayBufferViewCore;
var $filterReject$1 = arrayIteration.filterReject;
var fromSameTypeAndList$1 = typedArrayFromSameTypeAndList;
var aTypedArray$4 = ArrayBufferViewCore$4.aTypedArray;
var exportTypedArrayMethod$4 = ArrayBufferViewCore$4.exportTypedArrayMethod;
exportTypedArrayMethod$4("filterOut", function filterOut2(callbackfn) {
  var list = $filterReject$1(aTypedArray$4(this), callbackfn, arguments.length > 1 ? arguments[1] : void 0);
  return fromSameTypeAndList$1(this, list);
}, true);
var ArrayBufferViewCore$3 = arrayBufferViewCore;
var $filterReject = arrayIteration.filterReject;
var fromSameTypeAndList = typedArrayFromSameTypeAndList;
var aTypedArray$3 = ArrayBufferViewCore$3.aTypedArray;
var exportTypedArrayMethod$3 = ArrayBufferViewCore$3.exportTypedArrayMethod;
exportTypedArrayMethod$3("filterReject", function filterReject2(callbackfn) {
  var list = $filterReject(aTypedArray$3(this), callbackfn, arguments.length > 1 ? arguments[1] : void 0);
  return fromSameTypeAndList(this, list);
}, true);
var ArrayBufferViewCore$2 = arrayBufferViewCore;
var $group = arrayGroup;
var aTypedArray$2 = ArrayBufferViewCore$2.aTypedArray;
var getTypedArrayConstructor$2 = ArrayBufferViewCore$2.getTypedArrayConstructor;
var exportTypedArrayMethod$2 = ArrayBufferViewCore$2.exportTypedArrayMethod;
exportTypedArrayMethod$2("groupBy", function groupBy4(callbackfn) {
  var thisArg = arguments.length > 1 ? arguments[1] : void 0;
  return $group(aTypedArray$2(this), callbackfn, thisArg, getTypedArrayConstructor$2);
}, true);
var ArrayBufferViewCore$1 = arrayBufferViewCore;
var lengthOfArrayLike$1 = lengthOfArrayLike$B;
var isBigIntArray = isBigIntArray$3;
var toAbsoluteIndex = toAbsoluteIndex$a;
var toBigInt = toBigInt$4;
var toIntegerOrInfinity = toIntegerOrInfinity$p;
var fails$7 = fails$1z;
var aTypedArray$1 = ArrayBufferViewCore$1.aTypedArray;
var getTypedArrayConstructor$1 = ArrayBufferViewCore$1.getTypedArrayConstructor;
var exportTypedArrayMethod$1 = ArrayBufferViewCore$1.exportTypedArrayMethod;
var max = Math.max;
var min$1 = Math.min;
var PROPER_ORDER = !fails$7(function() {
  var array = new Int8Array([1]);
  var spliced = array.toSpliced(1, 0, {
    valueOf: function() {
      array[0] = 2;
      return 3;
    }
  });
  return spliced[0] !== 2 || spliced[1] !== 3;
});
exportTypedArrayMethod$1("toSpliced", function toSpliced2(start, deleteCount) {
  var O2 = aTypedArray$1(this);
  var C2 = getTypedArrayConstructor$1(O2);
  var len = lengthOfArrayLike$1(O2);
  var actualStart = toAbsoluteIndex(start, len);
  var argumentsLength = arguments.length;
  var k2 = 0;
  var insertCount, actualDeleteCount, thisIsBigIntArray, convertedItems, value, newLen, A2;
  if (argumentsLength === 0) {
    insertCount = actualDeleteCount = 0;
  } else if (argumentsLength === 1) {
    insertCount = 0;
    actualDeleteCount = len - actualStart;
  } else {
    actualDeleteCount = min$1(max(toIntegerOrInfinity(deleteCount), 0), len - actualStart);
    insertCount = argumentsLength - 2;
    if (insertCount) {
      convertedItems = new C2(insertCount);
      thisIsBigIntArray = isBigIntArray(convertedItems);
      for (var i = 2; i < argumentsLength; i++) {
        value = arguments[i];
        convertedItems[i - 2] = thisIsBigIntArray ? toBigInt(value) : +value;
      }
    }
  }
  newLen = len + insertCount - actualDeleteCount;
  A2 = new C2(newLen);
  for (; k2 < actualStart; k2++) A2[k2] = O2[k2];
  for (; k2 < actualStart + insertCount; k2++) A2[k2] = convertedItems[k2 - actualStart];
  for (; k2 < newLen; k2++) A2[k2] = O2[k2 + actualDeleteCount - insertCount];
  return A2;
}, !PROPER_ORDER);
var uncurryThis$e = functionUncurryThis;
var ArrayBufferViewCore = arrayBufferViewCore;
var arrayFromConstructorAndList$1 = arrayFromConstructorAndList$8;
var $arrayUniqueBy = arrayUniqueBy$2;
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var getTypedArrayConstructor = ArrayBufferViewCore.getTypedArrayConstructor;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
var arrayUniqueBy = uncurryThis$e($arrayUniqueBy);
exportTypedArrayMethod("uniqueBy", function uniqueBy3(resolver) {
  aTypedArray(this);
  return arrayFromConstructorAndList$1(getTypedArrayConstructor(this), arrayUniqueBy(this, resolver));
}, true);
var isObject$3 = isObject$O;
var $String = String;
var $TypeError$3 = TypeError;
var anObjectOrUndefined$2 = function(argument) {
  if (argument === void 0 || isObject$3(argument)) return argument;
  throw new $TypeError$3($String(argument) + " is not an object or undefined");
};
var commonAlphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
var base64Alphabet$2 = commonAlphabet + "+/";
var base64UrlAlphabet$2 = commonAlphabet + "-_";
var inverse = function(characters2) {
  var result = {};
  var index = 0;
  for (; index < 64; index++) result[characters2.charAt(index)] = index;
  return result;
};
var base64Map$2 = {
  i2c: base64Alphabet$2,
  c2i: inverse(base64Alphabet$2),
  i2cUrl: base64UrlAlphabet$2,
  c2iUrl: inverse(base64UrlAlphabet$2)
};
var $TypeError$2 = TypeError;
var getAlphabetOption$2 = function(options) {
  var alphabet = options && options.alphabet;
  if (alphabet === void 0 || alphabet === "base64" || alphabet === "base64url") return alphabet || "base64";
  throw new $TypeError$2("Incorrect `alphabet` option");
};
var globalThis$n = globalThis_1;
var uncurryThis$d = functionUncurryThis;
var anObjectOrUndefined$1 = anObjectOrUndefined$2;
var aString$2 = aString$4;
var hasOwn$6 = hasOwnProperty_1;
var base64Map$1 = base64Map$2;
var getAlphabetOption$1 = getAlphabetOption$2;
var notDetached$3 = arrayBufferNotDetached;
var base64Alphabet$1 = base64Map$1.c2i;
var base64UrlAlphabet$1 = base64Map$1.c2iUrl;
var SyntaxError$2 = globalThis$n.SyntaxError;
var TypeError$4 = globalThis$n.TypeError;
var at5 = uncurryThis$d("".charAt);
var skipAsciiWhitespace = function(string, index) {
  var length2 = string.length;
  for (; index < length2; index++) {
    var chr = at5(string, index);
    if (chr !== " " && chr !== "	" && chr !== "\n" && chr !== "\f" && chr !== "\r") break;
  }
  return index;
};
var decodeBase64Chunk = function(chunk, alphabet, throwOnExtraBits) {
  var chunkLength = chunk.length;
  if (chunkLength < 4) {
    chunk += chunkLength === 2 ? "AA" : "A";
  }
  var triplet = (alphabet[at5(chunk, 0)] << 18) + (alphabet[at5(chunk, 1)] << 12) + (alphabet[at5(chunk, 2)] << 6) + alphabet[at5(chunk, 3)];
  var chunkBytes = [
    triplet >> 16 & 255,
    triplet >> 8 & 255,
    triplet & 255
  ];
  if (chunkLength === 2) {
    if (throwOnExtraBits && chunkBytes[1] !== 0) {
      throw new SyntaxError$2("Extra bits");
    }
    return [chunkBytes[0]];
  }
  if (chunkLength === 3) {
    if (throwOnExtraBits && chunkBytes[2] !== 0) {
      throw new SyntaxError$2("Extra bits");
    }
    return [chunkBytes[0], chunkBytes[1]];
  }
  return chunkBytes;
};
var writeBytes = function(bytes, elements, written) {
  var elementsLength = elements.length;
  for (var index = 0; index < elementsLength; index++) {
    bytes[written + index] = elements[index];
  }
  return written + elementsLength;
};
var uint8FromBase64 = function(string, options, into, maxLength) {
  aString$2(string);
  anObjectOrUndefined$1(options);
  var alphabet = getAlphabetOption$1(options) === "base64" ? base64Alphabet$1 : base64UrlAlphabet$1;
  var lastChunkHandling = options ? options.lastChunkHandling : void 0;
  if (lastChunkHandling === void 0) lastChunkHandling = "loose";
  if (lastChunkHandling !== "loose" && lastChunkHandling !== "strict" && lastChunkHandling !== "stop-before-partial") {
    throw new TypeError$4("Incorrect `lastChunkHandling` option");
  }
  if (into) notDetached$3(into.buffer);
  var bytes = into || [];
  var written = 0;
  var read = 0;
  var chunk = "";
  var index = 0;
  if (maxLength) while (true) {
    index = skipAsciiWhitespace(string, index);
    if (index === string.length) {
      if (chunk.length > 0) {
        if (lastChunkHandling === "stop-before-partial") {
          break;
        }
        if (lastChunkHandling === "loose") {
          if (chunk.length === 1) {
            throw new SyntaxError$2("Malformed padding: exactly one additional character");
          }
          written = writeBytes(bytes, decodeBase64Chunk(chunk, alphabet, false), written);
        } else {
          throw new SyntaxError$2("Missing padding");
        }
      }
      read = string.length;
      break;
    }
    var chr = at5(string, index);
    ++index;
    if (chr === "=") {
      if (chunk.length < 2) {
        throw new SyntaxError$2("Padding is too early");
      }
      index = skipAsciiWhitespace(string, index);
      if (chunk.length === 2) {
        if (index === string.length) {
          if (lastChunkHandling === "stop-before-partial") {
            break;
          }
          throw new SyntaxError$2("Malformed padding: only one =");
        }
        if (at5(string, index) === "=") {
          ++index;
          index = skipAsciiWhitespace(string, index);
        }
      }
      if (index < string.length) {
        throw new SyntaxError$2("Unexpected character after padding");
      }
      written = writeBytes(bytes, decodeBase64Chunk(chunk, alphabet, lastChunkHandling === "strict"), written);
      read = string.length;
      break;
    }
    if (!hasOwn$6(alphabet, chr)) {
      throw new SyntaxError$2("Unexpected character");
    }
    var remainingBytes = maxLength - written;
    if (remainingBytes === 1 && chunk.length === 2 || remainingBytes === 2 && chunk.length === 3) {
      break;
    }
    chunk += chr;
    if (chunk.length === 4) {
      written = writeBytes(bytes, decodeBase64Chunk(chunk, alphabet, false), written);
      chunk = "";
      read = index;
      if (written === maxLength) {
        break;
      }
    }
  }
  return { bytes, read, written };
};
var $$w = _export;
var globalThis$m = globalThis_1;
var arrayFromConstructorAndList = arrayFromConstructorAndList$8;
var $fromBase64$1 = uint8FromBase64;
var Uint8Array$3 = globalThis$m.Uint8Array;
if (Uint8Array$3) $$w({ target: "Uint8Array", stat: true }, {
  fromBase64: function fromBase64(string) {
    var result = $fromBase64$1(string, arguments.length > 1 ? arguments[1] : void 0, null, 9007199254740991);
    return arrayFromConstructorAndList(Uint8Array$3, result.bytes);
  }
});
var globalThis$l = globalThis_1;
var uncurryThis$c = functionUncurryThis;
var Uint8Array$2 = globalThis$l.Uint8Array;
var SyntaxError$1 = globalThis$l.SyntaxError;
var parseInt$2 = globalThis$l.parseInt;
var min = Math.min;
var NOT_HEX = /[^\da-f]/i;
var exec$4 = uncurryThis$c(NOT_HEX.exec);
var stringSlice$2 = uncurryThis$c("".slice);
var uint8FromHex = function(string, into) {
  var stringLength = string.length;
  if (stringLength % 2 !== 0) throw new SyntaxError$1("String should be an even number of characters");
  var maxLength = into ? min(into.length, stringLength / 2) : stringLength / 2;
  var bytes = into || new Uint8Array$2(maxLength);
  var read = 0;
  var written = 0;
  while (written < maxLength) {
    var hexits = stringSlice$2(string, read, read += 2);
    if (exec$4(NOT_HEX, hexits)) throw new SyntaxError$1("String should only contain hex characters");
    bytes[written++] = parseInt$2(hexits, 16);
  }
  return { bytes, read };
};
var $$v = _export;
var globalThis$k = globalThis_1;
var aString$1 = aString$4;
var $fromHex$1 = uint8FromHex;
if (globalThis$k.Uint8Array) $$v({ target: "Uint8Array", stat: true }, {
  fromHex: function fromHex(string) {
    return $fromHex$1(aString$1(string)).bytes;
  }
});
var classof$2 = classof$p;
var $TypeError$1 = TypeError;
var anUint8Array$4 = function(argument) {
  if (classof$2(argument) === "Uint8Array") return argument;
  throw new $TypeError$1("Argument is not an Uint8Array");
};
var $$u = _export;
var globalThis$j = globalThis_1;
var $fromBase64 = uint8FromBase64;
var anUint8Array$3 = anUint8Array$4;
var Uint8Array$1 = globalThis$j.Uint8Array;
if (Uint8Array$1) $$u({ target: "Uint8Array", proto: true }, {
  setFromBase64: function setFromBase64(string) {
    anUint8Array$3(this);
    var result = $fromBase64(string, arguments.length > 1 ? arguments[1] : void 0, this, this.length);
    return { read: result.read, written: result.written };
  }
});
var $$t = _export;
var globalThis$i = globalThis_1;
var aString = aString$4;
var anUint8Array$2 = anUint8Array$4;
var notDetached$2 = arrayBufferNotDetached;
var $fromHex = uint8FromHex;
if (globalThis$i.Uint8Array) $$t({ target: "Uint8Array", proto: true }, {
  setFromHex: function setFromHex(string) {
    anUint8Array$2(this);
    aString(string);
    notDetached$2(this.buffer);
    var read = $fromHex(string, this).read;
    return { read, written: read / 2 };
  }
});
var $$s = _export;
var globalThis$h = globalThis_1;
var uncurryThis$b = functionUncurryThis;
var anObjectOrUndefined = anObjectOrUndefined$2;
var anUint8Array$1 = anUint8Array$4;
var notDetached$1 = arrayBufferNotDetached;
var base64Map = base64Map$2;
var getAlphabetOption = getAlphabetOption$2;
var base64Alphabet = base64Map.i2c;
var base64UrlAlphabet = base64Map.i2cUrl;
var charAt$4 = uncurryThis$b("".charAt);
if (globalThis$h.Uint8Array) $$s({ target: "Uint8Array", proto: true }, {
  toBase64: function toBase64() {
    var array = anUint8Array$1(this);
    var options = arguments.length ? anObjectOrUndefined(arguments[0]) : void 0;
    var alphabet = getAlphabetOption(options) === "base64" ? base64Alphabet : base64UrlAlphabet;
    var omitPadding = !!options && !!options.omitPadding;
    notDetached$1(this.buffer);
    var result = "";
    var i = 0;
    var length2 = array.length;
    var triplet;
    var at6 = function(shift2) {
      return charAt$4(alphabet, triplet >> 6 * shift2 & 63);
    };
    for (; i + 2 < length2; i += 3) {
      triplet = (array[i] << 16) + (array[i + 1] << 8) + array[i + 2];
      result += at6(3) + at6(2) + at6(1) + at6(0);
    }
    if (i + 2 === length2) {
      triplet = (array[i] << 16) + (array[i + 1] << 8);
      result += at6(3) + at6(2) + at6(1) + (omitPadding ? "" : "=");
    } else if (i + 1 === length2) {
      triplet = array[i] << 16;
      result += at6(3) + at6(2) + (omitPadding ? "" : "==");
    }
    return result;
  }
});
var $$r = _export;
var globalThis$g = globalThis_1;
var uncurryThis$a = functionUncurryThis;
var anUint8Array = anUint8Array$4;
var notDetached = arrayBufferNotDetached;
var numberToString$1 = uncurryThis$a(1 .toString);
if (globalThis$g.Uint8Array) $$r({ target: "Uint8Array", proto: true }, {
  toHex: function toHex() {
    anUint8Array(this);
    notDetached(this.buffer);
    var result = "";
    for (var i = 0, length2 = this.length; i < length2; i++) {
      var hex3 = numberToString$1(this[i], 16);
      result += hex3.length === 1 ? "0" + hex3 : hex3;
    }
    return result;
  }
});
var has$4 = weakMapHelpers.has;
var aWeakMap$4 = function(it) {
  has$4(it);
  return it;
};
var $$q = _export;
var aWeakMap$3 = aWeakMap$4;
var remove$1 = weakMapHelpers.remove;
$$q({ target: "WeakMap", proto: true, real: true, forced: true }, {
  deleteAll: function deleteAll3() {
    var collection2 = aWeakMap$3(this);
    var allDeleted = true;
    var wasDeleted;
    for (var k2 = 0, len = arguments.length; k2 < len; k2++) {
      wasDeleted = remove$1(collection2, arguments[k2]);
      allDeleted = allDeleted && wasDeleted;
    }
    return !!allDeleted;
  }
});
var $$p = _export;
var WeakMapHelpers$4 = weakMapHelpers;
var createCollectionFrom$1 = collectionFrom;
$$p({ target: "WeakMap", stat: true, forced: true }, {
  from: createCollectionFrom$1(WeakMapHelpers$4.WeakMap, WeakMapHelpers$4.set, true)
});
var $$o = _export;
var WeakMapHelpers$3 = weakMapHelpers;
var createCollectionOf$1 = collectionOf;
$$o({ target: "WeakMap", stat: true, forced: true }, {
  of: createCollectionOf$1(WeakMapHelpers$3.WeakMap, WeakMapHelpers$3.set, true)
});
var $$n = _export;
var aWeakMap$2 = aWeakMap$4;
var WeakMapHelpers$2 = weakMapHelpers;
var get$2 = WeakMapHelpers$2.get;
var has$3 = WeakMapHelpers$2.has;
var set$2 = WeakMapHelpers$2.set;
$$n({ target: "WeakMap", proto: true, real: true, forced: true }, {
  emplace: function emplace2(key, handler) {
    var map7 = aWeakMap$2(this);
    var value, inserted;
    if (has$3(map7, key)) {
      value = get$2(map7, key);
      if ("update" in handler) {
        value = handler.update(value, key, map7);
        set$2(map7, key, value);
      }
      return value;
    }
    inserted = handler.insert(key, map7);
    set$2(map7, key, inserted);
    return inserted;
  }
});
var $$m = _export;
var aWeakMap$1 = aWeakMap$4;
var WeakMapHelpers$1 = weakMapHelpers;
var get$1 = WeakMapHelpers$1.get;
var has$2 = WeakMapHelpers$1.has;
var set$1 = WeakMapHelpers$1.set;
$$m({ target: "WeakMap", proto: true, real: true, forced: true }, {
  getOrInsert: function getOrInsert2(key, value) {
    if (has$2(aWeakMap$1(this), key)) return get$1(this, key);
    set$1(this, key, value);
    return value;
  }
});
var $$l = _export;
var aCallable$1 = aCallable$Q;
var aWeakMap = aWeakMap$4;
var WeakMapHelpers = weakMapHelpers;
var get = WeakMapHelpers.get;
var has$1 = WeakMapHelpers.has;
var set2 = WeakMapHelpers.set;
$$l({ target: "WeakMap", proto: true, real: true, forced: true }, {
  getOrInsertComputed: function getOrInsertComputed2(key, callbackfn) {
    aWeakMap(this);
    aCallable$1(callbackfn);
    if (has$1(this, key)) return get(this, key);
    set2(this, key);
    var value = callbackfn(key);
    set2(this, key, value);
    return value;
  }
});
var $$k = _export;
var upsert2 = mapUpsert;
$$k({ target: "WeakMap", proto: true, real: true, forced: true }, {
  upsert: upsert2
});
var uncurryThis$9 = functionUncurryThis;
var WeakSetPrototype = WeakSet.prototype;
var weakSetHelpers = {
  // eslint-disable-next-line es/no-weak-set -- safe
  WeakSet,
  add: uncurryThis$9(WeakSetPrototype.add),
  has: uncurryThis$9(WeakSetPrototype.has),
  remove: uncurryThis$9(WeakSetPrototype["delete"])
};
var has2 = weakSetHelpers.has;
var aWeakSet$2 = function(it) {
  has2(it);
  return it;
};
var $$j = _export;
var aWeakSet$1 = aWeakSet$2;
var add = weakSetHelpers.add;
$$j({ target: "WeakSet", proto: true, real: true, forced: true }, {
  addAll: function addAll2() {
    var set4 = aWeakSet$1(this);
    for (var k2 = 0, len = arguments.length; k2 < len; k2++) {
      add(set4, arguments[k2]);
    }
    return set4;
  }
});
var $$i = _export;
var aWeakSet = aWeakSet$2;
var remove = weakSetHelpers.remove;
$$i({ target: "WeakSet", proto: true, real: true, forced: true }, {
  deleteAll: function deleteAll4() {
    var collection2 = aWeakSet(this);
    var allDeleted = true;
    var wasDeleted;
    for (var k2 = 0, len = arguments.length; k2 < len; k2++) {
      wasDeleted = remove(collection2, arguments[k2]);
      allDeleted = allDeleted && wasDeleted;
    }
    return !!allDeleted;
  }
});
var $$h = _export;
var WeakSetHelpers$1 = weakSetHelpers;
var createCollectionFrom = collectionFrom;
$$h({ target: "WeakSet", stat: true, forced: true }, {
  from: createCollectionFrom(WeakSetHelpers$1.WeakSet, WeakSetHelpers$1.add, false)
});
var $$g = _export;
var WeakSetHelpers = weakSetHelpers;
var createCollectionOf = collectionOf;
$$g({ target: "WeakSet", stat: true, forced: true }, {
  of: createCollectionOf(WeakSetHelpers.WeakSet, WeakSetHelpers.add, false)
});
var $$f = _export;
var globalThis$f = globalThis_1;
var getBuiltIn$8 = getBuiltIn$O;
var uncurryThis$8 = functionUncurryThis;
var call$3 = functionCall;
var fails$6 = fails$1z;
var toString$6 = toString$K;
var validateArgumentsLength$a = validateArgumentsLength$c;
var c2i = base64Map$2.c2i;
var disallowed = /[^\d+/a-z]/i;
var whitespaces = /[\t\n\f\r ]+/g;
var finalEq = /[=]{1,2}$/;
var $atob = getBuiltIn$8("atob");
var fromCharCode$2 = String.fromCharCode;
var charAt$3 = uncurryThis$8("".charAt);
var replace$5 = uncurryThis$8("".replace);
var exec$3 = uncurryThis$8(disallowed.exec);
var BASIC$1 = !!$atob && !fails$6(function() {
  return $atob("aGk=") !== "hi";
});
var NO_SPACES_IGNORE = BASIC$1 && fails$6(function() {
  return $atob(" ") !== "";
});
var NO_ENCODING_CHECK = BASIC$1 && !fails$6(function() {
  $atob("a");
});
var NO_ARG_RECEIVING_CHECK$1 = BASIC$1 && !fails$6(function() {
  $atob();
});
var WRONG_ARITY$3 = BASIC$1 && $atob.length !== 1;
var FORCED = !BASIC$1 || NO_SPACES_IGNORE || NO_ENCODING_CHECK || NO_ARG_RECEIVING_CHECK$1 || WRONG_ARITY$3;
$$f({ global: true, bind: true, enumerable: true, forced: FORCED }, {
  atob: function atob(data2) {
    validateArgumentsLength$a(arguments.length, 1);
    if (BASIC$1 && !NO_SPACES_IGNORE && !NO_ENCODING_CHECK) return call$3($atob, globalThis$f, data2);
    var string = replace$5(toString$6(data2), whitespaces, "");
    var output = "";
    var position2 = 0;
    var bc2 = 0;
    var length2, chr, bs;
    if (string.length % 4 === 0) {
      string = replace$5(string, finalEq, "");
    }
    length2 = string.length;
    if (length2 % 4 === 1 || exec$3(disallowed, string)) {
      throw new (getBuiltIn$8("DOMException"))("The string is not correctly encoded", "InvalidCharacterError");
    }
    while (position2 < length2) {
      chr = charAt$3(string, position2++);
      bs = bc2 % 4 ? bs * 64 + c2i[chr] : c2i[chr];
      if (bc2++ % 4) output += fromCharCode$2(255 & bs >> (-2 * bc2 & 6));
    }
    return output;
  }
});
var $$e = _export;
var globalThis$e = globalThis_1;
var getBuiltIn$7 = getBuiltIn$O;
var uncurryThis$7 = functionUncurryThis;
var call$2 = functionCall;
var fails$5 = fails$1z;
var toString$5 = toString$K;
var validateArgumentsLength$9 = validateArgumentsLength$c;
var i2c = base64Map$2.i2c;
var $btoa = getBuiltIn$7("btoa");
var charAt$2 = uncurryThis$7("".charAt);
var charCodeAt$1 = uncurryThis$7("".charCodeAt);
var BASIC = !!$btoa && !fails$5(function() {
  return $btoa("hi") !== "aGk=";
});
var NO_ARG_RECEIVING_CHECK = BASIC && !fails$5(function() {
  $btoa();
});
var WRONG_ARG_CONVERSION = BASIC && fails$5(function() {
  return $btoa(null) !== "bnVsbA==";
});
var WRONG_ARITY$2 = BASIC && $btoa.length !== 1;
$$e({ global: true, bind: true, enumerable: true, forced: !BASIC || NO_ARG_RECEIVING_CHECK || WRONG_ARG_CONVERSION || WRONG_ARITY$2 }, {
  btoa: function btoa2(data2) {
    validateArgumentsLength$9(arguments.length, 1);
    if (BASIC) return call$2($btoa, globalThis$e, toString$5(data2));
    var string = toString$5(data2);
    var output = "";
    var position2 = 0;
    var map7 = i2c;
    var block, charCode;
    while (charAt$2(string, position2) || (map7 = "=", position2 % 1)) {
      charCode = charCodeAt$1(string, position2 += 3 / 4);
      if (charCode > 255) {
        throw new (getBuiltIn$7("DOMException"))("The string contains characters outside of the Latin1 range", "InvalidCharacterError");
      }
      block = block << 8 | charCode;
      output += charAt$2(map7, 63 & block >> 8 - position2 % 1 * 8);
    }
    return output;
  }
});
var domIterables = {
  CSSRuleList: 0,
  CSSStyleDeclaration: 0,
  CSSValueList: 0,
  ClientRectList: 0,
  DOMRectList: 0,
  DOMStringList: 0,
  DOMTokenList: 1,
  DataTransferItemList: 0,
  FileList: 0,
  HTMLAllCollection: 0,
  HTMLCollection: 0,
  HTMLFormElement: 0,
  HTMLSelectElement: 0,
  MediaList: 0,
  MimeTypeArray: 0,
  NamedNodeMap: 0,
  NodeList: 1,
  PaintRequestList: 0,
  Plugin: 0,
  PluginArray: 0,
  SVGLengthList: 0,
  SVGNumberList: 0,
  SVGPathSegList: 0,
  SVGPointList: 0,
  SVGStringList: 0,
  SVGTransformList: 0,
  SourceBufferList: 0,
  StyleSheetList: 0,
  TextTrackCueList: 0,
  TextTrackList: 0,
  TouchList: 0
};
var documentCreateElement = documentCreateElement$2;
var classList = documentCreateElement("span").classList;
var DOMTokenListPrototype$2 = classList && classList.constructor && classList.constructor.prototype;
var domTokenListPrototype = DOMTokenListPrototype$2 === Object.prototype ? void 0 : DOMTokenListPrototype$2;
var globalThis$d = globalThis_1;
var DOMIterables$1 = domIterables;
var DOMTokenListPrototype$1 = domTokenListPrototype;
var forEach$3 = arrayForEach;
var createNonEnumerableProperty$2 = createNonEnumerableProperty$j;
var handlePrototype$1 = function(CollectionPrototype) {
  if (CollectionPrototype && CollectionPrototype.forEach !== forEach$3) try {
    createNonEnumerableProperty$2(CollectionPrototype, "forEach", forEach$3);
  } catch (error2) {
    CollectionPrototype.forEach = forEach$3;
  }
};
for (var COLLECTION_NAME$1 in DOMIterables$1) {
  if (DOMIterables$1[COLLECTION_NAME$1]) {
    handlePrototype$1(globalThis$d[COLLECTION_NAME$1] && globalThis$d[COLLECTION_NAME$1].prototype);
  }
}
handlePrototype$1(DOMTokenListPrototype$1);
var globalThis$c = globalThis_1;
var DOMIterables = domIterables;
var DOMTokenListPrototype = domTokenListPrototype;
var ArrayIteratorMethods = es_array_iterator;
var createNonEnumerableProperty$1 = createNonEnumerableProperty$j;
var setToStringTag$3 = setToStringTag$e;
var wellKnownSymbol$2 = wellKnownSymbol$S;
var ITERATOR$2 = wellKnownSymbol$2("iterator");
var ArrayValues = ArrayIteratorMethods.values;
var handlePrototype = function(CollectionPrototype, COLLECTION_NAME) {
  if (CollectionPrototype) {
    if (CollectionPrototype[ITERATOR$2] !== ArrayValues) try {
      createNonEnumerableProperty$1(CollectionPrototype, ITERATOR$2, ArrayValues);
    } catch (error2) {
      CollectionPrototype[ITERATOR$2] = ArrayValues;
    }
    setToStringTag$3(CollectionPrototype, COLLECTION_NAME, true);
    if (DOMIterables[COLLECTION_NAME]) for (var METHOD_NAME in ArrayIteratorMethods) {
      if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME]) try {
        createNonEnumerableProperty$1(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
      } catch (error2) {
        CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
      }
    }
  }
};
for (var COLLECTION_NAME in DOMIterables) {
  handlePrototype(globalThis$c[COLLECTION_NAME] && globalThis$c[COLLECTION_NAME].prototype, COLLECTION_NAME);
}
handlePrototype(DOMTokenListPrototype, "DOMTokenList");
var domExceptionConstants = {
  IndexSizeError: { s: "INDEX_SIZE_ERR", c: 1, m: 1 },
  DOMStringSizeError: { s: "DOMSTRING_SIZE_ERR", c: 2, m: 0 },
  HierarchyRequestError: { s: "HIERARCHY_REQUEST_ERR", c: 3, m: 1 },
  WrongDocumentError: { s: "WRONG_DOCUMENT_ERR", c: 4, m: 1 },
  InvalidCharacterError: { s: "INVALID_CHARACTER_ERR", c: 5, m: 1 },
  NoDataAllowedError: { s: "NO_DATA_ALLOWED_ERR", c: 6, m: 0 },
  NoModificationAllowedError: { s: "NO_MODIFICATION_ALLOWED_ERR", c: 7, m: 1 },
  NotFoundError: { s: "NOT_FOUND_ERR", c: 8, m: 1 },
  NotSupportedError: { s: "NOT_SUPPORTED_ERR", c: 9, m: 1 },
  InUseAttributeError: { s: "INUSE_ATTRIBUTE_ERR", c: 10, m: 1 },
  InvalidStateError: { s: "INVALID_STATE_ERR", c: 11, m: 1 },
  SyntaxError: { s: "SYNTAX_ERR", c: 12, m: 1 },
  InvalidModificationError: { s: "INVALID_MODIFICATION_ERR", c: 13, m: 1 },
  NamespaceError: { s: "NAMESPACE_ERR", c: 14, m: 1 },
  InvalidAccessError: { s: "INVALID_ACCESS_ERR", c: 15, m: 1 },
  ValidationError: { s: "VALIDATION_ERR", c: 16, m: 0 },
  TypeMismatchError: { s: "TYPE_MISMATCH_ERR", c: 17, m: 1 },
  SecurityError: { s: "SECURITY_ERR", c: 18, m: 1 },
  NetworkError: { s: "NETWORK_ERR", c: 19, m: 1 },
  AbortError: { s: "ABORT_ERR", c: 20, m: 1 },
  URLMismatchError: { s: "URL_MISMATCH_ERR", c: 21, m: 1 },
  QuotaExceededError: { s: "QUOTA_EXCEEDED_ERR", c: 22, m: 1 },
  TimeoutError: { s: "TIMEOUT_ERR", c: 23, m: 1 },
  InvalidNodeTypeError: { s: "INVALID_NODE_TYPE_ERR", c: 24, m: 1 },
  DataCloneError: { s: "DATA_CLONE_ERR", c: 25, m: 1 }
};
var $$d = _export;
var getBuiltIn$6 = getBuiltIn$O;
var getBuiltInNodeModule = getBuiltInNodeModule$2;
var fails$4 = fails$1z;
var create$1 = objectCreate$1;
var createPropertyDescriptor$2 = createPropertyDescriptor$d;
var defineProperty$2 = objectDefineProperty.f;
var defineBuiltIn$4 = defineBuiltIn$u;
var defineBuiltInAccessor$4 = defineBuiltInAccessor$p;
var hasOwn$5 = hasOwnProperty_1;
var anInstance$3 = anInstance$f;
var anObject$2 = anObject$1i;
var errorToString = errorToString$2;
var normalizeStringArgument$1 = normalizeStringArgument$6;
var DOMExceptionConstants$1 = domExceptionConstants;
var clearErrorStack$1 = errorStackClear;
var InternalStateModule$2 = internalState;
var DESCRIPTORS$7 = descriptors$1;
var DOM_EXCEPTION$2 = "DOMException";
var DATA_CLONE_ERR = "DATA_CLONE_ERR";
var Error$3 = getBuiltIn$6("Error");
var NativeDOMException$1 = getBuiltIn$6(DOM_EXCEPTION$2) || function() {
  try {
    var MessageChannel2 = getBuiltIn$6("MessageChannel") || getBuiltInNodeModule("worker_threads").MessageChannel;
    new MessageChannel2().port1.postMessage(/* @__PURE__ */ new WeakMap());
  } catch (error2) {
    if (error2.name === DATA_CLONE_ERR && error2.code === 25) return error2.constructor;
  }
}();
var NativeDOMExceptionPrototype = NativeDOMException$1 && NativeDOMException$1.prototype;
var ErrorPrototype = Error$3.prototype;
var setInternalState$2 = InternalStateModule$2.set;
var getInternalState = InternalStateModule$2.getterFor(DOM_EXCEPTION$2);
var HAS_STACK = "stack" in new Error$3(DOM_EXCEPTION$2);
var codeFor = function(name) {
  return hasOwn$5(DOMExceptionConstants$1, name) && DOMExceptionConstants$1[name].m ? DOMExceptionConstants$1[name].c : 0;
};
var $DOMException$1 = function DOMException2() {
  anInstance$3(this, DOMExceptionPrototype$1);
  var argumentsLength = arguments.length;
  var message = normalizeStringArgument$1(argumentsLength < 1 ? void 0 : arguments[0]);
  var name = normalizeStringArgument$1(argumentsLength < 2 ? void 0 : arguments[1], "Error");
  var code = codeFor(name);
  setInternalState$2(this, {
    type: DOM_EXCEPTION$2,
    name,
    message,
    code
  });
  if (!DESCRIPTORS$7) {
    this.name = name;
    this.message = message;
    this.code = code;
  }
  if (HAS_STACK) {
    var error2 = new Error$3(message);
    error2.name = DOM_EXCEPTION$2;
    defineProperty$2(this, "stack", createPropertyDescriptor$2(1, clearErrorStack$1(error2.stack, 1)));
  }
};
var DOMExceptionPrototype$1 = $DOMException$1.prototype = create$1(ErrorPrototype);
var createGetterDescriptor = function(get3) {
  return { enumerable: true, configurable: true, get: get3 };
};
var getterFor = function(key) {
  return createGetterDescriptor(function() {
    return getInternalState(this)[key];
  });
};
if (DESCRIPTORS$7) {
  defineBuiltInAccessor$4(DOMExceptionPrototype$1, "code", getterFor("code"));
  defineBuiltInAccessor$4(DOMExceptionPrototype$1, "message", getterFor("message"));
  defineBuiltInAccessor$4(DOMExceptionPrototype$1, "name", getterFor("name"));
}
defineProperty$2(DOMExceptionPrototype$1, "constructor", createPropertyDescriptor$2(1, $DOMException$1));
var INCORRECT_CONSTRUCTOR = fails$4(function() {
  return !(new NativeDOMException$1() instanceof Error$3);
});
var INCORRECT_TO_STRING = INCORRECT_CONSTRUCTOR || fails$4(function() {
  return ErrorPrototype.toString !== errorToString || String(new NativeDOMException$1(1, 2)) !== "2: 1";
});
var INCORRECT_CODE = INCORRECT_CONSTRUCTOR || fails$4(function() {
  return new NativeDOMException$1(1, "DataCloneError").code !== 25;
});
INCORRECT_CONSTRUCTOR || NativeDOMException$1[DATA_CLONE_ERR] !== 25 || NativeDOMExceptionPrototype[DATA_CLONE_ERR] !== 25;
var FORCED_CONSTRUCTOR$1 = INCORRECT_CONSTRUCTOR;
$$d({ global: true, constructor: true, forced: FORCED_CONSTRUCTOR$1 }, {
  DOMException: FORCED_CONSTRUCTOR$1 ? $DOMException$1 : NativeDOMException$1
});
var PolyfilledDOMException$1 = getBuiltIn$6(DOM_EXCEPTION$2);
var PolyfilledDOMExceptionPrototype$1 = PolyfilledDOMException$1.prototype;
if (INCORRECT_TO_STRING && NativeDOMException$1 === PolyfilledDOMException$1) {
  defineBuiltIn$4(PolyfilledDOMExceptionPrototype$1, "toString", errorToString);
}
if (INCORRECT_CODE && DESCRIPTORS$7 && NativeDOMException$1 === PolyfilledDOMException$1) {
  defineBuiltInAccessor$4(PolyfilledDOMExceptionPrototype$1, "code", createGetterDescriptor(function() {
    return codeFor(anObject$2(this).name);
  }));
}
for (var key$1 in DOMExceptionConstants$1) if (hasOwn$5(DOMExceptionConstants$1, key$1)) {
  var constant$1 = DOMExceptionConstants$1[key$1];
  var constantName$1 = constant$1.s;
  var descriptor$2 = createPropertyDescriptor$2(6, constant$1.c);
  if (!hasOwn$5(PolyfilledDOMException$1, constantName$1)) {
    defineProperty$2(PolyfilledDOMException$1, constantName$1, descriptor$2);
  }
  if (!hasOwn$5(PolyfilledDOMExceptionPrototype$1, constantName$1)) {
    defineProperty$2(PolyfilledDOMExceptionPrototype$1, constantName$1, descriptor$2);
  }
}
var $$c = _export;
var globalThis$b = globalThis_1;
var getBuiltIn$5 = getBuiltIn$O;
var createPropertyDescriptor$1 = createPropertyDescriptor$d;
var defineProperty$1 = objectDefineProperty.f;
var hasOwn$4 = hasOwnProperty_1;
var anInstance$2 = anInstance$f;
var inheritIfRequired = inheritIfRequired$7;
var normalizeStringArgument = normalizeStringArgument$6;
var DOMExceptionConstants = domExceptionConstants;
var clearErrorStack = errorStackClear;
var DESCRIPTORS$6 = descriptors$1;
var DOM_EXCEPTION$1 = "DOMException";
var Error$2 = getBuiltIn$5("Error");
var NativeDOMException = getBuiltIn$5(DOM_EXCEPTION$1);
var $DOMException = function DOMException3() {
  anInstance$2(this, DOMExceptionPrototype);
  var argumentsLength = arguments.length;
  var message = normalizeStringArgument(argumentsLength < 1 ? void 0 : arguments[0]);
  var name = normalizeStringArgument(argumentsLength < 2 ? void 0 : arguments[1], "Error");
  var that = new NativeDOMException(message, name);
  var error2 = new Error$2(message);
  error2.name = DOM_EXCEPTION$1;
  defineProperty$1(that, "stack", createPropertyDescriptor$1(1, clearErrorStack(error2.stack, 1)));
  inheritIfRequired(that, this, $DOMException);
  return that;
};
var DOMExceptionPrototype = $DOMException.prototype = NativeDOMException.prototype;
var ERROR_HAS_STACK = "stack" in new Error$2(DOM_EXCEPTION$1);
var DOM_EXCEPTION_HAS_STACK = "stack" in new NativeDOMException(1, 2);
var descriptor$1 = NativeDOMException && DESCRIPTORS$6 && Object.getOwnPropertyDescriptor(globalThis$b, DOM_EXCEPTION$1);
var BUGGY_DESCRIPTOR = !!descriptor$1 && !(descriptor$1.writable && descriptor$1.configurable);
var FORCED_CONSTRUCTOR = ERROR_HAS_STACK && !BUGGY_DESCRIPTOR && !DOM_EXCEPTION_HAS_STACK;
$$c({ global: true, constructor: true, forced: FORCED_CONSTRUCTOR }, {
  // TODO: fix export logic
  DOMException: FORCED_CONSTRUCTOR ? $DOMException : NativeDOMException
});
var PolyfilledDOMException = getBuiltIn$5(DOM_EXCEPTION$1);
var PolyfilledDOMExceptionPrototype = PolyfilledDOMException.prototype;
if (PolyfilledDOMExceptionPrototype.constructor !== PolyfilledDOMException) {
  {
    defineProperty$1(PolyfilledDOMExceptionPrototype, "constructor", createPropertyDescriptor$1(1, PolyfilledDOMException));
  }
  for (var key in DOMExceptionConstants) if (hasOwn$4(DOMExceptionConstants, key)) {
    var constant = DOMExceptionConstants[key];
    var constantName = constant.s;
    if (!hasOwn$4(PolyfilledDOMException, constantName)) {
      defineProperty$1(PolyfilledDOMException, constantName, createPropertyDescriptor$1(6, constant.c));
    }
  }
}
var getBuiltIn$4 = getBuiltIn$O;
var setToStringTag$2 = setToStringTag$e;
var DOM_EXCEPTION = "DOMException";
setToStringTag$2(getBuiltIn$4(DOM_EXCEPTION), DOM_EXCEPTION);
var $$b = _export;
var globalThis$a = globalThis_1;
var clearImmediate = task$1.clear;
$$b({ global: true, bind: true, enumerable: true, forced: globalThis$a.clearImmediate !== clearImmediate }, {
  clearImmediate
});
var globalThis$9 = globalThis_1;
var apply2 = functionApply$1;
var isCallable$2 = isCallable$I;
var ENVIRONMENT = environment;
var USER_AGENT = environmentUserAgent;
var arraySlice$1 = arraySlice$a;
var validateArgumentsLength$8 = validateArgumentsLength$c;
var Function$1 = globalThis$9.Function;
var WRAP = /MSIE .\./.test(USER_AGENT) || ENVIRONMENT === "BUN" && function() {
  var version2 = globalThis$9.Bun.version.split(".");
  return version2.length < 3 || version2[0] === "0" && (version2[1] < 3 || version2[1] === "3" && version2[2] === "0");
}();
var schedulersFix$3 = function(scheduler2, hasTimeArg) {
  var firstParamIndex = hasTimeArg ? 2 : 1;
  return WRAP ? function(handler, timeout) {
    var boundArgs = validateArgumentsLength$8(arguments.length, 1) > firstParamIndex;
    var fn = isCallable$2(handler) ? handler : Function$1(handler);
    var params2 = boundArgs ? arraySlice$1(arguments, firstParamIndex) : [];
    var callback2 = boundArgs ? function() {
      apply2(fn, this, params2);
    } : fn;
    return hasTimeArg ? scheduler2(callback2, timeout) : scheduler2(callback2);
  } : scheduler2;
};
var $$a = _export;
var globalThis$8 = globalThis_1;
var setTask = task$1.set;
var schedulersFix$2 = schedulersFix$3;
var setImmediate$1 = globalThis$8.setImmediate ? schedulersFix$2(setTask, false) : setTask;
$$a({ global: true, bind: true, enumerable: true, forced: globalThis$8.setImmediate !== setImmediate$1 }, {
  setImmediate: setImmediate$1
});
var $$9 = _export;
var globalThis$7 = globalThis_1;
var microtask = microtask_1;
var aCallable = aCallable$Q;
var validateArgumentsLength$7 = validateArgumentsLength$c;
var fails$3 = fails$1z;
var DESCRIPTORS$5 = descriptors$1;
var WRONG_ARITY$1 = fails$3(function() {
  return DESCRIPTORS$5 && Object.getOwnPropertyDescriptor(globalThis$7, "queueMicrotask").value.length !== 1;
});
$$9({ global: true, enumerable: true, dontCallGetSet: true, forced: WRONG_ARITY$1 }, {
  queueMicrotask: function queueMicrotask2(fn) {
    validateArgumentsLength$7(arguments.length, 1);
    microtask(aCallable(fn));
  }
});
var $$8 = _export;
var globalThis$6 = globalThis_1;
var defineBuiltInAccessor$3 = defineBuiltInAccessor$p;
var DESCRIPTORS$4 = descriptors$1;
var $TypeError = TypeError;
var defineProperty6 = Object.defineProperty;
var INCORRECT_VALUE = globalThis$6.self !== globalThis$6;
try {
  if (DESCRIPTORS$4) {
    var descriptor = Object.getOwnPropertyDescriptor(globalThis$6, "self");
    if (INCORRECT_VALUE || !descriptor || !descriptor.get || !descriptor.enumerable) {
      defineBuiltInAccessor$3(globalThis$6, "self", {
        get: function self2() {
          return globalThis$6;
        },
        set: function self2(value) {
          if (this !== globalThis$6) throw new $TypeError("Illegal invocation");
          defineProperty6(globalThis$6, "self", {
            value,
            writable: true,
            configurable: true,
            enumerable: true
          });
        },
        configurable: true,
        enumerable: true
      });
    }
  } else $$8({ global: true, simple: true, forced: INCORRECT_VALUE }, {
    self: globalThis$6
  });
} catch (error2) {
}
var $$7 = _export;
var globalThis$5 = globalThis_1;
var getBuiltIn$3 = getBuiltIn$O;
var uncurryThis$6 = functionUncurryThis;
var fails$2 = fails$1z;
var uid = uid$7;
var isCallable$1 = isCallable$I;
var isConstructor3 = isConstructor$a;
var isNullOrUndefined = isNullOrUndefined$j;
var isObject$2 = isObject$O;
var isSymbol = isSymbol$8;
var iterate = iterate$H;
var anObject$1 = anObject$1i;
var classof$1 = classof$p;
var hasOwn$3 = hasOwnProperty_1;
var createProperty = createProperty$b;
var createNonEnumerableProperty = createNonEnumerableProperty$j;
var lengthOfArrayLike = lengthOfArrayLike$B;
var validateArgumentsLength$6 = validateArgumentsLength$c;
var getRegExpFlags = regexpGetFlags;
var MapHelpers = mapHelpers;
var SetHelpers = setHelpers;
var setIterate = setIterate$1;
var detachTransferable = detachTransferable$2;
var ERROR_STACK_INSTALLABLE = errorStackInstallable;
var PROPER_STRUCTURED_CLONE_TRANSFER = structuredCloneProperTransfer;
var Object$1 = globalThis$5.Object;
var Array$1 = globalThis$5.Array;
var Date$1 = globalThis$5.Date;
var Error$1 = globalThis$5.Error;
var TypeError$3 = globalThis$5.TypeError;
var PerformanceMark = globalThis$5.PerformanceMark;
var DOMException$1 = getBuiltIn$3("DOMException");
var Map$1 = MapHelpers.Map;
var mapHas = MapHelpers.has;
var mapGet = MapHelpers.get;
var mapSet = MapHelpers.set;
var Set$1 = SetHelpers.Set;
var setAdd = SetHelpers.add;
var setHas = SetHelpers.has;
var objectKeys = getBuiltIn$3("Object", "keys");
var push$4 = uncurryThis$6([].push);
var thisBooleanValue = uncurryThis$6(true.valueOf);
var thisNumberValue = uncurryThis$6(1 .valueOf);
var thisStringValue = uncurryThis$6("".valueOf);
var thisTimeValue = uncurryThis$6(Date$1.prototype.getTime);
var PERFORMANCE_MARK = uid("structuredClone");
var DATA_CLONE_ERROR = "DataCloneError";
var TRANSFERRING = "Transferring";
var checkBasicSemantic = function(structuredCloneImplementation) {
  return !fails$2(function() {
    var set1 = new globalThis$5.Set([7]);
    var set22 = structuredCloneImplementation(set1);
    var number = structuredCloneImplementation(Object$1(7));
    return set22 === set1 || !set22.has(7) || !isObject$2(number) || +number !== 7;
  }) && structuredCloneImplementation;
};
var checkErrorsCloning = function(structuredCloneImplementation, $Error2) {
  return !fails$2(function() {
    var error2 = new $Error2();
    var test2 = structuredCloneImplementation({ a: error2, b: error2 });
    return !(test2 && test2.a === test2.b && test2.a instanceof $Error2 && test2.a.stack === error2.stack);
  });
};
var checkNewErrorsCloningSemantic = function(structuredCloneImplementation) {
  return !fails$2(function() {
    var test2 = structuredCloneImplementation(new globalThis$5.AggregateError([1], PERFORMANCE_MARK, { cause: 3 }));
    return test2.name !== "AggregateError" || test2.errors[0] !== 1 || test2.message !== PERFORMANCE_MARK || test2.cause !== 3;
  });
};
var nativeStructuredClone = globalThis$5.structuredClone;
var FORCED_REPLACEMENT = !checkErrorsCloning(nativeStructuredClone, Error$1) || !checkErrorsCloning(nativeStructuredClone, DOMException$1) || !checkNewErrorsCloningSemantic(nativeStructuredClone);
var structuredCloneFromMark = !nativeStructuredClone && checkBasicSemantic(function(value) {
  return new PerformanceMark(PERFORMANCE_MARK, { detail: value }).detail;
});
var nativeRestrictedStructuredClone = checkBasicSemantic(nativeStructuredClone) || structuredCloneFromMark;
var throwUncloneable = function(type) {
  throw new DOMException$1("Uncloneable type: " + type, DATA_CLONE_ERROR);
};
var throwUnpolyfillable = function(type, action) {
  throw new DOMException$1((action || "Cloning") + " of " + type + " cannot be properly polyfilled in this engine", DATA_CLONE_ERROR);
};
var tryNativeRestrictedStructuredClone = function(value, type) {
  if (!nativeRestrictedStructuredClone) throwUnpolyfillable(type);
  return nativeRestrictedStructuredClone(value);
};
var createDataTransfer = function() {
  var dataTransfer;
  try {
    dataTransfer = new globalThis$5.DataTransfer();
  } catch (error2) {
    try {
      dataTransfer = new globalThis$5.ClipboardEvent("").clipboardData;
    } catch (error22) {
    }
  }
  return dataTransfer && dataTransfer.items && dataTransfer.files ? dataTransfer : null;
};
var cloneBuffer = function(value, map7, $type) {
  if (mapHas(map7, value)) return mapGet(map7, value);
  var type = $type || classof$1(value);
  var clone2, length2, options, source, target, i;
  if (type === "SharedArrayBuffer") {
    if (nativeRestrictedStructuredClone) clone2 = nativeRestrictedStructuredClone(value);
    else clone2 = value;
  } else {
    var DataView2 = globalThis$5.DataView;
    if (!DataView2 && !isCallable$1(value.slice)) throwUnpolyfillable("ArrayBuffer");
    try {
      if (isCallable$1(value.slice) && !value.resizable) {
        clone2 = value.slice(0);
      } else {
        length2 = value.byteLength;
        options = "maxByteLength" in value ? { maxByteLength: value.maxByteLength } : void 0;
        clone2 = new ArrayBuffer(length2, options);
        source = new DataView2(value);
        target = new DataView2(clone2);
        for (i = 0; i < length2; i++) {
          target.setUint8(i, source.getUint8(i));
        }
      }
    } catch (error2) {
      throw new DOMException$1("ArrayBuffer is detached", DATA_CLONE_ERROR);
    }
  }
  mapSet(map7, value, clone2);
  return clone2;
};
var cloneView = function(value, type, offset, length2, map7) {
  var C2 = globalThis$5[type];
  if (!isObject$2(C2)) throwUnpolyfillable(type);
  return new C2(cloneBuffer(value.buffer, map7), offset, length2);
};
var structuredCloneInternal = function(value, map7) {
  if (isSymbol(value)) throwUncloneable("Symbol");
  if (!isObject$2(value)) return value;
  if (map7) {
    if (mapHas(map7, value)) return mapGet(map7, value);
  } else map7 = new Map$1();
  var type = classof$1(value);
  var C2, name, cloned, dataTransfer, i, length2, keys6, key;
  switch (type) {
    case "Array":
      cloned = Array$1(lengthOfArrayLike(value));
      break;
    case "Object":
      cloned = {};
      break;
    case "Map":
      cloned = new Map$1();
      break;
    case "Set":
      cloned = new Set$1();
      break;
    case "RegExp":
      cloned = new RegExp(value.source, getRegExpFlags(value));
      break;
    case "Error":
      name = value.name;
      switch (name) {
        case "AggregateError":
          cloned = new (getBuiltIn$3(name))([]);
          break;
        case "EvalError":
        case "RangeError":
        case "ReferenceError":
        case "SuppressedError":
        case "SyntaxError":
        case "TypeError":
        case "URIError":
          cloned = new (getBuiltIn$3(name))();
          break;
        case "CompileError":
        case "LinkError":
        case "RuntimeError":
          cloned = new (getBuiltIn$3("WebAssembly", name))();
          break;
        default:
          cloned = new Error$1();
      }
      break;
    case "DOMException":
      cloned = new DOMException$1(value.message, value.name);
      break;
    case "ArrayBuffer":
    case "SharedArrayBuffer":
      cloned = cloneBuffer(value, map7, type);
      break;
    case "DataView":
    case "Int8Array":
    case "Uint8Array":
    case "Uint8ClampedArray":
    case "Int16Array":
    case "Uint16Array":
    case "Int32Array":
    case "Uint32Array":
    case "Float16Array":
    case "Float32Array":
    case "Float64Array":
    case "BigInt64Array":
    case "BigUint64Array":
      length2 = type === "DataView" ? value.byteLength : value.length;
      cloned = cloneView(value, type, value.byteOffset, length2, map7);
      break;
    case "DOMQuad":
      try {
        cloned = new DOMQuad(
          structuredCloneInternal(value.p1, map7),
          structuredCloneInternal(value.p2, map7),
          structuredCloneInternal(value.p3, map7),
          structuredCloneInternal(value.p4, map7)
        );
      } catch (error2) {
        cloned = tryNativeRestrictedStructuredClone(value, type);
      }
      break;
    case "File":
      if (nativeRestrictedStructuredClone) try {
        cloned = nativeRestrictedStructuredClone(value);
        if (classof$1(cloned) !== type) cloned = void 0;
      } catch (error2) {
      }
      if (!cloned) try {
        cloned = new File([value], value.name, value);
      } catch (error2) {
      }
      if (!cloned) throwUnpolyfillable(type);
      break;
    case "FileList":
      dataTransfer = createDataTransfer();
      if (dataTransfer) {
        for (i = 0, length2 = lengthOfArrayLike(value); i < length2; i++) {
          dataTransfer.items.add(structuredCloneInternal(value[i], map7));
        }
        cloned = dataTransfer.files;
      } else cloned = tryNativeRestrictedStructuredClone(value, type);
      break;
    case "ImageData":
      try {
        cloned = new ImageData(
          structuredCloneInternal(value.data, map7),
          value.width,
          value.height,
          { colorSpace: value.colorSpace }
        );
      } catch (error2) {
        cloned = tryNativeRestrictedStructuredClone(value, type);
      }
      break;
    default:
      if (nativeRestrictedStructuredClone) {
        cloned = nativeRestrictedStructuredClone(value);
      } else switch (type) {
        case "BigInt":
          cloned = Object$1(value.valueOf());
          break;
        case "Boolean":
          cloned = Object$1(thisBooleanValue(value));
          break;
        case "Number":
          cloned = Object$1(thisNumberValue(value));
          break;
        case "String":
          cloned = Object$1(thisStringValue(value));
          break;
        case "Date":
          cloned = new Date$1(thisTimeValue(value));
          break;
        case "Blob":
          try {
            cloned = value.slice(0, value.size, value.type);
          } catch (error2) {
            throwUnpolyfillable(type);
          }
          break;
        case "DOMPoint":
        case "DOMPointReadOnly":
          C2 = globalThis$5[type];
          try {
            cloned = C2.fromPoint ? C2.fromPoint(value) : new C2(value.x, value.y, value.z, value.w);
          } catch (error2) {
            throwUnpolyfillable(type);
          }
          break;
        case "DOMRect":
        case "DOMRectReadOnly":
          C2 = globalThis$5[type];
          try {
            cloned = C2.fromRect ? C2.fromRect(value) : new C2(value.x, value.y, value.width, value.height);
          } catch (error2) {
            throwUnpolyfillable(type);
          }
          break;
        case "DOMMatrix":
        case "DOMMatrixReadOnly":
          C2 = globalThis$5[type];
          try {
            cloned = C2.fromMatrix ? C2.fromMatrix(value) : new C2(value);
          } catch (error2) {
            throwUnpolyfillable(type);
          }
          break;
        case "AudioData":
        case "VideoFrame":
          if (!isCallable$1(value.clone)) throwUnpolyfillable(type);
          try {
            cloned = value.clone();
          } catch (error2) {
            throwUncloneable(type);
          }
          break;
        case "CropTarget":
        case "CryptoKey":
        case "FileSystemDirectoryHandle":
        case "FileSystemFileHandle":
        case "FileSystemHandle":
        case "GPUCompilationInfo":
        case "GPUCompilationMessage":
        case "ImageBitmap":
        case "RTCCertificate":
        case "WebAssembly.Module":
          throwUnpolyfillable(type);
        default:
          throwUncloneable(type);
      }
  }
  mapSet(map7, value, cloned);
  switch (type) {
    case "Array":
    case "Object":
      keys6 = objectKeys(value);
      for (i = 0, length2 = lengthOfArrayLike(keys6); i < length2; i++) {
        key = keys6[i];
        createProperty(cloned, key, structuredCloneInternal(value[key], map7));
      }
      break;
    case "Map":
      value.forEach(function(v2, k2) {
        mapSet(cloned, structuredCloneInternal(k2, map7), structuredCloneInternal(v2, map7));
      });
      break;
    case "Set":
      value.forEach(function(v2) {
        setAdd(cloned, structuredCloneInternal(v2, map7));
      });
      break;
    case "Error":
      createNonEnumerableProperty(cloned, "message", structuredCloneInternal(value.message, map7));
      if (hasOwn$3(value, "cause")) {
        createNonEnumerableProperty(cloned, "cause", structuredCloneInternal(value.cause, map7));
      }
      if (name === "AggregateError") {
        cloned.errors = structuredCloneInternal(value.errors, map7);
      } else if (name === "SuppressedError") {
        cloned.error = structuredCloneInternal(value.error, map7);
        cloned.suppressed = structuredCloneInternal(value.suppressed, map7);
      }
    case "DOMException":
      if (ERROR_STACK_INSTALLABLE) {
        createNonEnumerableProperty(cloned, "stack", structuredCloneInternal(value.stack, map7));
      }
  }
  return cloned;
};
var tryToTransfer = function(rawTransfer, map7) {
  if (!isObject$2(rawTransfer)) throw new TypeError$3("Transfer option cannot be converted to a sequence");
  var transfer2 = [];
  iterate(rawTransfer, function(value2) {
    push$4(transfer2, anObject$1(value2));
  });
  var i = 0;
  var length2 = lengthOfArrayLike(transfer2);
  var buffers = new Set$1();
  var value, type, C2, transferred, canvas, context;
  while (i < length2) {
    value = transfer2[i++];
    type = classof$1(value);
    if (type === "ArrayBuffer" ? setHas(buffers, value) : mapHas(map7, value)) {
      throw new DOMException$1("Duplicate transferable", DATA_CLONE_ERROR);
    }
    if (type === "ArrayBuffer") {
      setAdd(buffers, value);
      continue;
    }
    if (PROPER_STRUCTURED_CLONE_TRANSFER) {
      transferred = nativeStructuredClone(value, { transfer: [value] });
    } else switch (type) {
      case "ImageBitmap":
        C2 = globalThis$5.OffscreenCanvas;
        if (!isConstructor3(C2)) throwUnpolyfillable(type, TRANSFERRING);
        try {
          canvas = new C2(value.width, value.height);
          context = canvas.getContext("bitmaprenderer");
          context.transferFromImageBitmap(value);
          transferred = canvas.transferToImageBitmap();
        } catch (error2) {
        }
        break;
      case "AudioData":
      case "VideoFrame":
        if (!isCallable$1(value.clone) || !isCallable$1(value.close)) throwUnpolyfillable(type, TRANSFERRING);
        try {
          transferred = value.clone();
          value.close();
        } catch (error2) {
        }
        break;
      case "MediaSourceHandle":
      case "MessagePort":
      case "MIDIAccess":
      case "OffscreenCanvas":
      case "ReadableStream":
      case "RTCDataChannel":
      case "TransformStream":
      case "WebTransportReceiveStream":
      case "WebTransportSendStream":
      case "WritableStream":
        throwUnpolyfillable(type, TRANSFERRING);
    }
    if (transferred === void 0) throw new DOMException$1("This object cannot be transferred: " + type, DATA_CLONE_ERROR);
    mapSet(map7, value, transferred);
  }
  return buffers;
};
var detachBuffers = function(buffers) {
  setIterate(buffers, function(buffer2) {
    if (PROPER_STRUCTURED_CLONE_TRANSFER) {
      nativeRestrictedStructuredClone(buffer2, { transfer: [buffer2] });
    } else if (isCallable$1(buffer2.transfer)) {
      buffer2.transfer();
    } else if (detachTransferable) {
      detachTransferable(buffer2);
    } else {
      throwUnpolyfillable("ArrayBuffer", TRANSFERRING);
    }
  });
};
$$7({ global: true, enumerable: true, sham: !PROPER_STRUCTURED_CLONE_TRANSFER, forced: FORCED_REPLACEMENT }, {
  structuredClone: function structuredClone2(value) {
    var options = validateArgumentsLength$6(arguments.length, 1) > 1 && !isNullOrUndefined(arguments[1]) ? anObject$1(arguments[1]) : void 0;
    var transfer2 = options ? options.transfer : void 0;
    var map7, buffers;
    if (transfer2 !== void 0) {
      map7 = new Map$1();
      buffers = tryToTransfer(transfer2, map7);
    }
    var clone2 = structuredCloneInternal(value, map7);
    if (buffers) detachBuffers(buffers);
    return clone2;
  }
});
var $$6 = _export;
var globalThis$4 = globalThis_1;
var schedulersFix$1 = schedulersFix$3;
var setInterval$1 = schedulersFix$1(globalThis$4.setInterval, true);
$$6({ global: true, bind: true, forced: globalThis$4.setInterval !== setInterval$1 }, {
  setInterval: setInterval$1
});
var $$5 = _export;
var globalThis$3 = globalThis_1;
var schedulersFix = schedulersFix$3;
var setTimeout$1 = schedulersFix(globalThis$3.setTimeout, true);
$$5({ global: true, bind: true, forced: globalThis$3.setTimeout !== setTimeout$1 }, {
  setTimeout: setTimeout$1
});
var fails$1 = fails$1z;
var wellKnownSymbol$1 = wellKnownSymbol$S;
var DESCRIPTORS$3 = descriptors$1;
var IS_PURE = isPure;
var ITERATOR$1 = wellKnownSymbol$1("iterator");
var urlConstructorDetection = !fails$1(function() {
  var url = new URL("b?a=1&b=2&c=3", "https://a");
  var params2 = url.searchParams;
  var params22 = new URLSearchParams("a=1&a=2&b=3");
  var result = "";
  url.pathname = "c%20d";
  params2.forEach(function(value, key) {
    params2["delete"]("b");
    result += key + value;
  });
  params22["delete"]("a", 2);
  params22["delete"]("b", void 0);
  return IS_PURE && (!url.toJSON || !params22.has("a", 1) || params22.has("a", 2) || !params22.has("a", void 0) || params22.has("b")) || !params2.size && (IS_PURE || !DESCRIPTORS$3) || !params2.sort || url.href !== "https://a/c%20d?a=1&c=3" || params2.get("c") !== "3" || String(new URLSearchParams("?a=1")) !== "a=1" || !params2[ITERATOR$1] || new URL("https://a@b").username !== "a" || new URLSearchParams(new URLSearchParams("a=b")).get("a") !== "b" || new URL("https://тест").host !== "xn--e1aybc" || new URL("https://a#б").hash !== "#%D0%B1" || result !== "a1c3" || new URL("https://x", void 0).host !== "x";
});
var uncurryThis$5 = functionUncurryThis;
var maxInt = 2147483647;
var base = 36;
var tMin = 1;
var tMax = 26;
var skew = 38;
var damp = 700;
var initialBias = 72;
var initialN = 128;
var delimiter$2 = "-";
var regexNonASCII = /[^\0-\u007E]/;
var regexSeparators = /[.\u3002\uFF0E\uFF61]/g;
var OVERFLOW_ERROR = "Overflow: input needs wider integers to process";
var baseMinusTMin = base - tMin;
var $RangeError = RangeError;
var exec$2 = uncurryThis$5(regexSeparators.exec);
var floor$1 = Math.floor;
var fromCharCode$1 = String.fromCharCode;
var charCodeAt = uncurryThis$5("".charCodeAt);
var join$2 = uncurryThis$5([].join);
var push$3 = uncurryThis$5([].push);
var replace$4 = uncurryThis$5("".replace);
var split$2 = uncurryThis$5("".split);
var toLowerCase$1 = uncurryThis$5("".toLowerCase);
var ucs2decode = function(string) {
  var output = [];
  var counter2 = 0;
  var length2 = string.length;
  while (counter2 < length2) {
    var value = charCodeAt(string, counter2++);
    if (value >= 55296 && value <= 56319 && counter2 < length2) {
      var extra = charCodeAt(string, counter2++);
      if ((extra & 64512) === 56320) {
        push$3(output, ((value & 1023) << 10) + (extra & 1023) + 65536);
      } else {
        push$3(output, value);
        counter2--;
      }
    } else {
      push$3(output, value);
    }
  }
  return output;
};
var digitToBasic = function(digit) {
  return digit + 22 + 75 * (digit < 26);
};
var adapt = function(delta, numPoints, firstTime) {
  var k2 = 0;
  delta = firstTime ? floor$1(delta / damp) : delta >> 1;
  delta += floor$1(delta / numPoints);
  while (delta > baseMinusTMin * tMax >> 1) {
    delta = floor$1(delta / baseMinusTMin);
    k2 += base;
  }
  return floor$1(k2 + (baseMinusTMin + 1) * delta / (delta + skew));
};
var encode$2 = function(input) {
  var output = [];
  input = ucs2decode(input);
  var inputLength = input.length;
  var n2 = initialN;
  var delta = 0;
  var bias = initialBias;
  var i, currentValue;
  for (i = 0; i < input.length; i++) {
    currentValue = input[i];
    if (currentValue < 128) {
      push$3(output, fromCharCode$1(currentValue));
    }
  }
  var basicLength = output.length;
  var handledCPCount = basicLength;
  if (basicLength) {
    push$3(output, delimiter$2);
  }
  while (handledCPCount < inputLength) {
    var m2 = maxInt;
    for (i = 0; i < input.length; i++) {
      currentValue = input[i];
      if (currentValue >= n2 && currentValue < m2) {
        m2 = currentValue;
      }
    }
    var handledCPCountPlusOne = handledCPCount + 1;
    if (m2 - n2 > floor$1((maxInt - delta) / handledCPCountPlusOne)) {
      throw new $RangeError(OVERFLOW_ERROR);
    }
    delta += (m2 - n2) * handledCPCountPlusOne;
    n2 = m2;
    for (i = 0; i < input.length; i++) {
      currentValue = input[i];
      if (currentValue < n2 && ++delta > maxInt) {
        throw new $RangeError(OVERFLOW_ERROR);
      }
      if (currentValue === n2) {
        var q2 = delta;
        var k2 = base;
        while (true) {
          var t2 = k2 <= bias ? tMin : k2 >= bias + tMax ? tMax : k2 - bias;
          if (q2 < t2) break;
          var qMinusT = q2 - t2;
          var baseMinusT = base - t2;
          push$3(output, fromCharCode$1(digitToBasic(t2 + qMinusT % baseMinusT)));
          q2 = floor$1(qMinusT / baseMinusT);
          k2 += base;
        }
        push$3(output, fromCharCode$1(digitToBasic(q2)));
        bias = adapt(delta, handledCPCountPlusOne, handledCPCount === basicLength);
        delta = 0;
        handledCPCount++;
      }
    }
    delta++;
    n2++;
  }
  return join$2(output, "");
};
var stringPunycodeToAscii = function(input) {
  var encoded = [];
  var labels = split$2(replace$4(toLowerCase$1(input), regexSeparators, "."), ".");
  var i, label;
  for (i = 0; i < labels.length; i++) {
    label = labels[i];
    push$3(encoded, exec$2(regexNonASCII, label) ? "xn--" + encode$2(label) : label);
  }
  return join$2(encoded, ".");
};
var $$4 = _export;
var globalThis$2 = globalThis_1;
var safeGetBuiltIn = safeGetBuiltIn$2;
var getBuiltIn$2 = getBuiltIn$O;
var call$1 = functionCall;
var uncurryThis$4 = functionUncurryThis;
var DESCRIPTORS$2 = descriptors$1;
var USE_NATIVE_URL$3 = urlConstructorDetection;
var defineBuiltIn$3 = defineBuiltIn$u;
var defineBuiltInAccessor$2 = defineBuiltInAccessor$p;
var defineBuiltIns = defineBuiltIns$b;
var setToStringTag$1 = setToStringTag$e;
var createIteratorConstructor = iteratorCreateConstructor;
var InternalStateModule$1 = internalState;
var anInstance$1 = anInstance$f;
var isCallable2 = isCallable$I;
var hasOwn$2 = hasOwnProperty_1;
var bind$2 = functionBindContext;
var classof = classof$p;
var anObject = anObject$1i;
var isObject$1 = isObject$O;
var $toString$1 = toString$K;
var create3 = objectCreate$1;
var createPropertyDescriptor = createPropertyDescriptor$d;
var getIterator = getIterator$7;
var getIteratorMethod = getIteratorMethod$9;
var createIterResultObject = createIterResultObject$h;
var validateArgumentsLength$5 = validateArgumentsLength$c;
var wellKnownSymbol = wellKnownSymbol$S;
var arraySort = arraySort$1;
var ITERATOR = wellKnownSymbol("iterator");
var URL_SEARCH_PARAMS = "URLSearchParams";
var URL_SEARCH_PARAMS_ITERATOR = URL_SEARCH_PARAMS + "Iterator";
var setInternalState$1 = InternalStateModule$1.set;
var getInternalParamsState = InternalStateModule$1.getterFor(URL_SEARCH_PARAMS);
var getInternalIteratorState = InternalStateModule$1.getterFor(URL_SEARCH_PARAMS_ITERATOR);
var nativeFetch = safeGetBuiltIn("fetch");
var NativeRequest = safeGetBuiltIn("Request");
var Headers = safeGetBuiltIn("Headers");
var RequestPrototype = NativeRequest && NativeRequest.prototype;
var HeadersPrototype = Headers && Headers.prototype;
var TypeError$2 = globalThis$2.TypeError;
var encodeURIComponent$1 = globalThis$2.encodeURIComponent;
var fromCharCode = String.fromCharCode;
var fromCodePoint2 = getBuiltIn$2("String", "fromCodePoint");
var $parseInt = parseInt;
var charAt$1 = uncurryThis$4("".charAt);
var join$1 = uncurryThis$4([].join);
var push$2 = uncurryThis$4([].push);
var replace$3 = uncurryThis$4("".replace);
var shift$1 = uncurryThis$4([].shift);
var splice2 = uncurryThis$4([].splice);
var split$1 = uncurryThis$4("".split);
var stringSlice$1 = uncurryThis$4("".slice);
var exec$1 = uncurryThis$4(/./.exec);
var plus = /\+/g;
var FALLBACK_REPLACER = "�";
var VALID_HEX = /^[0-9a-f]+$/i;
var parseHexOctet = function(string, start) {
  var substr3 = stringSlice$1(string, start, start + 2);
  if (!exec$1(VALID_HEX, substr3)) return NaN;
  return $parseInt(substr3, 16);
};
var getLeadingOnes = function(octet) {
  var count = 0;
  for (var mask = 128; mask > 0 && (octet & mask) !== 0; mask >>= 1) {
    count++;
  }
  return count;
};
var utf8Decode = function(octets) {
  var codePoint = null;
  switch (octets.length) {
    case 1:
      codePoint = octets[0];
      break;
    case 2:
      codePoint = (octets[0] & 31) << 6 | octets[1] & 63;
      break;
    case 3:
      codePoint = (octets[0] & 15) << 12 | (octets[1] & 63) << 6 | octets[2] & 63;
      break;
    case 4:
      codePoint = (octets[0] & 7) << 18 | (octets[1] & 63) << 12 | (octets[2] & 63) << 6 | octets[3] & 63;
      break;
  }
  return codePoint > 1114111 ? null : codePoint;
};
var decode = function(input) {
  input = replace$3(input, plus, " ");
  var length2 = input.length;
  var result = "";
  var i = 0;
  while (i < length2) {
    var decodedChar = charAt$1(input, i);
    if (decodedChar === "%") {
      if (charAt$1(input, i + 1) === "%" || i + 3 > length2) {
        result += "%";
        i++;
        continue;
      }
      var octet = parseHexOctet(input, i + 1);
      if (octet !== octet) {
        result += decodedChar;
        i++;
        continue;
      }
      i += 2;
      var byteSequenceLength = getLeadingOnes(octet);
      if (byteSequenceLength === 0) {
        decodedChar = fromCharCode(octet);
      } else {
        if (byteSequenceLength === 1 || byteSequenceLength > 4) {
          result += FALLBACK_REPLACER;
          i++;
          continue;
        }
        var octets = [octet];
        var sequenceIndex = 1;
        while (sequenceIndex < byteSequenceLength) {
          i++;
          if (i + 3 > length2 || charAt$1(input, i) !== "%") break;
          var nextByte = parseHexOctet(input, i + 1);
          if (nextByte !== nextByte) {
            i += 3;
            break;
          }
          if (nextByte > 191 || nextByte < 128) break;
          push$2(octets, nextByte);
          i += 2;
          sequenceIndex++;
        }
        if (octets.length !== byteSequenceLength) {
          result += FALLBACK_REPLACER;
          continue;
        }
        var codePoint = utf8Decode(octets);
        if (codePoint === null) {
          result += FALLBACK_REPLACER;
        } else {
          decodedChar = fromCodePoint2(codePoint);
        }
      }
    }
    result += decodedChar;
    i++;
  }
  return result;
};
var find7 = /[!'()~]|%20/g;
var replacements = {
  "!": "%21",
  "'": "%27",
  "(": "%28",
  ")": "%29",
  "~": "%7E",
  "%20": "+"
};
var replacer = function(match2) {
  return replacements[match2];
};
var serialize$2 = function(it) {
  return replace$3(encodeURIComponent$1(it), find7, replacer);
};
var URLSearchParamsIterator = createIteratorConstructor(function Iterator2(params2, kind) {
  setInternalState$1(this, {
    type: URL_SEARCH_PARAMS_ITERATOR,
    target: getInternalParamsState(params2).entries,
    index: 0,
    kind
  });
}, URL_SEARCH_PARAMS, function next9() {
  var state = getInternalIteratorState(this);
  var target = state.target;
  var index = state.index++;
  if (!target || index >= target.length) {
    state.target = null;
    return createIterResultObject(void 0, true);
  }
  var entry = target[index];
  switch (state.kind) {
    case "keys":
      return createIterResultObject(entry.key, false);
    case "values":
      return createIterResultObject(entry.value, false);
  }
  return createIterResultObject([entry.key, entry.value], false);
}, true);
var URLSearchParamsState = function(init) {
  this.entries = [];
  this.url = null;
  if (init !== void 0) {
    if (isObject$1(init)) this.parseObject(init);
    else this.parseQuery(typeof init == "string" ? charAt$1(init, 0) === "?" ? stringSlice$1(init, 1) : init : $toString$1(init));
  }
};
URLSearchParamsState.prototype = {
  type: URL_SEARCH_PARAMS,
  bindURL: function(url) {
    this.url = url;
    this.update();
  },
  parseObject: function(object) {
    var entries5 = this.entries;
    var iteratorMethod = getIteratorMethod(object);
    var iterator, next11, step, entryIterator, entryNext, first, second;
    if (iteratorMethod) {
      iterator = getIterator(object, iteratorMethod);
      next11 = iterator.next;
      while (!(step = call$1(next11, iterator)).done) {
        entryIterator = getIterator(anObject(step.value));
        entryNext = entryIterator.next;
        if ((first = call$1(entryNext, entryIterator)).done || (second = call$1(entryNext, entryIterator)).done || !call$1(entryNext, entryIterator).done) throw new TypeError$2("Expected sequence with length 2");
        push$2(entries5, { key: $toString$1(first.value), value: $toString$1(second.value) });
      }
    } else for (var key in object) if (hasOwn$2(object, key)) {
      push$2(entries5, { key, value: $toString$1(object[key]) });
    }
  },
  parseQuery: function(query) {
    if (query) {
      var entries5 = this.entries;
      var attributes = split$1(query, "&");
      var index = 0;
      var attribute, entry;
      while (index < attributes.length) {
        attribute = attributes[index++];
        if (attribute.length) {
          entry = split$1(attribute, "=");
          push$2(entries5, {
            key: decode(shift$1(entry)),
            value: decode(join$1(entry, "="))
          });
        }
      }
    }
  },
  serialize: function() {
    var entries5 = this.entries;
    var result = [];
    var index = 0;
    var entry;
    while (index < entries5.length) {
      entry = entries5[index++];
      push$2(result, serialize$2(entry.key) + "=" + serialize$2(entry.value));
    }
    return join$1(result, "&");
  },
  update: function() {
    this.entries.length = 0;
    this.parseQuery(this.url.query);
  },
  updateURL: function() {
    if (this.url) this.url.update();
  }
};
var URLSearchParamsConstructor = function URLSearchParams2() {
  anInstance$1(this, URLSearchParamsPrototype$3);
  var init = arguments.length > 0 ? arguments[0] : void 0;
  var state = setInternalState$1(this, new URLSearchParamsState(init));
  if (!DESCRIPTORS$2) this.size = state.entries.length;
};
var URLSearchParamsPrototype$3 = URLSearchParamsConstructor.prototype;
defineBuiltIns(URLSearchParamsPrototype$3, {
  // `URLSearchParams.prototype.append` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-append
  append: function append(name, value) {
    var state = getInternalParamsState(this);
    validateArgumentsLength$5(arguments.length, 2);
    push$2(state.entries, { key: $toString$1(name), value: $toString$1(value) });
    if (!DESCRIPTORS$2) this.length++;
    state.updateURL();
  },
  // `URLSearchParams.prototype.delete` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-delete
  "delete": function(name) {
    var state = getInternalParamsState(this);
    var length2 = validateArgumentsLength$5(arguments.length, 1);
    var entries5 = state.entries;
    var key = $toString$1(name);
    var $value = length2 < 2 ? void 0 : arguments[1];
    var value = $value === void 0 ? $value : $toString$1($value);
    var index = 0;
    while (index < entries5.length) {
      var entry = entries5[index];
      if (entry.key === key && (value === void 0 || entry.value === value)) {
        splice2(entries5, index, 1);
        if (value !== void 0) break;
      } else index++;
    }
    if (!DESCRIPTORS$2) this.size = entries5.length;
    state.updateURL();
  },
  // `URLSearchParams.prototype.get` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-get
  get: function get2(name) {
    var entries5 = getInternalParamsState(this).entries;
    validateArgumentsLength$5(arguments.length, 1);
    var key = $toString$1(name);
    var index = 0;
    for (; index < entries5.length; index++) {
      if (entries5[index].key === key) return entries5[index].value;
    }
    return null;
  },
  // `URLSearchParams.prototype.getAll` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-getall
  getAll: function getAll(name) {
    var entries5 = getInternalParamsState(this).entries;
    validateArgumentsLength$5(arguments.length, 1);
    var key = $toString$1(name);
    var result = [];
    var index = 0;
    for (; index < entries5.length; index++) {
      if (entries5[index].key === key) push$2(result, entries5[index].value);
    }
    return result;
  },
  // `URLSearchParams.prototype.has` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-has
  has: function has3(name) {
    var entries5 = getInternalParamsState(this).entries;
    var length2 = validateArgumentsLength$5(arguments.length, 1);
    var key = $toString$1(name);
    var $value = length2 < 2 ? void 0 : arguments[1];
    var value = $value === void 0 ? $value : $toString$1($value);
    var index = 0;
    while (index < entries5.length) {
      var entry = entries5[index++];
      if (entry.key === key && (value === void 0 || entry.value === value)) return true;
    }
    return false;
  },
  // `URLSearchParams.prototype.set` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-set
  set: function set3(name, value) {
    var state = getInternalParamsState(this);
    validateArgumentsLength$5(arguments.length, 1);
    var entries5 = state.entries;
    var found = false;
    var key = $toString$1(name);
    var val = $toString$1(value);
    var index = 0;
    var entry;
    for (; index < entries5.length; index++) {
      entry = entries5[index];
      if (entry.key === key) {
        if (found) splice2(entries5, index--, 1);
        else {
          found = true;
          entry.value = val;
        }
      }
    }
    if (!found) push$2(entries5, { key, value: val });
    if (!DESCRIPTORS$2) this.size = entries5.length;
    state.updateURL();
  },
  // `URLSearchParams.prototype.sort` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-sort
  sort: function sort4() {
    var state = getInternalParamsState(this);
    arraySort(state.entries, function(a, b2) {
      return a.key > b2.key ? 1 : -1;
    });
    state.updateURL();
  },
  // `URLSearchParams.prototype.forEach` method
  forEach: function forEach5(callback2) {
    var entries5 = getInternalParamsState(this).entries;
    var boundFunction = bind$2(callback2, arguments.length > 1 ? arguments[1] : void 0);
    var index = 0;
    var entry;
    while (index < entries5.length) {
      entry = entries5[index++];
      boundFunction(entry.value, entry.key, this);
    }
  },
  // `URLSearchParams.prototype.keys` method
  keys: function keys5() {
    return new URLSearchParamsIterator(this, "keys");
  },
  // `URLSearchParams.prototype.values` method
  values: function values3() {
    return new URLSearchParamsIterator(this, "values");
  },
  // `URLSearchParams.prototype.entries` method
  entries: function entries4() {
    return new URLSearchParamsIterator(this, "entries");
  }
}, { enumerable: true });
defineBuiltIn$3(URLSearchParamsPrototype$3, ITERATOR, URLSearchParamsPrototype$3.entries, { name: "entries" });
defineBuiltIn$3(URLSearchParamsPrototype$3, "toString", function toString4() {
  return getInternalParamsState(this).serialize();
}, { enumerable: true });
if (DESCRIPTORS$2) defineBuiltInAccessor$2(URLSearchParamsPrototype$3, "size", {
  get: function size2() {
    return getInternalParamsState(this).entries.length;
  },
  configurable: true,
  enumerable: true
});
setToStringTag$1(URLSearchParamsConstructor, URL_SEARCH_PARAMS);
$$4({ global: true, constructor: true, forced: !USE_NATIVE_URL$3 }, {
  URLSearchParams: URLSearchParamsConstructor
});
if (!USE_NATIVE_URL$3 && isCallable2(Headers)) {
  var headersHas = uncurryThis$4(HeadersPrototype.has);
  var headersSet = uncurryThis$4(HeadersPrototype.set);
  var wrapRequestOptions = function(init) {
    if (isObject$1(init)) {
      var body = init.body;
      var headers;
      if (classof(body) === URL_SEARCH_PARAMS) {
        headers = init.headers ? new Headers(init.headers) : new Headers();
        if (!headersHas(headers, "content-type")) {
          headersSet(headers, "content-type", "application/x-www-form-urlencoded;charset=UTF-8");
        }
        return create3(init, {
          body: createPropertyDescriptor(0, $toString$1(body)),
          headers: createPropertyDescriptor(0, headers)
        });
      }
    }
    return init;
  };
  if (isCallable2(nativeFetch)) {
    $$4({ global: true, enumerable: true, dontCallGetSet: true, forced: true }, {
      fetch: function fetch2(input) {
        return nativeFetch(input, arguments.length > 1 ? wrapRequestOptions(arguments[1]) : {});
      }
    });
  }
  if (isCallable2(NativeRequest)) {
    var RequestConstructor = function Request2(input) {
      anInstance$1(this, RequestPrototype);
      return new NativeRequest(input, arguments.length > 1 ? wrapRequestOptions(arguments[1]) : {});
    };
    RequestPrototype.constructor = RequestConstructor;
    RequestConstructor.prototype = RequestPrototype;
    $$4({ global: true, constructor: true, dontCallGetSet: true, forced: true }, {
      Request: RequestConstructor
    });
  }
}
var web_urlSearchParams_constructor = {
  URLSearchParams: URLSearchParamsConstructor,
  getState: getInternalParamsState
};
var $$3 = _export;
var DESCRIPTORS$1 = descriptors$1;
var USE_NATIVE_URL$2 = urlConstructorDetection;
var globalThis$1 = globalThis_1;
var bind$1 = functionBindContext;
var uncurryThis$3 = functionUncurryThis;
var defineBuiltIn$2 = defineBuiltIn$u;
var defineBuiltInAccessor$1 = defineBuiltInAccessor$p;
var anInstance = anInstance$f;
var hasOwn$1 = hasOwnProperty_1;
var assign$2 = objectAssign;
var arrayFrom = arrayFrom$1;
var arraySlice = arraySlice$a;
var codeAt = stringMultibyte.codeAt;
var toASCII = stringPunycodeToAscii;
var $toString = toString$K;
var setToStringTag = setToStringTag$e;
var validateArgumentsLength$4 = validateArgumentsLength$c;
var URLSearchParamsModule = web_urlSearchParams_constructor;
var InternalStateModule = internalState;
var setInternalState = InternalStateModule.set;
var getInternalURLState = InternalStateModule.getterFor("URL");
var URLSearchParams$2 = URLSearchParamsModule.URLSearchParams;
var getInternalSearchParamsState = URLSearchParamsModule.getState;
var NativeURL = globalThis$1.URL;
var TypeError$1 = globalThis$1.TypeError;
var parseInt$1 = globalThis$1.parseInt;
var floor = Math.floor;
var pow = Math.pow;
var charAt = uncurryThis$3("".charAt);
var exec = uncurryThis$3(/./.exec);
var join4 = uncurryThis$3([].join);
var numberToString = uncurryThis$3(1 .toString);
var pop = uncurryThis$3([].pop);
var push$1 = uncurryThis$3([].push);
var replace$2 = uncurryThis$3("".replace);
var shift = uncurryThis$3([].shift);
var split = uncurryThis$3("".split);
var stringSlice = uncurryThis$3("".slice);
var toLowerCase = uncurryThis$3("".toLowerCase);
var unshift2 = uncurryThis$3([].unshift);
var INVALID_AUTHORITY = "Invalid authority";
var INVALID_SCHEME = "Invalid scheme";
var INVALID_HOST = "Invalid host";
var INVALID_PORT = "Invalid port";
var ALPHA$1 = /[a-z]/i;
var ALPHANUMERIC = /[\d+-.a-z]/i;
var DIGIT$1 = /\d/;
var HEX_START = /^0x/i;
var OCT = /^[0-7]+$/;
var DEC = /^\d+$/;
var HEX = /^[\da-f]+$/i;
var FORBIDDEN_HOST_CODE_POINT = /[\0\t\n\r #%/:<>?@[\\\]^|]/;
var FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT = /[\0\t\n\r #/:<>?@[\\\]^|]/;
var LEADING_C0_CONTROL_OR_SPACE = /^[\u0000-\u0020]+/;
var TRAILING_C0_CONTROL_OR_SPACE = /(^|[^\u0000-\u0020])[\u0000-\u0020]+$/;
var TAB_AND_NEW_LINE = /[\t\n\r]/g;
var EOF;
var parseIPv4 = function(input) {
  var parts = split(input, ".");
  var partsLength, numbers, index, part, radix, number, ipv4;
  if (parts.length && parts[parts.length - 1] === "") {
    parts.length--;
  }
  partsLength = parts.length;
  if (partsLength > 4) return input;
  numbers = [];
  for (index = 0; index < partsLength; index++) {
    part = parts[index];
    if (part === "") return input;
    radix = 10;
    if (part.length > 1 && charAt(part, 0) === "0") {
      radix = exec(HEX_START, part) ? 16 : 8;
      part = stringSlice(part, radix === 8 ? 1 : 2);
    }
    if (part === "") {
      number = 0;
    } else {
      if (!exec(radix === 10 ? DEC : radix === 8 ? OCT : HEX, part)) return input;
      number = parseInt$1(part, radix);
    }
    push$1(numbers, number);
  }
  for (index = 0; index < partsLength; index++) {
    number = numbers[index];
    if (index === partsLength - 1) {
      if (number >= pow(256, 5 - partsLength)) return null;
    } else if (number > 255) return null;
  }
  ipv4 = pop(numbers);
  for (index = 0; index < numbers.length; index++) {
    ipv4 += numbers[index] * pow(256, 3 - index);
  }
  return ipv4;
};
var parseIPv6 = function(input) {
  var address = [0, 0, 0, 0, 0, 0, 0, 0];
  var pieceIndex = 0;
  var compress = null;
  var pointer = 0;
  var value, length2, numbersSeen, ipv4Piece, number, swaps, swap;
  var chr = function() {
    return charAt(input, pointer);
  };
  if (chr() === ":") {
    if (charAt(input, 1) !== ":") return;
    pointer += 2;
    pieceIndex++;
    compress = pieceIndex;
  }
  while (chr()) {
    if (pieceIndex === 8) return;
    if (chr() === ":") {
      if (compress !== null) return;
      pointer++;
      pieceIndex++;
      compress = pieceIndex;
      continue;
    }
    value = length2 = 0;
    while (length2 < 4 && exec(HEX, chr())) {
      value = value * 16 + parseInt$1(chr(), 16);
      pointer++;
      length2++;
    }
    if (chr() === ".") {
      if (length2 === 0) return;
      pointer -= length2;
      if (pieceIndex > 6) return;
      numbersSeen = 0;
      while (chr()) {
        ipv4Piece = null;
        if (numbersSeen > 0) {
          if (chr() === "." && numbersSeen < 4) pointer++;
          else return;
        }
        if (!exec(DIGIT$1, chr())) return;
        while (exec(DIGIT$1, chr())) {
          number = parseInt$1(chr(), 10);
          if (ipv4Piece === null) ipv4Piece = number;
          else if (ipv4Piece === 0) return;
          else ipv4Piece = ipv4Piece * 10 + number;
          if (ipv4Piece > 255) return;
          pointer++;
        }
        address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
        numbersSeen++;
        if (numbersSeen === 2 || numbersSeen === 4) pieceIndex++;
      }
      if (numbersSeen !== 4) return;
      break;
    } else if (chr() === ":") {
      pointer++;
      if (!chr()) return;
    } else if (chr()) return;
    address[pieceIndex++] = value;
  }
  if (compress !== null) {
    swaps = pieceIndex - compress;
    pieceIndex = 7;
    while (pieceIndex !== 0 && swaps > 0) {
      swap = address[pieceIndex];
      address[pieceIndex--] = address[compress + swaps - 1];
      address[compress + --swaps] = swap;
    }
  } else if (pieceIndex !== 8) return;
  return address;
};
var findLongestZeroSequence = function(ipv6) {
  var maxIndex = null;
  var maxLength = 1;
  var currStart = null;
  var currLength = 0;
  var index = 0;
  for (; index < 8; index++) {
    if (ipv6[index] !== 0) {
      if (currLength > maxLength) {
        maxIndex = currStart;
        maxLength = currLength;
      }
      currStart = null;
      currLength = 0;
    } else {
      if (currStart === null) currStart = index;
      ++currLength;
    }
  }
  return currLength > maxLength ? currStart : maxIndex;
};
var serializeHost = function(host) {
  var result, index, compress, ignore0;
  if (typeof host == "number") {
    result = [];
    for (index = 0; index < 4; index++) {
      unshift2(result, host % 256);
      host = floor(host / 256);
    }
    return join4(result, ".");
  }
  if (typeof host == "object") {
    result = "";
    compress = findLongestZeroSequence(host);
    for (index = 0; index < 8; index++) {
      if (ignore0 && host[index] === 0) continue;
      if (ignore0) ignore0 = false;
      if (compress === index) {
        result += index ? ":" : "::";
        ignore0 = true;
      } else {
        result += numberToString(host[index], 16);
        if (index < 7) result += ":";
      }
    }
    return "[" + result + "]";
  }
  return host;
};
var C0ControlPercentEncodeSet = {};
var fragmentPercentEncodeSet = assign$2({}, C0ControlPercentEncodeSet, {
  " ": 1,
  '"': 1,
  "<": 1,
  ">": 1,
  "`": 1
});
var pathPercentEncodeSet = assign$2({}, fragmentPercentEncodeSet, {
  "#": 1,
  "?": 1,
  "{": 1,
  "}": 1
});
var userinfoPercentEncodeSet = assign$2({}, pathPercentEncodeSet, {
  "/": 1,
  ":": 1,
  ";": 1,
  "=": 1,
  "@": 1,
  "[": 1,
  "\\": 1,
  "]": 1,
  "^": 1,
  "|": 1
});
var percentEncode = function(chr, set4) {
  var code = codeAt(chr, 0);
  return code > 32 && code < 127 && !hasOwn$1(set4, chr) ? chr : encodeURIComponent(chr);
};
var specialSchemes = {
  ftp: 21,
  file: null,
  http: 80,
  https: 443,
  ws: 80,
  wss: 443
};
var isWindowsDriveLetter = function(string, normalized) {
  var second;
  return string.length === 2 && exec(ALPHA$1, charAt(string, 0)) && ((second = charAt(string, 1)) === ":" || !normalized && second === "|");
};
var startsWithWindowsDriveLetter = function(string) {
  var third;
  return string.length > 1 && isWindowsDriveLetter(stringSlice(string, 0, 2)) && (string.length === 2 || ((third = charAt(string, 2)) === "/" || third === "\\" || third === "?" || third === "#"));
};
var isSingleDot = function(segment) {
  return segment === "." || toLowerCase(segment) === "%2e";
};
var isDoubleDot = function(segment) {
  segment = toLowerCase(segment);
  return segment === ".." || segment === "%2e." || segment === ".%2e" || segment === "%2e%2e";
};
var SCHEME_START = {};
var SCHEME = {};
var NO_SCHEME = {};
var SPECIAL_RELATIVE_OR_AUTHORITY = {};
var PATH_OR_AUTHORITY = {};
var RELATIVE = {};
var RELATIVE_SLASH = {};
var SPECIAL_AUTHORITY_SLASHES = {};
var SPECIAL_AUTHORITY_IGNORE_SLASHES = {};
var AUTHORITY = {};
var HOST = {};
var HOSTNAME = {};
var PORT = {};
var FILE = {};
var FILE_SLASH = {};
var FILE_HOST = {};
var PATH_START = {};
var PATH = {};
var CANNOT_BE_A_BASE_URL_PATH = {};
var QUERY = {};
var FRAGMENT = {};
var URLState = function(url, isBase, base2) {
  var urlString = $toString(url);
  var baseState, failure, searchParams;
  if (isBase) {
    failure = this.parse(urlString);
    if (failure) throw new TypeError$1(failure);
    this.searchParams = null;
  } else {
    if (base2 !== void 0) baseState = new URLState(base2, true);
    failure = this.parse(urlString, null, baseState);
    if (failure) throw new TypeError$1(failure);
    searchParams = getInternalSearchParamsState(new URLSearchParams$2());
    searchParams.bindURL(this);
    this.searchParams = searchParams;
  }
};
URLState.prototype = {
  type: "URL",
  // https://url.spec.whatwg.org/#url-parsing
  // eslint-disable-next-line max-statements -- TODO
  parse: function(input, stateOverride, base2) {
    var url = this;
    var state = stateOverride || SCHEME_START;
    var pointer = 0;
    var buffer2 = "";
    var seenAt = false;
    var seenBracket = false;
    var seenPasswordToken = false;
    var codePoints3, chr, bufferCodePoints, failure;
    input = $toString(input);
    if (!stateOverride) {
      url.scheme = "";
      url.username = "";
      url.password = "";
      url.host = null;
      url.port = null;
      url.path = [];
      url.query = null;
      url.fragment = null;
      url.cannotBeABaseURL = false;
      input = replace$2(input, LEADING_C0_CONTROL_OR_SPACE, "");
      input = replace$2(input, TRAILING_C0_CONTROL_OR_SPACE, "$1");
    }
    input = replace$2(input, TAB_AND_NEW_LINE, "");
    codePoints3 = arrayFrom(input);
    while (pointer <= codePoints3.length) {
      chr = codePoints3[pointer];
      switch (state) {
        case SCHEME_START:
          if (chr && exec(ALPHA$1, chr)) {
            buffer2 += toLowerCase(chr);
            state = SCHEME;
          } else if (!stateOverride) {
            state = NO_SCHEME;
            continue;
          } else return INVALID_SCHEME;
          break;
        case SCHEME:
          if (chr && (exec(ALPHANUMERIC, chr) || chr === "+" || chr === "-" || chr === ".")) {
            buffer2 += toLowerCase(chr);
          } else if (chr === ":") {
            if (stateOverride && (url.isSpecial() !== hasOwn$1(specialSchemes, buffer2) || buffer2 === "file" && (url.includesCredentials() || url.port !== null) || url.scheme === "file" && !url.host)) return;
            url.scheme = buffer2;
            if (stateOverride) {
              if (url.isSpecial() && specialSchemes[url.scheme] === url.port) url.port = null;
              return;
            }
            buffer2 = "";
            if (url.scheme === "file") {
              state = FILE;
            } else if (url.isSpecial() && base2 && base2.scheme === url.scheme) {
              state = SPECIAL_RELATIVE_OR_AUTHORITY;
            } else if (url.isSpecial()) {
              state = SPECIAL_AUTHORITY_SLASHES;
            } else if (codePoints3[pointer + 1] === "/") {
              state = PATH_OR_AUTHORITY;
              pointer++;
            } else {
              url.cannotBeABaseURL = true;
              push$1(url.path, "");
              state = CANNOT_BE_A_BASE_URL_PATH;
            }
          } else if (!stateOverride) {
            buffer2 = "";
            state = NO_SCHEME;
            pointer = 0;
            continue;
          } else return INVALID_SCHEME;
          break;
        case NO_SCHEME:
          if (!base2 || base2.cannotBeABaseURL && chr !== "#") return INVALID_SCHEME;
          if (base2.cannotBeABaseURL && chr === "#") {
            url.scheme = base2.scheme;
            url.path = arraySlice(base2.path);
            url.query = base2.query;
            url.fragment = "";
            url.cannotBeABaseURL = true;
            state = FRAGMENT;
            break;
          }
          state = base2.scheme === "file" ? FILE : RELATIVE;
          continue;
        case SPECIAL_RELATIVE_OR_AUTHORITY:
          if (chr === "/" && codePoints3[pointer + 1] === "/") {
            state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
            pointer++;
          } else {
            state = RELATIVE;
            continue;
          }
          break;
        case PATH_OR_AUTHORITY:
          if (chr === "/") {
            state = AUTHORITY;
            break;
          } else {
            state = PATH;
            continue;
          }
        case RELATIVE:
          url.scheme = base2.scheme;
          if (chr === EOF) {
            url.username = base2.username;
            url.password = base2.password;
            url.host = base2.host;
            url.port = base2.port;
            url.path = arraySlice(base2.path);
            url.query = base2.query;
          } else if (chr === "/" || chr === "\\" && url.isSpecial()) {
            state = RELATIVE_SLASH;
          } else if (chr === "?") {
            url.username = base2.username;
            url.password = base2.password;
            url.host = base2.host;
            url.port = base2.port;
            url.path = arraySlice(base2.path);
            url.query = "";
            state = QUERY;
          } else if (chr === "#") {
            url.username = base2.username;
            url.password = base2.password;
            url.host = base2.host;
            url.port = base2.port;
            url.path = arraySlice(base2.path);
            url.query = base2.query;
            url.fragment = "";
            state = FRAGMENT;
          } else {
            url.username = base2.username;
            url.password = base2.password;
            url.host = base2.host;
            url.port = base2.port;
            url.path = arraySlice(base2.path);
            url.path.length--;
            state = PATH;
            continue;
          }
          break;
        case RELATIVE_SLASH:
          if (url.isSpecial() && (chr === "/" || chr === "\\")) {
            state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
          } else if (chr === "/") {
            state = AUTHORITY;
          } else {
            url.username = base2.username;
            url.password = base2.password;
            url.host = base2.host;
            url.port = base2.port;
            state = PATH;
            continue;
          }
          break;
        case SPECIAL_AUTHORITY_SLASHES:
          state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
          if (chr !== "/" || charAt(buffer2, pointer + 1) !== "/") continue;
          pointer++;
          break;
        case SPECIAL_AUTHORITY_IGNORE_SLASHES:
          if (chr !== "/" && chr !== "\\") {
            state = AUTHORITY;
            continue;
          }
          break;
        case AUTHORITY:
          if (chr === "@") {
            if (seenAt) buffer2 = "%40" + buffer2;
            seenAt = true;
            bufferCodePoints = arrayFrom(buffer2);
            for (var i = 0; i < bufferCodePoints.length; i++) {
              var codePoint = bufferCodePoints[i];
              if (codePoint === ":" && !seenPasswordToken) {
                seenPasswordToken = true;
                continue;
              }
              var encodedCodePoints = percentEncode(codePoint, userinfoPercentEncodeSet);
              if (seenPasswordToken) url.password += encodedCodePoints;
              else url.username += encodedCodePoints;
            }
            buffer2 = "";
          } else if (chr === EOF || chr === "/" || chr === "?" || chr === "#" || chr === "\\" && url.isSpecial()) {
            if (seenAt && buffer2 === "") return INVALID_AUTHORITY;
            pointer -= arrayFrom(buffer2).length + 1;
            buffer2 = "";
            state = HOST;
          } else buffer2 += chr;
          break;
        case HOST:
        case HOSTNAME:
          if (stateOverride && url.scheme === "file") {
            state = FILE_HOST;
            continue;
          } else if (chr === ":" && !seenBracket) {
            if (buffer2 === "") return INVALID_HOST;
            failure = url.parseHost(buffer2);
            if (failure) return failure;
            buffer2 = "";
            state = PORT;
            if (stateOverride === HOSTNAME) return;
          } else if (chr === EOF || chr === "/" || chr === "?" || chr === "#" || chr === "\\" && url.isSpecial()) {
            if (url.isSpecial() && buffer2 === "") return INVALID_HOST;
            if (stateOverride && buffer2 === "" && (url.includesCredentials() || url.port !== null)) return;
            failure = url.parseHost(buffer2);
            if (failure) return failure;
            buffer2 = "";
            state = PATH_START;
            if (stateOverride) return;
            continue;
          } else {
            if (chr === "[") seenBracket = true;
            else if (chr === "]") seenBracket = false;
            buffer2 += chr;
          }
          break;
        case PORT:
          if (exec(DIGIT$1, chr)) {
            buffer2 += chr;
          } else if (chr === EOF || chr === "/" || chr === "?" || chr === "#" || chr === "\\" && url.isSpecial() || stateOverride) {
            if (buffer2 !== "") {
              var port2 = parseInt$1(buffer2, 10);
              if (port2 > 65535) return INVALID_PORT;
              url.port = url.isSpecial() && port2 === specialSchemes[url.scheme] ? null : port2;
              buffer2 = "";
            }
            if (stateOverride) return;
            state = PATH_START;
            continue;
          } else return INVALID_PORT;
          break;
        case FILE:
          url.scheme = "file";
          if (chr === "/" || chr === "\\") state = FILE_SLASH;
          else if (base2 && base2.scheme === "file") {
            switch (chr) {
              case EOF:
                url.host = base2.host;
                url.path = arraySlice(base2.path);
                url.query = base2.query;
                break;
              case "?":
                url.host = base2.host;
                url.path = arraySlice(base2.path);
                url.query = "";
                state = QUERY;
                break;
              case "#":
                url.host = base2.host;
                url.path = arraySlice(base2.path);
                url.query = base2.query;
                url.fragment = "";
                state = FRAGMENT;
                break;
              default:
                if (!startsWithWindowsDriveLetter(join4(arraySlice(codePoints3, pointer), ""))) {
                  url.host = base2.host;
                  url.path = arraySlice(base2.path);
                  url.shortenPath();
                }
                state = PATH;
                continue;
            }
          } else {
            state = PATH;
            continue;
          }
          break;
        case FILE_SLASH:
          if (chr === "/" || chr === "\\") {
            state = FILE_HOST;
            break;
          }
          if (base2 && base2.scheme === "file" && !startsWithWindowsDriveLetter(join4(arraySlice(codePoints3, pointer), ""))) {
            if (isWindowsDriveLetter(base2.path[0], true)) push$1(url.path, base2.path[0]);
            else url.host = base2.host;
          }
          state = PATH;
          continue;
        case FILE_HOST:
          if (chr === EOF || chr === "/" || chr === "\\" || chr === "?" || chr === "#") {
            if (!stateOverride && isWindowsDriveLetter(buffer2)) {
              state = PATH;
            } else if (buffer2 === "") {
              url.host = "";
              if (stateOverride) return;
              state = PATH_START;
            } else {
              failure = url.parseHost(buffer2);
              if (failure) return failure;
              if (url.host === "localhost") url.host = "";
              if (stateOverride) return;
              buffer2 = "";
              state = PATH_START;
            }
            continue;
          } else buffer2 += chr;
          break;
        case PATH_START:
          if (url.isSpecial()) {
            state = PATH;
            if (chr !== "/" && chr !== "\\") continue;
          } else if (!stateOverride && chr === "?") {
            url.query = "";
            state = QUERY;
          } else if (!stateOverride && chr === "#") {
            url.fragment = "";
            state = FRAGMENT;
          } else if (chr !== EOF) {
            state = PATH;
            if (chr !== "/") continue;
          }
          break;
        case PATH:
          if (chr === EOF || chr === "/" || chr === "\\" && url.isSpecial() || !stateOverride && (chr === "?" || chr === "#")) {
            if (isDoubleDot(buffer2)) {
              url.shortenPath();
              if (chr !== "/" && !(chr === "\\" && url.isSpecial())) {
                push$1(url.path, "");
              }
            } else if (isSingleDot(buffer2)) {
              if (chr !== "/" && !(chr === "\\" && url.isSpecial())) {
                push$1(url.path, "");
              }
            } else {
              if (url.scheme === "file" && !url.path.length && isWindowsDriveLetter(buffer2)) {
                if (url.host) url.host = "";
                buffer2 = charAt(buffer2, 0) + ":";
              }
              push$1(url.path, buffer2);
            }
            buffer2 = "";
            if (url.scheme === "file" && (chr === EOF || chr === "?" || chr === "#")) {
              while (url.path.length > 1 && url.path[0] === "") {
                shift(url.path);
              }
            }
            if (chr === "?") {
              url.query = "";
              state = QUERY;
            } else if (chr === "#") {
              url.fragment = "";
              state = FRAGMENT;
            }
          } else {
            buffer2 += percentEncode(chr, pathPercentEncodeSet);
          }
          break;
        case CANNOT_BE_A_BASE_URL_PATH:
          if (chr === "?") {
            url.query = "";
            state = QUERY;
          } else if (chr === "#") {
            url.fragment = "";
            state = FRAGMENT;
          } else if (chr !== EOF) {
            url.path[0] += percentEncode(chr, C0ControlPercentEncodeSet);
          }
          break;
        case QUERY:
          if (!stateOverride && chr === "#") {
            url.fragment = "";
            state = FRAGMENT;
          } else if (chr !== EOF) {
            if (chr === "'" && url.isSpecial()) url.query += "%27";
            else if (chr === "#") url.query += "%23";
            else url.query += percentEncode(chr, C0ControlPercentEncodeSet);
          }
          break;
        case FRAGMENT:
          if (chr !== EOF) url.fragment += percentEncode(chr, fragmentPercentEncodeSet);
          break;
      }
      pointer++;
    }
  },
  // https://url.spec.whatwg.org/#host-parsing
  parseHost: function(input) {
    var result, codePoints3, index;
    if (charAt(input, 0) === "[") {
      if (charAt(input, input.length - 1) !== "]") return INVALID_HOST;
      result = parseIPv6(stringSlice(input, 1, -1));
      if (!result) return INVALID_HOST;
      this.host = result;
    } else if (!this.isSpecial()) {
      if (exec(FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT, input)) return INVALID_HOST;
      result = "";
      codePoints3 = arrayFrom(input);
      for (index = 0; index < codePoints3.length; index++) {
        result += percentEncode(codePoints3[index], C0ControlPercentEncodeSet);
      }
      this.host = result;
    } else {
      input = toASCII(input);
      if (exec(FORBIDDEN_HOST_CODE_POINT, input)) return INVALID_HOST;
      result = parseIPv4(input);
      if (result === null) return INVALID_HOST;
      this.host = result;
    }
  },
  // https://url.spec.whatwg.org/#cannot-have-a-username-password-port
  cannotHaveUsernamePasswordPort: function() {
    return !this.host || this.cannotBeABaseURL || this.scheme === "file";
  },
  // https://url.spec.whatwg.org/#include-credentials
  includesCredentials: function() {
    return this.username !== "" || this.password !== "";
  },
  // https://url.spec.whatwg.org/#is-special
  isSpecial: function() {
    return hasOwn$1(specialSchemes, this.scheme);
  },
  // https://url.spec.whatwg.org/#shorten-a-urls-path
  shortenPath: function() {
    var path2 = this.path;
    var pathSize = path2.length;
    if (pathSize && (this.scheme !== "file" || pathSize !== 1 || !isWindowsDriveLetter(path2[0], true))) {
      path2.length--;
    }
  },
  // https://url.spec.whatwg.org/#concept-url-serializer
  serialize: function() {
    var url = this;
    var scheme = url.scheme;
    var username = url.username;
    var password = url.password;
    var host = url.host;
    var port2 = url.port;
    var path2 = url.path;
    var query = url.query;
    var fragment = url.fragment;
    var output = scheme + ":";
    if (host !== null) {
      output += "//";
      if (url.includesCredentials()) {
        output += username + (password ? ":" + password : "") + "@";
      }
      output += serializeHost(host);
      if (port2 !== null) output += ":" + port2;
    } else if (scheme === "file") output += "//";
    output += url.cannotBeABaseURL ? path2[0] : path2.length ? "/" + join4(path2, "/") : "";
    if (query !== null) output += "?" + query;
    if (fragment !== null) output += "#" + fragment;
    return output;
  },
  // https://url.spec.whatwg.org/#dom-url-href
  setHref: function(href) {
    var failure = this.parse(href);
    if (failure) throw new TypeError$1(failure);
    this.searchParams.update();
  },
  // https://url.spec.whatwg.org/#dom-url-origin
  getOrigin: function() {
    var scheme = this.scheme;
    var port2 = this.port;
    if (scheme === "blob") try {
      return new URLConstructor(scheme.path[0]).origin;
    } catch (error2) {
      return "null";
    }
    if (scheme === "file" || !this.isSpecial()) return "null";
    return scheme + "://" + serializeHost(this.host) + (port2 !== null ? ":" + port2 : "");
  },
  // https://url.spec.whatwg.org/#dom-url-protocol
  getProtocol: function() {
    return this.scheme + ":";
  },
  setProtocol: function(protocol) {
    this.parse($toString(protocol) + ":", SCHEME_START);
  },
  // https://url.spec.whatwg.org/#dom-url-username
  getUsername: function() {
    return this.username;
  },
  setUsername: function(username) {
    var codePoints3 = arrayFrom($toString(username));
    if (this.cannotHaveUsernamePasswordPort()) return;
    this.username = "";
    for (var i = 0; i < codePoints3.length; i++) {
      this.username += percentEncode(codePoints3[i], userinfoPercentEncodeSet);
    }
  },
  // https://url.spec.whatwg.org/#dom-url-password
  getPassword: function() {
    return this.password;
  },
  setPassword: function(password) {
    var codePoints3 = arrayFrom($toString(password));
    if (this.cannotHaveUsernamePasswordPort()) return;
    this.password = "";
    for (var i = 0; i < codePoints3.length; i++) {
      this.password += percentEncode(codePoints3[i], userinfoPercentEncodeSet);
    }
  },
  // https://url.spec.whatwg.org/#dom-url-host
  getHost: function() {
    var host = this.host;
    var port2 = this.port;
    return host === null ? "" : port2 === null ? serializeHost(host) : serializeHost(host) + ":" + port2;
  },
  setHost: function(host) {
    if (this.cannotBeABaseURL) return;
    this.parse(host, HOST);
  },
  // https://url.spec.whatwg.org/#dom-url-hostname
  getHostname: function() {
    var host = this.host;
    return host === null ? "" : serializeHost(host);
  },
  setHostname: function(hostname) {
    if (this.cannotBeABaseURL) return;
    this.parse(hostname, HOSTNAME);
  },
  // https://url.spec.whatwg.org/#dom-url-port
  getPort: function() {
    var port2 = this.port;
    return port2 === null ? "" : $toString(port2);
  },
  setPort: function(port2) {
    if (this.cannotHaveUsernamePasswordPort()) return;
    port2 = $toString(port2);
    if (port2 === "") this.port = null;
    else this.parse(port2, PORT);
  },
  // https://url.spec.whatwg.org/#dom-url-pathname
  getPathname: function() {
    var path2 = this.path;
    return this.cannotBeABaseURL ? path2[0] : path2.length ? "/" + join4(path2, "/") : "";
  },
  setPathname: function(pathname) {
    if (this.cannotBeABaseURL) return;
    this.path = [];
    this.parse(pathname, PATH_START);
  },
  // https://url.spec.whatwg.org/#dom-url-search
  getSearch: function() {
    var query = this.query;
    return query ? "?" + query : "";
  },
  setSearch: function(search) {
    search = $toString(search);
    if (search === "") {
      this.query = null;
    } else {
      if (charAt(search, 0) === "?") search = stringSlice(search, 1);
      this.query = "";
      this.parse(search, QUERY);
    }
    this.searchParams.update();
  },
  // https://url.spec.whatwg.org/#dom-url-searchparams
  getSearchParams: function() {
    return this.searchParams.facade;
  },
  // https://url.spec.whatwg.org/#dom-url-hash
  getHash: function() {
    var fragment = this.fragment;
    return fragment ? "#" + fragment : "";
  },
  setHash: function(hash2) {
    hash2 = $toString(hash2);
    if (hash2 === "") {
      this.fragment = null;
      return;
    }
    if (charAt(hash2, 0) === "#") hash2 = stringSlice(hash2, 1);
    this.fragment = "";
    this.parse(hash2, FRAGMENT);
  },
  update: function() {
    this.query = this.searchParams.serialize() || null;
  }
};
var URLConstructor = function URL2(url) {
  var that = anInstance(this, URLPrototype);
  var base2 = validateArgumentsLength$4(arguments.length, 1) > 1 ? arguments[1] : void 0;
  var state = setInternalState(that, new URLState(url, false, base2));
  if (!DESCRIPTORS$1) {
    that.href = state.serialize();
    that.origin = state.getOrigin();
    that.protocol = state.getProtocol();
    that.username = state.getUsername();
    that.password = state.getPassword();
    that.host = state.getHost();
    that.hostname = state.getHostname();
    that.port = state.getPort();
    that.pathname = state.getPathname();
    that.search = state.getSearch();
    that.searchParams = state.getSearchParams();
    that.hash = state.getHash();
  }
};
var URLPrototype = URLConstructor.prototype;
var accessorDescriptor = function(getter, setter) {
  return {
    get: function() {
      return getInternalURLState(this)[getter]();
    },
    set: setter && function(value) {
      return getInternalURLState(this)[setter](value);
    },
    configurable: true,
    enumerable: true
  };
};
if (DESCRIPTORS$1) {
  defineBuiltInAccessor$1(URLPrototype, "href", accessorDescriptor("serialize", "setHref"));
  defineBuiltInAccessor$1(URLPrototype, "origin", accessorDescriptor("getOrigin"));
  defineBuiltInAccessor$1(URLPrototype, "protocol", accessorDescriptor("getProtocol", "setProtocol"));
  defineBuiltInAccessor$1(URLPrototype, "username", accessorDescriptor("getUsername", "setUsername"));
  defineBuiltInAccessor$1(URLPrototype, "password", accessorDescriptor("getPassword", "setPassword"));
  defineBuiltInAccessor$1(URLPrototype, "host", accessorDescriptor("getHost", "setHost"));
  defineBuiltInAccessor$1(URLPrototype, "hostname", accessorDescriptor("getHostname", "setHostname"));
  defineBuiltInAccessor$1(URLPrototype, "port", accessorDescriptor("getPort", "setPort"));
  defineBuiltInAccessor$1(URLPrototype, "pathname", accessorDescriptor("getPathname", "setPathname"));
  defineBuiltInAccessor$1(URLPrototype, "search", accessorDescriptor("getSearch", "setSearch"));
  defineBuiltInAccessor$1(URLPrototype, "searchParams", accessorDescriptor("getSearchParams"));
  defineBuiltInAccessor$1(URLPrototype, "hash", accessorDescriptor("getHash", "setHash"));
}
defineBuiltIn$2(URLPrototype, "toJSON", function toJSON2() {
  return getInternalURLState(this).serialize();
}, { enumerable: true });
defineBuiltIn$2(URLPrototype, "toString", function toString5() {
  return getInternalURLState(this).serialize();
}, { enumerable: true });
if (NativeURL) {
  var nativeCreateObjectURL = NativeURL.createObjectURL;
  var nativeRevokeObjectURL = NativeURL.revokeObjectURL;
  if (nativeCreateObjectURL) defineBuiltIn$2(URLConstructor, "createObjectURL", bind$1(nativeCreateObjectURL, NativeURL));
  if (nativeRevokeObjectURL) defineBuiltIn$2(URLConstructor, "revokeObjectURL", bind$1(nativeRevokeObjectURL, NativeURL));
}
setToStringTag(URLConstructor, "URL");
$$3({ global: true, constructor: true, forced: !USE_NATIVE_URL$2, sham: !DESCRIPTORS$1 }, {
  URL: URLConstructor
});
var $$2 = _export;
var getBuiltIn$1 = getBuiltIn$O;
var fails = fails$1z;
var validateArgumentsLength$3 = validateArgumentsLength$c;
var toString$4 = toString$K;
var USE_NATIVE_URL$1 = urlConstructorDetection;
var URL$2 = getBuiltIn$1("URL");
var THROWS_WITHOUT_ARGUMENTS = USE_NATIVE_URL$1 && fails(function() {
  URL$2.canParse();
});
var WRONG_ARITY = fails(function() {
  return URL$2.canParse.length !== 1;
});
$$2({ target: "URL", stat: true, forced: !THROWS_WITHOUT_ARGUMENTS || WRONG_ARITY }, {
  canParse: function canParse(url) {
    var length2 = validateArgumentsLength$3(arguments.length, 1);
    var urlString = toString$4(url);
    var base2 = length2 < 2 || arguments[1] === void 0 ? void 0 : toString$4(arguments[1]);
    try {
      return !!new URL$2(urlString, base2);
    } catch (error2) {
      return false;
    }
  }
});
var $$1 = _export;
var getBuiltIn = getBuiltIn$O;
var validateArgumentsLength$2 = validateArgumentsLength$c;
var toString$3 = toString$K;
var USE_NATIVE_URL = urlConstructorDetection;
var URL$1 = getBuiltIn("URL");
$$1({ target: "URL", stat: true, forced: !USE_NATIVE_URL }, {
  parse: function parse2(url) {
    var length2 = validateArgumentsLength$2(arguments.length, 1);
    var urlString = toString$3(url);
    var base2 = length2 < 2 || arguments[1] === void 0 ? void 0 : toString$3(arguments[1]);
    try {
      return new URL$1(urlString, base2);
    } catch (error2) {
      return null;
    }
  }
});
var $ = _export;
var call = functionCall;
$({ target: "URL", proto: true, enumerable: true }, {
  toJSON: function toJSON3() {
    return call(URL.prototype.toString, this);
  }
});
var defineBuiltIn$1 = defineBuiltIn$u;
var uncurryThis$2 = functionUncurryThis;
var toString$2 = toString$K;
var validateArgumentsLength$1 = validateArgumentsLength$c;
var $URLSearchParams$1 = URLSearchParams;
var URLSearchParamsPrototype$2 = $URLSearchParams$1.prototype;
var append$2 = uncurryThis$2(URLSearchParamsPrototype$2.append);
var $delete = uncurryThis$2(URLSearchParamsPrototype$2["delete"]);
var forEach$2 = uncurryThis$2(URLSearchParamsPrototype$2.forEach);
var push2 = uncurryThis$2([].push);
var params$1 = new $URLSearchParams$1("a=1&a=2&b=3");
params$1["delete"]("a", 1);
params$1["delete"]("b", void 0);
if (params$1 + "" !== "a=2") {
  defineBuiltIn$1(URLSearchParamsPrototype$2, "delete", function(name) {
    var length2 = arguments.length;
    var $value = length2 < 2 ? void 0 : arguments[1];
    if (length2 && $value === void 0) return $delete(this, name);
    var entries5 = [];
    forEach$2(this, function(v2, k2) {
      push2(entries5, { key: k2, value: v2 });
    });
    validateArgumentsLength$1(length2, 1);
    var key = toString$2(name);
    var value = toString$2($value);
    var index = 0;
    var dindex = 0;
    var found = false;
    var entriesLength = entries5.length;
    var entry;
    while (index < entriesLength) {
      entry = entries5[index++];
      if (found || entry.key === key) {
        found = true;
        $delete(this, entry.key);
      } else dindex++;
    }
    while (dindex < entriesLength) {
      entry = entries5[dindex++];
      if (!(entry.key === key && entry.value === value)) append$2(this, entry.key, entry.value);
    }
  }, { enumerable: true, unsafe: true });
}
var defineBuiltIn = defineBuiltIn$u;
var uncurryThis$1 = functionUncurryThis;
var toString$1 = toString$K;
var validateArgumentsLength = validateArgumentsLength$c;
var $URLSearchParams = URLSearchParams;
var URLSearchParamsPrototype$1 = $URLSearchParams.prototype;
var getAll2 = uncurryThis$1(URLSearchParamsPrototype$1.getAll);
var $has = uncurryThis$1(URLSearchParamsPrototype$1.has);
var params = new $URLSearchParams("a=1");
if (params.has("a", 2) || !params.has("a", void 0)) {
  defineBuiltIn(URLSearchParamsPrototype$1, "has", function has4(name) {
    var length2 = arguments.length;
    var $value = length2 < 2 ? void 0 : arguments[1];
    if (length2 && $value === void 0) return $has(this, name);
    var values5 = getAll2(this, name);
    validateArgumentsLength(length2, 1);
    var value = toString$1($value);
    var index = 0;
    while (index < values5.length) {
      if (values5[index++] === value) return true;
    }
    return false;
  }, { enumerable: true, unsafe: true });
}
var DESCRIPTORS = descriptors$1;
var uncurryThis = functionUncurryThis;
var defineBuiltInAccessor = defineBuiltInAccessor$p;
var URLSearchParamsPrototype = URLSearchParams.prototype;
var forEach$1 = uncurryThis(URLSearchParamsPrototype.forEach);
if (DESCRIPTORS && !("size" in URLSearchParamsPrototype)) {
  defineBuiltInAccessor(URLSearchParamsPrototype, "size", {
    get: function size3() {
      var count = 0;
      forEach$1(this, function() {
        count++;
      });
      return count;
    },
    configurable: true,
    enumerable: true
  });
}
const scriptRel = "modulepreload";
const assetsURL = function(dep, importerUrl) {
  return new URL(dep, importerUrl).href;
};
const seen = {};
const __vitePreload = function preload(baseModule, deps, importerUrl) {
  let promise2 = Promise.resolve();
  if (deps && deps.length > 0) {
    const links = document.getElementsByTagName("link");
    const cspNonceMeta = document.querySelector(
      "meta[property=csp-nonce]"
    );
    const cspNonce = (cspNonceMeta == null ? void 0 : cspNonceMeta.nonce) || (cspNonceMeta == null ? void 0 : cspNonceMeta.getAttribute("nonce"));
    promise2 = Promise.allSettled(
      deps.map((dep) => {
        dep = assetsURL(dep, importerUrl);
        if (dep in seen) return;
        seen[dep] = true;
        const isCss = dep.endsWith(".css");
        const cssSelector = isCss ? '[rel="stylesheet"]' : "";
        const isBaseRelative = !!importerUrl;
        if (isBaseRelative) {
          for (let i = links.length - 1; i >= 0; i--) {
            const link22 = links[i];
            if (link22.href === dep && (!isCss || link22.rel === "stylesheet")) {
              return;
            }
          }
        } else if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
          return;
        }
        const link2 = document.createElement("link");
        link2.rel = isCss ? "stylesheet" : scriptRel;
        if (!isCss) {
          link2.as = "script";
        }
        link2.crossOrigin = "";
        link2.href = dep;
        if (cspNonce) {
          link2.setAttribute("nonce", cspNonce);
        }
        document.head.appendChild(link2);
        if (isCss) {
          return new Promise((res, rej) => {
            link2.addEventListener("load", res);
            link2.addEventListener(
              "error",
              () => rej(new Error(`Unable to preload CSS for ${dep}`))
            );
          });
        }
      })
    );
  }
  function handlePreloadError(err) {
    const e2 = new Event("vite:preloadError", {
      cancelable: true
    });
    e2.payload = err;
    window.dispatchEvent(e2);
    if (!e2.defaultPrevented) {
      throw err;
    }
  }
  return promise2.then((res) => {
    for (const item of res || []) {
      if (item.status !== "rejected") continue;
      handlePreloadError(item.reason);
    }
    return baseModule().catch(handlePreloadError);
  });
};
/**
 * @remix-run/router v1.21.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends$4() {
  _extends$4 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$4.apply(this, arguments);
}
var Action;
(function(Action2) {
  Action2["Pop"] = "POP";
  Action2["Push"] = "PUSH";
  Action2["Replace"] = "REPLACE";
})(Action || (Action = {}));
const PopStateEventType = "popstate";
function createHashHistory(options) {
  if (options === void 0) {
    options = {};
  }
  function createHashLocation(window2, globalHistory) {
    let {
      pathname = "/",
      search = "",
      hash: hash2 = ""
    } = parsePath(window2.location.hash.substr(1));
    if (!pathname.startsWith("/") && !pathname.startsWith(".")) {
      pathname = "/" + pathname;
    }
    return createLocation(
      "",
      {
        pathname,
        search,
        hash: hash2
      },
      // state defaults to `null` because `window.history.state` does
      globalHistory.state && globalHistory.state.usr || null,
      globalHistory.state && globalHistory.state.key || "default"
    );
  }
  function createHashHref(window2, to) {
    let base2 = window2.document.querySelector("base");
    let href = "";
    if (base2 && base2.getAttribute("href")) {
      let url = window2.location.href;
      let hashIndex = url.indexOf("#");
      href = hashIndex === -1 ? url : url.slice(0, hashIndex);
    }
    return href + "#" + (typeof to === "string" ? to : createPath(to));
  }
  function validateHashLocation(location, to) {
    warning(location.pathname.charAt(0) === "/", "relative pathnames are not supported in hash history.push(" + JSON.stringify(to) + ")");
  }
  return getUrlBasedHistory(createHashLocation, createHashHref, validateHashLocation, options);
}
function invariant(value, message) {
  if (value === false || value === null || typeof value === "undefined") {
    throw new Error(message);
  }
}
function warning(cond, message) {
  if (!cond) {
    if (typeof console !== "undefined") console.warn(message);
    try {
      throw new Error(message);
    } catch (e2) {
    }
  }
}
function createKey() {
  return Math.random().toString(36).substr(2, 8);
}
function getHistoryState(location, index) {
  return {
    usr: location.state,
    key: location.key,
    idx: index
  };
}
function createLocation(current, to, state, key) {
  if (state === void 0) {
    state = null;
  }
  let location = _extends$4({
    pathname: typeof current === "string" ? current : current.pathname,
    search: "",
    hash: ""
  }, typeof to === "string" ? parsePath(to) : to, {
    state,
    // TODO: This could be cleaned up.  push/replace should probably just take
    // full Locations now and avoid the need to run through this flow at all
    // But that's a pretty big refactor to the current test suite so going to
    // keep as is for the time being and just let any incoming keys take precedence
    key: to && to.key || key || createKey()
  });
  return location;
}
function createPath(_ref) {
  let {
    pathname = "/",
    search = "",
    hash: hash2 = ""
  } = _ref;
  if (search && search !== "?") pathname += search.charAt(0) === "?" ? search : "?" + search;
  if (hash2 && hash2 !== "#") pathname += hash2.charAt(0) === "#" ? hash2 : "#" + hash2;
  return pathname;
}
function parsePath(path2) {
  let parsedPath = {};
  if (path2) {
    let hashIndex = path2.indexOf("#");
    if (hashIndex >= 0) {
      parsedPath.hash = path2.substr(hashIndex);
      path2 = path2.substr(0, hashIndex);
    }
    let searchIndex = path2.indexOf("?");
    if (searchIndex >= 0) {
      parsedPath.search = path2.substr(searchIndex);
      path2 = path2.substr(0, searchIndex);
    }
    if (path2) {
      parsedPath.pathname = path2;
    }
  }
  return parsedPath;
}
function getUrlBasedHistory(getLocation, createHref, validateLocation, options) {
  if (options === void 0) {
    options = {};
  }
  let {
    window: window2 = document.defaultView,
    v5Compat = false
  } = options;
  let globalHistory = window2.history;
  let action = Action.Pop;
  let listener = null;
  let index = getIndex();
  if (index == null) {
    index = 0;
    globalHistory.replaceState(_extends$4({}, globalHistory.state, {
      idx: index
    }), "");
  }
  function getIndex() {
    let state = globalHistory.state || {
      idx: null
    };
    return state.idx;
  }
  function handlePop() {
    action = Action.Pop;
    let nextIndex = getIndex();
    let delta = nextIndex == null ? null : nextIndex - index;
    index = nextIndex;
    if (listener) {
      listener({
        action,
        location: history.location,
        delta
      });
    }
  }
  function push3(to, state) {
    action = Action.Push;
    let location = createLocation(history.location, to, state);
    validateLocation(location, to);
    index = getIndex() + 1;
    let historyState = getHistoryState(location, index);
    let url = history.createHref(location);
    try {
      globalHistory.pushState(historyState, "", url);
    } catch (error2) {
      if (error2 instanceof DOMException && error2.name === "DataCloneError") {
        throw error2;
      }
      window2.location.assign(url);
    }
    if (v5Compat && listener) {
      listener({
        action,
        location: history.location,
        delta: 1
      });
    }
  }
  function replace2(to, state) {
    action = Action.Replace;
    let location = createLocation(history.location, to, state);
    validateLocation(location, to);
    index = getIndex();
    let historyState = getHistoryState(location, index);
    let url = history.createHref(location);
    globalHistory.replaceState(historyState, "", url);
    if (v5Compat && listener) {
      listener({
        action,
        location: history.location,
        delta: 0
      });
    }
  }
  function createURL(to) {
    let base2 = window2.location.origin !== "null" ? window2.location.origin : window2.location.href;
    let href = typeof to === "string" ? to : createPath(to);
    href = href.replace(/ $/, "%20");
    invariant(base2, "No window.location.(origin|href) available to create URL for href: " + href);
    return new URL(href, base2);
  }
  let history = {
    get action() {
      return action;
    },
    get location() {
      return getLocation(window2, globalHistory);
    },
    listen(fn) {
      if (listener) {
        throw new Error("A history only accepts one active listener");
      }
      window2.addEventListener(PopStateEventType, handlePop);
      listener = fn;
      return () => {
        window2.removeEventListener(PopStateEventType, handlePop);
        listener = null;
      };
    },
    createHref(to) {
      return createHref(window2, to);
    },
    createURL,
    encodeLocation(to) {
      let url = createURL(to);
      return {
        pathname: url.pathname,
        search: url.search,
        hash: url.hash
      };
    },
    push: push3,
    replace: replace2,
    go(n2) {
      return globalHistory.go(n2);
    }
  };
  return history;
}
var ResultType;
(function(ResultType2) {
  ResultType2["data"] = "data";
  ResultType2["deferred"] = "deferred";
  ResultType2["redirect"] = "redirect";
  ResultType2["error"] = "error";
})(ResultType || (ResultType = {}));
function matchRoutes(routes, locationArg, basename) {
  if (basename === void 0) {
    basename = "/";
  }
  return matchRoutesImpl(routes, locationArg, basename);
}
function matchRoutesImpl(routes, locationArg, basename, allowPartial) {
  let location = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
  let pathname = stripBasename(location.pathname || "/", basename);
  if (pathname == null) {
    return null;
  }
  let branches = flattenRoutes(routes);
  rankRouteBranches(branches);
  let matches = null;
  for (let i = 0; matches == null && i < branches.length; ++i) {
    let decoded = decodePath(pathname);
    matches = matchRouteBranch(branches[i], decoded);
  }
  return matches;
}
function flattenRoutes(routes, branches, parentsMeta, parentPath) {
  if (branches === void 0) {
    branches = [];
  }
  if (parentsMeta === void 0) {
    parentsMeta = [];
  }
  if (parentPath === void 0) {
    parentPath = "";
  }
  let flattenRoute = (route, index, relativePath) => {
    let meta2 = {
      relativePath: relativePath === void 0 ? route.path || "" : relativePath,
      caseSensitive: route.caseSensitive === true,
      childrenIndex: index,
      route
    };
    if (meta2.relativePath.startsWith("/")) {
      invariant(meta2.relativePath.startsWith(parentPath), 'Absolute route path "' + meta2.relativePath + '" nested under path ' + ('"' + parentPath + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes.");
      meta2.relativePath = meta2.relativePath.slice(parentPath.length);
    }
    let path2 = joinPaths([parentPath, meta2.relativePath]);
    let routesMeta = parentsMeta.concat(meta2);
    if (route.children && route.children.length > 0) {
      invariant(
        // Our types know better, but runtime JS may not!
        // @ts-expect-error
        route.index !== true,
        "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + path2 + '".')
      );
      flattenRoutes(route.children, branches, routesMeta, path2);
    }
    if (route.path == null && !route.index) {
      return;
    }
    branches.push({
      path: path2,
      score: computeScore(path2, route.index),
      routesMeta
    });
  };
  routes.forEach((route, index) => {
    var _route$path;
    if (route.path === "" || !((_route$path = route.path) != null && _route$path.includes("?"))) {
      flattenRoute(route, index);
    } else {
      for (let exploded of explodeOptionalSegments(route.path)) {
        flattenRoute(route, index, exploded);
      }
    }
  });
  return branches;
}
function explodeOptionalSegments(path2) {
  let segments = path2.split("/");
  if (segments.length === 0) return [];
  let [first, ...rest] = segments;
  let isOptional = first.endsWith("?");
  let required = first.replace(/\?$/, "");
  if (rest.length === 0) {
    return isOptional ? [required, ""] : [required];
  }
  let restExploded = explodeOptionalSegments(rest.join("/"));
  let result = [];
  result.push(...restExploded.map((subpath) => subpath === "" ? required : [required, subpath].join("/")));
  if (isOptional) {
    result.push(...restExploded);
  }
  return result.map((exploded) => path2.startsWith("/") && exploded === "" ? "/" : exploded);
}
function rankRouteBranches(branches) {
  branches.sort((a, b2) => a.score !== b2.score ? b2.score - a.score : compareIndexes(a.routesMeta.map((meta2) => meta2.childrenIndex), b2.routesMeta.map((meta2) => meta2.childrenIndex)));
}
const paramRe = /^:[\w-]+$/;
const dynamicSegmentValue = 3;
const indexRouteValue = 2;
const emptySegmentValue = 1;
const staticSegmentValue = 10;
const splatPenalty = -2;
const isSplat = (s) => s === "*";
function computeScore(path2, index) {
  let segments = path2.split("/");
  let initialScore = segments.length;
  if (segments.some(isSplat)) {
    initialScore += splatPenalty;
  }
  if (index) {
    initialScore += indexRouteValue;
  }
  return segments.filter((s) => !isSplat(s)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue), initialScore);
}
function compareIndexes(a, b2) {
  let siblings = a.length === b2.length && a.slice(0, -1).every((n2, i) => n2 === b2[i]);
  return siblings ? (
    // If two routes are siblings, we should try to match the earlier sibling
    // first. This allows people to have fine-grained control over the matching
    // behavior by simply putting routes with identical paths in the order they
    // want them tried.
    a[a.length - 1] - b2[b2.length - 1]
  ) : (
    // Otherwise, it doesn't really make sense to rank non-siblings by index,
    // so they sort equally.
    0
  );
}
function matchRouteBranch(branch, pathname, allowPartial) {
  let {
    routesMeta
  } = branch;
  let matchedParams = {};
  let matchedPathname = "/";
  let matches = [];
  for (let i = 0; i < routesMeta.length; ++i) {
    let meta2 = routesMeta[i];
    let end = i === routesMeta.length - 1;
    let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
    let match2 = matchPath({
      path: meta2.relativePath,
      caseSensitive: meta2.caseSensitive,
      end
    }, remainingPathname);
    let route = meta2.route;
    if (!match2) {
      return null;
    }
    Object.assign(matchedParams, match2.params);
    matches.push({
      // TODO: Can this as be avoided?
      params: matchedParams,
      pathname: joinPaths([matchedPathname, match2.pathname]),
      pathnameBase: normalizePathname(joinPaths([matchedPathname, match2.pathnameBase])),
      route
    });
    if (match2.pathnameBase !== "/") {
      matchedPathname = joinPaths([matchedPathname, match2.pathnameBase]);
    }
  }
  return matches;
}
function matchPath(pattern, pathname) {
  if (typeof pattern === "string") {
    pattern = {
      path: pattern,
      caseSensitive: false,
      end: true
    };
  }
  let [matcher, compiledParams] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);
  let match2 = pathname.match(matcher);
  if (!match2) return null;
  let matchedPathname = match2[0];
  let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
  let captureGroups = match2.slice(1);
  let params2 = compiledParams.reduce((memo, _ref, index) => {
    let {
      paramName,
      isOptional
    } = _ref;
    if (paramName === "*") {
      let splatValue = captureGroups[index] || "";
      pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
    }
    const value = captureGroups[index];
    if (isOptional && !value) {
      memo[paramName] = void 0;
    } else {
      memo[paramName] = (value || "").replace(/%2F/g, "/");
    }
    return memo;
  }, {});
  return {
    params: params2,
    pathname: matchedPathname,
    pathnameBase,
    pattern
  };
}
function compilePath(path2, caseSensitive, end) {
  if (caseSensitive === void 0) {
    caseSensitive = false;
  }
  if (end === void 0) {
    end = true;
  }
  warning(path2 === "*" || !path2.endsWith("*") || path2.endsWith("/*"), 'Route path "' + path2 + '" will be treated as if it were ' + ('"' + path2.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + path2.replace(/\*$/, "/*") + '".'));
  let params2 = [];
  let regexpSource = "^" + path2.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, (_, paramName, isOptional) => {
    params2.push({
      paramName,
      isOptional: isOptional != null
    });
    return isOptional ? "/?([^\\/]+)?" : "/([^\\/]+)";
  });
  if (path2.endsWith("*")) {
    params2.push({
      paramName: "*"
    });
    regexpSource += path2 === "*" || path2 === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$";
  } else if (end) {
    regexpSource += "\\/*$";
  } else if (path2 !== "" && path2 !== "/") {
    regexpSource += "(?:(?=\\/|$))";
  } else ;
  let matcher = new RegExp(regexpSource, caseSensitive ? void 0 : "i");
  return [matcher, params2];
}
function decodePath(value) {
  try {
    return value.split("/").map((v2) => decodeURIComponent(v2).replace(/\//g, "%2F")).join("/");
  } catch (error2) {
    warning(false, 'The URL path "' + value + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + error2 + ")."));
    return value;
  }
}
function stripBasename(pathname, basename) {
  if (basename === "/") return pathname;
  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
    return null;
  }
  let startIndex = basename.endsWith("/") ? basename.length - 1 : basename.length;
  let nextChar = pathname.charAt(startIndex);
  if (nextChar && nextChar !== "/") {
    return null;
  }
  return pathname.slice(startIndex) || "/";
}
function resolvePath(to, fromPathname) {
  if (fromPathname === void 0) {
    fromPathname = "/";
  }
  let {
    pathname: toPathname,
    search = "",
    hash: hash2 = ""
  } = typeof to === "string" ? parsePath(to) : to;
  let pathname = toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;
  return {
    pathname,
    search: normalizeSearch(search),
    hash: normalizeHash(hash2)
  };
}
function resolvePathname(relativePath, fromPathname) {
  let segments = fromPathname.replace(/\/+$/, "").split("/");
  let relativeSegments = relativePath.split("/");
  relativeSegments.forEach((segment) => {
    if (segment === "..") {
      if (segments.length > 1) segments.pop();
    } else if (segment !== ".") {
      segments.push(segment);
    }
  });
  return segments.length > 1 ? segments.join("/") : "/";
}
function getInvalidPathError(char2, field, dest, path2) {
  return "Cannot include a '" + char2 + "' character in a manually specified " + ("`to." + field + "` field [" + JSON.stringify(path2) + "].  Please separate it out to the ") + ("`to." + dest + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.';
}
function getPathContributingMatches(matches) {
  return matches.filter((match2, index) => index === 0 || match2.route.path && match2.route.path.length > 0);
}
function getResolveToMatches(matches, v7_relativeSplatPath) {
  let pathMatches = getPathContributingMatches(matches);
  if (v7_relativeSplatPath) {
    return pathMatches.map((match2, idx) => idx === pathMatches.length - 1 ? match2.pathname : match2.pathnameBase);
  }
  return pathMatches.map((match2) => match2.pathnameBase);
}
function resolveTo(toArg, routePathnames, locationPathname, isPathRelative) {
  if (isPathRelative === void 0) {
    isPathRelative = false;
  }
  let to;
  if (typeof toArg === "string") {
    to = parsePath(toArg);
  } else {
    to = _extends$4({}, toArg);
    invariant(!to.pathname || !to.pathname.includes("?"), getInvalidPathError("?", "pathname", "search", to));
    invariant(!to.pathname || !to.pathname.includes("#"), getInvalidPathError("#", "pathname", "hash", to));
    invariant(!to.search || !to.search.includes("#"), getInvalidPathError("#", "search", "hash", to));
  }
  let isEmptyPath = toArg === "" || to.pathname === "";
  let toPathname = isEmptyPath ? "/" : to.pathname;
  let from7;
  if (toPathname == null) {
    from7 = locationPathname;
  } else {
    let routePathnameIndex = routePathnames.length - 1;
    if (!isPathRelative && toPathname.startsWith("..")) {
      let toSegments = toPathname.split("/");
      while (toSegments[0] === "..") {
        toSegments.shift();
        routePathnameIndex -= 1;
      }
      to.pathname = toSegments.join("/");
    }
    from7 = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
  }
  let path2 = resolvePath(to, from7);
  let hasExplicitTrailingSlash = toPathname && toPathname !== "/" && toPathname.endsWith("/");
  let hasCurrentTrailingSlash = (isEmptyPath || toPathname === ".") && locationPathname.endsWith("/");
  if (!path2.pathname.endsWith("/") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {
    path2.pathname += "/";
  }
  return path2;
}
const joinPaths = (paths) => paths.join("/").replace(/\/\/+/g, "/");
const normalizePathname = (pathname) => pathname.replace(/\/+$/, "").replace(/^\/*/, "/");
const normalizeSearch = (search) => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search;
const normalizeHash = (hash2) => !hash2 || hash2 === "#" ? "" : hash2.startsWith("#") ? hash2 : "#" + hash2;
function isRouteErrorResponse(error2) {
  return error2 != null && typeof error2.status === "number" && typeof error2.statusText === "string" && typeof error2.internal === "boolean" && "data" in error2;
}
const validMutationMethodsArr = ["post", "put", "patch", "delete"];
new Set(validMutationMethodsArr);
const validRequestMethodsArr = ["get", ...validMutationMethodsArr];
new Set(validRequestMethodsArr);
/**
 * React Router v6.28.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends$3() {
  _extends$3 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$3.apply(this, arguments);
}
const DataRouterContext = /* @__PURE__ */ reactExports.createContext(null);
const DataRouterStateContext = /* @__PURE__ */ reactExports.createContext(null);
const NavigationContext = /* @__PURE__ */ reactExports.createContext(null);
const LocationContext = /* @__PURE__ */ reactExports.createContext(null);
const RouteContext = /* @__PURE__ */ reactExports.createContext({
  outlet: null,
  matches: [],
  isDataRoute: false
});
const RouteErrorContext = /* @__PURE__ */ reactExports.createContext(null);
function useHref(to, _temp) {
  let {
    relative
  } = _temp === void 0 ? {} : _temp;
  !useInRouterContext() ? invariant(false) : void 0;
  let {
    basename,
    navigator: navigator2
  } = reactExports.useContext(NavigationContext);
  let {
    hash: hash2,
    pathname,
    search
  } = useResolvedPath(to, {
    relative
  });
  let joinedPathname = pathname;
  if (basename !== "/") {
    joinedPathname = pathname === "/" ? basename : joinPaths([basename, pathname]);
  }
  return navigator2.createHref({
    pathname: joinedPathname,
    search,
    hash: hash2
  });
}
function useInRouterContext() {
  return reactExports.useContext(LocationContext) != null;
}
function useLocation() {
  !useInRouterContext() ? invariant(false) : void 0;
  return reactExports.useContext(LocationContext).location;
}
function useIsomorphicLayoutEffect(cb2) {
  let isStatic = reactExports.useContext(NavigationContext).static;
  if (!isStatic) {
    reactExports.useLayoutEffect(cb2);
  }
}
function useNavigate() {
  let {
    isDataRoute
  } = reactExports.useContext(RouteContext);
  return isDataRoute ? useNavigateStable() : useNavigateUnstable();
}
function useNavigateUnstable() {
  !useInRouterContext() ? invariant(false) : void 0;
  let dataRouterContext = reactExports.useContext(DataRouterContext);
  let {
    basename,
    future,
    navigator: navigator2
  } = reactExports.useContext(NavigationContext);
  let {
    matches
  } = reactExports.useContext(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify(getResolveToMatches(matches, future.v7_relativeSplatPath));
  let activeRef = reactExports.useRef(false);
  useIsomorphicLayoutEffect(() => {
    activeRef.current = true;
  });
  let navigate = reactExports.useCallback(function(to, options) {
    if (options === void 0) {
      options = {};
    }
    if (!activeRef.current) return;
    if (typeof to === "number") {
      navigator2.go(to);
      return;
    }
    let path2 = resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, options.relative === "path");
    if (dataRouterContext == null && basename !== "/") {
      path2.pathname = path2.pathname === "/" ? basename : joinPaths([basename, path2.pathname]);
    }
    (!!options.replace ? navigator2.replace : navigator2.push)(path2, options.state, options);
  }, [basename, navigator2, routePathnamesJson, locationPathname, dataRouterContext]);
  return navigate;
}
function useResolvedPath(to, _temp2) {
  let {
    relative
  } = _temp2 === void 0 ? {} : _temp2;
  let {
    future
  } = reactExports.useContext(NavigationContext);
  let {
    matches
  } = reactExports.useContext(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify(getResolveToMatches(matches, future.v7_relativeSplatPath));
  return reactExports.useMemo(() => resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, relative === "path"), [to, routePathnamesJson, locationPathname, relative]);
}
function useRoutes(routes, locationArg) {
  return useRoutesImpl(routes, locationArg);
}
function useRoutesImpl(routes, locationArg, dataRouterState, future) {
  !useInRouterContext() ? invariant(false) : void 0;
  let {
    navigator: navigator2
  } = reactExports.useContext(NavigationContext);
  let {
    matches: parentMatches
  } = reactExports.useContext(RouteContext);
  let routeMatch = parentMatches[parentMatches.length - 1];
  let parentParams = routeMatch ? routeMatch.params : {};
  routeMatch ? routeMatch.pathname : "/";
  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
  routeMatch && routeMatch.route;
  let locationFromContext = useLocation();
  let location;
  if (locationArg) {
    var _parsedLocationArg$pa;
    let parsedLocationArg = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
    !(parentPathnameBase === "/" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ? invariant(false) : void 0;
    location = parsedLocationArg;
  } else {
    location = locationFromContext;
  }
  let pathname = location.pathname || "/";
  let remainingPathname = pathname;
  if (parentPathnameBase !== "/") {
    let parentSegments = parentPathnameBase.replace(/^\//, "").split("/");
    let segments = pathname.replace(/^\//, "").split("/");
    remainingPathname = "/" + segments.slice(parentSegments.length).join("/");
  }
  let matches = matchRoutes(routes, {
    pathname: remainingPathname
  });
  let renderedMatches = _renderMatches(matches && matches.map((match2) => Object.assign({}, match2, {
    params: Object.assign({}, parentParams, match2.params),
    pathname: joinPaths([
      parentPathnameBase,
      // Re-encode pathnames that were decoded inside matchRoutes
      navigator2.encodeLocation ? navigator2.encodeLocation(match2.pathname).pathname : match2.pathname
    ]),
    pathnameBase: match2.pathnameBase === "/" ? parentPathnameBase : joinPaths([
      parentPathnameBase,
      // Re-encode pathnames that were decoded inside matchRoutes
      navigator2.encodeLocation ? navigator2.encodeLocation(match2.pathnameBase).pathname : match2.pathnameBase
    ])
  })), parentMatches, dataRouterState, future);
  if (locationArg && renderedMatches) {
    return /* @__PURE__ */ reactExports.createElement(LocationContext.Provider, {
      value: {
        location: _extends$3({
          pathname: "/",
          search: "",
          hash: "",
          state: null,
          key: "default"
        }, location),
        navigationType: Action.Pop
      }
    }, renderedMatches);
  }
  return renderedMatches;
}
function DefaultErrorComponent() {
  let error2 = useRouteError();
  let message = isRouteErrorResponse(error2) ? error2.status + " " + error2.statusText : error2 instanceof Error ? error2.message : JSON.stringify(error2);
  let stack = error2 instanceof Error ? error2.stack : null;
  let lightgrey = "rgba(200,200,200, 0.5)";
  let preStyles = {
    padding: "0.5rem",
    backgroundColor: lightgrey
  };
  let devInfo = null;
  return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement("h2", null, "Unexpected Application Error!"), /* @__PURE__ */ reactExports.createElement("h3", {
    style: {
      fontStyle: "italic"
    }
  }, message), stack ? /* @__PURE__ */ reactExports.createElement("pre", {
    style: preStyles
  }, stack) : null, devInfo);
}
const defaultErrorElement = /* @__PURE__ */ reactExports.createElement(DefaultErrorComponent, null);
class RenderErrorBoundary extends reactExports.Component {
  constructor(props) {
    super(props);
    this.state = {
      location: props.location,
      revalidation: props.revalidation,
      error: props.error
    };
  }
  static getDerivedStateFromError(error2) {
    return {
      error: error2
    };
  }
  static getDerivedStateFromProps(props, state) {
    if (state.location !== props.location || state.revalidation !== "idle" && props.revalidation === "idle") {
      return {
        error: props.error,
        location: props.location,
        revalidation: props.revalidation
      };
    }
    return {
      error: props.error !== void 0 ? props.error : state.error,
      location: state.location,
      revalidation: props.revalidation || state.revalidation
    };
  }
  componentDidCatch(error2, errorInfo) {
    console.error("React Router caught the following error during render", error2, errorInfo);
  }
  render() {
    return this.state.error !== void 0 ? /* @__PURE__ */ reactExports.createElement(RouteContext.Provider, {
      value: this.props.routeContext
    }, /* @__PURE__ */ reactExports.createElement(RouteErrorContext.Provider, {
      value: this.state.error,
      children: this.props.component
    })) : this.props.children;
  }
}
function RenderedRoute(_ref) {
  let {
    routeContext,
    match: match2,
    children
  } = _ref;
  let dataRouterContext = reactExports.useContext(DataRouterContext);
  if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match2.route.errorElement || match2.route.ErrorBoundary)) {
    dataRouterContext.staticContext._deepestRenderedBoundaryId = match2.route.id;
  }
  return /* @__PURE__ */ reactExports.createElement(RouteContext.Provider, {
    value: routeContext
  }, children);
}
function _renderMatches(matches, parentMatches, dataRouterState, future) {
  var _dataRouterState;
  if (parentMatches === void 0) {
    parentMatches = [];
  }
  if (dataRouterState === void 0) {
    dataRouterState = null;
  }
  if (future === void 0) {
    future = null;
  }
  if (matches == null) {
    var _future;
    if (!dataRouterState) {
      return null;
    }
    if (dataRouterState.errors) {
      matches = dataRouterState.matches;
    } else if ((_future = future) != null && _future.v7_partialHydration && parentMatches.length === 0 && !dataRouterState.initialized && dataRouterState.matches.length > 0) {
      matches = dataRouterState.matches;
    } else {
      return null;
    }
  }
  let renderedMatches = matches;
  let errors = (_dataRouterState = dataRouterState) == null ? void 0 : _dataRouterState.errors;
  if (errors != null) {
    let errorIndex = renderedMatches.findIndex((m2) => m2.route.id && (errors == null ? void 0 : errors[m2.route.id]) !== void 0);
    !(errorIndex >= 0) ? invariant(false) : void 0;
    renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));
  }
  let renderFallback = false;
  let fallbackIndex = -1;
  if (dataRouterState && future && future.v7_partialHydration) {
    for (let i = 0; i < renderedMatches.length; i++) {
      let match2 = renderedMatches[i];
      if (match2.route.HydrateFallback || match2.route.hydrateFallbackElement) {
        fallbackIndex = i;
      }
      if (match2.route.id) {
        let {
          loaderData,
          errors: errors2
        } = dataRouterState;
        let needsToRunLoader = match2.route.loader && loaderData[match2.route.id] === void 0 && (!errors2 || errors2[match2.route.id] === void 0);
        if (match2.route.lazy || needsToRunLoader) {
          renderFallback = true;
          if (fallbackIndex >= 0) {
            renderedMatches = renderedMatches.slice(0, fallbackIndex + 1);
          } else {
            renderedMatches = [renderedMatches[0]];
          }
          break;
        }
      }
    }
  }
  return renderedMatches.reduceRight((outlet, match2, index) => {
    let error2;
    let shouldRenderHydrateFallback = false;
    let errorElement = null;
    let hydrateFallbackElement = null;
    if (dataRouterState) {
      error2 = errors && match2.route.id ? errors[match2.route.id] : void 0;
      errorElement = match2.route.errorElement || defaultErrorElement;
      if (renderFallback) {
        if (fallbackIndex < 0 && index === 0) {
          shouldRenderHydrateFallback = true;
          hydrateFallbackElement = null;
        } else if (fallbackIndex === index) {
          shouldRenderHydrateFallback = true;
          hydrateFallbackElement = match2.route.hydrateFallbackElement || null;
        }
      }
    }
    let matches2 = parentMatches.concat(renderedMatches.slice(0, index + 1));
    let getChildren = () => {
      let children;
      if (error2) {
        children = errorElement;
      } else if (shouldRenderHydrateFallback) {
        children = hydrateFallbackElement;
      } else if (match2.route.Component) {
        children = /* @__PURE__ */ reactExports.createElement(match2.route.Component, null);
      } else if (match2.route.element) {
        children = match2.route.element;
      } else {
        children = outlet;
      }
      return /* @__PURE__ */ reactExports.createElement(RenderedRoute, {
        match: match2,
        routeContext: {
          outlet,
          matches: matches2,
          isDataRoute: dataRouterState != null
        },
        children
      });
    };
    return dataRouterState && (match2.route.ErrorBoundary || match2.route.errorElement || index === 0) ? /* @__PURE__ */ reactExports.createElement(RenderErrorBoundary, {
      location: dataRouterState.location,
      revalidation: dataRouterState.revalidation,
      component: errorElement,
      error: error2,
      children: getChildren(),
      routeContext: {
        outlet: null,
        matches: matches2,
        isDataRoute: true
      }
    }) : getChildren();
  }, null);
}
var DataRouterHook$1 = /* @__PURE__ */ function(DataRouterHook2) {
  DataRouterHook2["UseBlocker"] = "useBlocker";
  DataRouterHook2["UseRevalidator"] = "useRevalidator";
  DataRouterHook2["UseNavigateStable"] = "useNavigate";
  return DataRouterHook2;
}(DataRouterHook$1 || {});
var DataRouterStateHook$1 = /* @__PURE__ */ function(DataRouterStateHook2) {
  DataRouterStateHook2["UseBlocker"] = "useBlocker";
  DataRouterStateHook2["UseLoaderData"] = "useLoaderData";
  DataRouterStateHook2["UseActionData"] = "useActionData";
  DataRouterStateHook2["UseRouteError"] = "useRouteError";
  DataRouterStateHook2["UseNavigation"] = "useNavigation";
  DataRouterStateHook2["UseRouteLoaderData"] = "useRouteLoaderData";
  DataRouterStateHook2["UseMatches"] = "useMatches";
  DataRouterStateHook2["UseRevalidator"] = "useRevalidator";
  DataRouterStateHook2["UseNavigateStable"] = "useNavigate";
  DataRouterStateHook2["UseRouteId"] = "useRouteId";
  return DataRouterStateHook2;
}(DataRouterStateHook$1 || {});
function useDataRouterContext$1(hookName) {
  let ctx = reactExports.useContext(DataRouterContext);
  !ctx ? invariant(false) : void 0;
  return ctx;
}
function useDataRouterState(hookName) {
  let state = reactExports.useContext(DataRouterStateContext);
  !state ? invariant(false) : void 0;
  return state;
}
function useRouteContext(hookName) {
  let route = reactExports.useContext(RouteContext);
  !route ? invariant(false) : void 0;
  return route;
}
function useCurrentRouteId(hookName) {
  let route = useRouteContext();
  let thisRoute = route.matches[route.matches.length - 1];
  !thisRoute.route.id ? invariant(false) : void 0;
  return thisRoute.route.id;
}
function useRouteError() {
  var _state$errors;
  let error2 = reactExports.useContext(RouteErrorContext);
  let state = useDataRouterState(DataRouterStateHook$1.UseRouteError);
  let routeId = useCurrentRouteId(DataRouterStateHook$1.UseRouteError);
  if (error2 !== void 0) {
    return error2;
  }
  return (_state$errors = state.errors) == null ? void 0 : _state$errors[routeId];
}
function useNavigateStable() {
  let {
    router
  } = useDataRouterContext$1(DataRouterHook$1.UseNavigateStable);
  let id2 = useCurrentRouteId(DataRouterStateHook$1.UseNavigateStable);
  let activeRef = reactExports.useRef(false);
  useIsomorphicLayoutEffect(() => {
    activeRef.current = true;
  });
  let navigate = reactExports.useCallback(function(to, options) {
    if (options === void 0) {
      options = {};
    }
    if (!activeRef.current) return;
    if (typeof to === "number") {
      router.navigate(to);
    } else {
      router.navigate(to, _extends$3({
        fromRouteId: id2
      }, options));
    }
  }, [router, id2]);
  return navigate;
}
const alreadyWarned = {};
function warnOnce(key, message) {
  if (!alreadyWarned[message]) {
    alreadyWarned[message] = true;
    console.warn(message);
  }
}
const logDeprecation = (flag, msg, link2) => warnOnce(flag, "⚠️ React Router Future Flag Warning: " + msg + ". " + ("You can use the `" + flag + "` future flag to opt-in early. ") + ("For more information, see " + link2 + "."));
function logV6DeprecationWarnings(renderFuture, routerFuture) {
  if ((renderFuture == null ? void 0 : renderFuture.v7_startTransition) === void 0) {
    logDeprecation("v7_startTransition", "React Router will begin wrapping state updates in `React.startTransition` in v7", "https://reactrouter.com/v6/upgrading/future#v7_starttransition");
  }
  if ((renderFuture == null ? void 0 : renderFuture.v7_relativeSplatPath) === void 0 && !routerFuture) {
    logDeprecation("v7_relativeSplatPath", "Relative route resolution within Splat routes is changing in v7", "https://reactrouter.com/v6/upgrading/future#v7_relativesplatpath");
  }
}
function Navigate(_ref4) {
  let {
    to,
    replace: replace2,
    state,
    relative
  } = _ref4;
  !useInRouterContext() ? invariant(false) : void 0;
  let {
    future,
    static: isStatic
  } = reactExports.useContext(NavigationContext);
  let {
    matches
  } = reactExports.useContext(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let navigate = useNavigate();
  let path2 = resolveTo(to, getResolveToMatches(matches, future.v7_relativeSplatPath), locationPathname, relative === "path");
  let jsonPath = JSON.stringify(path2);
  reactExports.useEffect(() => navigate(JSON.parse(jsonPath), {
    replace: replace2,
    state,
    relative
  }), [navigate, jsonPath, relative, replace2, state]);
  return null;
}
function Route(_props) {
  invariant(false);
}
function Router(_ref5) {
  let {
    basename: basenameProp = "/",
    children = null,
    location: locationProp,
    navigationType = Action.Pop,
    navigator: navigator2,
    static: staticProp = false,
    future
  } = _ref5;
  !!useInRouterContext() ? invariant(false) : void 0;
  let basename = basenameProp.replace(/^\/*/, "/");
  let navigationContext = reactExports.useMemo(() => ({
    basename,
    navigator: navigator2,
    static: staticProp,
    future: _extends$3({
      v7_relativeSplatPath: false
    }, future)
  }), [basename, future, navigator2, staticProp]);
  if (typeof locationProp === "string") {
    locationProp = parsePath(locationProp);
  }
  let {
    pathname = "/",
    search = "",
    hash: hash2 = "",
    state = null,
    key = "default"
  } = locationProp;
  let locationContext = reactExports.useMemo(() => {
    let trailingPathname = stripBasename(pathname, basename);
    if (trailingPathname == null) {
      return null;
    }
    return {
      location: {
        pathname: trailingPathname,
        search,
        hash: hash2,
        state,
        key
      },
      navigationType
    };
  }, [basename, pathname, search, hash2, state, key, navigationType]);
  if (locationContext == null) {
    return null;
  }
  return /* @__PURE__ */ reactExports.createElement(NavigationContext.Provider, {
    value: navigationContext
  }, /* @__PURE__ */ reactExports.createElement(LocationContext.Provider, {
    children,
    value: locationContext
  }));
}
function Routes(_ref6) {
  let {
    children,
    location
  } = _ref6;
  return useRoutes(createRoutesFromChildren(children), location);
}
new Promise(() => {
});
function createRoutesFromChildren(children, parentPath) {
  if (parentPath === void 0) {
    parentPath = [];
  }
  let routes = [];
  reactExports.Children.forEach(children, (element, index) => {
    if (!/* @__PURE__ */ reactExports.isValidElement(element)) {
      return;
    }
    let treePath = [...parentPath, index];
    if (element.type === reactExports.Fragment) {
      routes.push.apply(routes, createRoutesFromChildren(element.props.children, treePath));
      return;
    }
    !(element.type === Route) ? invariant(false) : void 0;
    !(!element.props.index || !element.props.children) ? invariant(false) : void 0;
    let route = {
      id: element.props.id || treePath.join("-"),
      caseSensitive: element.props.caseSensitive,
      element: element.props.element,
      Component: element.props.Component,
      index: element.props.index,
      path: element.props.path,
      loader: element.props.loader,
      action: element.props.action,
      errorElement: element.props.errorElement,
      ErrorBoundary: element.props.ErrorBoundary,
      hasErrorBoundary: element.props.ErrorBoundary != null || element.props.errorElement != null,
      shouldRevalidate: element.props.shouldRevalidate,
      handle: element.props.handle,
      lazy: element.props.lazy
    };
    if (element.props.children) {
      route.children = createRoutesFromChildren(element.props.children, treePath);
    }
    routes.push(route);
  });
  return routes;
}
/**
 * React Router DOM v6.28.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends$2() {
  _extends$2 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$2.apply(this, arguments);
}
function _objectWithoutPropertiesLoose$2(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}
function shouldProcessLinkClick(event, target) {
  return event.button === 0 && // Ignore everything but left clicks
  (!target || target === "_self") && // Let browser handle "target=_blank" etc.
  !isModifiedEvent(event);
}
const _excluded = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset", "viewTransition"], _excluded2 = ["aria-current", "caseSensitive", "className", "end", "style", "to", "viewTransition", "children"];
const REACT_ROUTER_VERSION = "6";
try {
  window.__reactRouterVersion = REACT_ROUTER_VERSION;
} catch (e2) {
}
const ViewTransitionContext = /* @__PURE__ */ reactExports.createContext({
  isTransitioning: false
});
const START_TRANSITION = "startTransition";
const startTransitionImpl = React$2[START_TRANSITION];
function HashRouter(_ref5) {
  let {
    basename,
    children,
    future,
    window: window2
  } = _ref5;
  let historyRef = reactExports.useRef();
  if (historyRef.current == null) {
    historyRef.current = createHashHistory({
      window: window2,
      v5Compat: true
    });
  }
  let history = historyRef.current;
  let [state, setStateImpl] = reactExports.useState({
    action: history.action,
    location: history.location
  });
  let {
    v7_startTransition
  } = future || {};
  let setState = reactExports.useCallback((newState) => {
    v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);
  }, [setStateImpl, v7_startTransition]);
  reactExports.useLayoutEffect(() => history.listen(setState), [history, setState]);
  reactExports.useEffect(() => logV6DeprecationWarnings(future), [future]);
  return /* @__PURE__ */ reactExports.createElement(Router, {
    basename,
    children,
    location: state.location,
    navigationType: state.action,
    navigator: history,
    future
  });
}
const isBrowser$2 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
const ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
const Link = /* @__PURE__ */ reactExports.forwardRef(function LinkWithRef(_ref7, ref) {
  let {
    onClick,
    relative,
    reloadDocument,
    replace: replace2,
    state,
    target,
    to,
    preventScrollReset,
    viewTransition
  } = _ref7, rest = _objectWithoutPropertiesLoose$2(_ref7, _excluded);
  let {
    basename
  } = reactExports.useContext(NavigationContext);
  let absoluteHref;
  let isExternal = false;
  if (typeof to === "string" && ABSOLUTE_URL_REGEX.test(to)) {
    absoluteHref = to;
    if (isBrowser$2) {
      try {
        let currentUrl = new URL(window.location.href);
        let targetUrl = to.startsWith("//") ? new URL(currentUrl.protocol + to) : new URL(to);
        let path2 = stripBasename(targetUrl.pathname, basename);
        if (targetUrl.origin === currentUrl.origin && path2 != null) {
          to = path2 + targetUrl.search + targetUrl.hash;
        } else {
          isExternal = true;
        }
      } catch (e2) {
      }
    }
  }
  let href = useHref(to, {
    relative
  });
  let internalOnClick = useLinkClickHandler(to, {
    replace: replace2,
    state,
    target,
    preventScrollReset,
    relative,
    viewTransition
  });
  function handleClick(event) {
    if (onClick) onClick(event);
    if (!event.defaultPrevented) {
      internalOnClick(event);
    }
  }
  return (
    // eslint-disable-next-line jsx-a11y/anchor-has-content
    /* @__PURE__ */ reactExports.createElement("a", _extends$2({}, rest, {
      href: absoluteHref || href,
      onClick: isExternal || reloadDocument ? onClick : handleClick,
      ref,
      target
    }))
  );
});
const NavLink = /* @__PURE__ */ reactExports.forwardRef(function NavLinkWithRef(_ref8, ref) {
  let {
    "aria-current": ariaCurrentProp = "page",
    caseSensitive = false,
    className: classNameProp = "",
    end = false,
    style: styleProp,
    to,
    viewTransition,
    children
  } = _ref8, rest = _objectWithoutPropertiesLoose$2(_ref8, _excluded2);
  let path2 = useResolvedPath(to, {
    relative: rest.relative
  });
  let location = useLocation();
  let routerState = reactExports.useContext(DataRouterStateContext);
  let {
    navigator: navigator2,
    basename
  } = reactExports.useContext(NavigationContext);
  let isTransitioning = routerState != null && // Conditional usage is OK here because the usage of a data router is static
  // eslint-disable-next-line react-hooks/rules-of-hooks
  useViewTransitionState(path2) && viewTransition === true;
  let toPathname = navigator2.encodeLocation ? navigator2.encodeLocation(path2).pathname : path2.pathname;
  let locationPathname = location.pathname;
  let nextLocationPathname = routerState && routerState.navigation && routerState.navigation.location ? routerState.navigation.location.pathname : null;
  if (!caseSensitive) {
    locationPathname = locationPathname.toLowerCase();
    nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null;
    toPathname = toPathname.toLowerCase();
  }
  if (nextLocationPathname && basename) {
    nextLocationPathname = stripBasename(nextLocationPathname, basename) || nextLocationPathname;
  }
  const endSlashPosition = toPathname !== "/" && toPathname.endsWith("/") ? toPathname.length - 1 : toPathname.length;
  let isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(endSlashPosition) === "/";
  let isPending = nextLocationPathname != null && (nextLocationPathname === toPathname || !end && nextLocationPathname.startsWith(toPathname) && nextLocationPathname.charAt(toPathname.length) === "/");
  let renderProps = {
    isActive,
    isPending,
    isTransitioning
  };
  let ariaCurrent = isActive ? ariaCurrentProp : void 0;
  let className;
  if (typeof classNameProp === "function") {
    className = classNameProp(renderProps);
  } else {
    className = [classNameProp, isActive ? "active" : null, isPending ? "pending" : null, isTransitioning ? "transitioning" : null].filter(Boolean).join(" ");
  }
  let style2 = typeof styleProp === "function" ? styleProp(renderProps) : styleProp;
  return /* @__PURE__ */ reactExports.createElement(Link, _extends$2({}, rest, {
    "aria-current": ariaCurrent,
    className,
    ref,
    style: style2,
    to,
    viewTransition
  }), typeof children === "function" ? children(renderProps) : children);
});
var DataRouterHook;
(function(DataRouterHook2) {
  DataRouterHook2["UseScrollRestoration"] = "useScrollRestoration";
  DataRouterHook2["UseSubmit"] = "useSubmit";
  DataRouterHook2["UseSubmitFetcher"] = "useSubmitFetcher";
  DataRouterHook2["UseFetcher"] = "useFetcher";
  DataRouterHook2["useViewTransitionState"] = "useViewTransitionState";
})(DataRouterHook || (DataRouterHook = {}));
var DataRouterStateHook;
(function(DataRouterStateHook2) {
  DataRouterStateHook2["UseFetcher"] = "useFetcher";
  DataRouterStateHook2["UseFetchers"] = "useFetchers";
  DataRouterStateHook2["UseScrollRestoration"] = "useScrollRestoration";
})(DataRouterStateHook || (DataRouterStateHook = {}));
function useDataRouterContext(hookName) {
  let ctx = reactExports.useContext(DataRouterContext);
  !ctx ? invariant(false) : void 0;
  return ctx;
}
function useLinkClickHandler(to, _temp) {
  let {
    target,
    replace: replaceProp,
    state,
    preventScrollReset,
    relative,
    viewTransition
  } = _temp === void 0 ? {} : _temp;
  let navigate = useNavigate();
  let location = useLocation();
  let path2 = useResolvedPath(to, {
    relative
  });
  return reactExports.useCallback((event) => {
    if (shouldProcessLinkClick(event, target)) {
      event.preventDefault();
      let replace2 = replaceProp !== void 0 ? replaceProp : createPath(location) === createPath(path2);
      navigate(to, {
        replace: replace2,
        state,
        preventScrollReset,
        relative,
        viewTransition
      });
    }
  }, [location, navigate, path2, replaceProp, state, target, to, preventScrollReset, relative, viewTransition]);
}
function useViewTransitionState(to, opts) {
  if (opts === void 0) {
    opts = {};
  }
  let vtContext = reactExports.useContext(ViewTransitionContext);
  !(vtContext != null) ? invariant(false) : void 0;
  let {
    basename
  } = useDataRouterContext(DataRouterHook.useViewTransitionState);
  let path2 = useResolvedPath(to, {
    relative: opts.relative
  });
  if (!vtContext.isTransitioning) {
    return false;
  }
  let currentPath = stripBasename(vtContext.currentLocation.pathname, basename) || vtContext.currentLocation.pathname;
  let nextPath = stripBasename(vtContext.nextLocation.pathname, basename) || vtContext.nextLocation.pathname;
  return matchPath(path2.pathname, nextPath) != null || matchPath(path2.pathname, currentPath) != null;
}
var reactIs$2 = { exports: {} };
var reactIs_production = {};
/**
 * @license React
 * react-is.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler");
var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen"), REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
function typeOf(object) {
  if ("object" === typeof object && null !== object) {
    var $$typeof = object.$$typeof;
    switch ($$typeof) {
      case REACT_ELEMENT_TYPE:
        switch (object = object.type, object) {
          case REACT_FRAGMENT_TYPE:
          case REACT_PROFILER_TYPE:
          case REACT_STRICT_MODE_TYPE:
          case REACT_SUSPENSE_TYPE:
          case REACT_SUSPENSE_LIST_TYPE:
            return object;
          default:
            switch (object = object && object.$$typeof, object) {
              case REACT_CONTEXT_TYPE:
              case REACT_FORWARD_REF_TYPE:
              case REACT_LAZY_TYPE:
              case REACT_MEMO_TYPE:
                return object;
              case REACT_CONSUMER_TYPE:
                return object;
              default:
                return $$typeof;
            }
        }
      case REACT_PORTAL_TYPE:
        return $$typeof;
    }
  }
}
reactIs_production.ContextConsumer = REACT_CONSUMER_TYPE;
reactIs_production.ContextProvider = REACT_CONTEXT_TYPE;
reactIs_production.Element = REACT_ELEMENT_TYPE;
reactIs_production.ForwardRef = REACT_FORWARD_REF_TYPE;
reactIs_production.Fragment = REACT_FRAGMENT_TYPE;
reactIs_production.Lazy = REACT_LAZY_TYPE;
reactIs_production.Memo = REACT_MEMO_TYPE;
reactIs_production.Portal = REACT_PORTAL_TYPE;
reactIs_production.Profiler = REACT_PROFILER_TYPE;
reactIs_production.StrictMode = REACT_STRICT_MODE_TYPE;
reactIs_production.Suspense = REACT_SUSPENSE_TYPE;
reactIs_production.SuspenseList = REACT_SUSPENSE_LIST_TYPE;
reactIs_production.isContextConsumer = function(object) {
  return typeOf(object) === REACT_CONSUMER_TYPE;
};
reactIs_production.isContextProvider = function(object) {
  return typeOf(object) === REACT_CONTEXT_TYPE;
};
reactIs_production.isElement = function(object) {
  return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
};
reactIs_production.isForwardRef = function(object) {
  return typeOf(object) === REACT_FORWARD_REF_TYPE;
};
reactIs_production.isFragment = function(object) {
  return typeOf(object) === REACT_FRAGMENT_TYPE;
};
reactIs_production.isLazy = function(object) {
  return typeOf(object) === REACT_LAZY_TYPE;
};
reactIs_production.isMemo = function(object) {
  return typeOf(object) === REACT_MEMO_TYPE;
};
reactIs_production.isPortal = function(object) {
  return typeOf(object) === REACT_PORTAL_TYPE;
};
reactIs_production.isProfiler = function(object) {
  return typeOf(object) === REACT_PROFILER_TYPE;
};
reactIs_production.isStrictMode = function(object) {
  return typeOf(object) === REACT_STRICT_MODE_TYPE;
};
reactIs_production.isSuspense = function(object) {
  return typeOf(object) === REACT_SUSPENSE_TYPE;
};
reactIs_production.isSuspenseList = function(object) {
  return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;
};
reactIs_production.isValidElementType = function(type) {
  return "string" === typeof type || "function" === typeof type || type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_OFFSCREEN_TYPE || "object" === typeof type && null !== type && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_CONSUMER_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_CLIENT_REFERENCE || void 0 !== type.getModuleId) ? true : false;
};
reactIs_production.typeOf = typeOf;
{
  reactIs$2.exports = reactIs_production;
}
var reactIsExports$1 = reactIs$2.exports;
function isPlainObject$2(item) {
  if (typeof item !== "object" || item === null) {
    return false;
  }
  const prototype2 = Object.getPrototypeOf(item);
  return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(Symbol.toStringTag in item) && !(Symbol.iterator in item);
}
function deepClone(source) {
  if (/* @__PURE__ */ reactExports.isValidElement(source) || reactIsExports$1.isValidElementType(source) || !isPlainObject$2(source)) {
    return source;
  }
  const output = {};
  Object.keys(source).forEach((key) => {
    output[key] = deepClone(source[key]);
  });
  return output;
}
function deepmerge(target, source, options = {
  clone: true
}) {
  const output = options.clone ? {
    ...target
  } : target;
  if (isPlainObject$2(target) && isPlainObject$2(source)) {
    Object.keys(source).forEach((key) => {
      if (/* @__PURE__ */ reactExports.isValidElement(source[key]) || reactIsExports$1.isValidElementType(source[key])) {
        output[key] = source[key];
      } else if (isPlainObject$2(source[key]) && // Avoid prototype pollution
      Object.prototype.hasOwnProperty.call(target, key) && isPlainObject$2(target[key])) {
        output[key] = deepmerge(target[key], source[key], options);
      } else if (options.clone) {
        output[key] = isPlainObject$2(source[key]) ? deepClone(source[key]) : source[key];
      } else {
        output[key] = source[key];
      }
    });
  }
  return output;
}
var propTypes$1 = { exports: {} };
var ReactPropTypesSecret$1 = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
var ReactPropTypesSecret_1$1 = ReactPropTypesSecret$1;
var ReactPropTypesSecret = ReactPropTypesSecret_1$1;
function emptyFunction() {
}
function emptyFunctionWithReset() {
}
emptyFunctionWithReset.resetWarningCache = emptyFunction;
var factoryWithThrowingShims$1 = function() {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      return;
    }
    var err = new Error(
      "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
    );
    err.name = "Invariant Violation";
    throw err;
  }
  shim.isRequired = shim;
  function getShim() {
    return shim;
  }
  var ReactPropTypes = {
    array: shim,
    bigint: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,
    any: shim,
    arrayOf: getShim,
    element: shim,
    elementType: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim,
    checkPropTypes: emptyFunctionWithReset,
    resetWarningCache: emptyFunction
  };
  ReactPropTypes.PropTypes = ReactPropTypes;
  return ReactPropTypes;
};
{
  propTypes$1.exports = factoryWithThrowingShims$1();
}
var propTypesExports$1 = propTypes$1.exports;
const PropTypes$1 = /* @__PURE__ */ getDefaultExportFromCjs$2(propTypesExports$1);
function formatMuiErrorMessage(code, ...args) {
  const url = new URL(`https://mui.com/production-error/?code=${code}`);
  args.forEach((arg2) => url.searchParams.append("args[]", arg2));
  return `Minified MUI error #${code}; visit ${url} for the full message.`;
}
function capitalize(string) {
  if (typeof string !== "string") {
    throw new Error(formatMuiErrorMessage(7));
  }
  return string.charAt(0).toUpperCase() + string.slice(1);
}
function createChainedFunction(...funcs) {
  return funcs.reduce((acc, func) => {
    if (func == null) {
      return acc;
    }
    return function chainedFunction(...args) {
      acc.apply(this, args);
      func.apply(this, args);
    };
  }, () => {
  });
}
function ownerDocument(node2) {
  return node2 && node2.ownerDocument || document;
}
function ownerWindow(node2) {
  const doc = ownerDocument(node2);
  return doc.defaultView || window;
}
function setRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
}
const useEnhancedEffect = typeof window !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
let globalId = 0;
function useGlobalId(idOverride) {
  const [defaultId, setDefaultId] = reactExports.useState(idOverride);
  const id2 = idOverride || defaultId;
  reactExports.useEffect(() => {
    if (defaultId == null) {
      globalId += 1;
      setDefaultId(`mui-${globalId}`);
    }
  }, [defaultId]);
  return id2;
}
const safeReact = {
  ...React$2
};
const maybeReactUseId = safeReact.useId;
function useId(idOverride) {
  if (maybeReactUseId !== void 0) {
    const reactId = maybeReactUseId();
    return idOverride ?? reactId;
  }
  return useGlobalId(idOverride);
}
function useEventCallback(fn) {
  const ref = reactExports.useRef(fn);
  useEnhancedEffect(() => {
    ref.current = fn;
  });
  return reactExports.useRef((...args) => (
    // @ts-expect-error hide `this`
    (0, ref.current)(...args)
  )).current;
}
function useForkRef(...refs) {
  return reactExports.useMemo(() => {
    if (refs.every((ref) => ref == null)) {
      return null;
    }
    return (instance) => {
      refs.forEach((ref) => {
        setRef(ref, instance);
      });
    };
  }, refs);
}
const UNINITIALIZED = {};
function useLazyRef(init, initArg) {
  const ref = reactExports.useRef(UNINITIALIZED);
  if (ref.current === UNINITIALIZED) {
    ref.current = init(initArg);
  }
  return ref;
}
const EMPTY = [];
function useOnMount(fn) {
  reactExports.useEffect(fn, EMPTY);
}
class Timeout {
  constructor() {
    __publicField(this, "currentId", null);
    __publicField(this, "clear", () => {
      if (this.currentId !== null) {
        clearTimeout(this.currentId);
        this.currentId = null;
      }
    });
    __publicField(this, "disposeEffect", () => {
      return this.clear;
    });
  }
  static create() {
    return new Timeout();
  }
  /**
   * Executes `fn` after `delay`, clearing any previously scheduled call.
   */
  start(delay, fn) {
    this.clear();
    this.currentId = setTimeout(() => {
      this.currentId = null;
      fn();
    }, delay);
  }
}
function useTimeout() {
  const timeout = useLazyRef(Timeout.create).current;
  useOnMount(timeout.disposeEffect);
  return timeout;
}
function isFocusVisible(element) {
  try {
    return element.matches(":focus-visible");
  } catch (error2) {
  }
  return false;
}
function getScrollbarSize(win = window) {
  const documentWidth = win.document.documentElement.clientWidth;
  return win.innerWidth - documentWidth;
}
function resolveProps(defaultProps2, props) {
  const output = {
    ...props
  };
  for (const key in defaultProps2) {
    if (Object.prototype.hasOwnProperty.call(defaultProps2, key)) {
      const propName = key;
      if (propName === "components" || propName === "slots") {
        output[propName] = {
          ...defaultProps2[propName],
          ...output[propName]
        };
      } else if (propName === "componentsProps" || propName === "slotProps") {
        const defaultSlotProps = defaultProps2[propName];
        const slotProps = props[propName];
        if (!slotProps) {
          output[propName] = defaultSlotProps || {};
        } else if (!defaultSlotProps) {
          output[propName] = slotProps;
        } else {
          output[propName] = {
            ...slotProps
          };
          for (const slotKey in defaultSlotProps) {
            if (Object.prototype.hasOwnProperty.call(defaultSlotProps, slotKey)) {
              const slotPropName = slotKey;
              output[propName][slotPropName] = resolveProps(defaultSlotProps[slotPropName], slotProps[slotPropName]);
            }
          }
        }
      } else if (output[propName] === void 0) {
        output[propName] = defaultProps2[propName];
      }
    }
  }
  return output;
}
function composeClasses(slots, getUtilityClass, classes = void 0) {
  const output = {};
  for (const slotName in slots) {
    const slot = slots[slotName];
    let buffer2 = "";
    let start = true;
    for (let i = 0; i < slot.length; i += 1) {
      const value = slot[i];
      if (value) {
        buffer2 += (start === true ? "" : " ") + getUtilityClass(value);
        start = false;
        if (classes && classes[value]) {
          buffer2 += " " + classes[value];
        }
      }
    }
    output[slotName] = buffer2;
  }
  return output;
}
const defaultGenerator = (componentName) => componentName;
const createClassNameGenerator = () => {
  let generate = defaultGenerator;
  return {
    configure(generator) {
      generate = generator;
    },
    generate(componentName) {
      return generate(componentName);
    },
    reset() {
      generate = defaultGenerator;
    }
  };
};
const ClassNameGenerator = createClassNameGenerator();
const globalStateClasses = {
  active: "active",
  checked: "checked",
  completed: "completed",
  disabled: "disabled",
  error: "error",
  expanded: "expanded",
  focused: "focused",
  focusVisible: "focusVisible",
  open: "open",
  readOnly: "readOnly",
  required: "required",
  selected: "selected"
};
function generateUtilityClass(componentName, slot, globalStatePrefix = "Mui") {
  const globalStateClass = globalStateClasses[slot];
  return globalStateClass ? `${globalStatePrefix}-${globalStateClass}` : `${ClassNameGenerator.generate(componentName)}-${slot}`;
}
function generateUtilityClasses(componentName, slots, globalStatePrefix = "Mui") {
  const result = {};
  slots.forEach((slot) => {
    result[slot] = generateUtilityClass(componentName, slot, globalStatePrefix);
  });
  return result;
}
function clamp2(val, min2 = Number.MIN_SAFE_INTEGER, max2 = Number.MAX_SAFE_INTEGER) {
  return Math.max(min2, Math.min(val, max2));
}
function isHostComponent(element) {
  return typeof element === "string";
}
function appendOwnerState(elementType, otherProps, ownerState) {
  if (elementType === void 0 || isHostComponent(elementType)) {
    return otherProps;
  }
  return {
    ...otherProps,
    ownerState: {
      ...otherProps.ownerState,
      ...ownerState
    }
  };
}
function r$1(e2) {
  var t2, f2, n2 = "";
  if ("string" == typeof e2 || "number" == typeof e2) n2 += e2;
  else if ("object" == typeof e2) if (Array.isArray(e2)) {
    var o = e2.length;
    for (t2 = 0; t2 < o; t2++) e2[t2] && (f2 = r$1(e2[t2])) && (n2 && (n2 += " "), n2 += f2);
  } else for (f2 in e2) e2[f2] && (n2 && (n2 += " "), n2 += f2);
  return n2;
}
function clsx() {
  for (var e2, t2, f2 = 0, n2 = "", o = arguments.length; f2 < o; f2++) (e2 = arguments[f2]) && (t2 = r$1(e2)) && (n2 && (n2 += " "), n2 += t2);
  return n2;
}
function extractEventHandlers(object, excludeKeys = []) {
  if (object === void 0) {
    return {};
  }
  const result = {};
  Object.keys(object).filter((prop) => prop.match(/^on[A-Z]/) && typeof object[prop] === "function" && !excludeKeys.includes(prop)).forEach((prop) => {
    result[prop] = object[prop];
  });
  return result;
}
function omitEventHandlers(object) {
  if (object === void 0) {
    return {};
  }
  const result = {};
  Object.keys(object).filter((prop) => !(prop.match(/^on[A-Z]/) && typeof object[prop] === "function")).forEach((prop) => {
    result[prop] = object[prop];
  });
  return result;
}
function mergeSlotProps(parameters) {
  const {
    getSlotProps,
    additionalProps,
    externalSlotProps,
    externalForwardedProps,
    className
  } = parameters;
  if (!getSlotProps) {
    const joinedClasses2 = clsx(additionalProps == null ? void 0 : additionalProps.className, className, externalForwardedProps == null ? void 0 : externalForwardedProps.className, externalSlotProps == null ? void 0 : externalSlotProps.className);
    const mergedStyle2 = {
      ...additionalProps == null ? void 0 : additionalProps.style,
      ...externalForwardedProps == null ? void 0 : externalForwardedProps.style,
      ...externalSlotProps == null ? void 0 : externalSlotProps.style
    };
    const props2 = {
      ...additionalProps,
      ...externalForwardedProps,
      ...externalSlotProps
    };
    if (joinedClasses2.length > 0) {
      props2.className = joinedClasses2;
    }
    if (Object.keys(mergedStyle2).length > 0) {
      props2.style = mergedStyle2;
    }
    return {
      props: props2,
      internalRef: void 0
    };
  }
  const eventHandlers = extractEventHandlers({
    ...externalForwardedProps,
    ...externalSlotProps
  });
  const componentsPropsWithoutEventHandlers = omitEventHandlers(externalSlotProps);
  const otherPropsWithoutEventHandlers = omitEventHandlers(externalForwardedProps);
  const internalSlotProps = getSlotProps(eventHandlers);
  const joinedClasses = clsx(internalSlotProps == null ? void 0 : internalSlotProps.className, additionalProps == null ? void 0 : additionalProps.className, className, externalForwardedProps == null ? void 0 : externalForwardedProps.className, externalSlotProps == null ? void 0 : externalSlotProps.className);
  const mergedStyle = {
    ...internalSlotProps == null ? void 0 : internalSlotProps.style,
    ...additionalProps == null ? void 0 : additionalProps.style,
    ...externalForwardedProps == null ? void 0 : externalForwardedProps.style,
    ...externalSlotProps == null ? void 0 : externalSlotProps.style
  };
  const props = {
    ...internalSlotProps,
    ...additionalProps,
    ...otherPropsWithoutEventHandlers,
    ...componentsPropsWithoutEventHandlers
  };
  if (joinedClasses.length > 0) {
    props.className = joinedClasses;
  }
  if (Object.keys(mergedStyle).length > 0) {
    props.style = mergedStyle;
  }
  return {
    props,
    internalRef: internalSlotProps.ref
  };
}
function resolveComponentProps(componentProps, ownerState, slotState) {
  if (typeof componentProps === "function") {
    return componentProps(ownerState, slotState);
  }
  return componentProps;
}
function getReactElementRef(element) {
  var _a;
  if (parseInt(reactExports.version, 10) >= 19) {
    return ((_a = element == null ? void 0 : element.props) == null ? void 0 : _a.ref) || null;
  }
  return (element == null ? void 0 : element.ref) || null;
}
function isOverflowing(container) {
  const doc = ownerDocument(container);
  if (doc.body === container) {
    return ownerWindow(container).innerWidth > doc.documentElement.clientWidth;
  }
  return container.scrollHeight > container.clientHeight;
}
function ariaHidden(element, hide) {
  if (hide) {
    element.setAttribute("aria-hidden", "true");
  } else {
    element.removeAttribute("aria-hidden");
  }
}
function getPaddingRight(element) {
  return parseInt(ownerWindow(element).getComputedStyle(element).paddingRight, 10) || 0;
}
function isAriaHiddenForbiddenOnElement(element) {
  const forbiddenTagNames = ["TEMPLATE", "SCRIPT", "STYLE", "LINK", "MAP", "META", "NOSCRIPT", "PICTURE", "COL", "COLGROUP", "PARAM", "SLOT", "SOURCE", "TRACK"];
  const isForbiddenTagName = forbiddenTagNames.includes(element.tagName);
  const isInputHidden = element.tagName === "INPUT" && element.getAttribute("type") === "hidden";
  return isForbiddenTagName || isInputHidden;
}
function ariaHiddenSiblings(container, mountElement, currentElement, elementsToExclude, hide) {
  const blacklist = [mountElement, currentElement, ...elementsToExclude];
  [].forEach.call(container.children, (element) => {
    const isNotExcludedElement = !blacklist.includes(element);
    const isNotForbiddenElement = !isAriaHiddenForbiddenOnElement(element);
    if (isNotExcludedElement && isNotForbiddenElement) {
      ariaHidden(element, hide);
    }
  });
}
function findIndexOf(items, callback2) {
  let idx = -1;
  items.some((item, index) => {
    if (callback2(item)) {
      idx = index;
      return true;
    }
    return false;
  });
  return idx;
}
function handleContainer(containerInfo, props) {
  const restoreStyle = [];
  const container = containerInfo.container;
  if (!props.disableScrollLock) {
    if (isOverflowing(container)) {
      const scrollbarSize = getScrollbarSize(ownerWindow(container));
      restoreStyle.push({
        value: container.style.paddingRight,
        property: "padding-right",
        el: container
      });
      container.style.paddingRight = `${getPaddingRight(container) + scrollbarSize}px`;
      const fixedElements2 = ownerDocument(container).querySelectorAll(".mui-fixed");
      [].forEach.call(fixedElements2, (element) => {
        restoreStyle.push({
          value: element.style.paddingRight,
          property: "padding-right",
          el: element
        });
        element.style.paddingRight = `${getPaddingRight(element) + scrollbarSize}px`;
      });
    }
    let scrollContainer;
    if (container.parentNode instanceof DocumentFragment) {
      scrollContainer = ownerDocument(container).body;
    } else {
      const parent = container.parentElement;
      const containerWindow = ownerWindow(container);
      scrollContainer = (parent == null ? void 0 : parent.nodeName) === "HTML" && containerWindow.getComputedStyle(parent).overflowY === "scroll" ? parent : container;
    }
    restoreStyle.push({
      value: scrollContainer.style.overflow,
      property: "overflow",
      el: scrollContainer
    }, {
      value: scrollContainer.style.overflowX,
      property: "overflow-x",
      el: scrollContainer
    }, {
      value: scrollContainer.style.overflowY,
      property: "overflow-y",
      el: scrollContainer
    });
    scrollContainer.style.overflow = "hidden";
  }
  const restore = () => {
    restoreStyle.forEach(({
      value,
      el: el2,
      property
    }) => {
      if (value) {
        el2.style.setProperty(property, value);
      } else {
        el2.style.removeProperty(property);
      }
    });
  };
  return restore;
}
function getHiddenSiblings(container) {
  const hiddenSiblings = [];
  [].forEach.call(container.children, (element) => {
    if (element.getAttribute("aria-hidden") === "true") {
      hiddenSiblings.push(element);
    }
  });
  return hiddenSiblings;
}
class ModalManager {
  constructor() {
    this.modals = [];
    this.containers = [];
  }
  add(modal, container) {
    let modalIndex = this.modals.indexOf(modal);
    if (modalIndex !== -1) {
      return modalIndex;
    }
    modalIndex = this.modals.length;
    this.modals.push(modal);
    if (modal.modalRef) {
      ariaHidden(modal.modalRef, false);
    }
    const hiddenSiblings = getHiddenSiblings(container);
    ariaHiddenSiblings(container, modal.mount, modal.modalRef, hiddenSiblings, true);
    const containerIndex = findIndexOf(this.containers, (item) => item.container === container);
    if (containerIndex !== -1) {
      this.containers[containerIndex].modals.push(modal);
      return modalIndex;
    }
    this.containers.push({
      modals: [modal],
      container,
      restore: null,
      hiddenSiblings
    });
    return modalIndex;
  }
  mount(modal, props) {
    const containerIndex = findIndexOf(this.containers, (item) => item.modals.includes(modal));
    const containerInfo = this.containers[containerIndex];
    if (!containerInfo.restore) {
      containerInfo.restore = handleContainer(containerInfo, props);
    }
  }
  remove(modal, ariaHiddenState = true) {
    const modalIndex = this.modals.indexOf(modal);
    if (modalIndex === -1) {
      return modalIndex;
    }
    const containerIndex = findIndexOf(this.containers, (item) => item.modals.includes(modal));
    const containerInfo = this.containers[containerIndex];
    containerInfo.modals.splice(containerInfo.modals.indexOf(modal), 1);
    this.modals.splice(modalIndex, 1);
    if (containerInfo.modals.length === 0) {
      if (containerInfo.restore) {
        containerInfo.restore();
      }
      if (modal.modalRef) {
        ariaHidden(modal.modalRef, ariaHiddenState);
      }
      ariaHiddenSiblings(containerInfo.container, modal.mount, modal.modalRef, containerInfo.hiddenSiblings, false);
      this.containers.splice(containerIndex, 1);
    } else {
      const nextTop = containerInfo.modals[containerInfo.modals.length - 1];
      if (nextTop.modalRef) {
        ariaHidden(nextTop.modalRef, false);
      }
    }
    return modalIndex;
  }
  isTopModal(modal) {
    return this.modals.length > 0 && this.modals[this.modals.length - 1] === modal;
  }
}
const candidatesSelector = ["input", "select", "textarea", "a[href]", "button", "[tabindex]", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])'].join(",");
function getTabIndex(node2) {
  const tabindexAttr = parseInt(node2.getAttribute("tabindex") || "", 10);
  if (!Number.isNaN(tabindexAttr)) {
    return tabindexAttr;
  }
  if (node2.contentEditable === "true" || (node2.nodeName === "AUDIO" || node2.nodeName === "VIDEO" || node2.nodeName === "DETAILS") && node2.getAttribute("tabindex") === null) {
    return 0;
  }
  return node2.tabIndex;
}
function isNonTabbableRadio(node2) {
  if (node2.tagName !== "INPUT" || node2.type !== "radio") {
    return false;
  }
  if (!node2.name) {
    return false;
  }
  const getRadio = (selector) => node2.ownerDocument.querySelector(`input[type="radio"]${selector}`);
  let roving = getRadio(`[name="${node2.name}"]:checked`);
  if (!roving) {
    roving = getRadio(`[name="${node2.name}"]`);
  }
  return roving !== node2;
}
function isNodeMatchingSelectorFocusable(node2) {
  if (node2.disabled || node2.tagName === "INPUT" && node2.type === "hidden" || isNonTabbableRadio(node2)) {
    return false;
  }
  return true;
}
function defaultGetTabbable(root2) {
  const regularTabNodes = [];
  const orderedTabNodes = [];
  Array.from(root2.querySelectorAll(candidatesSelector)).forEach((node2, i) => {
    const nodeTabIndex = getTabIndex(node2);
    if (nodeTabIndex === -1 || !isNodeMatchingSelectorFocusable(node2)) {
      return;
    }
    if (nodeTabIndex === 0) {
      regularTabNodes.push(node2);
    } else {
      orderedTabNodes.push({
        documentOrder: i,
        tabIndex: nodeTabIndex,
        node: node2
      });
    }
  });
  return orderedTabNodes.sort((a, b2) => a.tabIndex === b2.tabIndex ? a.documentOrder - b2.documentOrder : a.tabIndex - b2.tabIndex).map((a) => a.node).concat(regularTabNodes);
}
function defaultIsEnabled() {
  return true;
}
function FocusTrap(props) {
  const {
    children,
    disableAutoFocus = false,
    disableEnforceFocus = false,
    disableRestoreFocus = false,
    getTabbable = defaultGetTabbable,
    isEnabled = defaultIsEnabled,
    open
  } = props;
  const ignoreNextEnforceFocus = reactExports.useRef(false);
  const sentinelStart = reactExports.useRef(null);
  const sentinelEnd = reactExports.useRef(null);
  const nodeToRestore = reactExports.useRef(null);
  const reactFocusEventTarget = reactExports.useRef(null);
  const activated = reactExports.useRef(false);
  const rootRef = reactExports.useRef(null);
  const handleRef = useForkRef(getReactElementRef(children), rootRef);
  const lastKeydown = reactExports.useRef(null);
  reactExports.useEffect(() => {
    if (!open || !rootRef.current) {
      return;
    }
    activated.current = !disableAutoFocus;
  }, [disableAutoFocus, open]);
  reactExports.useEffect(() => {
    if (!open || !rootRef.current) {
      return;
    }
    const doc = ownerDocument(rootRef.current);
    if (!rootRef.current.contains(doc.activeElement)) {
      if (!rootRef.current.hasAttribute("tabIndex")) {
        rootRef.current.setAttribute("tabIndex", "-1");
      }
      if (activated.current) {
        rootRef.current.focus();
      }
    }
    return () => {
      if (!disableRestoreFocus) {
        if (nodeToRestore.current && nodeToRestore.current.focus) {
          ignoreNextEnforceFocus.current = true;
          nodeToRestore.current.focus();
        }
        nodeToRestore.current = null;
      }
    };
  }, [open]);
  reactExports.useEffect(() => {
    if (!open || !rootRef.current) {
      return;
    }
    const doc = ownerDocument(rootRef.current);
    const loopFocus = (nativeEvent) => {
      lastKeydown.current = nativeEvent;
      if (disableEnforceFocus || !isEnabled() || nativeEvent.key !== "Tab") {
        return;
      }
      if (doc.activeElement === rootRef.current && nativeEvent.shiftKey) {
        ignoreNextEnforceFocus.current = true;
        if (sentinelEnd.current) {
          sentinelEnd.current.focus();
        }
      }
    };
    const contain = () => {
      var _a, _b;
      const rootElement = rootRef.current;
      if (rootElement === null) {
        return;
      }
      if (!doc.hasFocus() || !isEnabled() || ignoreNextEnforceFocus.current) {
        ignoreNextEnforceFocus.current = false;
        return;
      }
      if (rootElement.contains(doc.activeElement)) {
        return;
      }
      if (disableEnforceFocus && doc.activeElement !== sentinelStart.current && doc.activeElement !== sentinelEnd.current) {
        return;
      }
      if (doc.activeElement !== reactFocusEventTarget.current) {
        reactFocusEventTarget.current = null;
      } else if (reactFocusEventTarget.current !== null) {
        return;
      }
      if (!activated.current) {
        return;
      }
      let tabbable = [];
      if (doc.activeElement === sentinelStart.current || doc.activeElement === sentinelEnd.current) {
        tabbable = getTabbable(rootRef.current);
      }
      if (tabbable.length > 0) {
        const isShiftTab = Boolean(((_a = lastKeydown.current) == null ? void 0 : _a.shiftKey) && ((_b = lastKeydown.current) == null ? void 0 : _b.key) === "Tab");
        const focusNext = tabbable[0];
        const focusPrevious = tabbable[tabbable.length - 1];
        if (typeof focusNext !== "string" && typeof focusPrevious !== "string") {
          if (isShiftTab) {
            focusPrevious.focus();
          } else {
            focusNext.focus();
          }
        }
      } else {
        rootElement.focus();
      }
    };
    doc.addEventListener("focusin", contain);
    doc.addEventListener("keydown", loopFocus, true);
    const interval = setInterval(() => {
      if (doc.activeElement && doc.activeElement.tagName === "BODY") {
        contain();
      }
    }, 50);
    return () => {
      clearInterval(interval);
      doc.removeEventListener("focusin", contain);
      doc.removeEventListener("keydown", loopFocus, true);
    };
  }, [disableAutoFocus, disableEnforceFocus, disableRestoreFocus, isEnabled, open, getTabbable]);
  const onFocus = (event) => {
    if (nodeToRestore.current === null) {
      nodeToRestore.current = event.relatedTarget;
    }
    activated.current = true;
    reactFocusEventTarget.current = event.target;
    const childrenPropsHandler = children.props.onFocus;
    if (childrenPropsHandler) {
      childrenPropsHandler(event);
    }
  };
  const handleFocusSentinel = (event) => {
    if (nodeToRestore.current === null) {
      nodeToRestore.current = event.relatedTarget;
    }
    activated.current = true;
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx("div", {
      tabIndex: open ? 0 : -1,
      onFocus: handleFocusSentinel,
      ref: sentinelStart,
      "data-testid": "sentinelStart"
    }), /* @__PURE__ */ reactExports.cloneElement(children, {
      ref: handleRef,
      onFocus
    }), /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
      tabIndex: open ? 0 : -1,
      onFocus: handleFocusSentinel,
      ref: sentinelEnd,
      "data-testid": "sentinelEnd"
    })]
  });
}
function getContainer$2(container) {
  return typeof container === "function" ? container() : container;
}
const Portal = /* @__PURE__ */ reactExports.forwardRef(function Portal2(props, forwardedRef) {
  const {
    children,
    container,
    disablePortal = false
  } = props;
  const [mountNode, setMountNode] = reactExports.useState(null);
  const handleRef = useForkRef(/* @__PURE__ */ reactExports.isValidElement(children) ? getReactElementRef(children) : null, forwardedRef);
  useEnhancedEffect(() => {
    if (!disablePortal) {
      setMountNode(getContainer$2(container) || document.body);
    }
  }, [container, disablePortal]);
  useEnhancedEffect(() => {
    if (mountNode && !disablePortal) {
      setRef(forwardedRef, mountNode);
      return () => {
        setRef(forwardedRef, null);
      };
    }
    return void 0;
  }, [forwardedRef, mountNode, disablePortal]);
  if (disablePortal) {
    if (/* @__PURE__ */ reactExports.isValidElement(children)) {
      const newProps = {
        ref: handleRef
      };
      return /* @__PURE__ */ reactExports.cloneElement(children, newProps);
    }
    return children;
  }
  return mountNode ? /* @__PURE__ */ reactDomExports.createPortal(children, mountNode) : mountNode;
});
function merge$1(acc, item) {
  if (!item) {
    return acc;
  }
  return deepmerge(acc, item, {
    clone: false
    // No need to clone deep, it's way faster.
  });
}
function sortContainerQueries(theme, css2) {
  if (!theme.containerQueries) {
    return css2;
  }
  const sorted = Object.keys(css2).filter((key) => key.startsWith("@container")).sort((a, b2) => {
    var _a, _b;
    const regex = /min-width:\s*([0-9.]+)/;
    return +(((_a = a.match(regex)) == null ? void 0 : _a[1]) || 0) - +(((_b = b2.match(regex)) == null ? void 0 : _b[1]) || 0);
  });
  if (!sorted.length) {
    return css2;
  }
  return sorted.reduce((acc, key) => {
    const value = css2[key];
    delete acc[key];
    acc[key] = value;
    return acc;
  }, {
    ...css2
  });
}
function isCqShorthand(breakpointKeys, value) {
  return value === "@" || value.startsWith("@") && (breakpointKeys.some((key) => value.startsWith(`@${key}`)) || !!value.match(/^@\d/));
}
function getContainerQuery(theme, shorthand) {
  const matches = shorthand.match(/^@([^/]+)?\/?(.+)?$/);
  if (!matches) {
    return null;
  }
  const [, containerQuery, containerName] = matches;
  const value = Number.isNaN(+containerQuery) ? containerQuery || 0 : +containerQuery;
  return theme.containerQueries(containerName).up(value);
}
function cssContainerQueries(themeInput) {
  const toContainerQuery = (mediaQuery, name) => mediaQuery.replace("@media", name ? `@container ${name}` : "@container");
  function attachCq(node22, name) {
    node22.up = (...args) => toContainerQuery(themeInput.breakpoints.up(...args), name);
    node22.down = (...args) => toContainerQuery(themeInput.breakpoints.down(...args), name);
    node22.between = (...args) => toContainerQuery(themeInput.breakpoints.between(...args), name);
    node22.only = (...args) => toContainerQuery(themeInput.breakpoints.only(...args), name);
    node22.not = (...args) => {
      const result = toContainerQuery(themeInput.breakpoints.not(...args), name);
      if (result.includes("not all and")) {
        return result.replace("not all and ", "").replace("min-width:", "width<").replace("max-width:", "width>").replace("and", "or");
      }
      return result;
    };
  }
  const node2 = {};
  const containerQueries = (name) => {
    attachCq(node2, name);
    return node2;
  };
  attachCq(containerQueries);
  return {
    ...themeInput,
    containerQueries
  };
}
const values$1 = {
  xs: 0,
  // phone
  sm: 600,
  // tablet
  md: 900,
  // small laptop
  lg: 1200,
  // desktop
  xl: 1536
  // large screen
};
const defaultBreakpoints = {
  // Sorted ASC by size. That's important.
  // It can't be configured as it's used statically for propTypes.
  keys: ["xs", "sm", "md", "lg", "xl"],
  up: (key) => `@media (min-width:${values$1[key]}px)`
};
const defaultContainerQueries = {
  containerQueries: (containerName) => ({
    up: (key) => {
      let result = typeof key === "number" ? key : values$1[key] || key;
      if (typeof result === "number") {
        result = `${result}px`;
      }
      return containerName ? `@container ${containerName} (min-width:${result})` : `@container (min-width:${result})`;
    }
  })
};
function handleBreakpoints(props, propValue, styleFromPropValue) {
  const theme = props.theme || {};
  if (Array.isArray(propValue)) {
    const themeBreakpoints = theme.breakpoints || defaultBreakpoints;
    return propValue.reduce((acc, item, index) => {
      acc[themeBreakpoints.up(themeBreakpoints.keys[index])] = styleFromPropValue(propValue[index]);
      return acc;
    }, {});
  }
  if (typeof propValue === "object") {
    const themeBreakpoints = theme.breakpoints || defaultBreakpoints;
    return Object.keys(propValue).reduce((acc, breakpoint) => {
      if (isCqShorthand(themeBreakpoints.keys, breakpoint)) {
        const containerKey = getContainerQuery(theme.containerQueries ? theme : defaultContainerQueries, breakpoint);
        if (containerKey) {
          acc[containerKey] = styleFromPropValue(propValue[breakpoint], breakpoint);
        }
      } else if (Object.keys(themeBreakpoints.values || values$1).includes(breakpoint)) {
        const mediaKey = themeBreakpoints.up(breakpoint);
        acc[mediaKey] = styleFromPropValue(propValue[breakpoint], breakpoint);
      } else {
        const cssKey = breakpoint;
        acc[cssKey] = propValue[cssKey];
      }
      return acc;
    }, {});
  }
  const output = styleFromPropValue(propValue);
  return output;
}
function createEmptyBreakpointObject(breakpointsInput = {}) {
  var _a;
  const breakpointsInOrder = (_a = breakpointsInput.keys) == null ? void 0 : _a.reduce((acc, key) => {
    const breakpointStyleKey = breakpointsInput.up(key);
    acc[breakpointStyleKey] = {};
    return acc;
  }, {});
  return breakpointsInOrder || {};
}
function removeUnusedBreakpoints(breakpointKeys, style2) {
  return breakpointKeys.reduce((acc, key) => {
    const breakpointOutput = acc[key];
    const isBreakpointUnused = !breakpointOutput || Object.keys(breakpointOutput).length === 0;
    if (isBreakpointUnused) {
      delete acc[key];
    }
    return acc;
  }, style2);
}
function mergeBreakpointsInOrder(breakpointsInput, ...styles2) {
  const emptyBreakpoints = createEmptyBreakpointObject(breakpointsInput);
  const mergedOutput = [emptyBreakpoints, ...styles2].reduce((prev2, next11) => deepmerge(prev2, next11), {});
  return removeUnusedBreakpoints(Object.keys(emptyBreakpoints), mergedOutput);
}
function computeBreakpointsBase(breakpointValues, themeBreakpoints) {
  if (typeof breakpointValues !== "object") {
    return {};
  }
  const base2 = {};
  const breakpointsKeys = Object.keys(themeBreakpoints);
  if (Array.isArray(breakpointValues)) {
    breakpointsKeys.forEach((breakpoint, i) => {
      if (i < breakpointValues.length) {
        base2[breakpoint] = true;
      }
    });
  } else {
    breakpointsKeys.forEach((breakpoint) => {
      if (breakpointValues[breakpoint] != null) {
        base2[breakpoint] = true;
      }
    });
  }
  return base2;
}
function resolveBreakpointValues({
  values: breakpointValues,
  breakpoints: themeBreakpoints,
  base: customBase
}) {
  const base2 = customBase || computeBreakpointsBase(breakpointValues, themeBreakpoints);
  const keys6 = Object.keys(base2);
  if (keys6.length === 0) {
    return breakpointValues;
  }
  let previous;
  return keys6.reduce((acc, breakpoint, i) => {
    if (Array.isArray(breakpointValues)) {
      acc[breakpoint] = breakpointValues[i] != null ? breakpointValues[i] : breakpointValues[previous];
      previous = i;
    } else if (typeof breakpointValues === "object") {
      acc[breakpoint] = breakpointValues[breakpoint] != null ? breakpointValues[breakpoint] : breakpointValues[previous];
      previous = breakpoint;
    } else {
      acc[breakpoint] = breakpointValues;
    }
    return acc;
  }, {});
}
function getPath(obj, path2, checkVars = true) {
  if (!path2 || typeof path2 !== "string") {
    return null;
  }
  if (obj && obj.vars && checkVars) {
    const val = `vars.${path2}`.split(".").reduce((acc, item) => acc && acc[item] ? acc[item] : null, obj);
    if (val != null) {
      return val;
    }
  }
  return path2.split(".").reduce((acc, item) => {
    if (acc && acc[item] != null) {
      return acc[item];
    }
    return null;
  }, obj);
}
function getStyleValue(themeMapping, transform, propValueFinal, userValue = propValueFinal) {
  let value;
  if (typeof themeMapping === "function") {
    value = themeMapping(propValueFinal);
  } else if (Array.isArray(themeMapping)) {
    value = themeMapping[propValueFinal] || userValue;
  } else {
    value = getPath(themeMapping, propValueFinal) || userValue;
  }
  if (transform) {
    value = transform(value, userValue, themeMapping);
  }
  return value;
}
function style$2(options) {
  const {
    prop,
    cssProperty = options.prop,
    themeKey,
    transform
  } = options;
  const fn = (props) => {
    if (props[prop] == null) {
      return null;
    }
    const propValue = props[prop];
    const theme = props.theme;
    const themeMapping = getPath(theme, themeKey) || {};
    const styleFromPropValue = (propValueFinal) => {
      let value = getStyleValue(themeMapping, transform, propValueFinal);
      if (propValueFinal === value && typeof propValueFinal === "string") {
        value = getStyleValue(themeMapping, transform, `${prop}${propValueFinal === "default" ? "" : capitalize(propValueFinal)}`, propValueFinal);
      }
      if (cssProperty === false) {
        return value;
      }
      return {
        [cssProperty]: value
      };
    };
    return handleBreakpoints(props, propValue, styleFromPropValue);
  };
  fn.propTypes = {};
  fn.filterProps = [prop];
  return fn;
}
function memoize$2(fn) {
  const cache = {};
  return (arg2) => {
    if (cache[arg2] === void 0) {
      cache[arg2] = fn(arg2);
    }
    return cache[arg2];
  };
}
const properties = {
  m: "margin",
  p: "padding"
};
const directions = {
  t: "Top",
  r: "Right",
  b: "Bottom",
  l: "Left",
  x: ["Left", "Right"],
  y: ["Top", "Bottom"]
};
const aliases = {
  marginX: "mx",
  marginY: "my",
  paddingX: "px",
  paddingY: "py"
};
const getCssProperties = memoize$2((prop) => {
  if (prop.length > 2) {
    if (aliases[prop]) {
      prop = aliases[prop];
    } else {
      return [prop];
    }
  }
  const [a, b2] = prop.split("");
  const property = properties[a];
  const direction = directions[b2] || "";
  return Array.isArray(direction) ? direction.map((dir) => property + dir) : [property + direction];
});
const marginKeys = ["m", "mt", "mr", "mb", "ml", "mx", "my", "margin", "marginTop", "marginRight", "marginBottom", "marginLeft", "marginX", "marginY", "marginInline", "marginInlineStart", "marginInlineEnd", "marginBlock", "marginBlockStart", "marginBlockEnd"];
const paddingKeys = ["p", "pt", "pr", "pb", "pl", "px", "py", "padding", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "paddingX", "paddingY", "paddingInline", "paddingInlineStart", "paddingInlineEnd", "paddingBlock", "paddingBlockStart", "paddingBlockEnd"];
[...marginKeys, ...paddingKeys];
function createUnaryUnit(theme, themeKey, defaultValue, propName) {
  const themeSpacing = getPath(theme, themeKey, true) ?? defaultValue;
  if (typeof themeSpacing === "number" || typeof themeSpacing === "string") {
    return (val) => {
      if (typeof val === "string") {
        return val;
      }
      if (typeof themeSpacing === "string") {
        return `calc(${val} * ${themeSpacing})`;
      }
      return themeSpacing * val;
    };
  }
  if (Array.isArray(themeSpacing)) {
    return (val) => {
      if (typeof val === "string") {
        return val;
      }
      const abs2 = Math.abs(val);
      const transformed = themeSpacing[abs2];
      if (val >= 0) {
        return transformed;
      }
      if (typeof transformed === "number") {
        return -transformed;
      }
      return `-${transformed}`;
    };
  }
  if (typeof themeSpacing === "function") {
    return themeSpacing;
  }
  return () => void 0;
}
function createUnarySpacing(theme) {
  return createUnaryUnit(theme, "spacing", 8);
}
function getValue(transformer, propValue) {
  if (typeof propValue === "string" || propValue == null) {
    return propValue;
  }
  return transformer(propValue);
}
function getStyleFromPropValue(cssProperties, transformer) {
  return (propValue) => cssProperties.reduce((acc, cssProperty) => {
    acc[cssProperty] = getValue(transformer, propValue);
    return acc;
  }, {});
}
function resolveCssProperty(props, keys6, prop, transformer) {
  if (!keys6.includes(prop)) {
    return null;
  }
  const cssProperties = getCssProperties(prop);
  const styleFromPropValue = getStyleFromPropValue(cssProperties, transformer);
  const propValue = props[prop];
  return handleBreakpoints(props, propValue, styleFromPropValue);
}
function style$1(props, keys6) {
  const transformer = createUnarySpacing(props.theme);
  return Object.keys(props).map((prop) => resolveCssProperty(props, keys6, prop, transformer)).reduce(merge$1, {});
}
function margin(props) {
  return style$1(props, marginKeys);
}
margin.propTypes = {};
margin.filterProps = marginKeys;
function padding(props) {
  return style$1(props, paddingKeys);
}
padding.propTypes = {};
padding.filterProps = paddingKeys;
function compose(...styles2) {
  const handlers = styles2.reduce((acc, style2) => {
    style2.filterProps.forEach((prop) => {
      acc[prop] = style2;
    });
    return acc;
  }, {});
  const fn = (props) => {
    return Object.keys(props).reduce((acc, prop) => {
      if (handlers[prop]) {
        return merge$1(acc, handlers[prop](props));
      }
      return acc;
    }, {});
  };
  fn.propTypes = {};
  fn.filterProps = styles2.reduce((acc, style2) => acc.concat(style2.filterProps), []);
  return fn;
}
function borderTransform(value) {
  if (typeof value !== "number") {
    return value;
  }
  return `${value}px solid`;
}
function createBorderStyle(prop, transform) {
  return style$2({
    prop,
    themeKey: "borders",
    transform
  });
}
const border = createBorderStyle("border", borderTransform);
const borderTop = createBorderStyle("borderTop", borderTransform);
const borderRight = createBorderStyle("borderRight", borderTransform);
const borderBottom = createBorderStyle("borderBottom", borderTransform);
const borderLeft = createBorderStyle("borderLeft", borderTransform);
const borderColor = createBorderStyle("borderColor");
const borderTopColor = createBorderStyle("borderTopColor");
const borderRightColor = createBorderStyle("borderRightColor");
const borderBottomColor = createBorderStyle("borderBottomColor");
const borderLeftColor = createBorderStyle("borderLeftColor");
const outline = createBorderStyle("outline", borderTransform);
const outlineColor = createBorderStyle("outlineColor");
const borderRadius = (props) => {
  if (props.borderRadius !== void 0 && props.borderRadius !== null) {
    const transformer = createUnaryUnit(props.theme, "shape.borderRadius", 4);
    const styleFromPropValue = (propValue) => ({
      borderRadius: getValue(transformer, propValue)
    });
    return handleBreakpoints(props, props.borderRadius, styleFromPropValue);
  }
  return null;
};
borderRadius.propTypes = {};
borderRadius.filterProps = ["borderRadius"];
compose(border, borderTop, borderRight, borderBottom, borderLeft, borderColor, borderTopColor, borderRightColor, borderBottomColor, borderLeftColor, borderRadius, outline, outlineColor);
const gap = (props) => {
  if (props.gap !== void 0 && props.gap !== null) {
    const transformer = createUnaryUnit(props.theme, "spacing", 8);
    const styleFromPropValue = (propValue) => ({
      gap: getValue(transformer, propValue)
    });
    return handleBreakpoints(props, props.gap, styleFromPropValue);
  }
  return null;
};
gap.propTypes = {};
gap.filterProps = ["gap"];
const columnGap = (props) => {
  if (props.columnGap !== void 0 && props.columnGap !== null) {
    const transformer = createUnaryUnit(props.theme, "spacing", 8);
    const styleFromPropValue = (propValue) => ({
      columnGap: getValue(transformer, propValue)
    });
    return handleBreakpoints(props, props.columnGap, styleFromPropValue);
  }
  return null;
};
columnGap.propTypes = {};
columnGap.filterProps = ["columnGap"];
const rowGap = (props) => {
  if (props.rowGap !== void 0 && props.rowGap !== null) {
    const transformer = createUnaryUnit(props.theme, "spacing", 8);
    const styleFromPropValue = (propValue) => ({
      rowGap: getValue(transformer, propValue)
    });
    return handleBreakpoints(props, props.rowGap, styleFromPropValue);
  }
  return null;
};
rowGap.propTypes = {};
rowGap.filterProps = ["rowGap"];
const gridColumn = style$2({
  prop: "gridColumn"
});
const gridRow = style$2({
  prop: "gridRow"
});
const gridAutoFlow = style$2({
  prop: "gridAutoFlow"
});
const gridAutoColumns = style$2({
  prop: "gridAutoColumns"
});
const gridAutoRows = style$2({
  prop: "gridAutoRows"
});
const gridTemplateColumns = style$2({
  prop: "gridTemplateColumns"
});
const gridTemplateRows = style$2({
  prop: "gridTemplateRows"
});
const gridTemplateAreas = style$2({
  prop: "gridTemplateAreas"
});
const gridArea = style$2({
  prop: "gridArea"
});
compose(gap, columnGap, rowGap, gridColumn, gridRow, gridAutoFlow, gridAutoColumns, gridAutoRows, gridTemplateColumns, gridTemplateRows, gridTemplateAreas, gridArea);
function paletteTransform(value, userValue) {
  if (userValue === "grey") {
    return userValue;
  }
  return value;
}
const color = style$2({
  prop: "color",
  themeKey: "palette",
  transform: paletteTransform
});
const bgcolor = style$2({
  prop: "bgcolor",
  cssProperty: "backgroundColor",
  themeKey: "palette",
  transform: paletteTransform
});
const backgroundColor = style$2({
  prop: "backgroundColor",
  themeKey: "palette",
  transform: paletteTransform
});
compose(color, bgcolor, backgroundColor);
function sizingTransform(value) {
  return value <= 1 && value !== 0 ? `${value * 100}%` : value;
}
const width = style$2({
  prop: "width",
  transform: sizingTransform
});
const maxWidth = (props) => {
  if (props.maxWidth !== void 0 && props.maxWidth !== null) {
    const styleFromPropValue = (propValue) => {
      var _a, _b, _c, _d, _e;
      const breakpoint = ((_c = (_b = (_a = props.theme) == null ? void 0 : _a.breakpoints) == null ? void 0 : _b.values) == null ? void 0 : _c[propValue]) || values$1[propValue];
      if (!breakpoint) {
        return {
          maxWidth: sizingTransform(propValue)
        };
      }
      if (((_e = (_d = props.theme) == null ? void 0 : _d.breakpoints) == null ? void 0 : _e.unit) !== "px") {
        return {
          maxWidth: `${breakpoint}${props.theme.breakpoints.unit}`
        };
      }
      return {
        maxWidth: breakpoint
      };
    };
    return handleBreakpoints(props, props.maxWidth, styleFromPropValue);
  }
  return null;
};
maxWidth.filterProps = ["maxWidth"];
const minWidth = style$2({
  prop: "minWidth",
  transform: sizingTransform
});
const height = style$2({
  prop: "height",
  transform: sizingTransform
});
const maxHeight = style$2({
  prop: "maxHeight",
  transform: sizingTransform
});
const minHeight = style$2({
  prop: "minHeight",
  transform: sizingTransform
});
style$2({
  prop: "size",
  cssProperty: "width",
  transform: sizingTransform
});
style$2({
  prop: "size",
  cssProperty: "height",
  transform: sizingTransform
});
const boxSizing = style$2({
  prop: "boxSizing"
});
compose(width, maxWidth, minWidth, height, maxHeight, minHeight, boxSizing);
const defaultSxConfig = {
  // borders
  border: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderTop: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderRight: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderBottom: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderLeft: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderColor: {
    themeKey: "palette"
  },
  borderTopColor: {
    themeKey: "palette"
  },
  borderRightColor: {
    themeKey: "palette"
  },
  borderBottomColor: {
    themeKey: "palette"
  },
  borderLeftColor: {
    themeKey: "palette"
  },
  outline: {
    themeKey: "borders",
    transform: borderTransform
  },
  outlineColor: {
    themeKey: "palette"
  },
  borderRadius: {
    themeKey: "shape.borderRadius",
    style: borderRadius
  },
  // palette
  color: {
    themeKey: "palette",
    transform: paletteTransform
  },
  bgcolor: {
    themeKey: "palette",
    cssProperty: "backgroundColor",
    transform: paletteTransform
  },
  backgroundColor: {
    themeKey: "palette",
    transform: paletteTransform
  },
  // spacing
  p: {
    style: padding
  },
  pt: {
    style: padding
  },
  pr: {
    style: padding
  },
  pb: {
    style: padding
  },
  pl: {
    style: padding
  },
  px: {
    style: padding
  },
  py: {
    style: padding
  },
  padding: {
    style: padding
  },
  paddingTop: {
    style: padding
  },
  paddingRight: {
    style: padding
  },
  paddingBottom: {
    style: padding
  },
  paddingLeft: {
    style: padding
  },
  paddingX: {
    style: padding
  },
  paddingY: {
    style: padding
  },
  paddingInline: {
    style: padding
  },
  paddingInlineStart: {
    style: padding
  },
  paddingInlineEnd: {
    style: padding
  },
  paddingBlock: {
    style: padding
  },
  paddingBlockStart: {
    style: padding
  },
  paddingBlockEnd: {
    style: padding
  },
  m: {
    style: margin
  },
  mt: {
    style: margin
  },
  mr: {
    style: margin
  },
  mb: {
    style: margin
  },
  ml: {
    style: margin
  },
  mx: {
    style: margin
  },
  my: {
    style: margin
  },
  margin: {
    style: margin
  },
  marginTop: {
    style: margin
  },
  marginRight: {
    style: margin
  },
  marginBottom: {
    style: margin
  },
  marginLeft: {
    style: margin
  },
  marginX: {
    style: margin
  },
  marginY: {
    style: margin
  },
  marginInline: {
    style: margin
  },
  marginInlineStart: {
    style: margin
  },
  marginInlineEnd: {
    style: margin
  },
  marginBlock: {
    style: margin
  },
  marginBlockStart: {
    style: margin
  },
  marginBlockEnd: {
    style: margin
  },
  // display
  displayPrint: {
    cssProperty: false,
    transform: (value) => ({
      "@media print": {
        display: value
      }
    })
  },
  display: {},
  overflow: {},
  textOverflow: {},
  visibility: {},
  whiteSpace: {},
  // flexbox
  flexBasis: {},
  flexDirection: {},
  flexWrap: {},
  justifyContent: {},
  alignItems: {},
  alignContent: {},
  order: {},
  flex: {},
  flexGrow: {},
  flexShrink: {},
  alignSelf: {},
  justifyItems: {},
  justifySelf: {},
  // grid
  gap: {
    style: gap
  },
  rowGap: {
    style: rowGap
  },
  columnGap: {
    style: columnGap
  },
  gridColumn: {},
  gridRow: {},
  gridAutoFlow: {},
  gridAutoColumns: {},
  gridAutoRows: {},
  gridTemplateColumns: {},
  gridTemplateRows: {},
  gridTemplateAreas: {},
  gridArea: {},
  // positions
  position: {},
  zIndex: {
    themeKey: "zIndex"
  },
  top: {},
  right: {},
  bottom: {},
  left: {},
  // shadows
  boxShadow: {
    themeKey: "shadows"
  },
  // sizing
  width: {
    transform: sizingTransform
  },
  maxWidth: {
    style: maxWidth
  },
  minWidth: {
    transform: sizingTransform
  },
  height: {
    transform: sizingTransform
  },
  maxHeight: {
    transform: sizingTransform
  },
  minHeight: {
    transform: sizingTransform
  },
  boxSizing: {},
  // typography
  font: {
    themeKey: "font"
  },
  fontFamily: {
    themeKey: "typography"
  },
  fontSize: {
    themeKey: "typography"
  },
  fontStyle: {
    themeKey: "typography"
  },
  fontWeight: {
    themeKey: "typography"
  },
  letterSpacing: {},
  textTransform: {},
  lineHeight: {},
  textAlign: {},
  typography: {
    cssProperty: false,
    themeKey: "typography"
  }
};
function objectsHaveSameKeys(...objects) {
  const allKeys = objects.reduce((keys6, object) => keys6.concat(Object.keys(object)), []);
  const union4 = new Set(allKeys);
  return objects.every((object) => union4.size === Object.keys(object).length);
}
function callIfFn(maybeFn, arg2) {
  return typeof maybeFn === "function" ? maybeFn(arg2) : maybeFn;
}
function unstable_createStyleFunctionSx() {
  function getThemeValue(prop, val, theme, config2) {
    const props = {
      [prop]: val,
      theme
    };
    const options = config2[prop];
    if (!options) {
      return {
        [prop]: val
      };
    }
    const {
      cssProperty = prop,
      themeKey,
      transform,
      style: style2
    } = options;
    if (val == null) {
      return null;
    }
    if (themeKey === "typography" && val === "inherit") {
      return {
        [prop]: val
      };
    }
    const themeMapping = getPath(theme, themeKey) || {};
    if (style2) {
      return style2(props);
    }
    const styleFromPropValue = (propValueFinal) => {
      let value = getStyleValue(themeMapping, transform, propValueFinal);
      if (propValueFinal === value && typeof propValueFinal === "string") {
        value = getStyleValue(themeMapping, transform, `${prop}${propValueFinal === "default" ? "" : capitalize(propValueFinal)}`, propValueFinal);
      }
      if (cssProperty === false) {
        return value;
      }
      return {
        [cssProperty]: value
      };
    };
    return handleBreakpoints(props, val, styleFromPropValue);
  }
  function styleFunctionSx2(props) {
    const {
      sx,
      theme = {}
    } = props || {};
    if (!sx) {
      return null;
    }
    const config2 = theme.unstable_sxConfig ?? defaultSxConfig;
    function traverse(sxInput) {
      let sxObject = sxInput;
      if (typeof sxInput === "function") {
        sxObject = sxInput(theme);
      } else if (typeof sxInput !== "object") {
        return sxInput;
      }
      if (!sxObject) {
        return null;
      }
      const emptyBreakpoints = createEmptyBreakpointObject(theme.breakpoints);
      const breakpointsKeys = Object.keys(emptyBreakpoints);
      let css2 = emptyBreakpoints;
      Object.keys(sxObject).forEach((styleKey) => {
        const value = callIfFn(sxObject[styleKey], theme);
        if (value !== null && value !== void 0) {
          if (typeof value === "object") {
            if (config2[styleKey]) {
              css2 = merge$1(css2, getThemeValue(styleKey, value, theme, config2));
            } else {
              const breakpointsValues = handleBreakpoints({
                theme
              }, value, (x2) => ({
                [styleKey]: x2
              }));
              if (objectsHaveSameKeys(breakpointsValues, value)) {
                css2[styleKey] = styleFunctionSx2({
                  sx: value,
                  theme
                });
              } else {
                css2 = merge$1(css2, breakpointsValues);
              }
            }
          } else {
            css2 = merge$1(css2, getThemeValue(styleKey, value, theme, config2));
          }
        }
      });
      return sortContainerQueries(theme, removeUnusedBreakpoints(breakpointsKeys, css2));
    }
    return Array.isArray(sx) ? sx.map(traverse) : traverse(sx);
  }
  return styleFunctionSx2;
}
const styleFunctionSx = unstable_createStyleFunctionSx();
styleFunctionSx.filterProps = ["sx"];
const splitProps = (props) => {
  var _a;
  const result = {
    systemProps: {},
    otherProps: {}
  };
  const config2 = ((_a = props == null ? void 0 : props.theme) == null ? void 0 : _a.unstable_sxConfig) ?? defaultSxConfig;
  Object.keys(props).forEach((prop) => {
    if (config2[prop]) {
      result.systemProps[prop] = props[prop];
    } else {
      result.otherProps[prop] = props[prop];
    }
  });
  return result;
};
function extendSxProp$1(props) {
  const {
    sx: inSx,
    ...other
  } = props;
  const {
    systemProps,
    otherProps
  } = splitProps(other);
  let finalSx;
  if (Array.isArray(inSx)) {
    finalSx = [systemProps, ...inSx];
  } else if (typeof inSx === "function") {
    finalSx = (...args) => {
      const result = inSx(...args);
      if (!isPlainObject$2(result)) {
        return systemProps;
      }
      return {
        ...systemProps,
        ...result
      };
    };
  } else {
    finalSx = {
      ...systemProps,
      ...inSx
    };
  }
  return {
    ...otherProps,
    sx: finalSx
  };
}
function _extends$1() {
  _extends$1 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$1.apply(this, arguments);
}
function memoize$1(fn) {
  var cache = /* @__PURE__ */ Object.create(null);
  return function(arg2) {
    if (cache[arg2] === void 0) cache[arg2] = fn(arg2);
    return cache[arg2];
  };
}
var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
var isPropValid = /* @__PURE__ */ memoize$1(
  function(prop) {
    return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;
  }
  /* Z+1 */
);
function sheetForTag$1(tag) {
  if (tag.sheet) {
    return tag.sheet;
  }
  for (var i = 0; i < document.styleSheets.length; i++) {
    if (document.styleSheets[i].ownerNode === tag) {
      return document.styleSheets[i];
    }
  }
}
function createStyleElement$1(options) {
  var tag = document.createElement("style");
  tag.setAttribute("data-emotion", options.key);
  if (options.nonce !== void 0) {
    tag.setAttribute("nonce", options.nonce);
  }
  tag.appendChild(document.createTextNode(""));
  tag.setAttribute("data-s", "");
  return tag;
}
var StyleSheet$1 = /* @__PURE__ */ function() {
  function StyleSheet2(options) {
    var _this = this;
    this._insertTag = function(tag) {
      var before;
      if (_this.tags.length === 0) {
        if (_this.insertionPoint) {
          before = _this.insertionPoint.nextSibling;
        } else if (_this.prepend) {
          before = _this.container.firstChild;
        } else {
          before = _this.before;
        }
      } else {
        before = _this.tags[_this.tags.length - 1].nextSibling;
      }
      _this.container.insertBefore(tag, before);
      _this.tags.push(tag);
    };
    this.isSpeedy = options.speedy === void 0 ? true : options.speedy;
    this.tags = [];
    this.ctr = 0;
    this.nonce = options.nonce;
    this.key = options.key;
    this.container = options.container;
    this.prepend = options.prepend;
    this.insertionPoint = options.insertionPoint;
    this.before = null;
  }
  var _proto = StyleSheet2.prototype;
  _proto.hydrate = function hydrate(nodes) {
    nodes.forEach(this._insertTag);
  };
  _proto.insert = function insert(rule) {
    if (this.ctr % (this.isSpeedy ? 65e3 : 1) === 0) {
      this._insertTag(createStyleElement$1(this));
    }
    var tag = this.tags[this.tags.length - 1];
    if (this.isSpeedy) {
      var sheet = sheetForTag$1(tag);
      try {
        sheet.insertRule(rule, sheet.cssRules.length);
      } catch (e2) {
      }
    } else {
      tag.appendChild(document.createTextNode(rule));
    }
    this.ctr++;
  };
  _proto.flush = function flush() {
    this.tags.forEach(function(tag) {
      return tag.parentNode && tag.parentNode.removeChild(tag);
    });
    this.tags = [];
    this.ctr = 0;
  };
  return StyleSheet2;
}();
var MS$1 = "-ms-";
var MOZ$1 = "-moz-";
var WEBKIT$1 = "-webkit-";
var COMMENT$1 = "comm";
var RULESET$1 = "rule";
var DECLARATION$1 = "decl";
var IMPORT$1 = "@import";
var KEYFRAMES$1 = "@keyframes";
var LAYER$1 = "@layer";
var abs$1 = Math.abs;
var from$1 = String.fromCharCode;
var assign$1 = Object.assign;
function hash$1(value, length2) {
  return charat$1(value, 0) ^ 45 ? (((length2 << 2 ^ charat$1(value, 0)) << 2 ^ charat$1(value, 1)) << 2 ^ charat$1(value, 2)) << 2 ^ charat$1(value, 3) : 0;
}
function trim$2(value) {
  return value.trim();
}
function match$1(value, pattern) {
  return (value = pattern.exec(value)) ? value[0] : value;
}
function replace$1(value, pattern, replacement2) {
  return value.replace(pattern, replacement2);
}
function indexof$1(value, search) {
  return value.indexOf(search);
}
function charat$1(value, index) {
  return value.charCodeAt(index) | 0;
}
function substr$1(value, begin, end) {
  return value.slice(begin, end);
}
function strlen$1(value) {
  return value.length;
}
function sizeof$1(value) {
  return value.length;
}
function append$1(value, array) {
  return array.push(value), value;
}
function combine$1(array, callback2) {
  return array.map(callback2).join("");
}
var line$1 = 1;
var column$1 = 1;
var length$1 = 0;
var position$1 = 0;
var character$1 = 0;
var characters$1 = "";
function node$1(value, root2, parent, type, props, children, length2) {
  return { value, root: root2, parent, type, props, children, line: line$1, column: column$1, length: length2, return: "" };
}
function copy$1(root2, props) {
  return assign$1(node$1("", null, null, "", null, null, 0), root2, { length: -root2.length }, props);
}
function char$1() {
  return character$1;
}
function prev$1() {
  character$1 = position$1 > 0 ? charat$1(characters$1, --position$1) : 0;
  if (column$1--, character$1 === 10)
    column$1 = 1, line$1--;
  return character$1;
}
function next$1() {
  character$1 = position$1 < length$1 ? charat$1(characters$1, position$1++) : 0;
  if (column$1++, character$1 === 10)
    column$1 = 1, line$1++;
  return character$1;
}
function peek$1() {
  return charat$1(characters$1, position$1);
}
function caret$1() {
  return position$1;
}
function slice$1(begin, end) {
  return substr$1(characters$1, begin, end);
}
function token$1(type) {
  switch (type) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function alloc$1(value) {
  return line$1 = column$1 = 1, length$1 = strlen$1(characters$1 = value), position$1 = 0, [];
}
function dealloc$1(value) {
  return characters$1 = "", value;
}
function delimit$1(type) {
  return trim$2(slice$1(position$1 - 1, delimiter$1(type === 91 ? type + 2 : type === 40 ? type + 1 : type)));
}
function whitespace$1(type) {
  while (character$1 = peek$1())
    if (character$1 < 33)
      next$1();
    else
      break;
  return token$1(type) > 2 || token$1(character$1) > 3 ? "" : " ";
}
function escaping$1(index, count) {
  while (--count && next$1())
    if (character$1 < 48 || character$1 > 102 || character$1 > 57 && character$1 < 65 || character$1 > 70 && character$1 < 97)
      break;
  return slice$1(index, caret$1() + (count < 6 && peek$1() == 32 && next$1() == 32));
}
function delimiter$1(type) {
  while (next$1())
    switch (character$1) {
      case type:
        return position$1;
      case 34:
      case 39:
        if (type !== 34 && type !== 39)
          delimiter$1(character$1);
        break;
      case 40:
        if (type === 41)
          delimiter$1(type);
        break;
      case 92:
        next$1();
        break;
    }
  return position$1;
}
function commenter$1(type, index) {
  while (next$1())
    if (type + character$1 === 47 + 10)
      break;
    else if (type + character$1 === 42 + 42 && peek$1() === 47)
      break;
  return "/*" + slice$1(index, position$1 - 1) + "*" + from$1(type === 47 ? type : next$1());
}
function identifier$1(index) {
  while (!token$1(peek$1()))
    next$1();
  return slice$1(index, position$1);
}
function compile$1(value) {
  return dealloc$1(parse$1("", null, null, null, [""], value = alloc$1(value), 0, [0], value));
}
function parse$1(value, root2, parent, rule, rules, rulesets, pseudo, points, declarations) {
  var index = 0;
  var offset = 0;
  var length2 = pseudo;
  var atrule = 0;
  var property = 0;
  var previous = 0;
  var variable = 1;
  var scanning = 1;
  var ampersand = 1;
  var character2 = 0;
  var type = "";
  var props = rules;
  var children = rulesets;
  var reference = rule;
  var characters2 = type;
  while (scanning)
    switch (previous = character2, character2 = next$1()) {
      case 40:
        if (previous != 108 && charat$1(characters2, length2 - 1) == 58) {
          if (indexof$1(characters2 += replace$1(delimit$1(character2), "&", "&\f"), "&\f") != -1)
            ampersand = -1;
          break;
        }
      case 34:
      case 39:
      case 91:
        characters2 += delimit$1(character2);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        characters2 += whitespace$1(previous);
        break;
      case 92:
        characters2 += escaping$1(caret$1() - 1, 7);
        continue;
      case 47:
        switch (peek$1()) {
          case 42:
          case 47:
            append$1(comment$1(commenter$1(next$1(), caret$1()), root2, parent), declarations);
            break;
          default:
            characters2 += "/";
        }
        break;
      case 123 * variable:
        points[index++] = strlen$1(characters2) * ampersand;
      case 125 * variable:
      case 59:
      case 0:
        switch (character2) {
          case 0:
          case 125:
            scanning = 0;
          case 59 + offset:
            if (ampersand == -1) characters2 = replace$1(characters2, /\f/g, "");
            if (property > 0 && strlen$1(characters2) - length2)
              append$1(property > 32 ? declaration$1(characters2 + ";", rule, parent, length2 - 1) : declaration$1(replace$1(characters2, " ", "") + ";", rule, parent, length2 - 2), declarations);
            break;
          case 59:
            characters2 += ";";
          default:
            append$1(reference = ruleset$1(characters2, root2, parent, index, offset, rules, points, type, props = [], children = [], length2), rulesets);
            if (character2 === 123)
              if (offset === 0)
                parse$1(characters2, root2, reference, reference, props, rulesets, length2, points, children);
              else
                switch (atrule === 99 && charat$1(characters2, 3) === 110 ? 100 : atrule) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    parse$1(value, reference, reference, rule && append$1(ruleset$1(value, reference, reference, 0, 0, rules, points, type, rules, props = [], length2), children), rules, children, length2, points, rule ? props : children);
                    break;
                  default:
                    parse$1(characters2, reference, reference, reference, [""], children, 0, points, children);
                }
        }
        index = offset = property = 0, variable = ampersand = 1, type = characters2 = "", length2 = pseudo;
        break;
      case 58:
        length2 = 1 + strlen$1(characters2), property = previous;
      default:
        if (variable < 1) {
          if (character2 == 123)
            --variable;
          else if (character2 == 125 && variable++ == 0 && prev$1() == 125)
            continue;
        }
        switch (characters2 += from$1(character2), character2 * variable) {
          case 38:
            ampersand = offset > 0 ? 1 : (characters2 += "\f", -1);
            break;
          case 44:
            points[index++] = (strlen$1(characters2) - 1) * ampersand, ampersand = 1;
            break;
          case 64:
            if (peek$1() === 45)
              characters2 += delimit$1(next$1());
            atrule = peek$1(), offset = length2 = strlen$1(type = characters2 += identifier$1(caret$1())), character2++;
            break;
          case 45:
            if (previous === 45 && strlen$1(characters2) == 2)
              variable = 0;
        }
    }
  return rulesets;
}
function ruleset$1(value, root2, parent, index, offset, rules, points, type, props, children, length2) {
  var post = offset - 1;
  var rule = offset === 0 ? rules : [""];
  var size3 = sizeof$1(rule);
  for (var i = 0, j = 0, k2 = 0; i < index; ++i)
    for (var x2 = 0, y2 = substr$1(value, post + 1, post = abs$1(j = points[i])), z2 = value; x2 < size3; ++x2)
      if (z2 = trim$2(j > 0 ? rule[x2] + " " + y2 : replace$1(y2, /&\f/g, rule[x2])))
        props[k2++] = z2;
  return node$1(value, root2, parent, offset === 0 ? RULESET$1 : type, props, children, length2);
}
function comment$1(value, root2, parent) {
  return node$1(value, root2, parent, COMMENT$1, from$1(char$1()), substr$1(value, 2, -2), 0);
}
function declaration$1(value, root2, parent, length2) {
  return node$1(value, root2, parent, DECLARATION$1, substr$1(value, 0, length2), substr$1(value, length2 + 1, -1), length2);
}
function serialize$1(children, callback2) {
  var output = "";
  var length2 = sizeof$1(children);
  for (var i = 0; i < length2; i++)
    output += callback2(children[i], i, children, callback2) || "";
  return output;
}
function stringify$1(element, index, children, callback2) {
  switch (element.type) {
    case LAYER$1:
      if (element.children.length) break;
    case IMPORT$1:
    case DECLARATION$1:
      return element.return = element.return || element.value;
    case COMMENT$1:
      return "";
    case KEYFRAMES$1:
      return element.return = element.value + "{" + serialize$1(element.children, callback2) + "}";
    case RULESET$1:
      element.value = element.props.join(",");
  }
  return strlen$1(children = serialize$1(element.children, callback2)) ? element.return = element.value + "{" + children + "}" : "";
}
function middleware$1(collection2) {
  var length2 = sizeof$1(collection2);
  return function(element, index, children, callback2) {
    var output = "";
    for (var i = 0; i < length2; i++)
      output += collection2[i](element, index, children, callback2) || "";
    return output;
  };
}
function rulesheet$1(callback2) {
  return function(element) {
    if (!element.root) {
      if (element = element.return)
        callback2(element);
    }
  };
}
var identifierWithPointTracking$1 = function identifierWithPointTracking2(begin, points, index) {
  var previous = 0;
  var character2 = 0;
  while (true) {
    previous = character2;
    character2 = peek$1();
    if (previous === 38 && character2 === 12) {
      points[index] = 1;
    }
    if (token$1(character2)) {
      break;
    }
    next$1();
  }
  return slice$1(begin, position$1);
};
var toRules$1 = function toRules2(parsed, points) {
  var index = -1;
  var character2 = 44;
  do {
    switch (token$1(character2)) {
      case 0:
        if (character2 === 38 && peek$1() === 12) {
          points[index] = 1;
        }
        parsed[index] += identifierWithPointTracking$1(position$1 - 1, points, index);
        break;
      case 2:
        parsed[index] += delimit$1(character2);
        break;
      case 4:
        if (character2 === 44) {
          parsed[++index] = peek$1() === 58 ? "&\f" : "";
          points[index] = parsed[index].length;
          break;
        }
      default:
        parsed[index] += from$1(character2);
    }
  } while (character2 = next$1());
  return parsed;
};
var getRules$1 = function getRules2(value, points) {
  return dealloc$1(toRules$1(alloc$1(value), points));
};
var fixedElements$1 = /* @__PURE__ */ new WeakMap();
var compat$1 = function compat2(element) {
  if (element.type !== "rule" || !element.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  element.length < 1) {
    return;
  }
  var value = element.value, parent = element.parent;
  var isImplicitRule = element.column === parent.column && element.line === parent.line;
  while (parent.type !== "rule") {
    parent = parent.parent;
    if (!parent) return;
  }
  if (element.props.length === 1 && value.charCodeAt(0) !== 58 && !fixedElements$1.get(parent)) {
    return;
  }
  if (isImplicitRule) {
    return;
  }
  fixedElements$1.set(element, true);
  var points = [];
  var rules = getRules$1(value, points);
  var parentRules = parent.props;
  for (var i = 0, k2 = 0; i < rules.length; i++) {
    for (var j = 0; j < parentRules.length; j++, k2++) {
      element.props[k2] = points[i] ? rules[i].replace(/&\f/g, parentRules[j]) : parentRules[j] + " " + rules[i];
    }
  }
};
var removeLabel$1 = function removeLabel2(element) {
  if (element.type === "decl") {
    var value = element.value;
    if (
      // charcode for l
      value.charCodeAt(0) === 108 && // charcode for b
      value.charCodeAt(2) === 98
    ) {
      element["return"] = "";
      element.value = "";
    }
  }
};
function prefix$1(value, length2) {
  switch (hash$1(value, length2)) {
    case 5103:
      return WEBKIT$1 + "print-" + value + value;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return WEBKIT$1 + value + value;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return WEBKIT$1 + value + MOZ$1 + value + MS$1 + value + value;
    case 6828:
    case 4268:
      return WEBKIT$1 + value + MS$1 + value + value;
    case 6165:
      return WEBKIT$1 + value + MS$1 + "flex-" + value + value;
    case 5187:
      return WEBKIT$1 + value + replace$1(value, /(\w+).+(:[^]+)/, WEBKIT$1 + "box-$1$2" + MS$1 + "flex-$1$2") + value;
    case 5443:
      return WEBKIT$1 + value + MS$1 + "flex-item-" + replace$1(value, /flex-|-self/, "") + value;
    case 4675:
      return WEBKIT$1 + value + MS$1 + "flex-line-pack" + replace$1(value, /align-content|flex-|-self/, "") + value;
    case 5548:
      return WEBKIT$1 + value + MS$1 + replace$1(value, "shrink", "negative") + value;
    case 5292:
      return WEBKIT$1 + value + MS$1 + replace$1(value, "basis", "preferred-size") + value;
    case 6060:
      return WEBKIT$1 + "box-" + replace$1(value, "-grow", "") + WEBKIT$1 + value + MS$1 + replace$1(value, "grow", "positive") + value;
    case 4554:
      return WEBKIT$1 + replace$1(value, /([^-])(transform)/g, "$1" + WEBKIT$1 + "$2") + value;
    case 6187:
      return replace$1(replace$1(replace$1(value, /(zoom-|grab)/, WEBKIT$1 + "$1"), /(image-set)/, WEBKIT$1 + "$1"), value, "") + value;
    case 5495:
    case 3959:
      return replace$1(value, /(image-set\([^]*)/, WEBKIT$1 + "$1$`$1");
    case 4968:
      return replace$1(replace$1(value, /(.+:)(flex-)?(.*)/, WEBKIT$1 + "box-pack:$3" + MS$1 + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT$1 + value + value;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return replace$1(value, /(.+)-inline(.+)/, WEBKIT$1 + "$1$2") + value;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (strlen$1(value) - 1 - length2 > 6) switch (charat$1(value, length2 + 1)) {
        case 109:
          if (charat$1(value, length2 + 4) !== 45) break;
        case 102:
          return replace$1(value, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT$1 + "$2-$3$1" + MOZ$1 + (charat$1(value, length2 + 3) == 108 ? "$3" : "$2-$3")) + value;
        case 115:
          return ~indexof$1(value, "stretch") ? prefix$1(replace$1(value, "stretch", "fill-available"), length2) + value : value;
      }
      break;
    case 4949:
      if (charat$1(value, length2 + 1) !== 115) break;
    case 6444:
      switch (charat$1(value, strlen$1(value) - 3 - (~indexof$1(value, "!important") && 10))) {
        case 107:
          return replace$1(value, ":", ":" + WEBKIT$1) + value;
        case 101:
          return replace$1(value, /(.+:)([^;!]+)(;|!.+)?/, "$1" + WEBKIT$1 + (charat$1(value, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT$1 + "$2$3$1" + MS$1 + "$2box$3") + value;
      }
      break;
    case 5936:
      switch (charat$1(value, length2 + 11)) {
        case 114:
          return WEBKIT$1 + value + MS$1 + replace$1(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
        case 108:
          return WEBKIT$1 + value + MS$1 + replace$1(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
        case 45:
          return WEBKIT$1 + value + MS$1 + replace$1(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
      }
      return WEBKIT$1 + value + MS$1 + value + value;
  }
  return value;
}
var prefixer$1 = function prefixer2(element, index, children, callback2) {
  if (element.length > -1) {
    if (!element["return"]) switch (element.type) {
      case DECLARATION$1:
        element["return"] = prefix$1(element.value, element.length);
        break;
      case KEYFRAMES$1:
        return serialize$1([copy$1(element, {
          value: replace$1(element.value, "@", "@" + WEBKIT$1)
        })], callback2);
      case RULESET$1:
        if (element.length) return combine$1(element.props, function(value) {
          switch (match$1(value, /(::plac\w+|:read-\w+)/)) {
            case ":read-only":
            case ":read-write":
              return serialize$1([copy$1(element, {
                props: [replace$1(value, /:(read-\w+)/, ":" + MOZ$1 + "$1")]
              })], callback2);
            case "::placeholder":
              return serialize$1([copy$1(element, {
                props: [replace$1(value, /:(plac\w+)/, ":" + WEBKIT$1 + "input-$1")]
              }), copy$1(element, {
                props: [replace$1(value, /:(plac\w+)/, ":" + MOZ$1 + "$1")]
              }), copy$1(element, {
                props: [replace$1(value, /:(plac\w+)/, MS$1 + "input-$1")]
              })], callback2);
          }
          return "";
        });
    }
  }
};
var defaultStylisPlugins$1 = [prefixer$1];
var createCache$1 = function createCache2(options) {
  var key = options.key;
  if (key === "css") {
    var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(ssrStyles, function(node2) {
      var dataEmotionAttribute = node2.getAttribute("data-emotion");
      if (dataEmotionAttribute.indexOf(" ") === -1) {
        return;
      }
      document.head.appendChild(node2);
      node2.setAttribute("data-s", "");
    });
  }
  var stylisPlugins = options.stylisPlugins || defaultStylisPlugins$1;
  var inserted = {};
  var container;
  var nodesToHydrate = [];
  {
    container = options.container || document.head;
    Array.prototype.forEach.call(
      // this means we will ignore elements which don't have a space in them which
      // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
      document.querySelectorAll('style[data-emotion^="' + key + ' "]'),
      function(node2) {
        var attrib = node2.getAttribute("data-emotion").split(" ");
        for (var i = 1; i < attrib.length; i++) {
          inserted[attrib[i]] = true;
        }
        nodesToHydrate.push(node2);
      }
    );
  }
  var _insert;
  var omnipresentPlugins = [compat$1, removeLabel$1];
  {
    var currentSheet;
    var finalizingPlugins = [stringify$1, rulesheet$1(function(rule) {
      currentSheet.insert(rule);
    })];
    var serializer = middleware$1(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));
    var stylis = function stylis2(styles2) {
      return serialize$1(compile$1(styles2), serializer);
    };
    _insert = function insert(selector, serialized, sheet, shouldCache) {
      currentSheet = sheet;
      stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
      if (shouldCache) {
        cache.inserted[serialized.name] = true;
      }
    };
  }
  var cache = {
    key,
    sheet: new StyleSheet$1({
      key,
      container,
      nonce: options.nonce,
      speedy: options.speedy,
      prepend: options.prepend,
      insertionPoint: options.insertionPoint
    }),
    nonce: options.nonce,
    inserted,
    registered: {},
    insert: _insert
  };
  cache.sheet.hydrate(nodesToHydrate);
  return cache;
};
var isBrowser$1 = true;
function getRegisteredStyles$1(registered, registeredStyles, classNames2) {
  var rawClassName = "";
  classNames2.split(" ").forEach(function(className) {
    if (registered[className] !== void 0) {
      registeredStyles.push(registered[className] + ";");
    } else {
      rawClassName += className + " ";
    }
  });
  return rawClassName;
}
var registerStyles$1 = function registerStyles(cache, serialized, isStringTag2) {
  var className = cache.key + "-" + serialized.name;
  if (
    // we only need to add the styles to the registered cache if the
    // class name could be used further down
    // the tree but if it's a string tag, we know it won't
    // so we don't have to add it to registered cache.
    // this improves memory usage since we can avoid storing the whole style string
    (isStringTag2 === false || // we need to always store it if we're in compat mode and
    // in node since emotion-server relies on whether a style is in
    // the registered cache to know whether a style is global or not
    // also, note that this check will be dead code eliminated in the browser
    isBrowser$1 === false) && cache.registered[className] === void 0
  ) {
    cache.registered[className] = serialized.styles;
  }
};
var insertStyles$1 = function insertStyles(cache, serialized, isStringTag2) {
  registerStyles$1(cache, serialized, isStringTag2);
  var className = cache.key + "-" + serialized.name;
  if (cache.inserted[serialized.name] === void 0) {
    var current = serialized;
    do {
      cache.insert(serialized === current ? "." + className : "", current, cache.sheet, true);
      current = current.next;
    } while (current !== void 0);
  }
};
function murmur2$1(str) {
  var h2 = 0;
  var k2, i = 0, len = str.length;
  for (; len >= 4; ++i, len -= 4) {
    k2 = str.charCodeAt(i) & 255 | (str.charCodeAt(++i) & 255) << 8 | (str.charCodeAt(++i) & 255) << 16 | (str.charCodeAt(++i) & 255) << 24;
    k2 = /* Math.imul(k, m): */
    (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16);
    k2 ^= /* k >>> r: */
    k2 >>> 24;
    h2 = /* Math.imul(k, m): */
    (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  }
  switch (len) {
    case 3:
      h2 ^= (str.charCodeAt(i + 2) & 255) << 16;
    case 2:
      h2 ^= (str.charCodeAt(i + 1) & 255) << 8;
    case 1:
      h2 ^= str.charCodeAt(i) & 255;
      h2 = /* Math.imul(h, m): */
      (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  }
  h2 ^= h2 >>> 13;
  h2 = /* Math.imul(h, m): */
  (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  return ((h2 ^ h2 >>> 15) >>> 0).toString(36);
}
var unitlessKeys$1 = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};
var hyphenateRegex$1 = /[A-Z]|^ms/g;
var animationRegex$1 = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
var isCustomProperty$1 = function isCustomProperty2(property) {
  return property.charCodeAt(1) === 45;
};
var isProcessableValue$1 = function isProcessableValue2(value) {
  return value != null && typeof value !== "boolean";
};
var processStyleName$1 = /* @__PURE__ */ memoize$1(function(styleName) {
  return isCustomProperty$1(styleName) ? styleName : styleName.replace(hyphenateRegex$1, "-$&").toLowerCase();
});
var processStyleValue$1 = function processStyleValue2(key, value) {
  switch (key) {
    case "animation":
    case "animationName": {
      if (typeof value === "string") {
        return value.replace(animationRegex$1, function(match2, p1, p2) {
          cursor$1 = {
            name: p1,
            styles: p2,
            next: cursor$1
          };
          return p1;
        });
      }
    }
  }
  if (unitlessKeys$1[key] !== 1 && !isCustomProperty$1(key) && typeof value === "number" && value !== 0) {
    return value + "px";
  }
  return value;
};
function handleInterpolation$1(mergedProps, registered, interpolation) {
  if (interpolation == null) {
    return "";
  }
  if (interpolation.__emotion_styles !== void 0) {
    return interpolation;
  }
  switch (typeof interpolation) {
    case "boolean": {
      return "";
    }
    case "object": {
      if (interpolation.anim === 1) {
        cursor$1 = {
          name: interpolation.name,
          styles: interpolation.styles,
          next: cursor$1
        };
        return interpolation.name;
      }
      if (interpolation.styles !== void 0) {
        var next11 = interpolation.next;
        if (next11 !== void 0) {
          while (next11 !== void 0) {
            cursor$1 = {
              name: next11.name,
              styles: next11.styles,
              next: cursor$1
            };
            next11 = next11.next;
          }
        }
        var styles2 = interpolation.styles + ";";
        return styles2;
      }
      return createStringFromObject$1(mergedProps, registered, interpolation);
    }
    case "function": {
      if (mergedProps !== void 0) {
        var previousCursor = cursor$1;
        var result = interpolation(mergedProps);
        cursor$1 = previousCursor;
        return handleInterpolation$1(mergedProps, registered, result);
      }
      break;
    }
  }
  if (registered == null) {
    return interpolation;
  }
  var cached = registered[interpolation];
  return cached !== void 0 ? cached : interpolation;
}
function createStringFromObject$1(mergedProps, registered, obj) {
  var string = "";
  if (Array.isArray(obj)) {
    for (var i = 0; i < obj.length; i++) {
      string += handleInterpolation$1(mergedProps, registered, obj[i]) + ";";
    }
  } else {
    for (var _key in obj) {
      var value = obj[_key];
      if (typeof value !== "object") {
        if (registered != null && registered[value] !== void 0) {
          string += _key + "{" + registered[value] + "}";
        } else if (isProcessableValue$1(value)) {
          string += processStyleName$1(_key) + ":" + processStyleValue$1(_key, value) + ";";
        }
      } else {
        if (Array.isArray(value) && typeof value[0] === "string" && (registered == null || registered[value[0]] === void 0)) {
          for (var _i = 0; _i < value.length; _i++) {
            if (isProcessableValue$1(value[_i])) {
              string += processStyleName$1(_key) + ":" + processStyleValue$1(_key, value[_i]) + ";";
            }
          }
        } else {
          var interpolated = handleInterpolation$1(mergedProps, registered, value);
          switch (_key) {
            case "animation":
            case "animationName": {
              string += processStyleName$1(_key) + ":" + interpolated + ";";
              break;
            }
            default: {
              string += _key + "{" + interpolated + "}";
            }
          }
        }
      }
    }
  }
  return string;
}
var labelPattern$1 = /label:\s*([^\s;\n{]+)\s*(;|$)/g;
var cursor$1;
var serializeStyles$1 = function serializeStyles2(args, registered, mergedProps) {
  if (args.length === 1 && typeof args[0] === "object" && args[0] !== null && args[0].styles !== void 0) {
    return args[0];
  }
  var stringMode = true;
  var styles2 = "";
  cursor$1 = void 0;
  var strings = args[0];
  if (strings == null || strings.raw === void 0) {
    stringMode = false;
    styles2 += handleInterpolation$1(mergedProps, registered, strings);
  } else {
    styles2 += strings[0];
  }
  for (var i = 1; i < args.length; i++) {
    styles2 += handleInterpolation$1(mergedProps, registered, args[i]);
    if (stringMode) {
      styles2 += strings[i];
    }
  }
  labelPattern$1.lastIndex = 0;
  var identifierName = "";
  var match2;
  while ((match2 = labelPattern$1.exec(styles2)) !== null) {
    identifierName += "-" + // $FlowFixMe we know it's not null
    match2[1];
  }
  var name = murmur2$1(styles2) + identifierName;
  return {
    name,
    styles: styles2,
    next: cursor$1
  };
};
var syncFallback$1 = function syncFallback(create4) {
  return create4();
};
var useInsertionEffect$1 = React$2["useInsertionEffect"] ? React$2["useInsertionEffect"] : false;
var useInsertionEffectAlwaysWithSyncFallback$1 = useInsertionEffect$1 || syncFallback$1;
var EmotionCacheContext$1 = /* @__PURE__ */ reactExports.createContext(
  // we're doing this to avoid preconstruct's dead code elimination in this one case
  // because this module is primarily intended for the browser and node
  // but it's also required in react native and similar environments sometimes
  // and we could have a special build just for that
  // but this is much easier and the native packages
  // might use a different theme context in the future anyway
  typeof HTMLElement !== "undefined" ? /* @__PURE__ */ createCache$1({
    key: "css"
  }) : null
);
EmotionCacheContext$1.Provider;
var withEmotionCache$1 = function withEmotionCache2(func) {
  return /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
    var cache = reactExports.useContext(EmotionCacheContext$1);
    return func(props, cache, ref);
  });
};
var ThemeContext$1 = /* @__PURE__ */ reactExports.createContext({});
var testOmitPropsOnStringTag = isPropValid;
var testOmitPropsOnComponent = function testOmitPropsOnComponent2(key) {
  return key !== "theme";
};
var getDefaultShouldForwardProp = function getDefaultShouldForwardProp2(tag) {
  return typeof tag === "string" && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  tag.charCodeAt(0) > 96 ? testOmitPropsOnStringTag : testOmitPropsOnComponent;
};
var composeShouldForwardProps = function composeShouldForwardProps2(tag, options, isReal) {
  var shouldForwardProp2;
  if (options) {
    var optionsShouldForwardProp = options.shouldForwardProp;
    shouldForwardProp2 = tag.__emotion_forwardProp && optionsShouldForwardProp ? function(propName) {
      return tag.__emotion_forwardProp(propName) && optionsShouldForwardProp(propName);
    } : optionsShouldForwardProp;
  }
  if (typeof shouldForwardProp2 !== "function" && isReal) {
    shouldForwardProp2 = tag.__emotion_forwardProp;
  }
  return shouldForwardProp2;
};
var Insertion$1 = function Insertion2(_ref) {
  var cache = _ref.cache, serialized = _ref.serialized, isStringTag2 = _ref.isStringTag;
  registerStyles$1(cache, serialized, isStringTag2);
  useInsertionEffectAlwaysWithSyncFallback$1(function() {
    return insertStyles$1(cache, serialized, isStringTag2);
  });
  return null;
};
var createStyled$1 = function createStyled2(tag, options) {
  var isReal = tag.__emotion_real === tag;
  var baseTag = isReal && tag.__emotion_base || tag;
  var identifierName;
  var targetClassName;
  if (options !== void 0) {
    identifierName = options.label;
    targetClassName = options.target;
  }
  var shouldForwardProp2 = composeShouldForwardProps(tag, options, isReal);
  var defaultShouldForwardProp = shouldForwardProp2 || getDefaultShouldForwardProp(baseTag);
  var shouldUseAs = !defaultShouldForwardProp("as");
  return function() {
    var args = arguments;
    var styles2 = isReal && tag.__emotion_styles !== void 0 ? tag.__emotion_styles.slice(0) : [];
    if (identifierName !== void 0) {
      styles2.push("label:" + identifierName + ";");
    }
    if (args[0] == null || args[0].raw === void 0) {
      styles2.push.apply(styles2, args);
    } else {
      styles2.push(args[0][0]);
      var len = args.length;
      var i = 1;
      for (; i < len; i++) {
        styles2.push(args[i], args[0][i]);
      }
    }
    var Styled = withEmotionCache$1(function(props, cache, ref) {
      var FinalTag = shouldUseAs && props.as || baseTag;
      var className = "";
      var classInterpolations = [];
      var mergedProps = props;
      if (props.theme == null) {
        mergedProps = {};
        for (var key in props) {
          mergedProps[key] = props[key];
        }
        mergedProps.theme = reactExports.useContext(ThemeContext$1);
      }
      if (typeof props.className === "string") {
        className = getRegisteredStyles$1(cache.registered, classInterpolations, props.className);
      } else if (props.className != null) {
        className = props.className + " ";
      }
      var serialized = serializeStyles$1(styles2.concat(classInterpolations), cache.registered, mergedProps);
      className += cache.key + "-" + serialized.name;
      if (targetClassName !== void 0) {
        className += " " + targetClassName;
      }
      var finalShouldForwardProp = shouldUseAs && shouldForwardProp2 === void 0 ? getDefaultShouldForwardProp(FinalTag) : defaultShouldForwardProp;
      var newProps = {};
      for (var _key in props) {
        if (shouldUseAs && _key === "as") continue;
        if (
          // $FlowFixMe
          finalShouldForwardProp(_key)
        ) {
          newProps[_key] = props[_key];
        }
      }
      newProps.className = className;
      newProps.ref = ref;
      return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(Insertion$1, {
        cache,
        serialized,
        isStringTag: typeof FinalTag === "string"
      }), /* @__PURE__ */ reactExports.createElement(FinalTag, newProps));
    });
    Styled.displayName = identifierName !== void 0 ? identifierName : "Styled(" + (typeof baseTag === "string" ? baseTag : baseTag.displayName || baseTag.name || "Component") + ")";
    Styled.defaultProps = tag.defaultProps;
    Styled.__emotion_real = Styled;
    Styled.__emotion_base = baseTag;
    Styled.__emotion_styles = styles2;
    Styled.__emotion_forwardProp = shouldForwardProp2;
    Object.defineProperty(Styled, "toString", {
      value: function value() {
        return "." + targetClassName;
      }
    });
    Styled.withComponent = function(nextTag, nextOptions) {
      return createStyled2(nextTag, _extends$1({}, options, nextOptions, {
        shouldForwardProp: composeShouldForwardProps(Styled, nextOptions, true)
      })).apply(void 0, styles2);
    };
    return Styled;
  };
};
var tags = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "big",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "marquee",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  // SVG
  "circle",
  "clipPath",
  "defs",
  "ellipse",
  "foreignObject",
  "g",
  "image",
  "line",
  "linearGradient",
  "mask",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "stop",
  "svg",
  "text",
  "tspan"
];
var newStyled = createStyled$1.bind();
tags.forEach(function(tagName) {
  newStyled[tagName] = newStyled(tagName);
});
function murmur2(str) {
  var h2 = 0;
  var k2, i = 0, len = str.length;
  for (; len >= 4; ++i, len -= 4) {
    k2 = str.charCodeAt(i) & 255 | (str.charCodeAt(++i) & 255) << 8 | (str.charCodeAt(++i) & 255) << 16 | (str.charCodeAt(++i) & 255) << 24;
    k2 = /* Math.imul(k, m): */
    (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16);
    k2 ^= /* k >>> r: */
    k2 >>> 24;
    h2 = /* Math.imul(k, m): */
    (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  }
  switch (len) {
    case 3:
      h2 ^= (str.charCodeAt(i + 2) & 255) << 16;
    case 2:
      h2 ^= (str.charCodeAt(i + 1) & 255) << 8;
    case 1:
      h2 ^= str.charCodeAt(i) & 255;
      h2 = /* Math.imul(h, m): */
      (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  }
  h2 ^= h2 >>> 13;
  h2 = /* Math.imul(h, m): */
  (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  return ((h2 ^ h2 >>> 15) >>> 0).toString(36);
}
var unitlessKeys = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  scale: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};
function memoize(fn) {
  var cache = /* @__PURE__ */ Object.create(null);
  return function(arg2) {
    if (cache[arg2] === void 0) cache[arg2] = fn(arg2);
    return cache[arg2];
  };
}
var hyphenateRegex = /[A-Z]|^ms/g;
var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
var isCustomProperty = function isCustomProperty3(property) {
  return property.charCodeAt(1) === 45;
};
var isProcessableValue = function isProcessableValue3(value) {
  return value != null && typeof value !== "boolean";
};
var processStyleName = /* @__PURE__ */ memoize(function(styleName) {
  return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, "-$&").toLowerCase();
});
var processStyleValue = function processStyleValue3(key, value) {
  switch (key) {
    case "animation":
    case "animationName": {
      if (typeof value === "string") {
        return value.replace(animationRegex, function(match2, p1, p2) {
          cursor = {
            name: p1,
            styles: p2,
            next: cursor
          };
          return p1;
        });
      }
    }
  }
  if (unitlessKeys[key] !== 1 && !isCustomProperty(key) && typeof value === "number" && value !== 0) {
    return value + "px";
  }
  return value;
};
function handleInterpolation(mergedProps, registered, interpolation) {
  if (interpolation == null) {
    return "";
  }
  var componentSelector = interpolation;
  if (componentSelector.__emotion_styles !== void 0) {
    return componentSelector;
  }
  switch (typeof interpolation) {
    case "boolean": {
      return "";
    }
    case "object": {
      var keyframes2 = interpolation;
      if (keyframes2.anim === 1) {
        cursor = {
          name: keyframes2.name,
          styles: keyframes2.styles,
          next: cursor
        };
        return keyframes2.name;
      }
      var serializedStyles = interpolation;
      if (serializedStyles.styles !== void 0) {
        var next11 = serializedStyles.next;
        if (next11 !== void 0) {
          while (next11 !== void 0) {
            cursor = {
              name: next11.name,
              styles: next11.styles,
              next: cursor
            };
            next11 = next11.next;
          }
        }
        var styles2 = serializedStyles.styles + ";";
        return styles2;
      }
      return createStringFromObject(mergedProps, registered, interpolation);
    }
    case "function": {
      if (mergedProps !== void 0) {
        var previousCursor = cursor;
        var result = interpolation(mergedProps);
        cursor = previousCursor;
        return handleInterpolation(mergedProps, registered, result);
      }
      break;
    }
  }
  var asString = interpolation;
  {
    return asString;
  }
}
function createStringFromObject(mergedProps, registered, obj) {
  var string = "";
  if (Array.isArray(obj)) {
    for (var i = 0; i < obj.length; i++) {
      string += handleInterpolation(mergedProps, registered, obj[i]) + ";";
    }
  } else {
    for (var key in obj) {
      var value = obj[key];
      if (typeof value !== "object") {
        var asString = value;
        if (isProcessableValue(asString)) {
          string += processStyleName(key) + ":" + processStyleValue(key, asString) + ";";
        }
      } else {
        if (Array.isArray(value) && typeof value[0] === "string" && registered == null) {
          for (var _i = 0; _i < value.length; _i++) {
            if (isProcessableValue(value[_i])) {
              string += processStyleName(key) + ":" + processStyleValue(key, value[_i]) + ";";
            }
          }
        } else {
          var interpolated = handleInterpolation(mergedProps, registered, value);
          switch (key) {
            case "animation":
            case "animationName": {
              string += processStyleName(key) + ":" + interpolated + ";";
              break;
            }
            default: {
              string += key + "{" + interpolated + "}";
            }
          }
        }
      }
    }
  }
  return string;
}
var labelPattern = /label:\s*([^\s;{]+)\s*(;|$)/g;
var cursor;
function serializeStyles(args, registered, mergedProps) {
  if (args.length === 1 && typeof args[0] === "object" && args[0] !== null && args[0].styles !== void 0) {
    return args[0];
  }
  var stringMode = true;
  var styles2 = "";
  cursor = void 0;
  var strings = args[0];
  if (strings == null || strings.raw === void 0) {
    stringMode = false;
    styles2 += handleInterpolation(mergedProps, registered, strings);
  } else {
    var asTemplateStringsArr = strings;
    styles2 += asTemplateStringsArr[0];
  }
  for (var i = 1; i < args.length; i++) {
    styles2 += handleInterpolation(mergedProps, registered, args[i]);
    if (stringMode) {
      var templateStringsArr = strings;
      styles2 += templateStringsArr[i];
    }
  }
  labelPattern.lastIndex = 0;
  var identifierName = "";
  var match2;
  while ((match2 = labelPattern.exec(styles2)) !== null) {
    identifierName += "-" + match2[1];
  }
  var name = murmur2(styles2) + identifierName;
  return {
    name,
    styles: styles2,
    next: cursor
  };
}
var isDevelopment$1 = false;
function sheetForTag(tag) {
  if (tag.sheet) {
    return tag.sheet;
  }
  for (var i = 0; i < document.styleSheets.length; i++) {
    if (document.styleSheets[i].ownerNode === tag) {
      return document.styleSheets[i];
    }
  }
  return void 0;
}
function createStyleElement(options) {
  var tag = document.createElement("style");
  tag.setAttribute("data-emotion", options.key);
  if (options.nonce !== void 0) {
    tag.setAttribute("nonce", options.nonce);
  }
  tag.appendChild(document.createTextNode(""));
  tag.setAttribute("data-s", "");
  return tag;
}
var StyleSheet = /* @__PURE__ */ function() {
  function StyleSheet2(options) {
    var _this = this;
    this._insertTag = function(tag) {
      var before;
      if (_this.tags.length === 0) {
        if (_this.insertionPoint) {
          before = _this.insertionPoint.nextSibling;
        } else if (_this.prepend) {
          before = _this.container.firstChild;
        } else {
          before = _this.before;
        }
      } else {
        before = _this.tags[_this.tags.length - 1].nextSibling;
      }
      _this.container.insertBefore(tag, before);
      _this.tags.push(tag);
    };
    this.isSpeedy = options.speedy === void 0 ? !isDevelopment$1 : options.speedy;
    this.tags = [];
    this.ctr = 0;
    this.nonce = options.nonce;
    this.key = options.key;
    this.container = options.container;
    this.prepend = options.prepend;
    this.insertionPoint = options.insertionPoint;
    this.before = null;
  }
  var _proto = StyleSheet2.prototype;
  _proto.hydrate = function hydrate(nodes) {
    nodes.forEach(this._insertTag);
  };
  _proto.insert = function insert(rule) {
    if (this.ctr % (this.isSpeedy ? 65e3 : 1) === 0) {
      this._insertTag(createStyleElement(this));
    }
    var tag = this.tags[this.tags.length - 1];
    if (this.isSpeedy) {
      var sheet = sheetForTag(tag);
      try {
        sheet.insertRule(rule, sheet.cssRules.length);
      } catch (e2) {
      }
    } else {
      tag.appendChild(document.createTextNode(rule));
    }
    this.ctr++;
  };
  _proto.flush = function flush() {
    this.tags.forEach(function(tag) {
      var _tag$parentNode;
      return (_tag$parentNode = tag.parentNode) == null ? void 0 : _tag$parentNode.removeChild(tag);
    });
    this.tags = [];
    this.ctr = 0;
  };
  return StyleSheet2;
}();
var MS = "-ms-";
var MOZ = "-moz-";
var WEBKIT = "-webkit-";
var COMMENT = "comm";
var RULESET = "rule";
var DECLARATION = "decl";
var IMPORT = "@import";
var KEYFRAMES = "@keyframes";
var LAYER = "@layer";
var abs = Math.abs;
var from6 = String.fromCharCode;
var assign2 = Object.assign;
function hash(value, length2) {
  return charat(value, 0) ^ 45 ? (((length2 << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3) : 0;
}
function trim$1(value) {
  return value.trim();
}
function match(value, pattern) {
  return (value = pattern.exec(value)) ? value[0] : value;
}
function replace(value, pattern, replacement2) {
  return value.replace(pattern, replacement2);
}
function indexof(value, search) {
  return value.indexOf(search);
}
function charat(value, index) {
  return value.charCodeAt(index) | 0;
}
function substr2(value, begin, end) {
  return value.slice(begin, end);
}
function strlen(value) {
  return value.length;
}
function sizeof(value) {
  return value.length;
}
function append2(value, array) {
  return array.push(value), value;
}
function combine(array, callback2) {
  return array.map(callback2).join("");
}
var line = 1;
var column = 1;
var length = 0;
var position = 0;
var character = 0;
var characters = "";
function node(value, root2, parent, type, props, children, length2) {
  return { value, root: root2, parent, type, props, children, line, column, length: length2, return: "" };
}
function copy(root2, props) {
  return assign2(node("", null, null, "", null, null, 0), root2, { length: -root2.length }, props);
}
function char() {
  return character;
}
function prev() {
  character = position > 0 ? charat(characters, --position) : 0;
  if (column--, character === 10)
    column = 1, line--;
  return character;
}
function next10() {
  character = position < length ? charat(characters, position++) : 0;
  if (column++, character === 10)
    column = 1, line++;
  return character;
}
function peek() {
  return charat(characters, position);
}
function caret() {
  return position;
}
function slice4(begin, end) {
  return substr2(characters, begin, end);
}
function token(type) {
  switch (type) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function alloc(value) {
  return line = column = 1, length = strlen(characters = value), position = 0, [];
}
function dealloc(value) {
  return characters = "", value;
}
function delimit(type) {
  return trim$1(slice4(position - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)));
}
function whitespace(type) {
  while (character = peek())
    if (character < 33)
      next10();
    else
      break;
  return token(type) > 2 || token(character) > 3 ? "" : " ";
}
function escaping(index, count) {
  while (--count && next10())
    if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
      break;
  return slice4(index, caret() + (count < 6 && peek() == 32 && next10() == 32));
}
function delimiter(type) {
  while (next10())
    switch (character) {
      case type:
        return position;
      case 34:
      case 39:
        if (type !== 34 && type !== 39)
          delimiter(character);
        break;
      case 40:
        if (type === 41)
          delimiter(type);
        break;
      case 92:
        next10();
        break;
    }
  return position;
}
function commenter(type, index) {
  while (next10())
    if (type + character === 47 + 10)
      break;
    else if (type + character === 42 + 42 && peek() === 47)
      break;
  return "/*" + slice4(index, position - 1) + "*" + from6(type === 47 ? type : next10());
}
function identifier(index) {
  while (!token(peek()))
    next10();
  return slice4(index, position);
}
function compile(value) {
  return dealloc(parse3("", null, null, null, [""], value = alloc(value), 0, [0], value));
}
function parse3(value, root2, parent, rule, rules, rulesets, pseudo, points, declarations) {
  var index = 0;
  var offset = 0;
  var length2 = pseudo;
  var atrule = 0;
  var property = 0;
  var previous = 0;
  var variable = 1;
  var scanning = 1;
  var ampersand = 1;
  var character2 = 0;
  var type = "";
  var props = rules;
  var children = rulesets;
  var reference = rule;
  var characters2 = type;
  while (scanning)
    switch (previous = character2, character2 = next10()) {
      case 40:
        if (previous != 108 && charat(characters2, length2 - 1) == 58) {
          if (indexof(characters2 += replace(delimit(character2), "&", "&\f"), "&\f") != -1)
            ampersand = -1;
          break;
        }
      case 34:
      case 39:
      case 91:
        characters2 += delimit(character2);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        characters2 += whitespace(previous);
        break;
      case 92:
        characters2 += escaping(caret() - 1, 7);
        continue;
      case 47:
        switch (peek()) {
          case 42:
          case 47:
            append2(comment(commenter(next10(), caret()), root2, parent), declarations);
            break;
          default:
            characters2 += "/";
        }
        break;
      case 123 * variable:
        points[index++] = strlen(characters2) * ampersand;
      case 125 * variable:
      case 59:
      case 0:
        switch (character2) {
          case 0:
          case 125:
            scanning = 0;
          case 59 + offset:
            if (ampersand == -1) characters2 = replace(characters2, /\f/g, "");
            if (property > 0 && strlen(characters2) - length2)
              append2(property > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1) : declaration(replace(characters2, " ", "") + ";", rule, parent, length2 - 2), declarations);
            break;
          case 59:
            characters2 += ";";
          default:
            append2(reference = ruleset(characters2, root2, parent, index, offset, rules, points, type, props = [], children = [], length2), rulesets);
            if (character2 === 123)
              if (offset === 0)
                parse3(characters2, root2, reference, reference, props, rulesets, length2, points, children);
              else
                switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    parse3(value, reference, reference, rule && append2(ruleset(value, reference, reference, 0, 0, rules, points, type, rules, props = [], length2), children), rules, children, length2, points, rule ? props : children);
                    break;
                  default:
                    parse3(characters2, reference, reference, reference, [""], children, 0, points, children);
                }
        }
        index = offset = property = 0, variable = ampersand = 1, type = characters2 = "", length2 = pseudo;
        break;
      case 58:
        length2 = 1 + strlen(characters2), property = previous;
      default:
        if (variable < 1) {
          if (character2 == 123)
            --variable;
          else if (character2 == 125 && variable++ == 0 && prev() == 125)
            continue;
        }
        switch (characters2 += from6(character2), character2 * variable) {
          case 38:
            ampersand = offset > 0 ? 1 : (characters2 += "\f", -1);
            break;
          case 44:
            points[index++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
            break;
          case 64:
            if (peek() === 45)
              characters2 += delimit(next10());
            atrule = peek(), offset = length2 = strlen(type = characters2 += identifier(caret())), character2++;
            break;
          case 45:
            if (previous === 45 && strlen(characters2) == 2)
              variable = 0;
        }
    }
  return rulesets;
}
function ruleset(value, root2, parent, index, offset, rules, points, type, props, children, length2) {
  var post = offset - 1;
  var rule = offset === 0 ? rules : [""];
  var size3 = sizeof(rule);
  for (var i = 0, j = 0, k2 = 0; i < index; ++i)
    for (var x2 = 0, y2 = substr2(value, post + 1, post = abs(j = points[i])), z2 = value; x2 < size3; ++x2)
      if (z2 = trim$1(j > 0 ? rule[x2] + " " + y2 : replace(y2, /&\f/g, rule[x2])))
        props[k2++] = z2;
  return node(value, root2, parent, offset === 0 ? RULESET : type, props, children, length2);
}
function comment(value, root2, parent) {
  return node(value, root2, parent, COMMENT, from6(char()), substr2(value, 2, -2), 0);
}
function declaration(value, root2, parent, length2) {
  return node(value, root2, parent, DECLARATION, substr2(value, 0, length2), substr2(value, length2 + 1, -1), length2);
}
function serialize(children, callback2) {
  var output = "";
  var length2 = sizeof(children);
  for (var i = 0; i < length2; i++)
    output += callback2(children[i], i, children, callback2) || "";
  return output;
}
function stringify2(element, index, children, callback2) {
  switch (element.type) {
    case LAYER:
      if (element.children.length) break;
    case IMPORT:
    case DECLARATION:
      return element.return = element.return || element.value;
    case COMMENT:
      return "";
    case KEYFRAMES:
      return element.return = element.value + "{" + serialize(element.children, callback2) + "}";
    case RULESET:
      element.value = element.props.join(",");
  }
  return strlen(children = serialize(element.children, callback2)) ? element.return = element.value + "{" + children + "}" : "";
}
function middleware(collection2) {
  var length2 = sizeof(collection2);
  return function(element, index, children, callback2) {
    var output = "";
    for (var i = 0; i < length2; i++)
      output += collection2[i](element, index, children, callback2) || "";
    return output;
  };
}
function rulesheet(callback2) {
  return function(element) {
    if (!element.root) {
      if (element = element.return)
        callback2(element);
    }
  };
}
var identifierWithPointTracking = function identifierWithPointTracking3(begin, points, index) {
  var previous = 0;
  var character2 = 0;
  while (true) {
    previous = character2;
    character2 = peek();
    if (previous === 38 && character2 === 12) {
      points[index] = 1;
    }
    if (token(character2)) {
      break;
    }
    next10();
  }
  return slice4(begin, position);
};
var toRules = function toRules3(parsed, points) {
  var index = -1;
  var character2 = 44;
  do {
    switch (token(character2)) {
      case 0:
        if (character2 === 38 && peek() === 12) {
          points[index] = 1;
        }
        parsed[index] += identifierWithPointTracking(position - 1, points, index);
        break;
      case 2:
        parsed[index] += delimit(character2);
        break;
      case 4:
        if (character2 === 44) {
          parsed[++index] = peek() === 58 ? "&\f" : "";
          points[index] = parsed[index].length;
          break;
        }
      default:
        parsed[index] += from6(character2);
    }
  } while (character2 = next10());
  return parsed;
};
var getRules = function getRules3(value, points) {
  return dealloc(toRules(alloc(value), points));
};
var fixedElements = /* @__PURE__ */ new WeakMap();
var compat = function compat3(element) {
  if (element.type !== "rule" || !element.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  element.length < 1) {
    return;
  }
  var value = element.value;
  var parent = element.parent;
  var isImplicitRule = element.column === parent.column && element.line === parent.line;
  while (parent.type !== "rule") {
    parent = parent.parent;
    if (!parent) return;
  }
  if (element.props.length === 1 && value.charCodeAt(0) !== 58 && !fixedElements.get(parent)) {
    return;
  }
  if (isImplicitRule) {
    return;
  }
  fixedElements.set(element, true);
  var points = [];
  var rules = getRules(value, points);
  var parentRules = parent.props;
  for (var i = 0, k2 = 0; i < rules.length; i++) {
    for (var j = 0; j < parentRules.length; j++, k2++) {
      element.props[k2] = points[i] ? rules[i].replace(/&\f/g, parentRules[j]) : parentRules[j] + " " + rules[i];
    }
  }
};
var removeLabel = function removeLabel3(element) {
  if (element.type === "decl") {
    var value = element.value;
    if (
      // charcode for l
      value.charCodeAt(0) === 108 && // charcode for b
      value.charCodeAt(2) === 98
    ) {
      element["return"] = "";
      element.value = "";
    }
  }
};
function prefix(value, length2) {
  switch (hash(value, length2)) {
    case 5103:
      return WEBKIT + "print-" + value + value;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return WEBKIT + value + value;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return WEBKIT + value + MOZ + value + MS + value + value;
    case 6828:
    case 4268:
      return WEBKIT + value + MS + value + value;
    case 6165:
      return WEBKIT + value + MS + "flex-" + value + value;
    case 5187:
      return WEBKIT + value + replace(value, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + value;
    case 5443:
      return WEBKIT + value + MS + "flex-item-" + replace(value, /flex-|-self/, "") + value;
    case 4675:
      return WEBKIT + value + MS + "flex-line-pack" + replace(value, /align-content|flex-|-self/, "") + value;
    case 5548:
      return WEBKIT + value + MS + replace(value, "shrink", "negative") + value;
    case 5292:
      return WEBKIT + value + MS + replace(value, "basis", "preferred-size") + value;
    case 6060:
      return WEBKIT + "box-" + replace(value, "-grow", "") + WEBKIT + value + MS + replace(value, "grow", "positive") + value;
    case 4554:
      return WEBKIT + replace(value, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + value;
    case 6187:
      return replace(replace(replace(value, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value, "") + value;
    case 5495:
    case 3959:
      return replace(value, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
    case 4968:
      return replace(replace(value, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + value + value;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return replace(value, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (strlen(value) - 1 - length2 > 6) switch (charat(value, length2 + 1)) {
        case 109:
          if (charat(value, length2 + 4) !== 45) break;
        case 102:
          return replace(value, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(value, length2 + 3) == 108 ? "$3" : "$2-$3")) + value;
        case 115:
          return ~indexof(value, "stretch") ? prefix(replace(value, "stretch", "fill-available"), length2) + value : value;
      }
      break;
    case 4949:
      if (charat(value, length2 + 1) !== 115) break;
    case 6444:
      switch (charat(value, strlen(value) - 3 - (~indexof(value, "!important") && 10))) {
        case 107:
          return replace(value, ":", ":" + WEBKIT) + value;
        case 101:
          return replace(value, /(.+:)([^;!]+)(;|!.+)?/, "$1" + WEBKIT + (charat(value, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + value;
      }
      break;
    case 5936:
      switch (charat(value, length2 + 11)) {
        case 114:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
        case 108:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
        case 45:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
      }
      return WEBKIT + value + MS + value + value;
  }
  return value;
}
var prefixer = function prefixer3(element, index, children, callback2) {
  if (element.length > -1) {
    if (!element["return"]) switch (element.type) {
      case DECLARATION:
        element["return"] = prefix(element.value, element.length);
        break;
      case KEYFRAMES:
        return serialize([copy(element, {
          value: replace(element.value, "@", "@" + WEBKIT)
        })], callback2);
      case RULESET:
        if (element.length) return combine(element.props, function(value) {
          switch (match(value, /(::plac\w+|:read-\w+)/)) {
            case ":read-only":
            case ":read-write":
              return serialize([copy(element, {
                props: [replace(value, /:(read-\w+)/, ":" + MOZ + "$1")]
              })], callback2);
            case "::placeholder":
              return serialize([copy(element, {
                props: [replace(value, /:(plac\w+)/, ":" + WEBKIT + "input-$1")]
              }), copy(element, {
                props: [replace(value, /:(plac\w+)/, ":" + MOZ + "$1")]
              }), copy(element, {
                props: [replace(value, /:(plac\w+)/, MS + "input-$1")]
              })], callback2);
          }
          return "";
        });
    }
  }
};
var defaultStylisPlugins = [prefixer];
var createCache = function createCache3(options) {
  var key = options.key;
  if (key === "css") {
    var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(ssrStyles, function(node2) {
      var dataEmotionAttribute = node2.getAttribute("data-emotion");
      if (dataEmotionAttribute.indexOf(" ") === -1) {
        return;
      }
      document.head.appendChild(node2);
      node2.setAttribute("data-s", "");
    });
  }
  var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;
  var inserted = {};
  var container;
  var nodesToHydrate = [];
  {
    container = options.container || document.head;
    Array.prototype.forEach.call(
      // this means we will ignore elements which don't have a space in them which
      // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
      document.querySelectorAll('style[data-emotion^="' + key + ' "]'),
      function(node2) {
        var attrib = node2.getAttribute("data-emotion").split(" ");
        for (var i = 1; i < attrib.length; i++) {
          inserted[attrib[i]] = true;
        }
        nodesToHydrate.push(node2);
      }
    );
  }
  var _insert;
  var omnipresentPlugins = [compat, removeLabel];
  {
    var currentSheet;
    var finalizingPlugins = [stringify2, rulesheet(function(rule) {
      currentSheet.insert(rule);
    })];
    var serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));
    var stylis = function stylis2(styles2) {
      return serialize(compile(styles2), serializer);
    };
    _insert = function insert(selector, serialized, sheet, shouldCache) {
      currentSheet = sheet;
      stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
      if (shouldCache) {
        cache.inserted[serialized.name] = true;
      }
    };
  }
  var cache = {
    key,
    sheet: new StyleSheet({
      key,
      container,
      nonce: options.nonce,
      speedy: options.speedy,
      prepend: options.prepend,
      insertionPoint: options.insertionPoint
    }),
    nonce: options.nonce,
    inserted,
    registered: {},
    insert: _insert
  };
  cache.sheet.hydrate(nodesToHydrate);
  return cache;
};
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(n2) {
    for (var e2 = 1; e2 < arguments.length; e2++) {
      var t2 = arguments[e2];
      for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
    }
    return n2;
  }, _extends.apply(null, arguments);
}
var reactIs$1 = { exports: {} };
var reactIs_production_min = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b = "function" === typeof Symbol && Symbol.for, c = b ? Symbol.for("react.element") : 60103, d = b ? Symbol.for("react.portal") : 60106, e = b ? Symbol.for("react.fragment") : 60107, f = b ? Symbol.for("react.strict_mode") : 60108, g = b ? Symbol.for("react.profiler") : 60114, h = b ? Symbol.for("react.provider") : 60109, k = b ? Symbol.for("react.context") : 60110, l = b ? Symbol.for("react.async_mode") : 60111, m = b ? Symbol.for("react.concurrent_mode") : 60111, n = b ? Symbol.for("react.forward_ref") : 60112, p = b ? Symbol.for("react.suspense") : 60113, q = b ? Symbol.for("react.suspense_list") : 60120, r = b ? Symbol.for("react.memo") : 60115, t = b ? Symbol.for("react.lazy") : 60116, v = b ? Symbol.for("react.block") : 60121, w = b ? Symbol.for("react.fundamental") : 60117, x = b ? Symbol.for("react.responder") : 60118, y = b ? Symbol.for("react.scope") : 60119;
function z(a) {
  if ("object" === typeof a && null !== a) {
    var u2 = a.$$typeof;
    switch (u2) {
      case c:
        switch (a = a.type, a) {
          case l:
          case m:
          case e:
          case g:
          case f:
          case p:
            return a;
          default:
            switch (a = a && a.$$typeof, a) {
              case k:
              case n:
              case t:
              case r:
              case h:
                return a;
              default:
                return u2;
            }
        }
      case d:
        return u2;
    }
  }
}
function A(a) {
  return z(a) === m;
}
reactIs_production_min.AsyncMode = l;
reactIs_production_min.ConcurrentMode = m;
reactIs_production_min.ContextConsumer = k;
reactIs_production_min.ContextProvider = h;
reactIs_production_min.Element = c;
reactIs_production_min.ForwardRef = n;
reactIs_production_min.Fragment = e;
reactIs_production_min.Lazy = t;
reactIs_production_min.Memo = r;
reactIs_production_min.Portal = d;
reactIs_production_min.Profiler = g;
reactIs_production_min.StrictMode = f;
reactIs_production_min.Suspense = p;
reactIs_production_min.isAsyncMode = function(a) {
  return A(a) || z(a) === l;
};
reactIs_production_min.isConcurrentMode = A;
reactIs_production_min.isContextConsumer = function(a) {
  return z(a) === k;
};
reactIs_production_min.isContextProvider = function(a) {
  return z(a) === h;
};
reactIs_production_min.isElement = function(a) {
  return "object" === typeof a && null !== a && a.$$typeof === c;
};
reactIs_production_min.isForwardRef = function(a) {
  return z(a) === n;
};
reactIs_production_min.isFragment = function(a) {
  return z(a) === e;
};
reactIs_production_min.isLazy = function(a) {
  return z(a) === t;
};
reactIs_production_min.isMemo = function(a) {
  return z(a) === r;
};
reactIs_production_min.isPortal = function(a) {
  return z(a) === d;
};
reactIs_production_min.isProfiler = function(a) {
  return z(a) === g;
};
reactIs_production_min.isStrictMode = function(a) {
  return z(a) === f;
};
reactIs_production_min.isSuspense = function(a) {
  return z(a) === p;
};
reactIs_production_min.isValidElementType = function(a) {
  return "string" === typeof a || "function" === typeof a || a === e || a === m || a === g || a === f || a === p || a === q || "object" === typeof a && null !== a && (a.$$typeof === t || a.$$typeof === r || a.$$typeof === h || a.$$typeof === k || a.$$typeof === n || a.$$typeof === w || a.$$typeof === x || a.$$typeof === y || a.$$typeof === v);
};
reactIs_production_min.typeOf = z;
{
  reactIs$1.exports = reactIs_production_min;
}
var reactIsExports = reactIs$1.exports;
var reactIs = reactIsExports;
var FORWARD_REF_STATICS = {
  "$$typeof": true,
  render: true,
  defaultProps: true,
  displayName: true,
  propTypes: true
};
var MEMO_STATICS = {
  "$$typeof": true,
  compare: true,
  defaultProps: true,
  displayName: true,
  propTypes: true,
  type: true
};
var TYPE_STATICS = {};
TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
var isBrowser = true;
function getRegisteredStyles(registered, registeredStyles, classNames2) {
  var rawClassName = "";
  classNames2.split(" ").forEach(function(className) {
    if (registered[className] !== void 0) {
      registeredStyles.push(registered[className] + ";");
    } else if (className) {
      rawClassName += className + " ";
    }
  });
  return rawClassName;
}
var registerStyles2 = function registerStyles3(cache, serialized, isStringTag2) {
  var className = cache.key + "-" + serialized.name;
  if (
    // we only need to add the styles to the registered cache if the
    // class name could be used further down
    // the tree but if it's a string tag, we know it won't
    // so we don't have to add it to registered cache.
    // this improves memory usage since we can avoid storing the whole style string
    (isStringTag2 === false || // we need to always store it if we're in compat mode and
    // in node since emotion-server relies on whether a style is in
    // the registered cache to know whether a style is global or not
    // also, note that this check will be dead code eliminated in the browser
    isBrowser === false) && cache.registered[className] === void 0
  ) {
    cache.registered[className] = serialized.styles;
  }
};
var insertStyles2 = function insertStyles3(cache, serialized, isStringTag2) {
  registerStyles2(cache, serialized, isStringTag2);
  var className = cache.key + "-" + serialized.name;
  if (cache.inserted[serialized.name] === void 0) {
    var current = serialized;
    do {
      cache.insert(serialized === current ? "." + className : "", current, cache.sheet, true);
      current = current.next;
    } while (current !== void 0);
  }
};
var syncFallback2 = function syncFallback3(create4) {
  return create4();
};
var useInsertionEffect = React$2["useInsertionEffect"] ? React$2["useInsertionEffect"] : false;
var useInsertionEffectAlwaysWithSyncFallback = useInsertionEffect || syncFallback2;
var useInsertionEffectWithLayoutFallback = useInsertionEffect || reactExports.useLayoutEffect;
var isDevelopment = false;
var EmotionCacheContext = /* @__PURE__ */ reactExports.createContext(
  // we're doing this to avoid preconstruct's dead code elimination in this one case
  // because this module is primarily intended for the browser and node
  // but it's also required in react native and similar environments sometimes
  // and we could have a special build just for that
  // but this is much easier and the native packages
  // might use a different theme context in the future anyway
  typeof HTMLElement !== "undefined" ? /* @__PURE__ */ createCache({
    key: "css"
  }) : null
);
EmotionCacheContext.Provider;
var withEmotionCache = function withEmotionCache3(func) {
  return /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
    var cache = reactExports.useContext(EmotionCacheContext);
    return func(props, cache, ref);
  });
};
var ThemeContext = /* @__PURE__ */ reactExports.createContext({});
var hasOwn2 = {}.hasOwnProperty;
var typePropName = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__";
var createEmotionProps = function createEmotionProps2(type, props) {
  var newProps = {};
  for (var _key in props) {
    if (hasOwn2.call(props, _key)) {
      newProps[_key] = props[_key];
    }
  }
  newProps[typePropName] = type;
  return newProps;
};
var Insertion = function Insertion3(_ref) {
  var cache = _ref.cache, serialized = _ref.serialized, isStringTag2 = _ref.isStringTag;
  registerStyles2(cache, serialized, isStringTag2);
  useInsertionEffectAlwaysWithSyncFallback(function() {
    return insertStyles2(cache, serialized, isStringTag2);
  });
  return null;
};
var Emotion = /* @__PURE__ */ withEmotionCache(function(props, cache, ref) {
  var cssProp = props.css;
  if (typeof cssProp === "string" && cache.registered[cssProp] !== void 0) {
    cssProp = cache.registered[cssProp];
  }
  var WrappedComponent = props[typePropName];
  var registeredStyles = [cssProp];
  var className = "";
  if (typeof props.className === "string") {
    className = getRegisteredStyles(cache.registered, registeredStyles, props.className);
  } else if (props.className != null) {
    className = props.className + " ";
  }
  var serialized = serializeStyles(registeredStyles, void 0, reactExports.useContext(ThemeContext));
  className += cache.key + "-" + serialized.name;
  var newProps = {};
  for (var _key2 in props) {
    if (hasOwn2.call(props, _key2) && _key2 !== "css" && _key2 !== typePropName && !isDevelopment) {
      newProps[_key2] = props[_key2];
    }
  }
  newProps.className = className;
  if (ref) {
    newProps.ref = ref;
  }
  return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(Insertion, {
    cache,
    serialized,
    isStringTag: typeof WrappedComponent === "string"
  }), /* @__PURE__ */ reactExports.createElement(WrappedComponent, newProps));
});
var Emotion$1 = Emotion;
var jsx = function jsx2(type, props) {
  var args = arguments;
  if (props == null || !hasOwn2.call(props, "css")) {
    return reactExports.createElement.apply(void 0, args);
  }
  var argsLength = args.length;
  var createElementArgArray = new Array(argsLength);
  createElementArgArray[0] = Emotion$1;
  createElementArgArray[1] = createEmotionProps(type, props);
  for (var i = 2; i < argsLength; i++) {
    createElementArgArray[i] = args[i];
  }
  return reactExports.createElement.apply(null, createElementArgArray);
};
(function(_jsx) {
  var JSX;
  /* @__PURE__ */ (function(_JSX) {
  })(JSX || (JSX = _jsx.JSX || (_jsx.JSX = {})));
})(jsx);
var Global = /* @__PURE__ */ withEmotionCache(function(props, cache) {
  var styles2 = props.styles;
  var serialized = serializeStyles([styles2], void 0, reactExports.useContext(ThemeContext));
  var sheetRef = reactExports.useRef();
  useInsertionEffectWithLayoutFallback(function() {
    var key = cache.key + "-global";
    var sheet = new cache.sheet.constructor({
      key,
      nonce: cache.sheet.nonce,
      container: cache.sheet.container,
      speedy: cache.sheet.isSpeedy
    });
    var rehydrating = false;
    var node2 = document.querySelector('style[data-emotion="' + key + " " + serialized.name + '"]');
    if (cache.sheet.tags.length) {
      sheet.before = cache.sheet.tags[0];
    }
    if (node2 !== null) {
      rehydrating = true;
      node2.setAttribute("data-emotion", key);
      sheet.hydrate([node2]);
    }
    sheetRef.current = [sheet, rehydrating];
    return function() {
      sheet.flush();
    };
  }, [cache]);
  useInsertionEffectWithLayoutFallback(function() {
    var sheetRefCurrent = sheetRef.current;
    var sheet = sheetRefCurrent[0], rehydrating = sheetRefCurrent[1];
    if (rehydrating) {
      sheetRefCurrent[1] = false;
      return;
    }
    if (serialized.next !== void 0) {
      insertStyles2(cache, serialized.next, true);
    }
    if (sheet.tags.length) {
      var element = sheet.tags[sheet.tags.length - 1].nextElementSibling;
      sheet.before = element;
      sheet.flush();
    }
    cache.insert("", serialized, sheet, false);
  }, [cache, serialized.name]);
  return null;
});
function css() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return serializeStyles(args);
}
function keyframes() {
  var insertable = css.apply(void 0, arguments);
  var name = "animation-" + insertable.name;
  return {
    name,
    styles: "@keyframes " + name + "{" + insertable.styles + "}",
    anim: 1,
    toString: function toString8() {
      return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
    }
  };
}
function isEmpty(obj) {
  return obj === void 0 || obj === null || Object.keys(obj).length === 0;
}
function GlobalStyles$2(props) {
  const {
    styles: styles2,
    defaultTheme: defaultTheme2 = {}
  } = props;
  const globalStyles = typeof styles2 === "function" ? (themeInput) => styles2(isEmpty(themeInput) ? defaultTheme2 : themeInput) : styles2;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Global, {
    styles: globalStyles
  });
}
/**
 * @mui/styled-engine v6.4.6
 *
 * @license MIT
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
function styled$2(tag, options) {
  const stylesFactory = newStyled(tag, options);
  return stylesFactory;
}
function internal_mutateStyles(tag, processor) {
  if (Array.isArray(tag.__emotion_styles)) {
    tag.__emotion_styles = processor(tag.__emotion_styles);
  }
}
const wrapper = [];
function internal_serializeStyles(styles2) {
  wrapper[0] = styles2;
  return serializeStyles(wrapper);
}
const sortBreakpointsValues = (values5) => {
  const breakpointsAsArray = Object.keys(values5).map((key) => ({
    key,
    val: values5[key]
  })) || [];
  breakpointsAsArray.sort((breakpoint1, breakpoint2) => breakpoint1.val - breakpoint2.val);
  return breakpointsAsArray.reduce((acc, obj) => {
    return {
      ...acc,
      [obj.key]: obj.val
    };
  }, {});
};
function createBreakpoints(breakpoints) {
  const {
    // The breakpoint **start** at this value.
    // For instance with the first breakpoint xs: [xs, sm).
    values: values5 = {
      xs: 0,
      // phone
      sm: 600,
      // tablet
      md: 900,
      // small laptop
      lg: 1200,
      // desktop
      xl: 1536
      // large screen
    },
    unit = "px",
    step = 5,
    ...other
  } = breakpoints;
  const sortedValues = sortBreakpointsValues(values5);
  const keys6 = Object.keys(sortedValues);
  function up(key) {
    const value = typeof values5[key] === "number" ? values5[key] : key;
    return `@media (min-width:${value}${unit})`;
  }
  function down(key) {
    const value = typeof values5[key] === "number" ? values5[key] : key;
    return `@media (max-width:${value - step / 100}${unit})`;
  }
  function between(start, end) {
    const endIndex = keys6.indexOf(end);
    return `@media (min-width:${typeof values5[start] === "number" ? values5[start] : start}${unit}) and (max-width:${(endIndex !== -1 && typeof values5[keys6[endIndex]] === "number" ? values5[keys6[endIndex]] : end) - step / 100}${unit})`;
  }
  function only(key) {
    if (keys6.indexOf(key) + 1 < keys6.length) {
      return between(key, keys6[keys6.indexOf(key) + 1]);
    }
    return up(key);
  }
  function not(key) {
    const keyIndex = keys6.indexOf(key);
    if (keyIndex === 0) {
      return up(keys6[1]);
    }
    if (keyIndex === keys6.length - 1) {
      return down(keys6[keyIndex]);
    }
    return between(key, keys6[keys6.indexOf(key) + 1]).replace("@media", "@media not all and");
  }
  return {
    keys: keys6,
    values: sortedValues,
    up,
    down,
    between,
    only,
    not,
    unit,
    ...other
  };
}
const shape = {
  borderRadius: 4
};
function createSpacing(spacingInput = 8, transform = createUnarySpacing({
  spacing: spacingInput
})) {
  if (spacingInput.mui) {
    return spacingInput;
  }
  const spacing = (...argsInput) => {
    const args = argsInput.length === 0 ? [1] : argsInput;
    return args.map((argument) => {
      const output = transform(argument);
      return typeof output === "number" ? `${output}px` : output;
    }).join(" ");
  };
  spacing.mui = true;
  return spacing;
}
function applyStyles(key, styles2) {
  var _a;
  const theme = this;
  if (theme.vars) {
    if (!((_a = theme.colorSchemes) == null ? void 0 : _a[key]) || typeof theme.getColorSchemeSelector !== "function") {
      return {};
    }
    let selector = theme.getColorSchemeSelector(key);
    if (selector === "&") {
      return styles2;
    }
    if (selector.includes("data-") || selector.includes(".")) {
      selector = `*:where(${selector.replace(/\s*&$/, "")}) &`;
    }
    return {
      [selector]: styles2
    };
  }
  if (theme.palette.mode === key) {
    return styles2;
  }
  return {};
}
function createTheme$1(options = {}, ...args) {
  const {
    breakpoints: breakpointsInput = {},
    palette: paletteInput = {},
    spacing: spacingInput,
    shape: shapeInput = {},
    ...other
  } = options;
  const breakpoints = createBreakpoints(breakpointsInput);
  const spacing = createSpacing(spacingInput);
  let muiTheme = deepmerge({
    breakpoints,
    direction: "ltr",
    components: {},
    // Inject component definitions.
    palette: {
      mode: "light",
      ...paletteInput
    },
    spacing,
    shape: {
      ...shape,
      ...shapeInput
    }
  }, other);
  muiTheme = cssContainerQueries(muiTheme);
  muiTheme.applyStyles = applyStyles;
  muiTheme = args.reduce((acc, argument) => deepmerge(acc, argument), muiTheme);
  muiTheme.unstable_sxConfig = {
    ...defaultSxConfig,
    ...other == null ? void 0 : other.unstable_sxConfig
  };
  muiTheme.unstable_sx = function sx(props) {
    return styleFunctionSx({
      sx: props,
      theme: this
    });
  };
  return muiTheme;
}
function isObjectEmpty$1(obj) {
  return Object.keys(obj).length === 0;
}
function useTheme$2(defaultTheme2 = null) {
  const contextTheme = reactExports.useContext(ThemeContext);
  return !contextTheme || isObjectEmpty$1(contextTheme) ? defaultTheme2 : contextTheme;
}
const systemDefaultTheme$1 = createTheme$1();
function useTheme$1(defaultTheme2 = systemDefaultTheme$1) {
  return useTheme$2(defaultTheme2);
}
function GlobalStyles$1({
  styles: styles2,
  themeId,
  defaultTheme: defaultTheme2 = {}
}) {
  const upperTheme = useTheme$1(defaultTheme2);
  const globalStyles = typeof styles2 === "function" ? styles2(themeId ? upperTheme[themeId] || upperTheme : upperTheme) : styles2;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GlobalStyles$2, {
    styles: globalStyles
  });
}
function createBox(options = {}) {
  const {
    themeId,
    defaultTheme: defaultTheme2,
    defaultClassName = "MuiBox-root",
    generateClassName
  } = options;
  const BoxRoot = styled$2("div", {
    shouldForwardProp: (prop) => prop !== "theme" && prop !== "sx" && prop !== "as"
  })(styleFunctionSx);
  const Box2 = /* @__PURE__ */ reactExports.forwardRef(function Box3(inProps, ref) {
    const theme = useTheme$1(defaultTheme2);
    const {
      className,
      component = "div",
      ...other
    } = extendSxProp$1(inProps);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(BoxRoot, {
      as: component,
      ref,
      className: clsx(className, generateClassName ? generateClassName(defaultClassName) : defaultClassName),
      theme: themeId ? theme[themeId] || theme : theme,
      ...other
    });
  });
  return Box2;
}
function preprocessStyles(input) {
  const {
    variants,
    ...style2
  } = input;
  const result = {
    variants,
    style: internal_serializeStyles(style2),
    isProcessed: true
  };
  if (result.style === style2) {
    return result;
  }
  if (variants) {
    variants.forEach((variant) => {
      if (typeof variant.style !== "function") {
        variant.style = internal_serializeStyles(variant.style);
      }
    });
  }
  return result;
}
const systemDefaultTheme = createTheme$1();
function shouldForwardProp(prop) {
  return prop !== "ownerState" && prop !== "theme" && prop !== "sx" && prop !== "as";
}
function defaultOverridesResolver(slot) {
  if (!slot) {
    return null;
  }
  return (_props, styles2) => styles2[slot];
}
function attachTheme(props, themeId, defaultTheme2) {
  props.theme = isObjectEmpty(props.theme) ? defaultTheme2 : props.theme[themeId] || props.theme;
}
function processStyle(props, style2) {
  const resolvedStyle = typeof style2 === "function" ? style2(props) : style2;
  if (Array.isArray(resolvedStyle)) {
    return resolvedStyle.flatMap((subStyle) => processStyle(props, subStyle));
  }
  if (Array.isArray(resolvedStyle == null ? void 0 : resolvedStyle.variants)) {
    let rootStyle;
    if (resolvedStyle.isProcessed) {
      rootStyle = resolvedStyle.style;
    } else {
      const {
        variants,
        ...otherStyles
      } = resolvedStyle;
      rootStyle = otherStyles;
    }
    return processStyleVariants(props, resolvedStyle.variants, [rootStyle]);
  }
  if (resolvedStyle == null ? void 0 : resolvedStyle.isProcessed) {
    return resolvedStyle.style;
  }
  return resolvedStyle;
}
function processStyleVariants(props, variants, results = []) {
  var _a;
  let mergedState;
  variantLoop: for (let i = 0; i < variants.length; i += 1) {
    const variant = variants[i];
    if (typeof variant.props === "function") {
      mergedState ?? (mergedState = {
        ...props,
        ...props.ownerState,
        ownerState: props.ownerState
      });
      if (!variant.props(mergedState)) {
        continue;
      }
    } else {
      for (const key in variant.props) {
        if (props[key] !== variant.props[key] && ((_a = props.ownerState) == null ? void 0 : _a[key]) !== variant.props[key]) {
          continue variantLoop;
        }
      }
    }
    if (typeof variant.style === "function") {
      mergedState ?? (mergedState = {
        ...props,
        ...props.ownerState,
        ownerState: props.ownerState
      });
      results.push(variant.style(mergedState));
    } else {
      results.push(variant.style);
    }
  }
  return results;
}
function createStyled(input = {}) {
  const {
    themeId,
    defaultTheme: defaultTheme2 = systemDefaultTheme,
    rootShouldForwardProp: rootShouldForwardProp2 = shouldForwardProp,
    slotShouldForwardProp: slotShouldForwardProp2 = shouldForwardProp
  } = input;
  function styleAttachTheme(props) {
    attachTheme(props, themeId, defaultTheme2);
  }
  const styled2 = (tag, inputOptions = {}) => {
    internal_mutateStyles(tag, (styles2) => styles2.filter((style2) => style2 !== styleFunctionSx));
    const {
      name: componentName,
      slot: componentSlot,
      skipVariantsResolver: inputSkipVariantsResolver,
      skipSx: inputSkipSx,
      // TODO v6: remove `lowercaseFirstLetter()` in the next major release
      // For more details: https://github.com/mui/material-ui/pull/37908
      overridesResolver = defaultOverridesResolver(lowercaseFirstLetter(componentSlot)),
      ...options
    } = inputOptions;
    const skipVariantsResolver = inputSkipVariantsResolver !== void 0 ? inputSkipVariantsResolver : (
      // TODO v6: remove `Root` in the next major release
      // For more details: https://github.com/mui/material-ui/pull/37908
      componentSlot && componentSlot !== "Root" && componentSlot !== "root" || false
    );
    const skipSx = inputSkipSx || false;
    let shouldForwardPropOption = shouldForwardProp;
    if (componentSlot === "Root" || componentSlot === "root") {
      shouldForwardPropOption = rootShouldForwardProp2;
    } else if (componentSlot) {
      shouldForwardPropOption = slotShouldForwardProp2;
    } else if (isStringTag(tag)) {
      shouldForwardPropOption = void 0;
    }
    const defaultStyledResolver = styled$2(tag, {
      shouldForwardProp: shouldForwardPropOption,
      label: generateStyledLabel(),
      ...options
    });
    const transformStyle = (style2) => {
      if (typeof style2 === "function" && style2.__emotion_real !== style2) {
        return function styleFunctionProcessor(props) {
          return processStyle(props, style2);
        };
      }
      if (isPlainObject$2(style2)) {
        const serialized = preprocessStyles(style2);
        if (!serialized.variants) {
          return serialized.style;
        }
        return function styleObjectProcessor(props) {
          return processStyle(props, serialized);
        };
      }
      return style2;
    };
    const muiStyledResolver = (...expressionsInput) => {
      const expressionsHead = [];
      const expressionsBody = expressionsInput.map(transformStyle);
      const expressionsTail = [];
      expressionsHead.push(styleAttachTheme);
      if (componentName && overridesResolver) {
        expressionsTail.push(function styleThemeOverrides(props) {
          var _a, _b;
          const theme = props.theme;
          const styleOverrides = (_b = (_a = theme.components) == null ? void 0 : _a[componentName]) == null ? void 0 : _b.styleOverrides;
          if (!styleOverrides) {
            return null;
          }
          const resolvedStyleOverrides = {};
          for (const slotKey in styleOverrides) {
            resolvedStyleOverrides[slotKey] = processStyle(props, styleOverrides[slotKey]);
          }
          return overridesResolver(props, resolvedStyleOverrides);
        });
      }
      if (componentName && !skipVariantsResolver) {
        expressionsTail.push(function styleThemeVariants(props) {
          var _a, _b;
          const theme = props.theme;
          const themeVariants = (_b = (_a = theme == null ? void 0 : theme.components) == null ? void 0 : _a[componentName]) == null ? void 0 : _b.variants;
          if (!themeVariants) {
            return null;
          }
          return processStyleVariants(props, themeVariants);
        });
      }
      if (!skipSx) {
        expressionsTail.push(styleFunctionSx);
      }
      if (Array.isArray(expressionsBody[0])) {
        const inputStrings = expressionsBody.shift();
        const placeholdersHead = new Array(expressionsHead.length).fill("");
        const placeholdersTail = new Array(expressionsTail.length).fill("");
        let outputStrings;
        {
          outputStrings = [...placeholdersHead, ...inputStrings, ...placeholdersTail];
          outputStrings.raw = [...placeholdersHead, ...inputStrings.raw, ...placeholdersTail];
        }
        expressionsHead.unshift(outputStrings);
      }
      const expressions = [...expressionsHead, ...expressionsBody, ...expressionsTail];
      const Component = defaultStyledResolver(...expressions);
      if (tag.muiName) {
        Component.muiName = tag.muiName;
      }
      return Component;
    };
    if (defaultStyledResolver.withConfig) {
      muiStyledResolver.withConfig = defaultStyledResolver.withConfig;
    }
    return muiStyledResolver;
  };
  return styled2;
}
function generateStyledLabel(componentName, componentSlot) {
  let label;
  return label;
}
function isObjectEmpty(object) {
  for (const _ in object) {
    return false;
  }
  return true;
}
function isStringTag(tag) {
  return typeof tag === "string" && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  tag.charCodeAt(0) > 96;
}
function lowercaseFirstLetter(string) {
  if (!string) {
    return string;
  }
  return string.charAt(0).toLowerCase() + string.slice(1);
}
const styled$1 = createStyled();
function getThemeProps$1(params2) {
  const {
    theme,
    name,
    props
  } = params2;
  if (!theme || !theme.components || !theme.components[name] || !theme.components[name].defaultProps) {
    return props;
  }
  return resolveProps(theme.components[name].defaultProps, props);
}
function useThemeProps({
  props,
  name,
  defaultTheme: defaultTheme2,
  themeId
}) {
  let theme = useTheme$1(defaultTheme2);
  if (themeId) {
    theme = theme[themeId] || theme;
  }
  return getThemeProps$1({
    theme,
    name,
    props
  });
}
function clampWrapper(value, min2 = 0, max2 = 1) {
  return clamp2(value, min2, max2);
}
function hexToRgb(color2) {
  color2 = color2.slice(1);
  const re3 = new RegExp(`.{1,${color2.length >= 6 ? 2 : 1}}`, "g");
  let colors = color2.match(re3);
  if (colors && colors[0].length === 1) {
    colors = colors.map((n2) => n2 + n2);
  }
  return colors ? `rgb${colors.length === 4 ? "a" : ""}(${colors.map((n2, index) => {
    return index < 3 ? parseInt(n2, 16) : Math.round(parseInt(n2, 16) / 255 * 1e3) / 1e3;
  }).join(", ")})` : "";
}
function decomposeColor(color2) {
  if (color2.type) {
    return color2;
  }
  if (color2.charAt(0) === "#") {
    return decomposeColor(hexToRgb(color2));
  }
  const marker = color2.indexOf("(");
  const type = color2.substring(0, marker);
  if (!["rgb", "rgba", "hsl", "hsla", "color"].includes(type)) {
    throw new Error(formatMuiErrorMessage(9, color2));
  }
  let values5 = color2.substring(marker + 1, color2.length - 1);
  let colorSpace;
  if (type === "color") {
    values5 = values5.split(" ");
    colorSpace = values5.shift();
    if (values5.length === 4 && values5[3].charAt(0) === "/") {
      values5[3] = values5[3].slice(1);
    }
    if (!["srgb", "display-p3", "a98-rgb", "prophoto-rgb", "rec-2020"].includes(colorSpace)) {
      throw new Error(formatMuiErrorMessage(10, colorSpace));
    }
  } else {
    values5 = values5.split(",");
  }
  values5 = values5.map((value) => parseFloat(value));
  return {
    type,
    values: values5,
    colorSpace
  };
}
const colorChannel = (color2) => {
  const decomposedColor = decomposeColor(color2);
  return decomposedColor.values.slice(0, 3).map((val, idx) => decomposedColor.type.includes("hsl") && idx !== 0 ? `${val}%` : val).join(" ");
};
const private_safeColorChannel = (color2, warning2) => {
  try {
    return colorChannel(color2);
  } catch (error2) {
    return color2;
  }
};
function recomposeColor(color2) {
  const {
    type,
    colorSpace
  } = color2;
  let {
    values: values5
  } = color2;
  if (type.includes("rgb")) {
    values5 = values5.map((n2, i) => i < 3 ? parseInt(n2, 10) : n2);
  } else if (type.includes("hsl")) {
    values5[1] = `${values5[1]}%`;
    values5[2] = `${values5[2]}%`;
  }
  if (type.includes("color")) {
    values5 = `${colorSpace} ${values5.join(" ")}`;
  } else {
    values5 = `${values5.join(", ")}`;
  }
  return `${type}(${values5})`;
}
function hslToRgb(color2) {
  color2 = decomposeColor(color2);
  const {
    values: values5
  } = color2;
  const h2 = values5[0];
  const s = values5[1] / 100;
  const l2 = values5[2] / 100;
  const a = s * Math.min(l2, 1 - l2);
  const f2 = (n2, k2 = (n2 + h2 / 30) % 12) => l2 - a * Math.max(Math.min(k2 - 3, 9 - k2, 1), -1);
  let type = "rgb";
  const rgb = [Math.round(f2(0) * 255), Math.round(f2(8) * 255), Math.round(f2(4) * 255)];
  if (color2.type === "hsla") {
    type += "a";
    rgb.push(values5[3]);
  }
  return recomposeColor({
    type,
    values: rgb
  });
}
function getLuminance(color2) {
  color2 = decomposeColor(color2);
  let rgb = color2.type === "hsl" || color2.type === "hsla" ? decomposeColor(hslToRgb(color2)).values : color2.values;
  rgb = rgb.map((val) => {
    if (color2.type !== "color") {
      val /= 255;
    }
    return val <= 0.03928 ? val / 12.92 : ((val + 0.055) / 1.055) ** 2.4;
  });
  return Number((0.2126 * rgb[0] + 0.7152 * rgb[1] + 0.0722 * rgb[2]).toFixed(3));
}
function getContrastRatio(foreground, background) {
  const lumA = getLuminance(foreground);
  const lumB = getLuminance(background);
  return (Math.max(lumA, lumB) + 0.05) / (Math.min(lumA, lumB) + 0.05);
}
function alpha(color2, value) {
  color2 = decomposeColor(color2);
  value = clampWrapper(value);
  if (color2.type === "rgb" || color2.type === "hsl") {
    color2.type += "a";
  }
  if (color2.type === "color") {
    color2.values[3] = `/${value}`;
  } else {
    color2.values[3] = value;
  }
  return recomposeColor(color2);
}
function private_safeAlpha(color2, value, warning2) {
  try {
    return alpha(color2, value);
  } catch (error2) {
    return color2;
  }
}
function darken(color2, coefficient) {
  color2 = decomposeColor(color2);
  coefficient = clampWrapper(coefficient);
  if (color2.type.includes("hsl")) {
    color2.values[2] *= 1 - coefficient;
  } else if (color2.type.includes("rgb") || color2.type.includes("color")) {
    for (let i = 0; i < 3; i += 1) {
      color2.values[i] *= 1 - coefficient;
    }
  }
  return recomposeColor(color2);
}
function private_safeDarken(color2, coefficient, warning2) {
  try {
    return darken(color2, coefficient);
  } catch (error2) {
    return color2;
  }
}
function lighten(color2, coefficient) {
  color2 = decomposeColor(color2);
  coefficient = clampWrapper(coefficient);
  if (color2.type.includes("hsl")) {
    color2.values[2] += (100 - color2.values[2]) * coefficient;
  } else if (color2.type.includes("rgb")) {
    for (let i = 0; i < 3; i += 1) {
      color2.values[i] += (255 - color2.values[i]) * coefficient;
    }
  } else if (color2.type.includes("color")) {
    for (let i = 0; i < 3; i += 1) {
      color2.values[i] += (1 - color2.values[i]) * coefficient;
    }
  }
  return recomposeColor(color2);
}
function private_safeLighten(color2, coefficient, warning2) {
  try {
    return lighten(color2, coefficient);
  } catch (error2) {
    return color2;
  }
}
function emphasize(color2, coefficient = 0.15) {
  return getLuminance(color2) > 0.5 ? darken(color2, coefficient) : lighten(color2, coefficient);
}
function private_safeEmphasize(color2, coefficient, warning2) {
  try {
    return emphasize(color2, coefficient);
  } catch (error2) {
    return color2;
  }
}
const PropsContext = /* @__PURE__ */ reactExports.createContext(void 0);
function getThemeProps(params2) {
  const {
    theme,
    name,
    props
  } = params2;
  if (!theme || !theme.components || !theme.components[name]) {
    return props;
  }
  const config2 = theme.components[name];
  if (config2.defaultProps) {
    return resolveProps(config2.defaultProps, props);
  }
  if (!config2.styleOverrides && !config2.variants) {
    return resolveProps(config2, props);
  }
  return props;
}
function useDefaultProps$1({
  props,
  name
}) {
  const ctx = reactExports.useContext(PropsContext);
  return getThemeProps({
    props,
    name,
    theme: {
      components: ctx
    }
  });
}
const arg = {
  theme: void 0
};
function unstable_memoTheme(styleFn) {
  let lastValue;
  let lastTheme;
  return function styleMemoized(props) {
    let value = lastValue;
    if (value === void 0 || props.theme !== lastTheme) {
      arg.theme = props.theme;
      value = preprocessStyles(styleFn(arg));
      lastValue = value;
      lastTheme = props.theme;
    }
    return value;
  };
}
function createGetCssVar$1(prefix2 = "") {
  function appendVar(...vars) {
    if (!vars.length) {
      return "";
    }
    const value = vars[0];
    if (typeof value === "string" && !value.match(/(#|\(|\)|(-?(\d*\.)?\d+)(px|em|%|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc))|^(-?(\d*\.)?\d+)$|(\d+ \d+ \d+)/)) {
      return `, var(--${prefix2 ? `${prefix2}-` : ""}${value}${appendVar(...vars.slice(1))})`;
    }
    return `, ${value}`;
  }
  const getCssVar = (field, ...fallbacks) => {
    return `var(--${prefix2 ? `${prefix2}-` : ""}${field}${appendVar(...fallbacks)})`;
  };
  return getCssVar;
}
const assignNestedKeys = (obj, keys6, value, arrayKeys2 = []) => {
  let temp = obj;
  keys6.forEach((k2, index) => {
    if (index === keys6.length - 1) {
      if (Array.isArray(temp)) {
        temp[Number(k2)] = value;
      } else if (temp && typeof temp === "object") {
        temp[k2] = value;
      }
    } else if (temp && typeof temp === "object") {
      if (!temp[k2]) {
        temp[k2] = arrayKeys2.includes(k2) ? [] : {};
      }
      temp = temp[k2];
    }
  });
};
const walkObjectDeep = (obj, callback2, shouldSkipPaths) => {
  function recurse(object, parentKeys = [], arrayKeys2 = []) {
    Object.entries(object).forEach(([key, value]) => {
      if (!shouldSkipPaths || !shouldSkipPaths([...parentKeys, key])) {
        if (value !== void 0 && value !== null) {
          if (typeof value === "object" && Object.keys(value).length > 0) {
            recurse(value, [...parentKeys, key], Array.isArray(value) ? [...arrayKeys2, key] : arrayKeys2);
          } else {
            callback2([...parentKeys, key], value, arrayKeys2);
          }
        }
      }
    });
  }
  recurse(obj);
};
const getCssValue = (keys6, value) => {
  if (typeof value === "number") {
    if (["lineHeight", "fontWeight", "opacity", "zIndex"].some((prop) => keys6.includes(prop))) {
      return value;
    }
    const lastKey = keys6[keys6.length - 1];
    if (lastKey.toLowerCase().includes("opacity")) {
      return value;
    }
    return `${value}px`;
  }
  return value;
};
function cssVarsParser(theme, options) {
  const {
    prefix: prefix2,
    shouldSkipGeneratingVar: shouldSkipGeneratingVar2
  } = options || {};
  const css2 = {};
  const vars = {};
  const varsWithDefaults = {};
  walkObjectDeep(
    theme,
    (keys6, value, arrayKeys2) => {
      if (typeof value === "string" || typeof value === "number") {
        if (!shouldSkipGeneratingVar2 || !shouldSkipGeneratingVar2(keys6, value)) {
          const cssVar = `--${prefix2 ? `${prefix2}-` : ""}${keys6.join("-")}`;
          const resolvedValue = getCssValue(keys6, value);
          Object.assign(css2, {
            [cssVar]: resolvedValue
          });
          assignNestedKeys(vars, keys6, `var(${cssVar})`, arrayKeys2);
          assignNestedKeys(varsWithDefaults, keys6, `var(${cssVar}, ${resolvedValue})`, arrayKeys2);
        }
      }
    },
    (keys6) => keys6[0] === "vars"
    // skip 'vars/*' paths
  );
  return {
    css: css2,
    vars,
    varsWithDefaults
  };
}
function prepareCssVars(theme, parserConfig = {}) {
  const {
    getSelector = defaultGetSelector2,
    disableCssColorScheme,
    colorSchemeSelector: selector
  } = parserConfig;
  const {
    colorSchemes = {},
    components,
    defaultColorScheme = "light",
    ...otherTheme
  } = theme;
  const {
    vars: rootVars,
    css: rootCss,
    varsWithDefaults: rootVarsWithDefaults
  } = cssVarsParser(otherTheme, parserConfig);
  let themeVars = rootVarsWithDefaults;
  const colorSchemesMap = {};
  const {
    [defaultColorScheme]: defaultScheme,
    ...otherColorSchemes
  } = colorSchemes;
  Object.entries(otherColorSchemes || {}).forEach(([key, scheme]) => {
    const {
      vars,
      css: css2,
      varsWithDefaults
    } = cssVarsParser(scheme, parserConfig);
    themeVars = deepmerge(themeVars, varsWithDefaults);
    colorSchemesMap[key] = {
      css: css2,
      vars
    };
  });
  if (defaultScheme) {
    const {
      css: css2,
      vars,
      varsWithDefaults
    } = cssVarsParser(defaultScheme, parserConfig);
    themeVars = deepmerge(themeVars, varsWithDefaults);
    colorSchemesMap[defaultColorScheme] = {
      css: css2,
      vars
    };
  }
  function defaultGetSelector2(colorScheme, cssObject) {
    var _a, _b;
    let rule = selector;
    if (selector === "class") {
      rule = ".%s";
    }
    if (selector === "data") {
      rule = "[data-%s]";
    }
    if ((selector == null ? void 0 : selector.startsWith("data-")) && !selector.includes("%s")) {
      rule = `[${selector}="%s"]`;
    }
    if (colorScheme) {
      if (rule === "media") {
        if (theme.defaultColorScheme === colorScheme) {
          return ":root";
        }
        const mode = ((_b = (_a = colorSchemes[colorScheme]) == null ? void 0 : _a.palette) == null ? void 0 : _b.mode) || colorScheme;
        return {
          [`@media (prefers-color-scheme: ${mode})`]: {
            ":root": cssObject
          }
        };
      }
      if (rule) {
        if (theme.defaultColorScheme === colorScheme) {
          return `:root, ${rule.replace("%s", String(colorScheme))}`;
        }
        return rule.replace("%s", String(colorScheme));
      }
    }
    return ":root";
  }
  const generateThemeVars = () => {
    let vars = {
      ...rootVars
    };
    Object.entries(colorSchemesMap).forEach(([, {
      vars: schemeVars
    }]) => {
      vars = deepmerge(vars, schemeVars);
    });
    return vars;
  };
  const generateStyleSheets = () => {
    var _a, _b;
    const stylesheets = [];
    const colorScheme = theme.defaultColorScheme || "light";
    function insertStyleSheet(key, css2) {
      if (Object.keys(css2).length) {
        stylesheets.push(typeof key === "string" ? {
          [key]: {
            ...css2
          }
        } : key);
      }
    }
    insertStyleSheet(getSelector(void 0, {
      ...rootCss
    }), rootCss);
    const {
      [colorScheme]: defaultSchemeVal,
      ...other
    } = colorSchemesMap;
    if (defaultSchemeVal) {
      const {
        css: css2
      } = defaultSchemeVal;
      const cssColorSheme = (_b = (_a = colorSchemes[colorScheme]) == null ? void 0 : _a.palette) == null ? void 0 : _b.mode;
      const finalCss = !disableCssColorScheme && cssColorSheme ? {
        colorScheme: cssColorSheme,
        ...css2
      } : {
        ...css2
      };
      insertStyleSheet(getSelector(colorScheme, {
        ...finalCss
      }), finalCss);
    }
    Object.entries(other).forEach(([key, {
      css: css2
    }]) => {
      var _a2, _b2;
      const cssColorSheme = (_b2 = (_a2 = colorSchemes[key]) == null ? void 0 : _a2.palette) == null ? void 0 : _b2.mode;
      const finalCss = !disableCssColorScheme && cssColorSheme ? {
        colorScheme: cssColorSheme,
        ...css2
      } : {
        ...css2
      };
      insertStyleSheet(getSelector(key, {
        ...finalCss
      }), finalCss);
    });
    return stylesheets;
  };
  return {
    vars: themeVars,
    generateThemeVars,
    generateStyleSheets
  };
}
function createGetColorSchemeSelector(selector) {
  return function getColorSchemeSelector(colorScheme) {
    if (selector === "media") {
      return `@media (prefers-color-scheme: ${colorScheme})`;
    }
    if (selector) {
      if (selector.startsWith("data-") && !selector.includes("%s")) {
        return `[${selector}="${colorScheme}"] &`;
      }
      if (selector === "class") {
        return `.${colorScheme} &`;
      }
      if (selector === "data") {
        return `[data-${colorScheme}] &`;
      }
      return `${selector.replace("%s", colorScheme)} &`;
    }
    return "&";
  };
}
const defaultTheme$2 = createTheme$1();
const defaultCreateStyledComponent = styled$1("div", {
  name: "MuiStack",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
});
function useThemePropsDefault(props) {
  return useThemeProps({
    props,
    name: "MuiStack",
    defaultTheme: defaultTheme$2
  });
}
function joinChildren(children, separator) {
  const childrenArray = reactExports.Children.toArray(children).filter(Boolean);
  return childrenArray.reduce((output, child, index) => {
    output.push(child);
    if (index < childrenArray.length - 1) {
      output.push(/* @__PURE__ */ reactExports.cloneElement(separator, {
        key: `separator-${index}`
      }));
    }
    return output;
  }, []);
}
const getSideFromDirection = (direction) => {
  return {
    row: "Left",
    "row-reverse": "Right",
    column: "Top",
    "column-reverse": "Bottom"
  }[direction];
};
const style = ({
  ownerState,
  theme
}) => {
  let styles2 = {
    display: "flex",
    flexDirection: "column",
    ...handleBreakpoints({
      theme
    }, resolveBreakpointValues({
      values: ownerState.direction,
      breakpoints: theme.breakpoints.values
    }), (propValue) => ({
      flexDirection: propValue
    }))
  };
  if (ownerState.spacing) {
    const transformer = createUnarySpacing(theme);
    const base2 = Object.keys(theme.breakpoints.values).reduce((acc, breakpoint) => {
      if (typeof ownerState.spacing === "object" && ownerState.spacing[breakpoint] != null || typeof ownerState.direction === "object" && ownerState.direction[breakpoint] != null) {
        acc[breakpoint] = true;
      }
      return acc;
    }, {});
    const directionValues = resolveBreakpointValues({
      values: ownerState.direction,
      base: base2
    });
    const spacingValues = resolveBreakpointValues({
      values: ownerState.spacing,
      base: base2
    });
    if (typeof directionValues === "object") {
      Object.keys(directionValues).forEach((breakpoint, index, breakpoints) => {
        const directionValue = directionValues[breakpoint];
        if (!directionValue) {
          const previousDirectionValue = index > 0 ? directionValues[breakpoints[index - 1]] : "column";
          directionValues[breakpoint] = previousDirectionValue;
        }
      });
    }
    const styleFromPropValue = (propValue, breakpoint) => {
      if (ownerState.useFlexGap) {
        return {
          gap: getValue(transformer, propValue)
        };
      }
      return {
        // The useFlexGap={false} implement relies on each child to give up control of the margin.
        // We need to reset the margin to avoid double spacing.
        "& > :not(style):not(style)": {
          margin: 0
        },
        "& > :not(style) ~ :not(style)": {
          [`margin${getSideFromDirection(breakpoint ? directionValues[breakpoint] : ownerState.direction)}`]: getValue(transformer, propValue)
        }
      };
    };
    styles2 = deepmerge(styles2, handleBreakpoints({
      theme
    }, spacingValues, styleFromPropValue));
  }
  styles2 = mergeBreakpointsInOrder(theme.breakpoints, styles2);
  return styles2;
};
function createStack(options = {}) {
  const {
    // This will allow adding custom styled fn (for example for custom sx style function)
    createStyledComponent = defaultCreateStyledComponent,
    useThemeProps: useThemeProps2 = useThemePropsDefault,
    componentName = "MuiStack"
  } = options;
  const useUtilityClasses2 = () => {
    const slots = {
      root: ["root"]
    };
    return composeClasses(slots, (slot) => generateUtilityClass(componentName, slot), {});
  };
  const StackRoot = createStyledComponent(style);
  const Stack2 = /* @__PURE__ */ reactExports.forwardRef(function Grid(inProps, ref) {
    const themeProps = useThemeProps2(inProps);
    const props = extendSxProp$1(themeProps);
    const {
      component = "div",
      direction = "column",
      spacing = 0,
      divider,
      children,
      className,
      useFlexGap = false,
      ...other
    } = props;
    const ownerState = {
      direction,
      spacing,
      useFlexGap
    };
    const classes = useUtilityClasses2();
    return /* @__PURE__ */ jsxRuntimeExports.jsx(StackRoot, {
      as: component,
      ownerState,
      ref,
      className: clsx(classes.root, className),
      ...other,
      children: divider ? joinChildren(children, divider) : children
    });
  });
  return Stack2;
}
const common = {
  black: "#000",
  white: "#fff"
};
const grey = {
  50: "#fafafa",
  100: "#f5f5f5",
  200: "#eeeeee",
  300: "#e0e0e0",
  400: "#bdbdbd",
  500: "#9e9e9e",
  600: "#757575",
  700: "#616161",
  800: "#424242",
  900: "#212121",
  A100: "#f5f5f5",
  A200: "#eeeeee",
  A400: "#bdbdbd",
  A700: "#616161"
};
const purple = {
  50: "#f3e5f5",
  100: "#e1bee7",
  200: "#ce93d8",
  300: "#ba68c8",
  400: "#ab47bc",
  500: "#9c27b0",
  600: "#8e24aa",
  700: "#7b1fa2",
  800: "#6a1b9a",
  900: "#4a148c",
  A100: "#ea80fc",
  A200: "#e040fb",
  A400: "#d500f9",
  A700: "#aa00ff"
};
const red = {
  50: "#ffebee",
  100: "#ffcdd2",
  200: "#ef9a9a",
  300: "#e57373",
  400: "#ef5350",
  500: "#f44336",
  600: "#e53935",
  700: "#d32f2f",
  800: "#c62828",
  900: "#b71c1c",
  A100: "#ff8a80",
  A200: "#ff5252",
  A400: "#ff1744",
  A700: "#d50000"
};
const orange = {
  50: "#fff3e0",
  100: "#ffe0b2",
  200: "#ffcc80",
  300: "#ffb74d",
  400: "#ffa726",
  500: "#ff9800",
  600: "#fb8c00",
  700: "#f57c00",
  800: "#ef6c00",
  900: "#e65100",
  A100: "#ffd180",
  A200: "#ffab40",
  A400: "#ff9100",
  A700: "#ff6d00"
};
const blue = {
  50: "#e3f2fd",
  100: "#bbdefb",
  200: "#90caf9",
  300: "#64b5f6",
  400: "#42a5f5",
  500: "#2196f3",
  600: "#1e88e5",
  700: "#1976d2",
  800: "#1565c0",
  900: "#0d47a1",
  A100: "#82b1ff",
  A200: "#448aff",
  A400: "#2979ff",
  A700: "#2962ff"
};
const lightBlue = {
  50: "#e1f5fe",
  100: "#b3e5fc",
  200: "#81d4fa",
  300: "#4fc3f7",
  400: "#29b6f6",
  500: "#03a9f4",
  600: "#039be5",
  700: "#0288d1",
  800: "#0277bd",
  900: "#01579b",
  A100: "#80d8ff",
  A200: "#40c4ff",
  A400: "#00b0ff",
  A700: "#0091ea"
};
const green = {
  50: "#e8f5e9",
  100: "#c8e6c9",
  200: "#a5d6a7",
  300: "#81c784",
  400: "#66bb6a",
  500: "#4caf50",
  600: "#43a047",
  700: "#388e3c",
  800: "#2e7d32",
  900: "#1b5e20",
  A100: "#b9f6ca",
  A200: "#69f0ae",
  A400: "#00e676",
  A700: "#00c853"
};
function getLight() {
  return {
    // The colors used to style the text.
    text: {
      // The most important text.
      primary: "rgba(0, 0, 0, 0.87)",
      // Secondary text.
      secondary: "rgba(0, 0, 0, 0.6)",
      // Disabled text have even lower visual prominence.
      disabled: "rgba(0, 0, 0, 0.38)"
    },
    // The color used to divide different elements.
    divider: "rgba(0, 0, 0, 0.12)",
    // The background colors used to style the surfaces.
    // Consistency between these values is important.
    background: {
      paper: common.white,
      default: common.white
    },
    // The colors used to style the action elements.
    action: {
      // The color of an active action like an icon button.
      active: "rgba(0, 0, 0, 0.54)",
      // The color of an hovered action.
      hover: "rgba(0, 0, 0, 0.04)",
      hoverOpacity: 0.04,
      // The color of a selected action.
      selected: "rgba(0, 0, 0, 0.08)",
      selectedOpacity: 0.08,
      // The color of a disabled action.
      disabled: "rgba(0, 0, 0, 0.26)",
      // The background color of a disabled action.
      disabledBackground: "rgba(0, 0, 0, 0.12)",
      disabledOpacity: 0.38,
      focus: "rgba(0, 0, 0, 0.12)",
      focusOpacity: 0.12,
      activatedOpacity: 0.12
    }
  };
}
const light = getLight();
function getDark() {
  return {
    text: {
      primary: common.white,
      secondary: "rgba(255, 255, 255, 0.7)",
      disabled: "rgba(255, 255, 255, 0.5)",
      icon: "rgba(255, 255, 255, 0.5)"
    },
    divider: "rgba(255, 255, 255, 0.12)",
    background: {
      paper: "#121212",
      default: "#121212"
    },
    action: {
      active: common.white,
      hover: "rgba(255, 255, 255, 0.08)",
      hoverOpacity: 0.08,
      selected: "rgba(255, 255, 255, 0.16)",
      selectedOpacity: 0.16,
      disabled: "rgba(255, 255, 255, 0.3)",
      disabledBackground: "rgba(255, 255, 255, 0.12)",
      disabledOpacity: 0.38,
      focus: "rgba(255, 255, 255, 0.12)",
      focusOpacity: 0.12,
      activatedOpacity: 0.24
    }
  };
}
const dark = getDark();
function addLightOrDark(intent, direction, shade, tonalOffset) {
  const tonalOffsetLight = tonalOffset.light || tonalOffset;
  const tonalOffsetDark = tonalOffset.dark || tonalOffset * 1.5;
  if (!intent[direction]) {
    if (intent.hasOwnProperty(shade)) {
      intent[direction] = intent[shade];
    } else if (direction === "light") {
      intent.light = lighten(intent.main, tonalOffsetLight);
    } else if (direction === "dark") {
      intent.dark = darken(intent.main, tonalOffsetDark);
    }
  }
}
function getDefaultPrimary(mode = "light") {
  if (mode === "dark") {
    return {
      main: blue[200],
      light: blue[50],
      dark: blue[400]
    };
  }
  return {
    main: blue[700],
    light: blue[400],
    dark: blue[800]
  };
}
function getDefaultSecondary(mode = "light") {
  if (mode === "dark") {
    return {
      main: purple[200],
      light: purple[50],
      dark: purple[400]
    };
  }
  return {
    main: purple[500],
    light: purple[300],
    dark: purple[700]
  };
}
function getDefaultError(mode = "light") {
  if (mode === "dark") {
    return {
      main: red[500],
      light: red[300],
      dark: red[700]
    };
  }
  return {
    main: red[700],
    light: red[400],
    dark: red[800]
  };
}
function getDefaultInfo(mode = "light") {
  if (mode === "dark") {
    return {
      main: lightBlue[400],
      light: lightBlue[300],
      dark: lightBlue[700]
    };
  }
  return {
    main: lightBlue[700],
    light: lightBlue[500],
    dark: lightBlue[900]
  };
}
function getDefaultSuccess(mode = "light") {
  if (mode === "dark") {
    return {
      main: green[400],
      light: green[300],
      dark: green[700]
    };
  }
  return {
    main: green[800],
    light: green[500],
    dark: green[900]
  };
}
function getDefaultWarning(mode = "light") {
  if (mode === "dark") {
    return {
      main: orange[400],
      light: orange[300],
      dark: orange[700]
    };
  }
  return {
    main: "#ed6c02",
    // closest to orange[800] that pass 3:1.
    light: orange[500],
    dark: orange[900]
  };
}
function createPalette(palette) {
  const {
    mode = "light",
    contrastThreshold = 3,
    tonalOffset = 0.2,
    ...other
  } = palette;
  const primary = palette.primary || getDefaultPrimary(mode);
  const secondary = palette.secondary || getDefaultSecondary(mode);
  const error2 = palette.error || getDefaultError(mode);
  const info = palette.info || getDefaultInfo(mode);
  const success = palette.success || getDefaultSuccess(mode);
  const warning2 = palette.warning || getDefaultWarning(mode);
  function getContrastText(background) {
    const contrastText = getContrastRatio(background, dark.text.primary) >= contrastThreshold ? dark.text.primary : light.text.primary;
    return contrastText;
  }
  const augmentColor = ({
    color: color2,
    name,
    mainShade = 500,
    lightShade = 300,
    darkShade = 700
  }) => {
    color2 = {
      ...color2
    };
    if (!color2.main && color2[mainShade]) {
      color2.main = color2[mainShade];
    }
    if (!color2.hasOwnProperty("main")) {
      throw new Error(formatMuiErrorMessage(11, name ? ` (${name})` : "", mainShade));
    }
    if (typeof color2.main !== "string") {
      throw new Error(formatMuiErrorMessage(12, name ? ` (${name})` : "", JSON.stringify(color2.main)));
    }
    addLightOrDark(color2, "light", lightShade, tonalOffset);
    addLightOrDark(color2, "dark", darkShade, tonalOffset);
    if (!color2.contrastText) {
      color2.contrastText = getContrastText(color2.main);
    }
    return color2;
  };
  let modeHydrated;
  if (mode === "light") {
    modeHydrated = getLight();
  } else if (mode === "dark") {
    modeHydrated = getDark();
  }
  const paletteOutput = deepmerge({
    // A collection of common colors.
    common: {
      ...common
    },
    // prevent mutable object.
    // The palette mode, can be light or dark.
    mode,
    // The colors used to represent primary interface elements for a user.
    primary: augmentColor({
      color: primary,
      name: "primary"
    }),
    // The colors used to represent secondary interface elements for a user.
    secondary: augmentColor({
      color: secondary,
      name: "secondary",
      mainShade: "A400",
      lightShade: "A200",
      darkShade: "A700"
    }),
    // The colors used to represent interface elements that the user should be made aware of.
    error: augmentColor({
      color: error2,
      name: "error"
    }),
    // The colors used to represent potentially dangerous actions or important messages.
    warning: augmentColor({
      color: warning2,
      name: "warning"
    }),
    // The colors used to present information to the user that is neutral and not necessarily important.
    info: augmentColor({
      color: info,
      name: "info"
    }),
    // The colors used to indicate the successful completion of an action that user triggered.
    success: augmentColor({
      color: success,
      name: "success"
    }),
    // The grey colors.
    grey,
    // Used by `getContrastText()` to maximize the contrast between
    // the background and the text.
    contrastThreshold,
    // Takes a background color and returns the text color that maximizes the contrast.
    getContrastText,
    // Generate a rich color object.
    augmentColor,
    // Used by the functions below to shift a color's luminance by approximately
    // two indexes within its tonal palette.
    // E.g., shift from Red 500 to Red 300 or Red 700.
    tonalOffset,
    // The light and dark mode object.
    ...modeHydrated
  }, other);
  return paletteOutput;
}
function prepareTypographyVars(typography) {
  const vars = {};
  const entries5 = Object.entries(typography);
  entries5.forEach((entry) => {
    const [key, value] = entry;
    if (typeof value === "object") {
      vars[key] = `${value.fontStyle ? `${value.fontStyle} ` : ""}${value.fontVariant ? `${value.fontVariant} ` : ""}${value.fontWeight ? `${value.fontWeight} ` : ""}${value.fontStretch ? `${value.fontStretch} ` : ""}${value.fontSize || ""}${value.lineHeight ? `/${value.lineHeight} ` : ""}${value.fontFamily || ""}`;
    }
  });
  return vars;
}
function createMixins(breakpoints, mixins) {
  return {
    toolbar: {
      minHeight: 56,
      [breakpoints.up("xs")]: {
        "@media (orientation: landscape)": {
          minHeight: 48
        }
      },
      [breakpoints.up("sm")]: {
        minHeight: 64
      }
    },
    ...mixins
  };
}
function round(value) {
  return Math.round(value * 1e5) / 1e5;
}
const caseAllCaps = {
  textTransform: "uppercase"
};
const defaultFontFamily = '"Roboto", "Helvetica", "Arial", sans-serif';
function createTypography(palette, typography) {
  const {
    fontFamily = defaultFontFamily,
    // The default font size of the Material Specification.
    fontSize = 14,
    // px
    fontWeightLight = 300,
    fontWeightRegular = 400,
    fontWeightMedium = 500,
    fontWeightBold = 700,
    // Tell MUI what's the font-size on the html element.
    // 16px is the default font-size used by browsers.
    htmlFontSize = 16,
    // Apply the CSS properties to all the variants.
    allVariants,
    pxToRem: pxToRem2,
    ...other
  } = typeof typography === "function" ? typography(palette) : typography;
  const coef = fontSize / 14;
  const pxToRem = pxToRem2 || ((size3) => `${size3 / htmlFontSize * coef}rem`);
  const buildVariant = (fontWeight, size3, lineHeight, letterSpacing, casing) => ({
    fontFamily,
    fontWeight,
    fontSize: pxToRem(size3),
    // Unitless following https://meyerweb.com/eric/thoughts/2006/02/08/unitless-line-heights/
    lineHeight,
    // The letter spacing was designed for the Roboto font-family. Using the same letter-spacing
    // across font-families can cause issues with the kerning.
    ...fontFamily === defaultFontFamily ? {
      letterSpacing: `${round(letterSpacing / size3)}em`
    } : {},
    ...casing,
    ...allVariants
  });
  const variants = {
    h1: buildVariant(fontWeightLight, 96, 1.167, -1.5),
    h2: buildVariant(fontWeightLight, 60, 1.2, -0.5),
    h3: buildVariant(fontWeightRegular, 48, 1.167, 0),
    h4: buildVariant(fontWeightRegular, 34, 1.235, 0.25),
    h5: buildVariant(fontWeightRegular, 24, 1.334, 0),
    h6: buildVariant(fontWeightMedium, 20, 1.6, 0.15),
    subtitle1: buildVariant(fontWeightRegular, 16, 1.75, 0.15),
    subtitle2: buildVariant(fontWeightMedium, 14, 1.57, 0.1),
    body1: buildVariant(fontWeightRegular, 16, 1.5, 0.15),
    body2: buildVariant(fontWeightRegular, 14, 1.43, 0.15),
    button: buildVariant(fontWeightMedium, 14, 1.75, 0.4, caseAllCaps),
    caption: buildVariant(fontWeightRegular, 12, 1.66, 0.4),
    overline: buildVariant(fontWeightRegular, 12, 2.66, 1, caseAllCaps),
    // TODO v6: Remove handling of 'inherit' variant from the theme as it is already handled in Material UI's Typography component. Also, remember to remove the associated types.
    inherit: {
      fontFamily: "inherit",
      fontWeight: "inherit",
      fontSize: "inherit",
      lineHeight: "inherit",
      letterSpacing: "inherit"
    }
  };
  return deepmerge({
    htmlFontSize,
    pxToRem,
    fontFamily,
    fontSize,
    fontWeightLight,
    fontWeightRegular,
    fontWeightMedium,
    fontWeightBold,
    ...variants
  }, other, {
    clone: false
    // No need to clone deep
  });
}
const shadowKeyUmbraOpacity = 0.2;
const shadowKeyPenumbraOpacity = 0.14;
const shadowAmbientShadowOpacity = 0.12;
function createShadow(...px) {
  return [`${px[0]}px ${px[1]}px ${px[2]}px ${px[3]}px rgba(0,0,0,${shadowKeyUmbraOpacity})`, `${px[4]}px ${px[5]}px ${px[6]}px ${px[7]}px rgba(0,0,0,${shadowKeyPenumbraOpacity})`, `${px[8]}px ${px[9]}px ${px[10]}px ${px[11]}px rgba(0,0,0,${shadowAmbientShadowOpacity})`].join(",");
}
const shadows = ["none", createShadow(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0), createShadow(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0), createShadow(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0), createShadow(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0), createShadow(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0), createShadow(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0), createShadow(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1), createShadow(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2), createShadow(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2), createShadow(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3), createShadow(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3), createShadow(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4), createShadow(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4), createShadow(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4), createShadow(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5), createShadow(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5), createShadow(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5), createShadow(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6), createShadow(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6), createShadow(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7), createShadow(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7), createShadow(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7), createShadow(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8), createShadow(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)];
const easing = {
  // This is the most common easing curve.
  easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
  // Objects enter the screen at full velocity from off-screen and
  // slowly decelerate to a resting point.
  easeOut: "cubic-bezier(0.0, 0, 0.2, 1)",
  // Objects leave the screen at full velocity. They do not decelerate when off-screen.
  easeIn: "cubic-bezier(0.4, 0, 1, 1)",
  // The sharp curve is used by objects that may return to the screen at any time.
  sharp: "cubic-bezier(0.4, 0, 0.6, 1)"
};
const duration = {
  shortest: 150,
  shorter: 200,
  short: 250,
  // most basic recommended timing
  standard: 300,
  // this is to be used in complex animations
  complex: 375,
  // recommended when something is entering screen
  enteringScreen: 225,
  // recommended when something is leaving screen
  leavingScreen: 195
};
function formatMs(milliseconds) {
  return `${Math.round(milliseconds)}ms`;
}
function getAutoHeightDuration(height2) {
  if (!height2) {
    return 0;
  }
  const constant = height2 / 36;
  return Math.min(Math.round((4 + 15 * constant ** 0.25 + constant / 5) * 10), 3e3);
}
function createTransitions(inputTransitions) {
  const mergedEasing = {
    ...easing,
    ...inputTransitions.easing
  };
  const mergedDuration = {
    ...duration,
    ...inputTransitions.duration
  };
  const create4 = (props = ["all"], options = {}) => {
    const {
      duration: durationOption = mergedDuration.standard,
      easing: easingOption = mergedEasing.easeInOut,
      delay = 0,
      ...other
    } = options;
    return (Array.isArray(props) ? props : [props]).map((animatedProp) => `${animatedProp} ${typeof durationOption === "string" ? durationOption : formatMs(durationOption)} ${easingOption} ${typeof delay === "string" ? delay : formatMs(delay)}`).join(",");
  };
  return {
    getAutoHeightDuration,
    create: create4,
    ...inputTransitions,
    easing: mergedEasing,
    duration: mergedDuration
  };
}
const zIndex = {
  mobileStepper: 1e3,
  fab: 1050,
  speedDial: 1050,
  appBar: 1100,
  drawer: 1200,
  modal: 1300,
  snackbar: 1400,
  tooltip: 1500
};
function isSerializable(val) {
  return isPlainObject$2(val) || typeof val === "undefined" || typeof val === "string" || typeof val === "boolean" || typeof val === "number" || Array.isArray(val);
}
function stringifyTheme(baseTheme = {}) {
  const serializableTheme = {
    ...baseTheme
  };
  function serializeTheme(object) {
    const array = Object.entries(object);
    for (let index = 0; index < array.length; index++) {
      const [key, value] = array[index];
      if (!isSerializable(value) || key.startsWith("unstable_")) {
        delete object[key];
      } else if (isPlainObject$2(value)) {
        object[key] = {
          ...value
        };
        serializeTheme(object[key]);
      }
    }
  }
  serializeTheme(serializableTheme);
  return `import { unstable_createBreakpoints as createBreakpoints, createTransitions } from '@mui/material/styles';

const theme = ${JSON.stringify(serializableTheme, null, 2)};

theme.breakpoints = createBreakpoints(theme.breakpoints || {});
theme.transitions = createTransitions(theme.transitions || {});

export default theme;`;
}
function createThemeNoVars(options = {}, ...args) {
  const {
    breakpoints: breakpointsInput,
    mixins: mixinsInput = {},
    spacing: spacingInput,
    palette: paletteInput = {},
    transitions: transitionsInput = {},
    typography: typographyInput = {},
    shape: shapeInput,
    ...other
  } = options;
  if (options.vars && // The error should throw only for the root theme creation because user is not allowed to use a custom node `vars`.
  // `generateThemeVars` is the closest identifier for checking that the `options` is a result of `createTheme` with CSS variables so that user can create new theme for nested ThemeProvider.
  options.generateThemeVars === void 0) {
    throw new Error(formatMuiErrorMessage(20));
  }
  const palette = createPalette(paletteInput);
  const systemTheme = createTheme$1(options);
  let muiTheme = deepmerge(systemTheme, {
    mixins: createMixins(systemTheme.breakpoints, mixinsInput),
    palette,
    // Don't use [...shadows] until you've verified its transpiled code is not invoking the iterator protocol.
    shadows: shadows.slice(),
    typography: createTypography(palette, typographyInput),
    transitions: createTransitions(transitionsInput),
    zIndex: {
      ...zIndex
    }
  });
  muiTheme = deepmerge(muiTheme, other);
  muiTheme = args.reduce((acc, argument) => deepmerge(acc, argument), muiTheme);
  muiTheme.unstable_sxConfig = {
    ...defaultSxConfig,
    ...other == null ? void 0 : other.unstable_sxConfig
  };
  muiTheme.unstable_sx = function sx(props) {
    return styleFunctionSx({
      sx: props,
      theme: this
    });
  };
  muiTheme.toRuntimeSource = stringifyTheme;
  return muiTheme;
}
function getOverlayAlpha(elevation) {
  let alphaValue;
  if (elevation < 1) {
    alphaValue = 5.11916 * elevation ** 2;
  } else {
    alphaValue = 4.5 * Math.log(elevation + 1) + 2;
  }
  return Math.round(alphaValue * 10) / 1e3;
}
const defaultDarkOverlays = [...Array(25)].map((_, index) => {
  if (index === 0) {
    return "none";
  }
  const overlay = getOverlayAlpha(index);
  return `linear-gradient(rgba(255 255 255 / ${overlay}), rgba(255 255 255 / ${overlay}))`;
});
function getOpacity(mode) {
  return {
    inputPlaceholder: mode === "dark" ? 0.5 : 0.42,
    inputUnderline: mode === "dark" ? 0.7 : 0.42,
    switchTrackDisabled: mode === "dark" ? 0.2 : 0.12,
    switchTrack: mode === "dark" ? 0.3 : 0.38
  };
}
function getOverlays(mode) {
  return mode === "dark" ? defaultDarkOverlays : [];
}
function createColorScheme(options) {
  const {
    palette: paletteInput = {
      mode: "light"
    },
    // need to cast to avoid module augmentation test
    opacity,
    overlays,
    ...rest
  } = options;
  const palette = createPalette(paletteInput);
  return {
    palette,
    opacity: {
      ...getOpacity(palette.mode),
      ...opacity
    },
    overlays: overlays || getOverlays(palette.mode),
    ...rest
  };
}
function shouldSkipGeneratingVar(keys6) {
  var _a;
  return !!keys6[0].match(/(cssVarPrefix|colorSchemeSelector|rootSelector|typography|mixins|breakpoints|direction|transitions)/) || !!keys6[0].match(/sxConfig$/) || // ends with sxConfig
  keys6[0] === "palette" && !!((_a = keys6[1]) == null ? void 0 : _a.match(/(mode|contrastThreshold|tonalOffset)/));
}
const excludeVariablesFromRoot = (cssVarPrefix) => [...[...Array(25)].map((_, index) => `--${cssVarPrefix ? `${cssVarPrefix}-` : ""}overlays-${index}`), `--${cssVarPrefix ? `${cssVarPrefix}-` : ""}palette-AppBar-darkBg`, `--${cssVarPrefix ? `${cssVarPrefix}-` : ""}palette-AppBar-darkColor`];
const defaultGetSelector = (theme) => (colorScheme, css2) => {
  const root2 = theme.rootSelector || ":root";
  const selector = theme.colorSchemeSelector;
  let rule = selector;
  if (selector === "class") {
    rule = ".%s";
  }
  if (selector === "data") {
    rule = "[data-%s]";
  }
  if ((selector == null ? void 0 : selector.startsWith("data-")) && !selector.includes("%s")) {
    rule = `[${selector}="%s"]`;
  }
  if (theme.defaultColorScheme === colorScheme) {
    if (colorScheme === "dark") {
      const excludedVariables = {};
      excludeVariablesFromRoot(theme.cssVarPrefix).forEach((cssVar) => {
        excludedVariables[cssVar] = css2[cssVar];
        delete css2[cssVar];
      });
      if (rule === "media") {
        return {
          [root2]: css2,
          [`@media (prefers-color-scheme: dark)`]: {
            [root2]: excludedVariables
          }
        };
      }
      if (rule) {
        return {
          [rule.replace("%s", colorScheme)]: excludedVariables,
          [`${root2}, ${rule.replace("%s", colorScheme)}`]: css2
        };
      }
      return {
        [root2]: {
          ...css2,
          ...excludedVariables
        }
      };
    }
    if (rule && rule !== "media") {
      return `${root2}, ${rule.replace("%s", String(colorScheme))}`;
    }
  } else if (colorScheme) {
    if (rule === "media") {
      return {
        [`@media (prefers-color-scheme: ${String(colorScheme)})`]: {
          [root2]: css2
        }
      };
    }
    if (rule) {
      return rule.replace("%s", String(colorScheme));
    }
  }
  return root2;
};
function assignNode(obj, keys6) {
  keys6.forEach((k2) => {
    if (!obj[k2]) {
      obj[k2] = {};
    }
  });
}
function setColor(obj, key, defaultValue) {
  if (!obj[key] && defaultValue) {
    obj[key] = defaultValue;
  }
}
function toRgb(color2) {
  if (typeof color2 !== "string" || !color2.startsWith("hsl")) {
    return color2;
  }
  return hslToRgb(color2);
}
function setColorChannel(obj, key) {
  if (!(`${key}Channel` in obj)) {
    obj[`${key}Channel`] = private_safeColorChannel(toRgb(obj[key]));
  }
}
function getSpacingVal(spacingInput) {
  if (typeof spacingInput === "number") {
    return `${spacingInput}px`;
  }
  if (typeof spacingInput === "string" || typeof spacingInput === "function" || Array.isArray(spacingInput)) {
    return spacingInput;
  }
  return "8px";
}
const silent = (fn) => {
  try {
    return fn();
  } catch (error2) {
  }
  return void 0;
};
const createGetCssVar = (cssVarPrefix = "mui") => createGetCssVar$1(cssVarPrefix);
function attachColorScheme$1(colorSchemes, scheme, restTheme, colorScheme) {
  if (!scheme) {
    return void 0;
  }
  scheme = scheme === true ? {} : scheme;
  const mode = colorScheme === "dark" ? "dark" : "light";
  if (!restTheme) {
    colorSchemes[colorScheme] = createColorScheme({
      ...scheme,
      palette: {
        mode,
        ...scheme == null ? void 0 : scheme.palette
      }
    });
    return void 0;
  }
  const {
    palette,
    ...muiTheme
  } = createThemeNoVars({
    ...restTheme,
    palette: {
      mode,
      ...scheme == null ? void 0 : scheme.palette
    }
  });
  colorSchemes[colorScheme] = {
    ...scheme,
    palette,
    opacity: {
      ...getOpacity(mode),
      ...scheme == null ? void 0 : scheme.opacity
    },
    overlays: (scheme == null ? void 0 : scheme.overlays) || getOverlays(mode)
  };
  return muiTheme;
}
function createThemeWithVars(options = {}, ...args) {
  const {
    colorSchemes: colorSchemesInput = {
      light: true
    },
    defaultColorScheme: defaultColorSchemeInput,
    disableCssColorScheme = false,
    cssVarPrefix = "mui",
    shouldSkipGeneratingVar: shouldSkipGeneratingVar$1 = shouldSkipGeneratingVar,
    colorSchemeSelector: selector = colorSchemesInput.light && colorSchemesInput.dark ? "media" : void 0,
    rootSelector = ":root",
    ...input
  } = options;
  const firstColorScheme = Object.keys(colorSchemesInput)[0];
  const defaultColorScheme = defaultColorSchemeInput || (colorSchemesInput.light && firstColorScheme !== "light" ? "light" : firstColorScheme);
  const getCssVar = createGetCssVar(cssVarPrefix);
  const {
    [defaultColorScheme]: defaultSchemeInput,
    light: builtInLight,
    dark: builtInDark,
    ...customColorSchemes
  } = colorSchemesInput;
  const colorSchemes = {
    ...customColorSchemes
  };
  let defaultScheme = defaultSchemeInput;
  if (defaultColorScheme === "dark" && !("dark" in colorSchemesInput) || defaultColorScheme === "light" && !("light" in colorSchemesInput)) {
    defaultScheme = true;
  }
  if (!defaultScheme) {
    throw new Error(formatMuiErrorMessage(21, defaultColorScheme));
  }
  const muiTheme = attachColorScheme$1(colorSchemes, defaultScheme, input, defaultColorScheme);
  if (builtInLight && !colorSchemes.light) {
    attachColorScheme$1(colorSchemes, builtInLight, void 0, "light");
  }
  if (builtInDark && !colorSchemes.dark) {
    attachColorScheme$1(colorSchemes, builtInDark, void 0, "dark");
  }
  let theme = {
    defaultColorScheme,
    ...muiTheme,
    cssVarPrefix,
    colorSchemeSelector: selector,
    rootSelector,
    getCssVar,
    colorSchemes,
    font: {
      ...prepareTypographyVars(muiTheme.typography),
      ...muiTheme.font
    },
    spacing: getSpacingVal(input.spacing)
  };
  Object.keys(theme.colorSchemes).forEach((key) => {
    const palette = theme.colorSchemes[key].palette;
    const setCssVarColor = (cssVar) => {
      const tokens = cssVar.split("-");
      const color2 = tokens[1];
      const colorToken = tokens[2];
      return getCssVar(cssVar, palette[color2][colorToken]);
    };
    if (palette.mode === "light") {
      setColor(palette.common, "background", "#fff");
      setColor(palette.common, "onBackground", "#000");
    }
    if (palette.mode === "dark") {
      setColor(palette.common, "background", "#000");
      setColor(palette.common, "onBackground", "#fff");
    }
    assignNode(palette, ["Alert", "AppBar", "Avatar", "Button", "Chip", "FilledInput", "LinearProgress", "Skeleton", "Slider", "SnackbarContent", "SpeedDialAction", "StepConnector", "StepContent", "Switch", "TableCell", "Tooltip"]);
    if (palette.mode === "light") {
      setColor(palette.Alert, "errorColor", private_safeDarken(palette.error.light, 0.6));
      setColor(palette.Alert, "infoColor", private_safeDarken(palette.info.light, 0.6));
      setColor(palette.Alert, "successColor", private_safeDarken(palette.success.light, 0.6));
      setColor(palette.Alert, "warningColor", private_safeDarken(palette.warning.light, 0.6));
      setColor(palette.Alert, "errorFilledBg", setCssVarColor("palette-error-main"));
      setColor(palette.Alert, "infoFilledBg", setCssVarColor("palette-info-main"));
      setColor(palette.Alert, "successFilledBg", setCssVarColor("palette-success-main"));
      setColor(palette.Alert, "warningFilledBg", setCssVarColor("palette-warning-main"));
      setColor(palette.Alert, "errorFilledColor", silent(() => palette.getContrastText(palette.error.main)));
      setColor(palette.Alert, "infoFilledColor", silent(() => palette.getContrastText(palette.info.main)));
      setColor(palette.Alert, "successFilledColor", silent(() => palette.getContrastText(palette.success.main)));
      setColor(palette.Alert, "warningFilledColor", silent(() => palette.getContrastText(palette.warning.main)));
      setColor(palette.Alert, "errorStandardBg", private_safeLighten(palette.error.light, 0.9));
      setColor(palette.Alert, "infoStandardBg", private_safeLighten(palette.info.light, 0.9));
      setColor(palette.Alert, "successStandardBg", private_safeLighten(palette.success.light, 0.9));
      setColor(palette.Alert, "warningStandardBg", private_safeLighten(palette.warning.light, 0.9));
      setColor(palette.Alert, "errorIconColor", setCssVarColor("palette-error-main"));
      setColor(palette.Alert, "infoIconColor", setCssVarColor("palette-info-main"));
      setColor(palette.Alert, "successIconColor", setCssVarColor("palette-success-main"));
      setColor(palette.Alert, "warningIconColor", setCssVarColor("palette-warning-main"));
      setColor(palette.AppBar, "defaultBg", setCssVarColor("palette-grey-100"));
      setColor(palette.Avatar, "defaultBg", setCssVarColor("palette-grey-400"));
      setColor(palette.Button, "inheritContainedBg", setCssVarColor("palette-grey-300"));
      setColor(palette.Button, "inheritContainedHoverBg", setCssVarColor("palette-grey-A100"));
      setColor(palette.Chip, "defaultBorder", setCssVarColor("palette-grey-400"));
      setColor(palette.Chip, "defaultAvatarColor", setCssVarColor("palette-grey-700"));
      setColor(palette.Chip, "defaultIconColor", setCssVarColor("palette-grey-700"));
      setColor(palette.FilledInput, "bg", "rgba(0, 0, 0, 0.06)");
      setColor(palette.FilledInput, "hoverBg", "rgba(0, 0, 0, 0.09)");
      setColor(palette.FilledInput, "disabledBg", "rgba(0, 0, 0, 0.12)");
      setColor(palette.LinearProgress, "primaryBg", private_safeLighten(palette.primary.main, 0.62));
      setColor(palette.LinearProgress, "secondaryBg", private_safeLighten(palette.secondary.main, 0.62));
      setColor(palette.LinearProgress, "errorBg", private_safeLighten(palette.error.main, 0.62));
      setColor(palette.LinearProgress, "infoBg", private_safeLighten(palette.info.main, 0.62));
      setColor(palette.LinearProgress, "successBg", private_safeLighten(palette.success.main, 0.62));
      setColor(palette.LinearProgress, "warningBg", private_safeLighten(palette.warning.main, 0.62));
      setColor(palette.Skeleton, "bg", `rgba(${setCssVarColor("palette-text-primaryChannel")} / 0.11)`);
      setColor(palette.Slider, "primaryTrack", private_safeLighten(palette.primary.main, 0.62));
      setColor(palette.Slider, "secondaryTrack", private_safeLighten(palette.secondary.main, 0.62));
      setColor(palette.Slider, "errorTrack", private_safeLighten(palette.error.main, 0.62));
      setColor(palette.Slider, "infoTrack", private_safeLighten(palette.info.main, 0.62));
      setColor(palette.Slider, "successTrack", private_safeLighten(palette.success.main, 0.62));
      setColor(palette.Slider, "warningTrack", private_safeLighten(palette.warning.main, 0.62));
      const snackbarContentBackground = private_safeEmphasize(palette.background.default, 0.8);
      setColor(palette.SnackbarContent, "bg", snackbarContentBackground);
      setColor(palette.SnackbarContent, "color", silent(() => palette.getContrastText(snackbarContentBackground)));
      setColor(palette.SpeedDialAction, "fabHoverBg", private_safeEmphasize(palette.background.paper, 0.15));
      setColor(palette.StepConnector, "border", setCssVarColor("palette-grey-400"));
      setColor(palette.StepContent, "border", setCssVarColor("palette-grey-400"));
      setColor(palette.Switch, "defaultColor", setCssVarColor("palette-common-white"));
      setColor(palette.Switch, "defaultDisabledColor", setCssVarColor("palette-grey-100"));
      setColor(palette.Switch, "primaryDisabledColor", private_safeLighten(palette.primary.main, 0.62));
      setColor(palette.Switch, "secondaryDisabledColor", private_safeLighten(palette.secondary.main, 0.62));
      setColor(palette.Switch, "errorDisabledColor", private_safeLighten(palette.error.main, 0.62));
      setColor(palette.Switch, "infoDisabledColor", private_safeLighten(palette.info.main, 0.62));
      setColor(palette.Switch, "successDisabledColor", private_safeLighten(palette.success.main, 0.62));
      setColor(palette.Switch, "warningDisabledColor", private_safeLighten(palette.warning.main, 0.62));
      setColor(palette.TableCell, "border", private_safeLighten(private_safeAlpha(palette.divider, 1), 0.88));
      setColor(palette.Tooltip, "bg", private_safeAlpha(palette.grey[700], 0.92));
    }
    if (palette.mode === "dark") {
      setColor(palette.Alert, "errorColor", private_safeLighten(palette.error.light, 0.6));
      setColor(palette.Alert, "infoColor", private_safeLighten(palette.info.light, 0.6));
      setColor(palette.Alert, "successColor", private_safeLighten(palette.success.light, 0.6));
      setColor(palette.Alert, "warningColor", private_safeLighten(palette.warning.light, 0.6));
      setColor(palette.Alert, "errorFilledBg", setCssVarColor("palette-error-dark"));
      setColor(palette.Alert, "infoFilledBg", setCssVarColor("palette-info-dark"));
      setColor(palette.Alert, "successFilledBg", setCssVarColor("palette-success-dark"));
      setColor(palette.Alert, "warningFilledBg", setCssVarColor("palette-warning-dark"));
      setColor(palette.Alert, "errorFilledColor", silent(() => palette.getContrastText(palette.error.dark)));
      setColor(palette.Alert, "infoFilledColor", silent(() => palette.getContrastText(palette.info.dark)));
      setColor(palette.Alert, "successFilledColor", silent(() => palette.getContrastText(palette.success.dark)));
      setColor(palette.Alert, "warningFilledColor", silent(() => palette.getContrastText(palette.warning.dark)));
      setColor(palette.Alert, "errorStandardBg", private_safeDarken(palette.error.light, 0.9));
      setColor(palette.Alert, "infoStandardBg", private_safeDarken(palette.info.light, 0.9));
      setColor(palette.Alert, "successStandardBg", private_safeDarken(palette.success.light, 0.9));
      setColor(palette.Alert, "warningStandardBg", private_safeDarken(palette.warning.light, 0.9));
      setColor(palette.Alert, "errorIconColor", setCssVarColor("palette-error-main"));
      setColor(palette.Alert, "infoIconColor", setCssVarColor("palette-info-main"));
      setColor(palette.Alert, "successIconColor", setCssVarColor("palette-success-main"));
      setColor(palette.Alert, "warningIconColor", setCssVarColor("palette-warning-main"));
      setColor(palette.AppBar, "defaultBg", setCssVarColor("palette-grey-900"));
      setColor(palette.AppBar, "darkBg", setCssVarColor("palette-background-paper"));
      setColor(palette.AppBar, "darkColor", setCssVarColor("palette-text-primary"));
      setColor(palette.Avatar, "defaultBg", setCssVarColor("palette-grey-600"));
      setColor(palette.Button, "inheritContainedBg", setCssVarColor("palette-grey-800"));
      setColor(palette.Button, "inheritContainedHoverBg", setCssVarColor("palette-grey-700"));
      setColor(palette.Chip, "defaultBorder", setCssVarColor("palette-grey-700"));
      setColor(palette.Chip, "defaultAvatarColor", setCssVarColor("palette-grey-300"));
      setColor(palette.Chip, "defaultIconColor", setCssVarColor("palette-grey-300"));
      setColor(palette.FilledInput, "bg", "rgba(255, 255, 255, 0.09)");
      setColor(palette.FilledInput, "hoverBg", "rgba(255, 255, 255, 0.13)");
      setColor(palette.FilledInput, "disabledBg", "rgba(255, 255, 255, 0.12)");
      setColor(palette.LinearProgress, "primaryBg", private_safeDarken(palette.primary.main, 0.5));
      setColor(palette.LinearProgress, "secondaryBg", private_safeDarken(palette.secondary.main, 0.5));
      setColor(palette.LinearProgress, "errorBg", private_safeDarken(palette.error.main, 0.5));
      setColor(palette.LinearProgress, "infoBg", private_safeDarken(palette.info.main, 0.5));
      setColor(palette.LinearProgress, "successBg", private_safeDarken(palette.success.main, 0.5));
      setColor(palette.LinearProgress, "warningBg", private_safeDarken(palette.warning.main, 0.5));
      setColor(palette.Skeleton, "bg", `rgba(${setCssVarColor("palette-text-primaryChannel")} / 0.13)`);
      setColor(palette.Slider, "primaryTrack", private_safeDarken(palette.primary.main, 0.5));
      setColor(palette.Slider, "secondaryTrack", private_safeDarken(palette.secondary.main, 0.5));
      setColor(palette.Slider, "errorTrack", private_safeDarken(palette.error.main, 0.5));
      setColor(palette.Slider, "infoTrack", private_safeDarken(palette.info.main, 0.5));
      setColor(palette.Slider, "successTrack", private_safeDarken(palette.success.main, 0.5));
      setColor(palette.Slider, "warningTrack", private_safeDarken(palette.warning.main, 0.5));
      const snackbarContentBackground = private_safeEmphasize(palette.background.default, 0.98);
      setColor(palette.SnackbarContent, "bg", snackbarContentBackground);
      setColor(palette.SnackbarContent, "color", silent(() => palette.getContrastText(snackbarContentBackground)));
      setColor(palette.SpeedDialAction, "fabHoverBg", private_safeEmphasize(palette.background.paper, 0.15));
      setColor(palette.StepConnector, "border", setCssVarColor("palette-grey-600"));
      setColor(palette.StepContent, "border", setCssVarColor("palette-grey-600"));
      setColor(palette.Switch, "defaultColor", setCssVarColor("palette-grey-300"));
      setColor(palette.Switch, "defaultDisabledColor", setCssVarColor("palette-grey-600"));
      setColor(palette.Switch, "primaryDisabledColor", private_safeDarken(palette.primary.main, 0.55));
      setColor(palette.Switch, "secondaryDisabledColor", private_safeDarken(palette.secondary.main, 0.55));
      setColor(palette.Switch, "errorDisabledColor", private_safeDarken(palette.error.main, 0.55));
      setColor(palette.Switch, "infoDisabledColor", private_safeDarken(palette.info.main, 0.55));
      setColor(palette.Switch, "successDisabledColor", private_safeDarken(palette.success.main, 0.55));
      setColor(palette.Switch, "warningDisabledColor", private_safeDarken(palette.warning.main, 0.55));
      setColor(palette.TableCell, "border", private_safeDarken(private_safeAlpha(palette.divider, 1), 0.68));
      setColor(palette.Tooltip, "bg", private_safeAlpha(palette.grey[700], 0.92));
    }
    setColorChannel(palette.background, "default");
    setColorChannel(palette.background, "paper");
    setColorChannel(palette.common, "background");
    setColorChannel(palette.common, "onBackground");
    setColorChannel(palette, "divider");
    Object.keys(palette).forEach((color2) => {
      const colors = palette[color2];
      if (color2 !== "tonalOffset" && colors && typeof colors === "object") {
        if (colors.main) {
          setColor(palette[color2], "mainChannel", private_safeColorChannel(toRgb(colors.main)));
        }
        if (colors.light) {
          setColor(palette[color2], "lightChannel", private_safeColorChannel(toRgb(colors.light)));
        }
        if (colors.dark) {
          setColor(palette[color2], "darkChannel", private_safeColorChannel(toRgb(colors.dark)));
        }
        if (colors.contrastText) {
          setColor(palette[color2], "contrastTextChannel", private_safeColorChannel(toRgb(colors.contrastText)));
        }
        if (color2 === "text") {
          setColorChannel(palette[color2], "primary");
          setColorChannel(palette[color2], "secondary");
        }
        if (color2 === "action") {
          if (colors.active) {
            setColorChannel(palette[color2], "active");
          }
          if (colors.selected) {
            setColorChannel(palette[color2], "selected");
          }
        }
      }
    });
  });
  theme = args.reduce((acc, argument) => deepmerge(acc, argument), theme);
  const parserConfig = {
    prefix: cssVarPrefix,
    disableCssColorScheme,
    shouldSkipGeneratingVar: shouldSkipGeneratingVar$1,
    getSelector: defaultGetSelector(theme)
  };
  const {
    vars,
    generateThemeVars,
    generateStyleSheets
  } = prepareCssVars(theme, parserConfig);
  theme.vars = vars;
  Object.entries(theme.colorSchemes[theme.defaultColorScheme]).forEach(([key, value]) => {
    theme[key] = value;
  });
  theme.generateThemeVars = generateThemeVars;
  theme.generateStyleSheets = generateStyleSheets;
  theme.generateSpacing = function generateSpacing() {
    return createSpacing(input.spacing, createUnarySpacing(this));
  };
  theme.getColorSchemeSelector = createGetColorSchemeSelector(selector);
  theme.spacing = theme.generateSpacing();
  theme.shouldSkipGeneratingVar = shouldSkipGeneratingVar$1;
  theme.unstable_sxConfig = {
    ...defaultSxConfig,
    ...input == null ? void 0 : input.unstable_sxConfig
  };
  theme.unstable_sx = function sx(props) {
    return styleFunctionSx({
      sx: props,
      theme: this
    });
  };
  theme.toRuntimeSource = stringifyTheme;
  return theme;
}
function attachColorScheme(theme, scheme, colorScheme) {
  if (!theme.colorSchemes) {
    return void 0;
  }
  if (colorScheme) {
    theme.colorSchemes[scheme] = {
      ...colorScheme !== true && colorScheme,
      palette: createPalette({
        ...colorScheme === true ? {} : colorScheme.palette,
        mode: scheme
      })
      // cast type to skip module augmentation test
    };
  }
}
function createTheme(options = {}, ...args) {
  const {
    palette,
    cssVariables = false,
    colorSchemes: initialColorSchemes = !palette ? {
      light: true
    } : void 0,
    defaultColorScheme: initialDefaultColorScheme = palette == null ? void 0 : palette.mode,
    ...rest
  } = options;
  const defaultColorSchemeInput = initialDefaultColorScheme || "light";
  const defaultScheme = initialColorSchemes == null ? void 0 : initialColorSchemes[defaultColorSchemeInput];
  const colorSchemesInput = {
    ...initialColorSchemes,
    ...palette ? {
      [defaultColorSchemeInput]: {
        ...typeof defaultScheme !== "boolean" && defaultScheme,
        palette
      }
    } : void 0
  };
  if (cssVariables === false) {
    if (!("colorSchemes" in options)) {
      return createThemeNoVars(options, ...args);
    }
    let paletteOptions = palette;
    if (!("palette" in options)) {
      if (colorSchemesInput[defaultColorSchemeInput]) {
        if (colorSchemesInput[defaultColorSchemeInput] !== true) {
          paletteOptions = colorSchemesInput[defaultColorSchemeInput].palette;
        } else if (defaultColorSchemeInput === "dark") {
          paletteOptions = {
            mode: "dark"
          };
        }
      }
    }
    const theme = createThemeNoVars({
      ...options,
      palette: paletteOptions
    }, ...args);
    theme.defaultColorScheme = defaultColorSchemeInput;
    theme.colorSchemes = colorSchemesInput;
    if (theme.palette.mode === "light") {
      theme.colorSchemes.light = {
        ...colorSchemesInput.light !== true && colorSchemesInput.light,
        palette: theme.palette
      };
      attachColorScheme(theme, "dark", colorSchemesInput.dark);
    }
    if (theme.palette.mode === "dark") {
      theme.colorSchemes.dark = {
        ...colorSchemesInput.dark !== true && colorSchemesInput.dark,
        palette: theme.palette
      };
      attachColorScheme(theme, "light", colorSchemesInput.light);
    }
    return theme;
  }
  if (!palette && !("light" in colorSchemesInput) && defaultColorSchemeInput === "light") {
    colorSchemesInput.light = true;
  }
  return createThemeWithVars({
    ...rest,
    colorSchemes: colorSchemesInput,
    defaultColorScheme: defaultColorSchemeInput,
    ...typeof cssVariables !== "boolean" && cssVariables
  }, ...args);
}
const defaultTheme$1 = createTheme();
const THEME_ID = "$$material";
function useTheme() {
  const theme = useTheme$1(defaultTheme$1);
  return theme[THEME_ID] || theme;
}
function GlobalStyles(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GlobalStyles$1, {
    ...props,
    defaultTheme: defaultTheme$1,
    themeId: THEME_ID
  });
}
function slotShouldForwardProp(prop) {
  return prop !== "ownerState" && prop !== "theme" && prop !== "sx" && prop !== "as";
}
const rootShouldForwardProp = (prop) => slotShouldForwardProp(prop) && prop !== "classes";
const styled = createStyled({
  themeId: THEME_ID,
  defaultTheme: defaultTheme$1,
  rootShouldForwardProp
});
function globalCss(styles2) {
  return function GlobalStylesWrapper(props) {
    return (
      // Pigment CSS `globalCss` support callback with theme inside an object but `GlobalStyles` support theme as a callback value.
      /* @__PURE__ */ jsxRuntimeExports.jsx(GlobalStyles, {
        styles: typeof styles2 === "function" ? (theme) => styles2({
          theme,
          ...props
        }) : styles2
      })
    );
  };
}
function internal_createExtendSxProp() {
  return extendSxProp$1;
}
const memoTheme = unstable_memoTheme;
function useDefaultProps(params2) {
  return useDefaultProps$1(params2);
}
function useSlot(name, parameters) {
  const {
    className,
    elementType: initialElementType,
    ownerState,
    externalForwardedProps,
    internalForwardedProps,
    shouldForwardComponentProp = false,
    ...useSlotPropsParams
  } = parameters;
  const {
    component: rootComponent,
    slots = {
      [name]: void 0
    },
    slotProps = {
      [name]: void 0
    },
    ...other
  } = externalForwardedProps;
  const elementType = slots[name] || initialElementType;
  const resolvedComponentsProps = resolveComponentProps(slotProps[name], ownerState);
  const {
    props: {
      component: slotComponent,
      ...mergedProps
    },
    internalRef
  } = mergeSlotProps({
    className,
    ...useSlotPropsParams,
    externalForwardedProps: name === "root" ? other : void 0,
    externalSlotProps: resolvedComponentsProps
  });
  const ref = useForkRef(internalRef, resolvedComponentsProps == null ? void 0 : resolvedComponentsProps.ref, parameters.ref);
  const LeafComponent = name === "root" ? slotComponent || rootComponent : slotComponent;
  const props = appendOwnerState(elementType, {
    ...name === "root" && !rootComponent && !slots[name] && internalForwardedProps,
    ...name !== "root" && !slots[name] && internalForwardedProps,
    ...mergedProps,
    ...LeafComponent && !shouldForwardComponentProp && {
      as: LeafComponent
    },
    ...LeafComponent && shouldForwardComponentProp && {
      component: LeafComponent
    },
    ref
  }, ownerState);
  return [elementType, props];
}
function _objectWithoutPropertiesLoose$1(r2, e2) {
  if (null == r2) return {};
  var t2 = {};
  for (var n2 in r2) if ({}.hasOwnProperty.call(r2, n2)) {
    if (e2.includes(n2)) continue;
    t2[n2] = r2[n2];
  }
  return t2;
}
function _setPrototypeOf$1(t2, e2) {
  return _setPrototypeOf$1 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t3, e3) {
    return t3.__proto__ = e3, t3;
  }, _setPrototypeOf$1(t2, e2);
}
function _inheritsLoose$1(t2, o) {
  t2.prototype = Object.create(o.prototype), t2.prototype.constructor = t2, _setPrototypeOf$1(t2, o);
}
const config$1 = {
  disabled: false
};
const TransitionGroupContext$1 = React$1.createContext(null);
var forceReflow$1 = function forceReflow(node2) {
  return node2.scrollTop;
};
var UNMOUNTED$1 = "unmounted";
var EXITED$1 = "exited";
var ENTERING$1 = "entering";
var ENTERED$1 = "entered";
var EXITING$1 = "exiting";
var Transition$1 = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose$1(Transition2, _React$Component);
  function Transition2(props, context) {
    var _this;
    _this = _React$Component.call(this, props, context) || this;
    var parentGroup = context;
    var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;
    var initialStatus;
    _this.appearStatus = null;
    if (props.in) {
      if (appear) {
        initialStatus = EXITED$1;
        _this.appearStatus = ENTERING$1;
      } else {
        initialStatus = ENTERED$1;
      }
    } else {
      if (props.unmountOnExit || props.mountOnEnter) {
        initialStatus = UNMOUNTED$1;
      } else {
        initialStatus = EXITED$1;
      }
    }
    _this.state = {
      status: initialStatus
    };
    _this.nextCallback = null;
    return _this;
  }
  Transition2.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {
    var nextIn = _ref.in;
    if (nextIn && prevState.status === UNMOUNTED$1) {
      return {
        status: EXITED$1
      };
    }
    return null;
  };
  var _proto = Transition2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    this.updateStatus(true, this.appearStatus);
  };
  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    var nextStatus = null;
    if (prevProps !== this.props) {
      var status = this.state.status;
      if (this.props.in) {
        if (status !== ENTERING$1 && status !== ENTERED$1) {
          nextStatus = ENTERING$1;
        }
      } else {
        if (status === ENTERING$1 || status === ENTERED$1) {
          nextStatus = EXITING$1;
        }
      }
    }
    this.updateStatus(false, nextStatus);
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    this.cancelNextCallback();
  };
  _proto.getTimeouts = function getTimeouts() {
    var timeout2 = this.props.timeout;
    var exit, enter, appear;
    exit = enter = appear = timeout2;
    if (timeout2 != null && typeof timeout2 !== "number") {
      exit = timeout2.exit;
      enter = timeout2.enter;
      appear = timeout2.appear !== void 0 ? timeout2.appear : enter;
    }
    return {
      exit,
      enter,
      appear
    };
  };
  _proto.updateStatus = function updateStatus(mounting, nextStatus) {
    if (mounting === void 0) {
      mounting = false;
    }
    if (nextStatus !== null) {
      this.cancelNextCallback();
      if (nextStatus === ENTERING$1) {
        if (this.props.unmountOnExit || this.props.mountOnEnter) {
          var node2 = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this);
          if (node2) forceReflow$1(node2);
        }
        this.performEnter(mounting);
      } else {
        this.performExit();
      }
    } else if (this.props.unmountOnExit && this.state.status === EXITED$1) {
      this.setState({
        status: UNMOUNTED$1
      });
    }
  };
  _proto.performEnter = function performEnter(mounting) {
    var _this2 = this;
    var enter = this.props.enter;
    var appearing = this.context ? this.context.isMounting : mounting;
    var _ref2 = this.props.nodeRef ? [appearing] : [ReactDOM.findDOMNode(this), appearing], maybeNode = _ref2[0], maybeAppearing = _ref2[1];
    var timeouts = this.getTimeouts();
    var enterTimeout = appearing ? timeouts.appear : timeouts.enter;
    if (!mounting && !enter || config$1.disabled) {
      this.safeSetState({
        status: ENTERED$1
      }, function() {
        _this2.props.onEntered(maybeNode);
      });
      return;
    }
    this.props.onEnter(maybeNode, maybeAppearing);
    this.safeSetState({
      status: ENTERING$1
    }, function() {
      _this2.props.onEntering(maybeNode, maybeAppearing);
      _this2.onTransitionEnd(enterTimeout, function() {
        _this2.safeSetState({
          status: ENTERED$1
        }, function() {
          _this2.props.onEntered(maybeNode, maybeAppearing);
        });
      });
    });
  };
  _proto.performExit = function performExit() {
    var _this3 = this;
    var exit = this.props.exit;
    var timeouts = this.getTimeouts();
    var maybeNode = this.props.nodeRef ? void 0 : ReactDOM.findDOMNode(this);
    if (!exit || config$1.disabled) {
      this.safeSetState({
        status: EXITED$1
      }, function() {
        _this3.props.onExited(maybeNode);
      });
      return;
    }
    this.props.onExit(maybeNode);
    this.safeSetState({
      status: EXITING$1
    }, function() {
      _this3.props.onExiting(maybeNode);
      _this3.onTransitionEnd(timeouts.exit, function() {
        _this3.safeSetState({
          status: EXITED$1
        }, function() {
          _this3.props.onExited(maybeNode);
        });
      });
    });
  };
  _proto.cancelNextCallback = function cancelNextCallback() {
    if (this.nextCallback !== null) {
      this.nextCallback.cancel();
      this.nextCallback = null;
    }
  };
  _proto.safeSetState = function safeSetState(nextState, callback2) {
    callback2 = this.setNextCallback(callback2);
    this.setState(nextState, callback2);
  };
  _proto.setNextCallback = function setNextCallback(callback2) {
    var _this4 = this;
    var active = true;
    this.nextCallback = function(event) {
      if (active) {
        active = false;
        _this4.nextCallback = null;
        callback2(event);
      }
    };
    this.nextCallback.cancel = function() {
      active = false;
    };
    return this.nextCallback;
  };
  _proto.onTransitionEnd = function onTransitionEnd(timeout2, handler) {
    this.setNextCallback(handler);
    var node2 = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this);
    var doesNotHaveTimeoutOrListener = timeout2 == null && !this.props.addEndListener;
    if (!node2 || doesNotHaveTimeoutOrListener) {
      setTimeout(this.nextCallback, 0);
      return;
    }
    if (this.props.addEndListener) {
      var _ref3 = this.props.nodeRef ? [this.nextCallback] : [node2, this.nextCallback], maybeNode = _ref3[0], maybeNextCallback = _ref3[1];
      this.props.addEndListener(maybeNode, maybeNextCallback);
    }
    if (timeout2 != null) {
      setTimeout(this.nextCallback, timeout2);
    }
  };
  _proto.render = function render() {
    var status = this.state.status;
    if (status === UNMOUNTED$1) {
      return null;
    }
    var _this$props = this.props, children = _this$props.children;
    _this$props.in;
    _this$props.mountOnEnter;
    _this$props.unmountOnExit;
    _this$props.appear;
    _this$props.enter;
    _this$props.exit;
    _this$props.timeout;
    _this$props.addEndListener;
    _this$props.onEnter;
    _this$props.onEntering;
    _this$props.onEntered;
    _this$props.onExit;
    _this$props.onExiting;
    _this$props.onExited;
    _this$props.nodeRef;
    var childProps = _objectWithoutPropertiesLoose$1(_this$props, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
    return (
      // allows for nested Transitions
      /* @__PURE__ */ React$1.createElement(TransitionGroupContext$1.Provider, {
        value: null
      }, typeof children === "function" ? children(status, childProps) : React$1.cloneElement(React$1.Children.only(children), childProps))
    );
  };
  return Transition2;
}(React$1.Component);
Transition$1.contextType = TransitionGroupContext$1;
Transition$1.propTypes = {};
function noop$3() {
}
Transition$1.defaultProps = {
  in: false,
  mountOnEnter: false,
  unmountOnExit: false,
  appear: false,
  enter: true,
  exit: true,
  onEnter: noop$3,
  onEntering: noop$3,
  onEntered: noop$3,
  onExit: noop$3,
  onExiting: noop$3,
  onExited: noop$3
};
Transition$1.UNMOUNTED = UNMOUNTED$1;
Transition$1.EXITED = EXITED$1;
Transition$1.ENTERING = ENTERING$1;
Transition$1.ENTERED = ENTERED$1;
Transition$1.EXITING = EXITING$1;
function _assertThisInitialized(e2) {
  if (void 0 === e2) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e2;
}
function getChildMapping(children, mapFn) {
  var mapper = function mapper2(child) {
    return mapFn && reactExports.isValidElement(child) ? mapFn(child) : child;
  };
  var result = /* @__PURE__ */ Object.create(null);
  if (children) reactExports.Children.map(children, function(c2) {
    return c2;
  }).forEach(function(child) {
    result[child.key] = mapper(child);
  });
  return result;
}
function mergeChildMappings(prev2, next11) {
  prev2 = prev2 || {};
  next11 = next11 || {};
  function getValueForKey(key) {
    return key in next11 ? next11[key] : prev2[key];
  }
  var nextKeysPending = /* @__PURE__ */ Object.create(null);
  var pendingKeys = [];
  for (var prevKey in prev2) {
    if (prevKey in next11) {
      if (pendingKeys.length) {
        nextKeysPending[prevKey] = pendingKeys;
        pendingKeys = [];
      }
    } else {
      pendingKeys.push(prevKey);
    }
  }
  var i;
  var childMapping = {};
  for (var nextKey in next11) {
    if (nextKeysPending[nextKey]) {
      for (i = 0; i < nextKeysPending[nextKey].length; i++) {
        var pendingNextKey = nextKeysPending[nextKey][i];
        childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);
      }
    }
    childMapping[nextKey] = getValueForKey(nextKey);
  }
  for (i = 0; i < pendingKeys.length; i++) {
    childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);
  }
  return childMapping;
}
function getProp(child, prop, props) {
  return props[prop] != null ? props[prop] : child.props[prop];
}
function getInitialChildMapping(props, onExited) {
  return getChildMapping(props.children, function(child) {
    return reactExports.cloneElement(child, {
      onExited: onExited.bind(null, child),
      in: true,
      appear: getProp(child, "appear", props),
      enter: getProp(child, "enter", props),
      exit: getProp(child, "exit", props)
    });
  });
}
function getNextChildMapping(nextProps, prevChildMapping, onExited) {
  var nextChildMapping = getChildMapping(nextProps.children);
  var children = mergeChildMappings(prevChildMapping, nextChildMapping);
  Object.keys(children).forEach(function(key) {
    var child = children[key];
    if (!reactExports.isValidElement(child)) return;
    var hasPrev = key in prevChildMapping;
    var hasNext = key in nextChildMapping;
    var prevChild = prevChildMapping[key];
    var isLeaving = reactExports.isValidElement(prevChild) && !prevChild.props.in;
    if (hasNext && (!hasPrev || isLeaving)) {
      children[key] = reactExports.cloneElement(child, {
        onExited: onExited.bind(null, child),
        in: true,
        exit: getProp(child, "exit", nextProps),
        enter: getProp(child, "enter", nextProps)
      });
    } else if (!hasNext && hasPrev && !isLeaving) {
      children[key] = reactExports.cloneElement(child, {
        in: false
      });
    } else if (hasNext && hasPrev && reactExports.isValidElement(prevChild)) {
      children[key] = reactExports.cloneElement(child, {
        onExited: onExited.bind(null, child),
        in: prevChild.props.in,
        exit: getProp(child, "exit", nextProps),
        enter: getProp(child, "enter", nextProps)
      });
    }
  });
  return children;
}
var values4 = Object.values || function(obj) {
  return Object.keys(obj).map(function(k2) {
    return obj[k2];
  });
};
var defaultProps = {
  component: "div",
  childFactory: function childFactory(child) {
    return child;
  }
};
var TransitionGroup = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose$1(TransitionGroup2, _React$Component);
  function TransitionGroup2(props, context) {
    var _this;
    _this = _React$Component.call(this, props, context) || this;
    var handleExited = _this.handleExited.bind(_assertThisInitialized(_this));
    _this.state = {
      contextValue: {
        isMounting: true
      },
      handleExited,
      firstRender: true
    };
    return _this;
  }
  var _proto = TransitionGroup2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    this.mounted = true;
    this.setState({
      contextValue: {
        isMounting: false
      }
    });
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    this.mounted = false;
  };
  TransitionGroup2.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, _ref) {
    var prevChildMapping = _ref.children, handleExited = _ref.handleExited, firstRender = _ref.firstRender;
    return {
      children: firstRender ? getInitialChildMapping(nextProps, handleExited) : getNextChildMapping(nextProps, prevChildMapping, handleExited),
      firstRender: false
    };
  };
  _proto.handleExited = function handleExited(child, node2) {
    var currentChildMapping = getChildMapping(this.props.children);
    if (child.key in currentChildMapping) return;
    if (child.props.onExited) {
      child.props.onExited(node2);
    }
    if (this.mounted) {
      this.setState(function(state) {
        var children = _extends({}, state.children);
        delete children[child.key];
        return {
          children
        };
      });
    }
  };
  _proto.render = function render() {
    var _this$props = this.props, Component = _this$props.component, childFactory2 = _this$props.childFactory, props = _objectWithoutPropertiesLoose$1(_this$props, ["component", "childFactory"]);
    var contextValue = this.state.contextValue;
    var children = values4(this.state.children).map(childFactory2);
    delete props.appear;
    delete props.enter;
    delete props.exit;
    if (Component === null) {
      return /* @__PURE__ */ React$1.createElement(TransitionGroupContext$1.Provider, {
        value: contextValue
      }, children);
    }
    return /* @__PURE__ */ React$1.createElement(TransitionGroupContext$1.Provider, {
      value: contextValue
    }, /* @__PURE__ */ React$1.createElement(Component, props, children));
  };
  return TransitionGroup2;
}(React$1.Component);
TransitionGroup.propTypes = {};
TransitionGroup.defaultProps = defaultProps;
const reflow = (node2) => node2.scrollTop;
function getTransitionProps(props, options) {
  const {
    timeout,
    easing: easing2,
    style: style2 = {}
  } = props;
  return {
    duration: style2.transitionDuration ?? (typeof timeout === "number" ? timeout : timeout[options.mode] || 0),
    easing: style2.transitionTimingFunction ?? (typeof easing2 === "object" ? easing2[options.mode] : easing2),
    delay: style2.transitionDelay
  };
}
const styles = {
  entering: {
    opacity: 1
  },
  entered: {
    opacity: 1
  }
};
const Fade = /* @__PURE__ */ reactExports.forwardRef(function Fade2(props, ref) {
  const theme = useTheme();
  const defaultTimeout = {
    enter: theme.transitions.duration.enteringScreen,
    exit: theme.transitions.duration.leavingScreen
  };
  const {
    addEndListener,
    appear = true,
    children,
    easing: easing2,
    in: inProp,
    onEnter,
    onEntered,
    onEntering,
    onExit,
    onExited,
    onExiting,
    style: style2,
    timeout = defaultTimeout,
    // eslint-disable-next-line react/prop-types
    TransitionComponent = Transition$1,
    ...other
  } = props;
  const nodeRef = reactExports.useRef(null);
  const handleRef = useForkRef(nodeRef, getReactElementRef(children), ref);
  const normalizedTransitionCallback = (callback2) => (maybeIsAppearing) => {
    if (callback2) {
      const node2 = nodeRef.current;
      if (maybeIsAppearing === void 0) {
        callback2(node2);
      } else {
        callback2(node2, maybeIsAppearing);
      }
    }
  };
  const handleEntering = normalizedTransitionCallback(onEntering);
  const handleEnter = normalizedTransitionCallback((node2, isAppearing) => {
    reflow(node2);
    const transitionProps = getTransitionProps({
      style: style2,
      timeout,
      easing: easing2
    }, {
      mode: "enter"
    });
    node2.style.webkitTransition = theme.transitions.create("opacity", transitionProps);
    node2.style.transition = theme.transitions.create("opacity", transitionProps);
    if (onEnter) {
      onEnter(node2, isAppearing);
    }
  });
  const handleEntered = normalizedTransitionCallback(onEntered);
  const handleExiting = normalizedTransitionCallback(onExiting);
  const handleExit = normalizedTransitionCallback((node2) => {
    const transitionProps = getTransitionProps({
      style: style2,
      timeout,
      easing: easing2
    }, {
      mode: "exit"
    });
    node2.style.webkitTransition = theme.transitions.create("opacity", transitionProps);
    node2.style.transition = theme.transitions.create("opacity", transitionProps);
    if (onExit) {
      onExit(node2);
    }
  });
  const handleExited = normalizedTransitionCallback(onExited);
  const handleAddEndListener = (next11) => {
    if (addEndListener) {
      addEndListener(nodeRef.current, next11);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionComponent, {
    appear,
    in: inProp,
    nodeRef,
    onEnter: handleEnter,
    onEntered: handleEntered,
    onEntering: handleEntering,
    onExit: handleExit,
    onExited: handleExited,
    onExiting: handleExiting,
    addEndListener: handleAddEndListener,
    timeout,
    ...other,
    children: (state, {
      ownerState,
      ...restChildProps
    }) => {
      return /* @__PURE__ */ reactExports.cloneElement(children, {
        style: {
          opacity: 0,
          visibility: state === "exited" && !inProp ? "hidden" : void 0,
          ...styles[state],
          ...style2,
          ...children.props.style
        },
        ref: handleRef,
        ...restChildProps
      });
    }
  });
});
function getBackdropUtilityClass(slot) {
  return generateUtilityClass("MuiBackdrop", slot);
}
generateUtilityClasses("MuiBackdrop", ["root", "invisible"]);
const useUtilityClasses$6 = (ownerState) => {
  const {
    classes,
    invisible
  } = ownerState;
  const slots = {
    root: ["root", invisible && "invisible"]
  };
  return composeClasses(slots, getBackdropUtilityClass, classes);
};
const BackdropRoot = styled("div", {
  name: "MuiBackdrop",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.invisible && styles2.invisible];
  }
})({
  position: "fixed",
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  right: 0,
  bottom: 0,
  top: 0,
  left: 0,
  backgroundColor: "rgba(0, 0, 0, 0.5)",
  WebkitTapHighlightColor: "transparent",
  variants: [{
    props: {
      invisible: true
    },
    style: {
      backgroundColor: "transparent"
    }
  }]
});
const Backdrop = /* @__PURE__ */ reactExports.forwardRef(function Backdrop2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiBackdrop"
  });
  const {
    children,
    className,
    component = "div",
    invisible = false,
    open,
    components = {},
    componentsProps = {},
    slotProps = {},
    slots = {},
    TransitionComponent: TransitionComponentProp,
    transitionDuration,
    ...other
  } = props;
  const ownerState = {
    ...props,
    component,
    invisible
  };
  const classes = useUtilityClasses$6(ownerState);
  const backwardCompatibleSlots = {
    transition: TransitionComponentProp,
    root: components.Root,
    ...slots
  };
  const backwardCompatibleSlotProps = {
    ...componentsProps,
    ...slotProps
  };
  const externalForwardedProps = {
    slots: backwardCompatibleSlots,
    slotProps: backwardCompatibleSlotProps
  };
  const [RootSlot, rootProps] = useSlot("root", {
    elementType: BackdropRoot,
    externalForwardedProps,
    className: clsx(classes.root, className),
    ownerState
  });
  const [TransitionSlot, transitionProps] = useSlot("transition", {
    elementType: Fade,
    externalForwardedProps,
    ownerState
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionSlot, {
    in: open,
    timeout: transitionDuration,
    ...other,
    ...transitionProps,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(RootSlot, {
      "aria-hidden": true,
      ...rootProps,
      classes,
      ref,
      children
    })
  });
});
function getContainer$1(container) {
  return typeof container === "function" ? container() : container;
}
function getHasTransition(children) {
  return children ? children.props.hasOwnProperty("in") : false;
}
const noop$2 = () => {
};
const manager = new ModalManager();
function useModal(parameters) {
  const {
    container,
    disableEscapeKeyDown = false,
    disableScrollLock = false,
    closeAfterTransition = false,
    onTransitionEnter,
    onTransitionExited,
    children,
    onClose,
    open,
    rootRef
  } = parameters;
  const modal = reactExports.useRef({});
  const mountNodeRef = reactExports.useRef(null);
  const modalRef = reactExports.useRef(null);
  const handleRef = useForkRef(modalRef, rootRef);
  const [exited, setExited] = reactExports.useState(!open);
  const hasTransition = getHasTransition(children);
  let ariaHiddenProp = true;
  if (parameters["aria-hidden"] === "false" || parameters["aria-hidden"] === false) {
    ariaHiddenProp = false;
  }
  const getDoc = () => ownerDocument(mountNodeRef.current);
  const getModal = () => {
    modal.current.modalRef = modalRef.current;
    modal.current.mount = mountNodeRef.current;
    return modal.current;
  };
  const handleMounted = () => {
    manager.mount(getModal(), {
      disableScrollLock
    });
    if (modalRef.current) {
      modalRef.current.scrollTop = 0;
    }
  };
  const handleOpen = useEventCallback(() => {
    const resolvedContainer = getContainer$1(container) || getDoc().body;
    manager.add(getModal(), resolvedContainer);
    if (modalRef.current) {
      handleMounted();
    }
  });
  const isTopModal = () => manager.isTopModal(getModal());
  const handlePortalRef = useEventCallback((node2) => {
    mountNodeRef.current = node2;
    if (!node2) {
      return;
    }
    if (open && isTopModal()) {
      handleMounted();
    } else if (modalRef.current) {
      ariaHidden(modalRef.current, ariaHiddenProp);
    }
  });
  const handleClose = reactExports.useCallback(() => {
    manager.remove(getModal(), ariaHiddenProp);
  }, [ariaHiddenProp]);
  reactExports.useEffect(() => {
    return () => {
      handleClose();
    };
  }, [handleClose]);
  reactExports.useEffect(() => {
    if (open) {
      handleOpen();
    } else if (!hasTransition || !closeAfterTransition) {
      handleClose();
    }
  }, [open, handleClose, hasTransition, closeAfterTransition, handleOpen]);
  const createHandleKeyDown = (otherHandlers) => (event) => {
    var _a;
    (_a = otherHandlers.onKeyDown) == null ? void 0 : _a.call(otherHandlers, event);
    if (event.key !== "Escape" || event.which === 229 || // Wait until IME is settled.
    !isTopModal()) {
      return;
    }
    if (!disableEscapeKeyDown) {
      event.stopPropagation();
      if (onClose) {
        onClose(event, "escapeKeyDown");
      }
    }
  };
  const createHandleBackdropClick = (otherHandlers) => (event) => {
    var _a;
    (_a = otherHandlers.onClick) == null ? void 0 : _a.call(otherHandlers, event);
    if (event.target !== event.currentTarget) {
      return;
    }
    if (onClose) {
      onClose(event, "backdropClick");
    }
  };
  const getRootProps = (otherHandlers = {}) => {
    const propsEventHandlers = extractEventHandlers(parameters);
    delete propsEventHandlers.onTransitionEnter;
    delete propsEventHandlers.onTransitionExited;
    const externalEventHandlers = {
      ...propsEventHandlers,
      ...otherHandlers
    };
    return {
      /*
       * Marking an element with the role presentation indicates to assistive technology
       * that this element should be ignored; it exists to support the web application and
       * is not meant for humans to interact with directly.
       * https://github.com/evcohen/eslint-plugin-jsx-a11y/blob/master/docs/rules/no-static-element-interactions.md
       */
      role: "presentation",
      ...externalEventHandlers,
      onKeyDown: createHandleKeyDown(externalEventHandlers),
      ref: handleRef
    };
  };
  const getBackdropProps = (otherHandlers = {}) => {
    const externalEventHandlers = otherHandlers;
    return {
      "aria-hidden": true,
      ...externalEventHandlers,
      onClick: createHandleBackdropClick(externalEventHandlers),
      open
    };
  };
  const getTransitionProps2 = () => {
    const handleEnter = () => {
      setExited(false);
      if (onTransitionEnter) {
        onTransitionEnter();
      }
    };
    const handleExited = () => {
      setExited(true);
      if (onTransitionExited) {
        onTransitionExited();
      }
      if (closeAfterTransition) {
        handleClose();
      }
    };
    return {
      onEnter: createChainedFunction(handleEnter, (children == null ? void 0 : children.props.onEnter) ?? noop$2),
      onExited: createChainedFunction(handleExited, (children == null ? void 0 : children.props.onExited) ?? noop$2)
    };
  };
  return {
    getRootProps,
    getBackdropProps,
    getTransitionProps: getTransitionProps2,
    rootRef: handleRef,
    portalRef: handlePortalRef,
    isTopModal,
    exited,
    hasTransition
  };
}
function getModalUtilityClass(slot) {
  return generateUtilityClass("MuiModal", slot);
}
generateUtilityClasses("MuiModal", ["root", "hidden", "backdrop"]);
const useUtilityClasses$5 = (ownerState) => {
  const {
    open,
    exited,
    classes
  } = ownerState;
  const slots = {
    root: ["root", !open && exited && "hidden"],
    backdrop: ["backdrop"]
  };
  return composeClasses(slots, getModalUtilityClass, classes);
};
const ModalRoot = styled("div", {
  name: "MuiModal",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, !ownerState.open && ownerState.exited && styles2.hidden];
  }
})(memoTheme(({
  theme
}) => ({
  position: "fixed",
  zIndex: (theme.vars || theme).zIndex.modal,
  right: 0,
  bottom: 0,
  top: 0,
  left: 0,
  variants: [{
    props: ({
      ownerState
    }) => !ownerState.open && ownerState.exited,
    style: {
      visibility: "hidden"
    }
  }]
})));
const ModalBackdrop = styled(Backdrop, {
  name: "MuiModal",
  slot: "Backdrop",
  overridesResolver: (props, styles2) => {
    return styles2.backdrop;
  }
})({
  zIndex: -1
});
const Modal = /* @__PURE__ */ reactExports.forwardRef(function Modal2(inProps, ref) {
  const props = useDefaultProps({
    name: "MuiModal",
    props: inProps
  });
  const {
    BackdropComponent = ModalBackdrop,
    BackdropProps,
    classes: classesProp,
    className,
    closeAfterTransition = false,
    children,
    container,
    component,
    components = {},
    componentsProps = {},
    disableAutoFocus = false,
    disableEnforceFocus = false,
    disableEscapeKeyDown = false,
    disablePortal = false,
    disableRestoreFocus = false,
    disableScrollLock = false,
    hideBackdrop = false,
    keepMounted = false,
    onBackdropClick,
    onClose,
    onTransitionEnter,
    onTransitionExited,
    open,
    slotProps = {},
    slots = {},
    // eslint-disable-next-line react/prop-types
    theme,
    ...other
  } = props;
  const propsWithDefaults = {
    ...props,
    closeAfterTransition,
    disableAutoFocus,
    disableEnforceFocus,
    disableEscapeKeyDown,
    disablePortal,
    disableRestoreFocus,
    disableScrollLock,
    hideBackdrop,
    keepMounted
  };
  const {
    getRootProps,
    getBackdropProps,
    getTransitionProps: getTransitionProps2,
    portalRef,
    isTopModal,
    exited,
    hasTransition
  } = useModal({
    ...propsWithDefaults,
    rootRef: ref
  });
  const ownerState = {
    ...propsWithDefaults,
    exited
  };
  const classes = useUtilityClasses$5(ownerState);
  const childProps = {};
  if (children.props.tabIndex === void 0) {
    childProps.tabIndex = "-1";
  }
  if (hasTransition) {
    const {
      onEnter,
      onExited
    } = getTransitionProps2();
    childProps.onEnter = onEnter;
    childProps.onExited = onExited;
  }
  const externalForwardedProps = {
    slots: {
      root: components.Root,
      backdrop: components.Backdrop,
      ...slots
    },
    slotProps: {
      ...componentsProps,
      ...slotProps
    }
  };
  const [RootSlot, rootProps] = useSlot("root", {
    ref,
    elementType: ModalRoot,
    externalForwardedProps: {
      ...externalForwardedProps,
      ...other,
      component
    },
    getSlotProps: getRootProps,
    ownerState,
    className: clsx(className, classes == null ? void 0 : classes.root, !ownerState.open && ownerState.exited && (classes == null ? void 0 : classes.hidden))
  });
  const [BackdropSlot, backdropProps] = useSlot("backdrop", {
    ref: BackdropProps == null ? void 0 : BackdropProps.ref,
    elementType: BackdropComponent,
    externalForwardedProps,
    shouldForwardComponentProp: true,
    additionalProps: BackdropProps,
    getSlotProps: (otherHandlers) => {
      return getBackdropProps({
        ...otherHandlers,
        onClick: (event) => {
          if (onBackdropClick) {
            onBackdropClick(event);
          }
          if (otherHandlers == null ? void 0 : otherHandlers.onClick) {
            otherHandlers.onClick(event);
          }
        }
      });
    },
    className: clsx(BackdropProps == null ? void 0 : BackdropProps.className, classes == null ? void 0 : classes.backdrop),
    ownerState
  });
  if (!keepMounted && !open && (!hasTransition || exited)) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Portal, {
    ref: portalRef,
    container,
    disablePortal,
    children: /* @__PURE__ */ jsxRuntimeExports.jsxs(RootSlot, {
      ...rootProps,
      children: [!hideBackdrop && BackdropComponent ? /* @__PURE__ */ jsxRuntimeExports.jsx(BackdropSlot, {
        ...backdropProps
      }) : null, /* @__PURE__ */ jsxRuntimeExports.jsx(FocusTrap, {
        disableEnforceFocus,
        disableAutoFocus,
        disableRestoreFocus,
        isEnabled: isTopModal,
        open,
        children: /* @__PURE__ */ reactExports.cloneElement(children, childProps)
      })]
    })
  });
});
var __assign$1 = function() {
  __assign$1 = Object.assign || function __assign2(t2) {
    for (var s, i = 1, n2 = arguments.length; i < n2; i++) {
      s = arguments[i];
      for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2)) t2[p2] = s[p2];
    }
    return t2;
  };
  return __assign$1.apply(this, arguments);
};
function __rest$1(s, e2) {
  var t2 = {};
  for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
    t2[p2] = s[p2];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
        t2[p2[i]] = s[p2[i]];
    }
  return t2;
}
typeof SuppressedError === "function" ? SuppressedError : function(error2, suppressed, message) {
  var e2 = new Error(message);
  return e2.name = "SuppressedError", e2.error = error2, e2.suppressed = suppressed, e2;
};
function getDefaultExportFromCjs$1(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
var classnames$1 = { exports: {} };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
(function(module) {
  (function() {
    var hasOwn3 = {}.hasOwnProperty;
    function classNames2() {
      var classes = "";
      for (var i = 0; i < arguments.length; i++) {
        var arg2 = arguments[i];
        if (arg2) {
          classes = appendClass(classes, parseValue(arg2));
        }
      }
      return classes;
    }
    function parseValue(arg2) {
      if (typeof arg2 === "string" || typeof arg2 === "number") {
        return arg2;
      }
      if (typeof arg2 !== "object") {
        return "";
      }
      if (Array.isArray(arg2)) {
        return classNames2.apply(null, arg2);
      }
      if (arg2.toString !== Object.prototype.toString && !arg2.toString.toString().includes("[native code]")) {
        return arg2.toString();
      }
      var classes = "";
      for (var key in arg2) {
        if (hasOwn3.call(arg2, key) && arg2[key]) {
          classes = appendClass(classes, key);
        }
      }
      return classes;
    }
    function appendClass(value, newClass) {
      if (!newClass) {
        return value;
      }
      if (value) {
        return value + " " + newClass;
      }
      return value + newClass;
    }
    if (module.exports) {
      classNames2.default = classNames2;
      module.exports = classNames2;
    } else {
      window.classNames = classNames2;
    }
  })();
})(classnames$1);
var classnamesExports$1 = classnames$1.exports;
var classNames$1 = /* @__PURE__ */ getDefaultExportFromCjs$1(classnamesExports$1);
function useForkedRef() {
  var refs = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    refs[_i] = arguments[_i];
  }
  return reactExports.useMemo(function() {
    if (refs.every(function(ref) {
      return ref == null;
    })) {
      return null;
    }
    return function(node2) {
      refs.forEach(function(ref) {
        assignRef(ref, node2);
      });
    };
  }, refs);
}
function assignRef(ref, value) {
  if (ref == null)
    return;
  if (isFunction$1(ref)) {
    ref(value);
  } else {
    try {
      ref.current = value;
    } catch (_a) {
      throw new Error('Cannot assign value "'.concat(value, '" to ref "').concat(ref, '"'));
    }
  }
}
function isFunction$1(value) {
  return !!(value && {}.toString.call(value) == "[object Function]");
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function _setPrototypeOf(o, p2) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf(o, p2);
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
var config = {
  disabled: false
};
var TransitionGroupContext = React$1.createContext(null);
var forceReflow2 = function forceReflow3(node2) {
  return node2.scrollTop;
};
var UNMOUNTED = "unmounted";
var EXITED = "exited";
var ENTERING = "entering";
var ENTERED = "entered";
var EXITING = "exiting";
var Transition = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(Transition2, _React$Component);
  function Transition2(props, context) {
    var _this;
    _this = _React$Component.call(this, props, context) || this;
    var parentGroup = context;
    var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;
    var initialStatus;
    _this.appearStatus = null;
    if (props.in) {
      if (appear) {
        initialStatus = EXITED;
        _this.appearStatus = ENTERING;
      } else {
        initialStatus = ENTERED;
      }
    } else {
      if (props.unmountOnExit || props.mountOnEnter) {
        initialStatus = UNMOUNTED;
      } else {
        initialStatus = EXITED;
      }
    }
    _this.state = {
      status: initialStatus
    };
    _this.nextCallback = null;
    return _this;
  }
  Transition2.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {
    var nextIn = _ref.in;
    if (nextIn && prevState.status === UNMOUNTED) {
      return {
        status: EXITED
      };
    }
    return null;
  };
  var _proto = Transition2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    this.updateStatus(true, this.appearStatus);
  };
  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    var nextStatus = null;
    if (prevProps !== this.props) {
      var status = this.state.status;
      if (this.props.in) {
        if (status !== ENTERING && status !== ENTERED) {
          nextStatus = ENTERING;
        }
      } else {
        if (status === ENTERING || status === ENTERED) {
          nextStatus = EXITING;
        }
      }
    }
    this.updateStatus(false, nextStatus);
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    this.cancelNextCallback();
  };
  _proto.getTimeouts = function getTimeouts() {
    var timeout2 = this.props.timeout;
    var exit, enter, appear;
    exit = enter = appear = timeout2;
    if (timeout2 != null && typeof timeout2 !== "number") {
      exit = timeout2.exit;
      enter = timeout2.enter;
      appear = timeout2.appear !== void 0 ? timeout2.appear : enter;
    }
    return {
      exit,
      enter,
      appear
    };
  };
  _proto.updateStatus = function updateStatus(mounting, nextStatus) {
    if (mounting === void 0) {
      mounting = false;
    }
    if (nextStatus !== null) {
      this.cancelNextCallback();
      if (nextStatus === ENTERING) {
        if (this.props.unmountOnExit || this.props.mountOnEnter) {
          var node2 = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this);
          if (node2) forceReflow2(node2);
        }
        this.performEnter(mounting);
      } else {
        this.performExit();
      }
    } else if (this.props.unmountOnExit && this.state.status === EXITED) {
      this.setState({
        status: UNMOUNTED
      });
    }
  };
  _proto.performEnter = function performEnter(mounting) {
    var _this2 = this;
    var enter = this.props.enter;
    var appearing = this.context ? this.context.isMounting : mounting;
    var _ref2 = this.props.nodeRef ? [appearing] : [ReactDOM.findDOMNode(this), appearing], maybeNode = _ref2[0], maybeAppearing = _ref2[1];
    var timeouts = this.getTimeouts();
    var enterTimeout = appearing ? timeouts.appear : timeouts.enter;
    if (!mounting && !enter || config.disabled) {
      this.safeSetState({
        status: ENTERED
      }, function() {
        _this2.props.onEntered(maybeNode);
      });
      return;
    }
    this.props.onEnter(maybeNode, maybeAppearing);
    this.safeSetState({
      status: ENTERING
    }, function() {
      _this2.props.onEntering(maybeNode, maybeAppearing);
      _this2.onTransitionEnd(enterTimeout, function() {
        _this2.safeSetState({
          status: ENTERED
        }, function() {
          _this2.props.onEntered(maybeNode, maybeAppearing);
        });
      });
    });
  };
  _proto.performExit = function performExit() {
    var _this3 = this;
    var exit = this.props.exit;
    var timeouts = this.getTimeouts();
    var maybeNode = this.props.nodeRef ? void 0 : ReactDOM.findDOMNode(this);
    if (!exit || config.disabled) {
      this.safeSetState({
        status: EXITED
      }, function() {
        _this3.props.onExited(maybeNode);
      });
      return;
    }
    this.props.onExit(maybeNode);
    this.safeSetState({
      status: EXITING
    }, function() {
      _this3.props.onExiting(maybeNode);
      _this3.onTransitionEnd(timeouts.exit, function() {
        _this3.safeSetState({
          status: EXITED
        }, function() {
          _this3.props.onExited(maybeNode);
        });
      });
    });
  };
  _proto.cancelNextCallback = function cancelNextCallback() {
    if (this.nextCallback !== null) {
      this.nextCallback.cancel();
      this.nextCallback = null;
    }
  };
  _proto.safeSetState = function safeSetState(nextState, callback2) {
    callback2 = this.setNextCallback(callback2);
    this.setState(nextState, callback2);
  };
  _proto.setNextCallback = function setNextCallback(callback2) {
    var _this4 = this;
    var active = true;
    this.nextCallback = function(event) {
      if (active) {
        active = false;
        _this4.nextCallback = null;
        callback2(event);
      }
    };
    this.nextCallback.cancel = function() {
      active = false;
    };
    return this.nextCallback;
  };
  _proto.onTransitionEnd = function onTransitionEnd(timeout2, handler) {
    this.setNextCallback(handler);
    var node2 = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this);
    var doesNotHaveTimeoutOrListener = timeout2 == null && !this.props.addEndListener;
    if (!node2 || doesNotHaveTimeoutOrListener) {
      setTimeout(this.nextCallback, 0);
      return;
    }
    if (this.props.addEndListener) {
      var _ref3 = this.props.nodeRef ? [this.nextCallback] : [node2, this.nextCallback], maybeNode = _ref3[0], maybeNextCallback = _ref3[1];
      this.props.addEndListener(maybeNode, maybeNextCallback);
    }
    if (timeout2 != null) {
      setTimeout(this.nextCallback, timeout2);
    }
  };
  _proto.render = function render() {
    var status = this.state.status;
    if (status === UNMOUNTED) {
      return null;
    }
    var _this$props = this.props, children = _this$props.children;
    _this$props.in;
    _this$props.mountOnEnter;
    _this$props.unmountOnExit;
    _this$props.appear;
    _this$props.enter;
    _this$props.exit;
    _this$props.timeout;
    _this$props.addEndListener;
    _this$props.onEnter;
    _this$props.onEntering;
    _this$props.onEntered;
    _this$props.onExit;
    _this$props.onExiting;
    _this$props.onExited;
    _this$props.nodeRef;
    var childProps = _objectWithoutPropertiesLoose(_this$props, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
    return (
      // allows for nested Transitions
      /* @__PURE__ */ React$1.createElement(TransitionGroupContext.Provider, {
        value: null
      }, typeof children === "function" ? children(status, childProps) : React$1.cloneElement(React$1.Children.only(children), childProps))
    );
  };
  return Transition2;
}(React$1.Component);
Transition.contextType = TransitionGroupContext;
Transition.propTypes = {};
function noop$1() {
}
Transition.defaultProps = {
  in: false,
  mountOnEnter: false,
  unmountOnExit: false,
  appear: false,
  enter: true,
  exit: true,
  onEnter: noop$1,
  onEntering: noop$1,
  onEntered: noop$1,
  onExit: noop$1,
  onExiting: noop$1,
  onExited: noop$1
};
Transition.UNMOUNTED = UNMOUNTED;
Transition.EXITED = EXITED;
Transition.ENTERING = ENTERING;
Transition.ENTERED = ENTERED;
Transition.EXITING = EXITING;
var CCloseButton = reactExports.forwardRef(function(_a, ref) {
  var className = _a.className, dark2 = _a.dark, disabled = _a.disabled, white = _a.white, rest = __rest$1(_a, ["className", "dark", "disabled", "white"]);
  return React$1.createElement("button", __assign$1({ type: "button", className: classNames$1("btn", "btn-close", {
    "btn-close-white": white
  }, disabled, className), "aria-label": "Close", disabled }, dark2 && { "data-coreui-theme": "dark" }, rest, { ref }));
});
CCloseButton.propTypes = {
  className: PropTypes$1.string,
  dark: PropTypes$1.bool,
  disabled: PropTypes$1.bool,
  white: PropTypes$1.bool
};
CCloseButton.displayName = "CCloseButton";
var colorPropType = PropTypes$1.oneOfType([
  PropTypes$1.oneOf([
    "primary",
    "secondary",
    "success",
    "danger",
    "warning",
    "info",
    "dark",
    "light"
  ]),
  PropTypes$1.string
]);
PropTypes$1.oneOfType([
  PropTypes$1.arrayOf(PropTypes$1.oneOf(["top", "bottom", "right", "left"]).isRequired),
  PropTypes$1.oneOf(["top", "bottom", "right", "left"])
]);
PropTypes$1.oneOf([
  "auto",
  "auto-start",
  "auto-end",
  "top-end",
  "top",
  "top-start",
  "bottom-end",
  "bottom",
  "bottom-start",
  "right-start",
  "right",
  "right-end",
  "left-start",
  "left",
  "left-end"
]);
var shapePropType = PropTypes$1.oneOfType([
  PropTypes$1.oneOf([
    "rounded",
    "rounded-top",
    "rounded-end",
    "rounded-bottom",
    "rounded-start",
    "rounded-circle",
    "rounded-pill",
    "rounded-0",
    "rounded-1",
    "rounded-2",
    "rounded-3"
  ]),
  PropTypes$1.string
]);
var textColorsPropType = PropTypes$1.oneOfType([
  colorPropType,
  PropTypes$1.oneOf(["white", "muted"]),
  PropTypes$1.string
]);
PropTypes$1.oneOfType([
  PropTypes$1.arrayOf(PropTypes$1.oneOf(["hover", "focus", "click"]).isRequired),
  PropTypes$1.oneOf(["hover", "focus", "click"])
]);
var CLink = reactExports.forwardRef(function(_a, ref) {
  var children = _a.children, active = _a.active, _b = _a.as, Component = _b === void 0 ? "a" : _b, className = _a.className, disabled = _a.disabled, rest = __rest$1(_a, ["children", "active", "as", "className", "disabled"]);
  return React$1.createElement(
    Component,
    __assign$1({
      // TODO: remove duplicated classes ex. `active active` in `<CListGroupItem>`
      className: classNames$1(className, { active, disabled })
    }, active && { "aria-current": "page" }, Component === "a" && disabled && { "aria-disabled": true, tabIndex: -1 }, (Component === "a" || Component === "button") && {
      onClick: function(event) {
        event.preventDefault;
        !disabled && rest.onClick && rest.onClick(event);
      }
    }, { disabled }, rest, { ref }),
    children
  );
});
CLink.propTypes = {
  active: PropTypes$1.bool,
  as: PropTypes$1.elementType,
  children: PropTypes$1.node,
  className: PropTypes$1.string,
  disabled: PropTypes$1.bool
};
CLink.displayName = "CLink";
var CBackdrop = reactExports.forwardRef(function(_a, ref) {
  var _b = _a.className, className = _b === void 0 ? "modal-backdrop" : _b, visible = _a.visible, rest = __rest$1(_a, ["className", "visible"]);
  var backdropRef = reactExports.useRef(null);
  var forkedRef = useForkedRef(ref, backdropRef);
  return React$1.createElement(Transition, { in: visible, mountOnEnter: true, nodeRef: backdropRef, timeout: 150, unmountOnExit: true }, function(state) {
    return React$1.createElement("div", __assign$1({ className: classNames$1(className, "fade", {
      show: state === "entered"
    }) }, rest, { ref: forkedRef }));
  });
});
CBackdrop.propTypes = {
  className: PropTypes$1.string,
  visible: PropTypes$1.bool
};
CBackdrop.displayName = "CBackdrop";
var CButton = reactExports.forwardRef(function(_a, ref) {
  var _b;
  var children = _a.children, _c = _a.as, as = _c === void 0 ? "button" : _c, className = _a.className, color2 = _a.color, shape2 = _a.shape, size3 = _a.size, _d = _a.type, type = _d === void 0 ? "button" : _d, variant = _a.variant, rest = __rest$1(_a, ["children", "as", "className", "color", "shape", "size", "type", "variant"]);
  return React$1.createElement(CLink, __assign$1({ as: rest.href ? "a" : as }, !rest.href && { type }, { className: classNames$1("btn", (_b = {}, _b["btn-".concat(color2)] = color2 && !variant, _b["btn-".concat(variant, "-").concat(color2)] = color2 && variant, _b["btn-".concat(size3)] = size3, _b), shape2, className) }, rest, { ref }), children);
});
CButton.propTypes = {
  as: PropTypes$1.elementType,
  children: PropTypes$1.node,
  className: PropTypes$1.string,
  color: colorPropType,
  shape: PropTypes$1.string,
  size: PropTypes$1.oneOf(["sm", "lg"]),
  type: PropTypes$1.oneOf(["button", "submit", "reset"]),
  variant: PropTypes$1.oneOf(["outline", "ghost"])
};
CButton.displayName = "CButton";
var getContainer = function(container) {
  if (container) {
    return typeof container === "function" ? container() : container;
  }
  return document.body;
};
var CConditionalPortal = function(_a) {
  var children = _a.children, container = _a.container, portal = _a.portal;
  var _b = reactExports.useState(null), _container = _b[0], setContainer = _b[1];
  reactExports.useEffect(function() {
    portal && setContainer(getContainer(container) || document.body);
  }, [container, portal]);
  return typeof window !== "undefined" && portal && _container ? reactDomExports.createPortal(children, _container) : React$1.createElement(React$1.Fragment, null, children);
};
CConditionalPortal.propTypes = {
  children: PropTypes$1.node,
  container: PropTypes$1.any,
  // HTMLElement
  portal: PropTypes$1.bool.isRequired
};
CConditionalPortal.displayName = "CConditionalPortal";
var CForm = reactExports.forwardRef(function(_a, ref) {
  var children = _a.children, className = _a.className, validated = _a.validated, rest = __rest$1(_a, ["children", "className", "validated"]);
  return React$1.createElement("form", __assign$1({ className: classNames$1({ "was-validated": validated }, className) || void 0 }, rest, { ref }), children);
});
CForm.propTypes = {
  children: PropTypes$1.node,
  className: PropTypes$1.string,
  validated: PropTypes$1.bool
};
CForm.displayName = "CForm";
var CFormFeedback = reactExports.forwardRef(function(_a, ref) {
  var _b;
  var children = _a.children, _c = _a.as, Component = _c === void 0 ? "div" : _c, className = _a.className, invalid = _a.invalid, tooltip = _a.tooltip, valid2 = _a.valid, rest = __rest$1(_a, ["children", "as", "className", "invalid", "tooltip", "valid"]);
  return React$1.createElement(Component, __assign$1({ className: classNames$1((_b = {}, _b["invalid-".concat(tooltip ? "tooltip" : "feedback")] = invalid, _b["valid-".concat(tooltip ? "tooltip" : "feedback")] = valid2, _b), className) }, rest, { ref }), children);
});
CFormFeedback.propTypes = {
  as: PropTypes$1.elementType,
  children: PropTypes$1.node,
  className: PropTypes$1.string,
  invalid: PropTypes$1.bool,
  tooltip: PropTypes$1.bool,
  valid: PropTypes$1.bool
};
CFormFeedback.displayName = "CFormFeedback";
var CFormControlValidation = function(_a) {
  var describedby = _a.describedby, feedback = _a.feedback, feedbackInvalid = _a.feedbackInvalid, feedbackValid = _a.feedbackValid, invalid = _a.invalid, tooltipFeedback = _a.tooltipFeedback, valid2 = _a.valid;
  return React$1.createElement(
    React$1.Fragment,
    null,
    feedback && (valid2 || invalid) && React$1.createElement(CFormFeedback, __assign$1({}, invalid && { id: describedby }, { invalid, tooltip: tooltipFeedback, valid: valid2 }), feedback),
    feedbackInvalid && React$1.createElement(CFormFeedback, { id: describedby, invalid: true, tooltip: tooltipFeedback }, feedbackInvalid),
    feedbackValid && React$1.createElement(CFormFeedback, { valid: true, tooltip: tooltipFeedback }, feedbackValid)
  );
};
CFormControlValidation.propTypes = {
  describedby: PropTypes$1.string,
  feedback: PropTypes$1.oneOfType([PropTypes$1.node, PropTypes$1.string]),
  feedbackValid: PropTypes$1.oneOfType([PropTypes$1.node, PropTypes$1.string]),
  feedbackInvalid: PropTypes$1.oneOfType([PropTypes$1.node, PropTypes$1.string]),
  invalid: PropTypes$1.bool,
  tooltipFeedback: PropTypes$1.bool,
  valid: PropTypes$1.bool
};
CFormControlValidation.displayName = "CFormControlValidation";
var CFormLabel = reactExports.forwardRef(function(_a, ref) {
  var children = _a.children, className = _a.className, customClassName = _a.customClassName, rest = __rest$1(_a, ["children", "className", "customClassName"]);
  return React$1.createElement("label", __assign$1({ className: customClassName !== null && customClassName !== void 0 ? customClassName : classNames$1("form-label", className) }, rest, { ref }), children);
});
CFormLabel.propTypes = {
  children: PropTypes$1.node,
  className: PropTypes$1.string,
  customClassName: PropTypes$1.string
};
CFormLabel.displayName = "CFormLabel";
var CFormFloating = reactExports.forwardRef(function(_a, ref) {
  var children = _a.children, className = _a.className, rest = __rest$1(_a, ["children", "className"]);
  return React$1.createElement("div", __assign$1({ className: classNames$1("form-floating", className) }, rest, { ref }), children);
});
CFormFloating.propTypes = {
  children: PropTypes$1.node,
  className: PropTypes$1.string
};
CFormFloating.displayName = "CFormFloating";
var CFormText = reactExports.forwardRef(function(_a, ref) {
  var children = _a.children, _b = _a.as, Component = _b === void 0 ? "div" : _b, className = _a.className, rest = __rest$1(_a, ["children", "as", "className"]);
  return React$1.createElement(Component, __assign$1({ className: classNames$1("form-text", className) }, rest, { ref }), children);
});
CFormText.propTypes = {
  as: PropTypes$1.elementType,
  children: PropTypes$1.node,
  className: PropTypes$1.string
};
CFormText.displayName = "CFormText";
var CFormControlWrapper = function(_a) {
  var children = _a.children, describedby = _a.describedby, feedback = _a.feedback, feedbackInvalid = _a.feedbackInvalid, feedbackValid = _a.feedbackValid, floatingClassName = _a.floatingClassName, floatingLabel = _a.floatingLabel, id2 = _a.id, invalid = _a.invalid, label = _a.label, text = _a.text, tooltipFeedback = _a.tooltipFeedback, valid2 = _a.valid;
  var FormControlValidation = function() {
    return React$1.createElement(CFormControlValidation, { describedby, feedback, feedbackInvalid, feedbackValid, floatingLabel, invalid, tooltipFeedback, valid: valid2 });
  };
  return floatingLabel ? React$1.createElement(
    CFormFloating,
    { className: floatingClassName },
    children,
    React$1.createElement(CFormLabel, { htmlFor: id2 }, label || floatingLabel),
    text && React$1.createElement(CFormText, { id: describedby }, text),
    React$1.createElement(FormControlValidation, null)
  ) : React$1.createElement(
    React$1.Fragment,
    null,
    label && React$1.createElement(CFormLabel, { htmlFor: id2 }, label),
    children,
    text && React$1.createElement(CFormText, { id: describedby }, text),
    React$1.createElement(FormControlValidation, null)
  );
};
CFormControlWrapper.propTypes = __assign$1({ children: PropTypes$1.node, floatingClassName: PropTypes$1.string, floatingLabel: PropTypes$1.oneOfType([PropTypes$1.node, PropTypes$1.string]), label: PropTypes$1.oneOfType([PropTypes$1.node, PropTypes$1.string]), text: PropTypes$1.oneOfType([PropTypes$1.node, PropTypes$1.string]) }, CFormControlValidation.propTypes);
CFormControlWrapper.displayName = "CFormControlWrapper";
var CFormInput = reactExports.forwardRef(function(_a, ref) {
  var _b;
  var children = _a.children, className = _a.className, _c = _a.delay, delay = _c === void 0 ? false : _c, feedback = _a.feedback, feedbackInvalid = _a.feedbackInvalid, feedbackValid = _a.feedbackValid, floatingClassName = _a.floatingClassName, floatingLabel = _a.floatingLabel, id2 = _a.id, invalid = _a.invalid, label = _a.label, onChange = _a.onChange, plainText = _a.plainText, size3 = _a.size, text = _a.text, tooltipFeedback = _a.tooltipFeedback, _d = _a.type, type = _d === void 0 ? "text" : _d, valid2 = _a.valid, rest = __rest$1(_a, ["children", "className", "delay", "feedback", "feedbackInvalid", "feedbackValid", "floatingClassName", "floatingLabel", "id", "invalid", "label", "onChange", "plainText", "size", "text", "tooltipFeedback", "type", "valid"]);
  var _e = reactExports.useState(), value = _e[0], setValue = _e[1];
  reactExports.useEffect(function() {
    var timeOutId = setTimeout(function() {
      return value && onChange && onChange(value);
    }, typeof delay === "number" ? delay : 500);
    return function() {
      return clearTimeout(timeOutId);
    };
  }, [value]);
  return React$1.createElement(
    CFormControlWrapper,
    { describedby: rest["aria-describedby"], feedback, feedbackInvalid, feedbackValid, floatingClassName, floatingLabel, id: id2, invalid, label, text, tooltipFeedback, valid: valid2 },
    React$1.createElement("input", __assign$1({ className: classNames$1(plainText ? "form-control-plaintext" : "form-control", (_b = {}, _b["form-control-".concat(size3)] = size3, _b["form-control-color"] = type === "color", _b["is-invalid"] = invalid, _b["is-valid"] = valid2, _b), className), id: id2, type, onChange: function(event) {
      return delay ? setValue(event) : onChange && onChange(event);
    } }, rest, { ref }), children)
  );
});
CFormInput.propTypes = __assign$1({ className: PropTypes$1.string, id: PropTypes$1.string, delay: PropTypes$1.oneOfType([PropTypes$1.bool, PropTypes$1.number]), plainText: PropTypes$1.bool, size: PropTypes$1.oneOf(["sm", "lg"]), type: PropTypes$1.oneOfType([PropTypes$1.oneOf(["color", "file", "text"]), PropTypes$1.string]) }, CFormControlWrapper.propTypes);
CFormInput.displayName = "CFormInput";
var CInputGroup = reactExports.forwardRef(function(_a, ref) {
  var _b;
  var children = _a.children, className = _a.className, size3 = _a.size, rest = __rest$1(_a, ["children", "className", "size"]);
  return React$1.createElement("div", __assign$1({ className: classNames$1("input-group", (_b = {}, _b["input-group-".concat(size3)] = size3, _b), className) }, rest, { ref }), children);
});
CInputGroup.propTypes = {
  children: PropTypes$1.node,
  className: PropTypes$1.string,
  size: PropTypes$1.oneOf(["sm", "lg"])
};
CInputGroup.displayName = "CInputGroup";
var CInputGroupText = reactExports.forwardRef(function(_a, ref) {
  var children = _a.children, _b = _a.as, Component = _b === void 0 ? "span" : _b, className = _a.className, rest = __rest$1(_a, ["children", "as", "className"]);
  return React$1.createElement(Component, __assign$1({ className: classNames$1("input-group-text", className) }, rest, { ref }), children);
});
CInputGroupText.propTypes = {
  as: PropTypes$1.elementType,
  children: PropTypes$1.node,
  className: PropTypes$1.string
};
CInputGroupText.displayName = "CInputGroupText";
var CModalContent = reactExports.forwardRef(function(_a, ref) {
  var children = _a.children, className = _a.className, rest = __rest$1(_a, ["children", "className"]);
  return React$1.createElement("div", __assign$1({ className: classNames$1("modal-content", className) }, rest, { ref }), children);
});
CModalContent.propTypes = {
  children: PropTypes$1.node,
  className: PropTypes$1.string
};
CModalContent.displayName = "CModalContent";
var CModalDialog = reactExports.forwardRef(function(_a, ref) {
  var _b;
  var children = _a.children, alignment = _a.alignment, className = _a.className, fullscreen = _a.fullscreen, scrollable = _a.scrollable, size3 = _a.size, rest = __rest$1(_a, ["children", "alignment", "className", "fullscreen", "scrollable", "size"]);
  return React$1.createElement("div", __assign$1({ className: classNames$1("modal-dialog", (_b = {
    "modal-dialog-centered": alignment === "center"
  }, _b[typeof fullscreen === "boolean" ? "modal-fullscreen" : "modal-fullscreen-".concat(fullscreen, "-down")] = fullscreen, _b["modal-dialog-scrollable"] = scrollable, _b["modal-".concat(size3)] = size3, _b), className) }, rest, { ref }), children);
});
CModalDialog.propTypes = {
  alignment: PropTypes$1.oneOf(["top", "center"]),
  children: PropTypes$1.node,
  className: PropTypes$1.string,
  fullscreen: PropTypes$1.oneOfType([
    PropTypes$1.bool,
    PropTypes$1.oneOf(["sm", "md", "lg", "xl", "xxl"])
  ]),
  scrollable: PropTypes$1.bool,
  size: PropTypes$1.oneOf(["sm", "lg", "xl"])
};
CModalDialog.displayName = "CModalDialog";
var CModalContext = reactExports.createContext({});
var CModal = reactExports.forwardRef(function(_a, ref) {
  var children = _a.children, alignment = _a.alignment, _b = _a.backdrop, backdrop = _b === void 0 ? true : _b, className = _a.className, container = _a.container, _c = _a.duration, duration2 = _c === void 0 ? 150 : _c, _d = _a.focus, focus = _d === void 0 ? true : _d, fullscreen = _a.fullscreen, _e = _a.keyboard, keyboard = _e === void 0 ? true : _e, onClose = _a.onClose, onClosePrevented = _a.onClosePrevented, onShow = _a.onShow, _f = _a.portal, portal = _f === void 0 ? true : _f, scrollable = _a.scrollable, size3 = _a.size, _g = _a.transition, transition = _g === void 0 ? true : _g, _h = _a.unmountOnClose, unmountOnClose = _h === void 0 ? true : _h, visible = _a.visible, rest = __rest$1(_a, ["children", "alignment", "backdrop", "className", "container", "duration", "focus", "fullscreen", "keyboard", "onClose", "onClosePrevented", "onShow", "portal", "scrollable", "size", "transition", "unmountOnClose", "visible"]);
  var activeElementRef = reactExports.useRef(null);
  var modalRef = reactExports.useRef(null);
  var modalContentRef = reactExports.useRef(null);
  var forkedRef = useForkedRef(ref, modalRef);
  var _j = reactExports.useState(visible), _visible = _j[0], setVisible = _j[1];
  var _k = reactExports.useState(false), staticBackdrop = _k[0], setStaticBackdrop = _k[1];
  var contextValues = {
    visible: _visible,
    setVisible
  };
  reactExports.useEffect(function() {
    setVisible(visible);
  }, [visible]);
  reactExports.useEffect(function() {
    var _a2;
    if (_visible) {
      activeElementRef.current = document.activeElement;
      document.addEventListener("mouseup", handleClickOutside);
      document.addEventListener("keydown", handleKeyDown);
    } else {
      (_a2 = activeElementRef.current) === null || _a2 === void 0 ? void 0 : _a2.focus();
    }
    return function() {
      document.removeEventListener("mouseup", handleClickOutside);
      document.removeEventListener("keydown", handleKeyDown);
    };
  }, [_visible]);
  var handleDismiss = function() {
    if (backdrop === "static") {
      return setStaticBackdrop(true);
    }
    setVisible(false);
    return onClose && onClose();
  };
  reactExports.useLayoutEffect(function() {
    onClosePrevented && onClosePrevented();
    setTimeout(function() {
      return setStaticBackdrop(false);
    }, duration2);
  }, [staticBackdrop]);
  reactExports.useLayoutEffect(function() {
    if (_visible) {
      document.body.classList.add("modal-open");
      if (backdrop) {
        document.body.style.overflow = "hidden";
        document.body.style.paddingRight = "0px";
      }
      setTimeout(function() {
        var _a2;
        focus && ((_a2 = modalRef.current) === null || _a2 === void 0 ? void 0 : _a2.focus());
      }, transition ? duration2 : 0);
    } else {
      document.body.classList.remove("modal-open");
      if (backdrop) {
        document.body.style.removeProperty("overflow");
        document.body.style.removeProperty("padding-right");
      }
    }
    return function() {
      document.body.classList.remove("modal-open");
      if (backdrop) {
        document.body.style.removeProperty("overflow");
        document.body.style.removeProperty("padding-right");
      }
    };
  }, [_visible]);
  var handleClickOutside = function(event) {
    if (modalRef.current && modalRef.current == event.target) {
      handleDismiss();
    }
  };
  var handleKeyDown = function(event) {
    if (event.key === "Escape" && keyboard) {
      handleDismiss();
    }
  };
  return React$1.createElement(
    React$1.Fragment,
    null,
    React$1.createElement(Transition, { in: _visible, mountOnEnter: true, nodeRef: modalRef, onEnter: onShow, onExit: onClose, unmountOnExit: unmountOnClose, timeout: transition ? duration2 : 0 }, function(state) {
      return React$1.createElement(
        CConditionalPortal,
        { container, portal },
        React$1.createElement(
          CModalContext.Provider,
          { value: contextValues },
          React$1.createElement(
            "div",
            __assign$1({ className: classNames$1("modal", {
              "modal-static": staticBackdrop,
              fade: transition,
              show: state === "entered"
            }, className), tabIndex: -1 }, _visible ? { "aria-modal": true, role: "dialog" } : { "aria-hidden": "true" }, { style: __assign$1({}, state !== "exited" && { display: "block" }) }, rest, { ref: forkedRef }),
            React$1.createElement(
              CModalDialog,
              { alignment, fullscreen, scrollable, size: size3 },
              React$1.createElement(CModalContent, { ref: modalContentRef }, children)
            )
          )
        )
      );
    }),
    backdrop && React$1.createElement(
      CConditionalPortal,
      { container, portal },
      React$1.createElement(CBackdrop, { visible: _visible })
    )
  );
});
CModal.propTypes = {
  alignment: PropTypes$1.oneOf(["top", "center"]),
  backdrop: PropTypes$1.oneOfType([PropTypes$1.bool, PropTypes$1.oneOf(["static"])]),
  children: PropTypes$1.node,
  className: PropTypes$1.string,
  container: PropTypes$1.any,
  // HTMLElement
  duration: PropTypes$1.number,
  focus: PropTypes$1.bool,
  fullscreen: PropTypes$1.oneOfType([
    PropTypes$1.bool,
    PropTypes$1.oneOf(["sm", "md", "lg", "xl", "xxl"])
  ]),
  keyboard: PropTypes$1.bool,
  onClose: PropTypes$1.func,
  onClosePrevented: PropTypes$1.func,
  onShow: PropTypes$1.func,
  portal: PropTypes$1.bool,
  scrollable: PropTypes$1.bool,
  size: PropTypes$1.oneOf(["sm", "lg", "xl"]),
  transition: PropTypes$1.bool,
  unmountOnClose: PropTypes$1.bool,
  visible: PropTypes$1.bool
};
CModal.displayName = "CModal";
var CModalBody = reactExports.forwardRef(function(_a, ref) {
  var children = _a.children, className = _a.className, rest = __rest$1(_a, ["children", "className"]);
  return React$1.createElement("div", __assign$1({ className: classNames$1("modal-body", className) }, rest, { ref }), children);
});
CModalBody.propTypes = {
  children: PropTypes$1.node,
  className: PropTypes$1.string
};
CModalBody.displayName = "CModalBody";
var CModalFooter = reactExports.forwardRef(function(_a, ref) {
  var children = _a.children, className = _a.className, rest = __rest$1(_a, ["children", "className"]);
  return React$1.createElement("div", __assign$1({ className: classNames$1("modal-footer", className) }, rest, { ref }), children);
});
CModalFooter.propTypes = {
  children: PropTypes$1.node,
  className: PropTypes$1.string
};
CModalFooter.displayName = "CModalFooter";
var CModalHeader = reactExports.forwardRef(function(_a, ref) {
  var children = _a.children, className = _a.className, _b = _a.closeButton, closeButton = _b === void 0 ? true : _b, rest = __rest$1(_a, ["children", "className", "closeButton"]);
  var setVisible = reactExports.useContext(CModalContext).setVisible;
  return React$1.createElement(
    "div",
    __assign$1({ className: classNames$1("modal-header", className) }, rest, { ref }),
    children,
    closeButton && React$1.createElement(CCloseButton, { onClick: function() {
      return setVisible(false);
    } })
  );
});
CModalHeader.propTypes = {
  children: PropTypes$1.node,
  className: PropTypes$1.string,
  closeButton: PropTypes$1.bool
};
CModalHeader.displayName = "CModalHeader";
var CSpinner = reactExports.forwardRef(function(_a, ref) {
  var _b;
  var _c = _a.as, Component = _c === void 0 ? "div" : _c, className = _a.className, color2 = _a.color, size3 = _a.size, _d = _a.variant, variant = _d === void 0 ? "border" : _d, _e = _a.visuallyHiddenLabel, visuallyHiddenLabel = _e === void 0 ? "Loading..." : _e, rest = __rest$1(_a, ["as", "className", "color", "size", "variant", "visuallyHiddenLabel"]);
  return React$1.createElement(
    Component,
    __assign$1({ className: classNames$1("spinner-".concat(variant), (_b = {}, _b["spinner-".concat(variant, "-").concat(size3)] = size3, _b["text-".concat(color2)] = color2, _b), className), role: "status" }, rest, { ref }),
    React$1.createElement("span", { className: "visually-hidden" }, visuallyHiddenLabel)
  );
});
CSpinner.propTypes = {
  as: PropTypes$1.string,
  className: PropTypes$1.string,
  color: colorPropType,
  size: PropTypes$1.oneOf(["sm"]),
  variant: PropTypes$1.oneOf(["border", "grow"]),
  visuallyHiddenLabel: PropTypes$1.string
};
CSpinner.displayName = "CSpinner";
var getStoredTheme = function(localStorageItemName) {
  return typeof window !== "undefined" && localStorage.getItem(localStorageItemName);
};
var setStoredTheme = function(localStorageItemName, colorMode) {
  return localStorage.setItem(localStorageItemName, colorMode);
};
var getPreferredColorScheme = function(localStorageItemName) {
  if (typeof window === "undefined") {
    return "light";
  }
  var storedTheme = getStoredTheme(localStorageItemName);
  if (storedTheme) {
    return storedTheme;
  }
  return window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
};
var setTheme = function(colorMode) {
  document.documentElement.dataset.coreuiTheme = colorMode === "auto" && window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : colorMode;
  var event = new Event("ColorSchemeChange");
  document.documentElement.dispatchEvent(event);
};
var useColorModes = function(localStorageItemName) {
  var _a = reactExports.useState(getPreferredColorScheme(localStorageItemName)), colorMode = _a[0], setColorMode = _a[1];
  reactExports.useEffect(function() {
    if (colorMode) {
      setStoredTheme(localStorageItemName, colorMode);
      setTheme(colorMode);
    }
  }, [colorMode]);
  reactExports.useEffect(function() {
    window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change", function() {
      var storedTheme = getStoredTheme(localStorageItemName);
      if (storedTheme !== "light" && storedTheme !== "dark" && colorMode) {
        setTheme(colorMode);
      }
    });
  });
  return {
    colorMode,
    isColorModeSet: function() {
      return Boolean(getStoredTheme(localStorageItemName));
    },
    setColorMode
  };
};
const AuthContext = reactExports.createContext();
let showGlobalLogin;
let showGlobalLoginVar;
const useAuth = () => {
  return reactExports.useContext(AuthContext);
};
const AuthProvider = ({ children }) => {
  const [authData, setAuthData] = reactExports.useState(null);
  const [showAuthModal, setShowAuthModal] = reactExports.useState(false);
  showGlobalLogin = setShowAuthModal;
  showGlobalLoginVar = showAuthModal;
  console.log(showAuthModal, "in this");
  const login = (userData) => {
    setAuthData(userData);
    localStorage.setItem("authData", JSON.stringify(userData));
  };
  const logout = () => {
    setAuthData(null);
    localStorage.removeItem("authData");
  };
  const isAuthenticated = !!authData;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(AuthContext.Provider, { value: { authData, isAuthenticated, showAuthModal, login, logout }, children });
};
function bind2(fn, thisArg) {
  return function wrap2() {
    return fn.apply(thisArg, arguments);
  };
}
const { toString: toString6 } = Object.prototype;
const { getPrototypeOf: getPrototypeOf3 } = Object;
const kindOf = /* @__PURE__ */ ((cache) => (thing) => {
  const str = toString6.call(thing);
  return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
const kindOfTest = (type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type;
};
const typeOfTest = (type) => (thing) => typeof thing === type;
const { isArray: isArray2 } = Array;
const isUndefined = typeOfTest("undefined");
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
const isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
const isString = typeOfTest("string");
const isFunction = typeOfTest("function");
const isNumber = typeOfTest("number");
const isObject = (thing) => thing !== null && typeof thing === "object";
const isBoolean = (thing) => thing === true || thing === false;
const isPlainObject$1 = (val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype2 = getPrototypeOf3(val);
  return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};
const isDate = kindOfTest("Date");
const isFile = kindOfTest("File");
const isBlob = kindOfTest("Blob");
const isFileList = kindOfTest("FileList");
const isStream = (val) => isObject(val) && isFunction(val.pipe);
const isFormData = (thing) => {
  let kind;
  return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
  kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
};
const isURLSearchParams = kindOfTest("URLSearchParams");
const [isReadableStream, isRequest, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest);
const trim2 = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach6(obj, fn, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i;
  let l2;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray2(obj)) {
    for (i = 0, l2 = obj.length; i < l2; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    const keys6 = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys6.length;
    let key;
    for (i = 0; i < len; i++) {
      key = keys6[i];
      fn.call(null, obj[key], key, obj);
    }
  }
}
function findKey2(obj, key) {
  key = key.toLowerCase();
  const keys6 = Object.keys(obj);
  let i = keys6.length;
  let _key;
  while (i-- > 0) {
    _key = keys6[i];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
const _global = (() => {
  if (typeof globalThis !== "undefined") return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
const isContextDefined = (context) => !isUndefined(context) && context !== _global;
function merge2() {
  const { caseless } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey2(result, key) || key;
    if (isPlainObject$1(result[targetKey]) && isPlainObject$1(val)) {
      result[targetKey] = merge2(result[targetKey], val);
    } else if (isPlainObject$1(val)) {
      result[targetKey] = merge2({}, val);
    } else if (isArray2(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };
  for (let i = 0, l2 = arguments.length; i < l2; i++) {
    arguments[i] && forEach6(arguments[i], assignValue);
  }
  return result;
}
const extend = (a, b2, thisArg, { allOwnKeys } = {}) => {
  forEach6(b2, (val, key) => {
    if (thisArg && isFunction(val)) {
      a[key] = bind2(val, thisArg);
    } else {
      a[key] = val;
    }
  }, { allOwnKeys });
  return a;
};
const stripBOM = (content) => {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
};
const inherits = (constructor, superConstructor, props, descriptors2) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};
const toFlatObject = (sourceObj, destObj, filter8, propFilter) => {
  let props;
  let i;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null) return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter8 !== false && getPrototypeOf3(sourceObj);
  } while (sourceObj && (!filter8 || filter8(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
const endsWith2 = (str, searchString, position2) => {
  str = String(str);
  if (position2 === void 0 || position2 > str.length) {
    position2 = str.length;
  }
  position2 -= searchString.length;
  const lastIndex = str.indexOf(searchString, position2);
  return lastIndex !== -1 && lastIndex === position2;
};
const toArray3 = (thing) => {
  if (!thing) return null;
  if (isArray2(thing)) return thing;
  let i = thing.length;
  if (!isNumber(i)) return null;
  const arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
};
const isTypedArray = /* @__PURE__ */ ((TypedArray2) => {
  return (thing) => {
    return TypedArray2 && thing instanceof TypedArray2;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf3(Uint8Array));
const forEachEntry = (obj, fn) => {
  const generator = obj && obj[Symbol.iterator];
  const iterator = generator.call(obj);
  let result;
  while ((result = iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
};
const matchAll2 = (regExp, str) => {
  let matches;
  const arr = [];
  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }
  return arr;
};
const isHTMLForm = kindOfTest("HTMLFormElement");
const toCamelCase$1 = (str) => {
  return str.toLowerCase().replace(
    /[-_\s]([a-z\d])(\w*)/g,
    function replacer2(m2, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};
const hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
const isRegExp = kindOfTest("RegExp");
const reduceDescriptors = (obj, reducer) => {
  const descriptors2 = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach6(descriptors2, (descriptor, name) => {
    let ret;
    if ((ret = reducer(descriptor, name, obj)) !== false) {
      reducedDescriptors[name] = ret || descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};
const freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
      return false;
    }
    const value = obj[name];
    if (!isFunction(value)) return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name + "'");
      };
    }
  });
};
const toObjectSet = (arrayOrString, delimiter2) => {
  const obj = {};
  const define = (arr) => {
    arr.forEach((value) => {
      obj[value] = true;
    });
  };
  isArray2(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter2));
  return obj;
};
const noop = () => {
};
const toFiniteNumber = (value, defaultValue) => {
  return value != null && Number.isFinite(value = +value) ? value : defaultValue;
};
const ALPHA = "abcdefghijklmnopqrstuvwxyz";
const DIGIT = "0123456789";
const ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};
const generateString = (size3 = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
  let str = "";
  const { length: length2 } = alphabet;
  while (size3--) {
    str += alphabet[Math.random() * length2 | 0];
  }
  return str;
};
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
}
const toJSONObject = (obj) => {
  const stack = new Array(10);
  const visit = (source, i) => {
    if (isObject(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (!("toJSON" in source)) {
        stack[i] = source;
        const target = isArray2(source) ? [] : {};
        forEach6(source, (value, key) => {
          const reducedValue = visit(value, i + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });
        stack[i] = void 0;
        return target;
      }
    }
    return source;
  };
  return visit(obj, 0);
};
const isAsyncFn = kindOfTest("AsyncFunction");
const isThenable = (thing) => thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
const _setImmediate = ((setImmediateSupported, postMessageSupported) => {
  if (setImmediateSupported) {
    return setImmediate;
  }
  return postMessageSupported ? ((token2, callbacks) => {
    _global.addEventListener("message", ({ source, data: data2 }) => {
      if (source === _global && data2 === token2) {
        callbacks.length && callbacks.shift()();
      }
    }, false);
    return (cb2) => {
      callbacks.push(cb2);
      _global.postMessage(token2, "*");
    };
  })(`axios@${Math.random()}`, []) : (cb2) => setTimeout(cb2);
})(
  typeof setImmediate === "function",
  isFunction(_global.postMessage)
);
const asap = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global) : typeof process !== "undefined" && process.nextTick || _setImmediate;
const utils$1 = {
  isArray: isArray2,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject,
  isPlainObject: isPlainObject$1,
  isReadableStream,
  isRequest,
  isResponse,
  isHeaders,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach: forEach6,
  merge: merge2,
  extend,
  trim: trim2,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith: endsWith2,
  toArray: toArray3,
  forEachEntry,
  matchAll: matchAll2,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase: toCamelCase$1,
  noop,
  toFiniteNumber,
  findKey: findKey2,
  global: _global,
  isContextDefined,
  ALPHABET,
  generateString,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable,
  setImmediate: _setImmediate,
  asap
};
function AxiosError(message, code, config2, request, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = "AxiosError";
  code && (this.code = code);
  config2 && (this.config = config2);
  request && (this.request = request);
  if (response) {
    this.response = response;
    this.status = response.status ? response.status : null;
  }
}
utils$1.inherits(AxiosError, Error, {
  toJSON: function toJSON4() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils$1.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
const prototype$1 = AxiosError.prototype;
const descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((code) => {
  descriptors[code] = { value: code };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype$1, "isAxiosError", { value: true });
AxiosError.from = (error2, code, config2, request, response, customProps) => {
  const axiosError = Object.create(prototype$1);
  utils$1.toFlatObject(error2, axiosError, function filter8(obj) {
    return obj !== Error.prototype;
  }, (prop) => {
    return prop !== "isAxiosError";
  });
  AxiosError.call(axiosError, error2.message, code, config2, request, response);
  axiosError.cause = error2;
  axiosError.name = error2.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
const httpAdapter = null;
function isVisitable(thing) {
  return utils$1.isPlainObject(thing) || utils$1.isArray(thing);
}
function removeBrackets(key) {
  return utils$1.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
function renderKey(path2, key, dots) {
  if (!path2) return key;
  return path2.concat(key).map(function each(token2, i) {
    token2 = removeBrackets(token2);
    return !dots && i ? "[" + token2 + "]" : token2;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils$1.isArray(arr) && !arr.some(isVisitable);
}
const predicates = utils$1.toFlatObject(utils$1, {}, null, function filter7(prop) {
  return /^is[A-Z]/.test(prop);
});
function toFormData(obj, formData, options) {
  if (!utils$1.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new FormData();
  options = utils$1.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    return !utils$1.isUndefined(source[option]);
  });
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils$1.isSpecCompliantForm(formData);
  if (!utils$1.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value) {
    if (value === null) return "";
    if (utils$1.isDate(value)) {
      return value.toISOString();
    }
    if (!useBlob && utils$1.isBlob(value)) {
      throw new AxiosError("Blob is not supported. Use a Buffer instead.");
    }
    if (utils$1.isArrayBuffer(value) || utils$1.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }
  function defaultVisitor(value, key, path2) {
    let arr = value;
    if (value && !path2 && typeof value === "object") {
      if (utils$1.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value = JSON.stringify(value);
      } else if (utils$1.isArray(value) && isFlatArray(value) || (utils$1.isFileList(value) || utils$1.endsWith(key, "[]")) && (arr = utils$1.toArray(value))) {
        key = removeBrackets(key);
        arr.forEach(function each(el2, index) {
          !(utils$1.isUndefined(el2) || el2 === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]",
            convertValue(el2)
          );
        });
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path2, key, dots), convertValue(value));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value, path2) {
    if (utils$1.isUndefined(value)) return;
    if (stack.indexOf(value) !== -1) {
      throw Error("Circular reference detected in " + path2.join("."));
    }
    stack.push(value);
    utils$1.forEach(value, function each(el2, key) {
      const result = !(utils$1.isUndefined(el2) || el2 === null) && visitor.call(
        formData,
        el2,
        utils$1.isString(key) ? key.trim() : key,
        path2,
        exposedHelpers
      );
      if (result === true) {
        build(el2, path2 ? path2.concat(key) : [key]);
      }
    });
    stack.pop();
  }
  if (!utils$1.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build(obj);
  return formData;
}
function encode$1(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer2(match2) {
    return charMap[match2];
  });
}
function AxiosURLSearchParams(params2, options) {
  this._pairs = [];
  params2 && toFormData(params2, this, options);
}
const prototype = AxiosURLSearchParams.prototype;
prototype.append = function append3(name, value) {
  this._pairs.push([name, value]);
};
prototype.toString = function toString7(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode$1);
  } : encode$1;
  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "").join("&");
};
function encode(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(url, params2, options) {
  if (!params2) {
    return url;
  }
  const _encode = options && options.encode || encode;
  if (utils$1.isFunction(options)) {
    options = {
      serialize: options
    };
  }
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params2, options);
  } else {
    serializedParams = utils$1.isURLSearchParams(params2) ? params2.toString() : new AxiosURLSearchParams(params2, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
}
class InterceptorManager {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id2) {
    if (this.handlers[id2]) {
      this.handlers[id2] = null;
    }
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    utils$1.forEach(this.handlers, function forEachHandler(h2) {
      if (h2 !== null) {
        fn(h2);
      }
    });
  }
}
const transitionalDefaults = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};
const URLSearchParams$1 = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams;
const FormData$1 = typeof FormData !== "undefined" ? FormData : null;
const Blob$1 = typeof Blob !== "undefined" ? Blob : null;
const platform$1 = {
  isBrowser: true,
  classes: {
    URLSearchParams: URLSearchParams$1,
    FormData: FormData$1,
    Blob: Blob$1
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
};
const hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
const _navigator = typeof navigator === "object" && navigator || void 0;
const hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ["ReactNative", "NativeScript", "NS"].indexOf(_navigator.product) < 0);
const hasStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
  self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();
const origin = hasBrowserEnv && window.location.href || "http://localhost";
const utils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv,
  hasStandardBrowserEnv,
  hasStandardBrowserWebWorkerEnv,
  navigator: _navigator,
  origin
}, Symbol.toStringTag, { value: "Module" }));
const platform = {
  ...utils,
  ...platform$1
};
function toURLEncodedForm(data2, options) {
  return toFormData(data2, new platform.classes.URLSearchParams(), Object.assign({
    visitor: function(value, key, path2, helpers) {
      if (platform.isNode && utils$1.isBuffer(value)) {
        this.append(key, value.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}
function parsePropPath(name) {
  return utils$1.matchAll(/\w+|\[(\w*)]/g, name).map((match2) => {
    return match2[0] === "[]" ? "" : match2[1] || match2[0];
  });
}
function arrayToObject(arr) {
  const obj = {};
  const keys6 = Object.keys(arr);
  let i;
  const len = keys6.length;
  let key;
  for (i = 0; i < len; i++) {
    key = keys6[i];
    obj[key] = arr[key];
  }
  return obj;
}
function formDataToJSON(formData) {
  function buildPath(path2, value, target, index) {
    let name = path2[index++];
    if (name === "__proto__") return true;
    const isNumericKey = Number.isFinite(+name);
    const isLast = index >= path2.length;
    name = !name && utils$1.isArray(target) ? target.length : name;
    if (isLast) {
      if (utils$1.hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }
      return !isNumericKey;
    }
    if (!target[name] || !utils$1.isObject(target[name])) {
      target[name] = [];
    }
    const result = buildPath(path2, value, target[name], index);
    if (result && utils$1.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }
    return !isNumericKey;
  }
  if (utils$1.isFormData(formData) && utils$1.isFunction(formData.entries)) {
    const obj = {};
    utils$1.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });
    return obj;
  }
  return null;
}
function stringifySafely(rawValue, parser, encoder) {
  if (utils$1.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils$1.trim(rawValue);
    } catch (e2) {
      if (e2.name !== "SyntaxError") {
        throw e2;
      }
    }
  }
  return (0, JSON.stringify)(rawValue);
}
const defaults = {
  transitional: transitionalDefaults,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function transformRequest(data2, headers) {
    const contentType = headers.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils$1.isObject(data2);
    if (isObjectPayload && utils$1.isHTMLForm(data2)) {
      data2 = new FormData(data2);
    }
    const isFormData2 = utils$1.isFormData(data2);
    if (isFormData2) {
      return hasJSONContentType ? JSON.stringify(formDataToJSON(data2)) : data2;
    }
    if (utils$1.isArrayBuffer(data2) || utils$1.isBuffer(data2) || utils$1.isStream(data2) || utils$1.isFile(data2) || utils$1.isBlob(data2) || utils$1.isReadableStream(data2)) {
      return data2;
    }
    if (utils$1.isArrayBufferView(data2)) {
      return data2.buffer;
    }
    if (utils$1.isURLSearchParams(data2)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data2.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data2, this.formSerializer).toString();
      }
      if ((isFileList2 = utils$1.isFileList(data2)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData(
          isFileList2 ? { "files[]": data2 } : data2,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely(data2);
    }
    return data2;
  }],
  transformResponse: [function transformResponse(data2) {
    const transitional2 = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (utils$1.isResponse(data2) || utils$1.isReadableStream(data2)) {
      return data2;
    }
    if (data2 && utils$1.isString(data2) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data2);
      } catch (e2) {
        if (strictJSONParsing) {
          if (e2.name === "SyntaxError") {
            throw AxiosError.from(e2, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e2;
        }
      }
    }
    return data2;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform.classes.FormData,
    Blob: platform.classes.Blob
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
utils$1.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
  defaults.headers[method] = {};
});
const ignoreDuplicateOf = utils$1.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
const parseHeaders = (rawHeaders) => {
  const parsed = {};
  let key;
  let val;
  let i;
  rawHeaders && rawHeaders.split("\n").forEach(function parser(line2) {
    i = line2.indexOf(":");
    key = line2.substring(0, i).trim().toLowerCase();
    val = line2.substring(i + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === "set-cookie") {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    }
  });
  return parsed;
};
const $internals = Symbol("internals");
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils$1.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
  const tokens = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match2;
  while (match2 = tokensRE.exec(str)) {
    tokens[match2[1]] = match2[2];
  }
  return tokens;
}
const isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
function matchHeaderValue(context, value, header, filter8, isHeaderNameFilter) {
  if (utils$1.isFunction(filter8)) {
    return filter8.call(this, value, header);
  }
  if (isHeaderNameFilter) {
    value = header;
  }
  if (!utils$1.isString(value)) return;
  if (utils$1.isString(filter8)) {
    return value.indexOf(filter8) !== -1;
  }
  if (utils$1.isRegExp(filter8)) {
    return filter8.test(value);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w2, char2, str) => {
    return char2.toUpperCase() + str;
  });
}
function buildAccessors(obj, header) {
  const accessorName = utils$1.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
class AxiosHeaders {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key = utils$1.findKey(self2, lHeader);
      if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
        self2[key || _header] = normalizeValue(_value);
      }
    }
    const setHeaders = (headers, _rewrite) => utils$1.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
    if (utils$1.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils$1.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders(header), valueOrRewrite);
    } else if (utils$1.isHeaders(header)) {
      for (const [key, value] of header.entries()) {
        setHeader(value, key, rewrite);
      }
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils$1.findKey(this, header);
      if (key) {
        const value = this[key];
        if (!parser) {
          return value;
        }
        if (parser === true) {
          return parseTokens(value);
        }
        if (utils$1.isFunction(parser)) {
          return parser.call(this, value, key);
        }
        if (utils$1.isRegExp(parser)) {
          return parser.exec(value);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils$1.findKey(this, header);
      return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }
    return false;
  }
  delete(header, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key = utils$1.findKey(self2, _header);
        if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
          delete self2[key];
          deleted = true;
        }
      }
    }
    if (utils$1.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear(matcher) {
    const keys6 = Object.keys(this);
    let i = keys6.length;
    let deleted = false;
    while (i--) {
      const key = keys6[i];
      if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format) {
    const self2 = this;
    const headers = {};
    utils$1.forEach(this, (value, header) => {
      const key = utils$1.findKey(headers, header);
      if (key) {
        self2[key] = normalizeValue(value);
        delete self2[header];
        return;
      }
      const normalized = format ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue(value);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = /* @__PURE__ */ Object.create(null);
    utils$1.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils$1.isArray(value) ? value.join(", ") : value);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first, ...targets) {
    const computed = new this(first);
    targets.forEach((target) => computed.set(target));
    return computed;
  }
  static accessor(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype2 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype2, _header);
        accessors[lHeader] = true;
      }
    }
    utils$1.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
}
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils$1.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1);
  return {
    get: () => value,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  };
});
utils$1.freezeMethods(AxiosHeaders);
function transformData(fns, response) {
  const config2 = this || defaults;
  const context = response || config2;
  const headers = AxiosHeaders.from(context.headers);
  let data2 = context.data;
  utils$1.forEach(fns, function transform(fn) {
    data2 = fn.call(config2, data2, headers.normalize(), response ? response.status : void 0);
  });
  headers.normalize();
  return data2;
}
function isCancel(value) {
  return !!(value && value.__CANCEL__);
}
function CanceledError(message, config2, request) {
  AxiosError.call(this, message == null ? "canceled" : message, AxiosError.ERR_CANCELED, config2, request);
  this.name = "CanceledError";
}
utils$1.inherits(CanceledError, AxiosError, {
  __CANCEL__: true
});
function settle(resolve2, reject2, response) {
  const validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve2(response);
  } else {
    reject2(new AxiosError(
      "Request failed with status code " + response.status,
      [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}
function parseProtocol(url) {
  const match2 = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match2 && match2[1] || "";
}
function speedometer(samplesCount, min2) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min2 = min2 !== void 0 ? min2 : 1e3;
  return function push3(chunkLength) {
    const now2 = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now2;
    }
    bytes[head] = chunkLength;
    timestamps[head] = now2;
    let i = tail;
    let bytesCount = 0;
    while (i !== head) {
      bytesCount += bytes[i++];
      i = i % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now2 - firstSampleTS < min2) {
      return;
    }
    const passed = startedAt && now2 - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  };
}
function throttle(fn, freq) {
  let timestamp = 0;
  let threshold = 1e3 / freq;
  let lastArgs;
  let timer;
  const invoke = (args, now2 = Date.now()) => {
    timestamp = now2;
    lastArgs = null;
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
    fn.apply(null, args);
  };
  const throttled = (...args) => {
    const now2 = Date.now();
    const passed = now2 - timestamp;
    if (passed >= threshold) {
      invoke(args, now2);
    } else {
      lastArgs = args;
      if (!timer) {
        timer = setTimeout(() => {
          timer = null;
          invoke(lastArgs);
        }, threshold - passed);
      }
    }
  };
  const flush = () => lastArgs && invoke(lastArgs);
  return [throttled, flush];
}
const progressEventReducer = (listener, isDownloadStream, freq = 3) => {
  let bytesNotified = 0;
  const _speedometer = speedometer(50, 250);
  return throttle((e2) => {
    const loaded = e2.loaded;
    const total = e2.lengthComputable ? e2.total : void 0;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;
    bytesNotified = loaded;
    const data2 = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
      event: e2,
      lengthComputable: total != null,
      [isDownloadStream ? "download" : "upload"]: true
    };
    listener(data2);
  }, freq);
};
const progressEventDecorator = (total, throttled) => {
  const lengthComputable = total != null;
  return [(loaded) => throttled[0]({
    lengthComputable,
    total,
    loaded
  }), throttled[1]];
};
const asyncDecorator = (fn) => (...args) => utils$1.asap(() => fn(...args));
const isURLSameOrigin = platform.hasStandardBrowserEnv ? /* @__PURE__ */ ((origin2, isMSIE) => (url) => {
  url = new URL(url, platform.origin);
  return origin2.protocol === url.protocol && origin2.host === url.host && (isMSIE || origin2.port === url.port);
})(
  new URL(platform.origin),
  platform.navigator && /(msie|trident)/i.test(platform.navigator.userAgent)
) : () => true;
const cookies = platform.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(name, value, expires, path2, domain, secure) {
      const cookie = [name + "=" + encodeURIComponent(value)];
      utils$1.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
      utils$1.isString(path2) && cookie.push("path=" + path2);
      utils$1.isString(domain) && cookie.push("domain=" + domain);
      secure === true && cookie.push("secure");
      document.cookie = cookie.join("; ");
    },
    read(name) {
      const match2 = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
      return match2 ? decodeURIComponent(match2[3]) : null;
    },
    remove(name) {
      this.write(name, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function isAbsoluteURL(url) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}
function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}
const headersToObject = (thing) => thing instanceof AxiosHeaders ? { ...thing } : thing;
function mergeConfig(config1, config2) {
  config2 = config2 || {};
  const config3 = {};
  function getMergedValue(target, source, prop, caseless) {
    if (utils$1.isPlainObject(target) && utils$1.isPlainObject(source)) {
      return utils$1.merge.call({ caseless }, target, source);
    } else if (utils$1.isPlainObject(source)) {
      return utils$1.merge({}, source);
    } else if (utils$1.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(a, b2, prop, caseless) {
    if (!utils$1.isUndefined(b2)) {
      return getMergedValue(a, b2, prop, caseless);
    } else if (!utils$1.isUndefined(a)) {
      return getMergedValue(void 0, a, prop, caseless);
    }
  }
  function valueFromConfig2(a, b2) {
    if (!utils$1.isUndefined(b2)) {
      return getMergedValue(void 0, b2);
    }
  }
  function defaultToConfig2(a, b2) {
    if (!utils$1.isUndefined(b2)) {
      return getMergedValue(void 0, b2);
    } else if (!utils$1.isUndefined(a)) {
      return getMergedValue(void 0, a);
    }
  }
  function mergeDirectKeys(a, b2, prop) {
    if (prop in config2) {
      return getMergedValue(a, b2);
    } else if (prop in config1) {
      return getMergedValue(void 0, a);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a, b2, prop) => mergeDeepProperties(headersToObject(a), headersToObject(b2), prop, true)
  };
  utils$1.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
    const merge3 = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge3(config1[prop], config2[prop], prop);
    utils$1.isUndefined(configValue) && merge3 !== mergeDirectKeys || (config3[prop] = configValue);
  });
  return config3;
}
const resolveConfig = (config2) => {
  const newConfig = mergeConfig({}, config2);
  let { data: data2, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
  newConfig.headers = headers = AxiosHeaders.from(headers);
  newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url), config2.params, config2.paramsSerializer);
  if (auth) {
    headers.set(
      "Authorization",
      "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : ""))
    );
  }
  let contentType;
  if (utils$1.isFormData(data2)) {
    if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
      headers.setContentType(void 0);
    } else if ((contentType = headers.getContentType()) !== false) {
      const [type, ...tokens] = contentType ? contentType.split(";").map((token2) => token2.trim()).filter(Boolean) : [];
      headers.setContentType([type || "multipart/form-data", ...tokens].join("; "));
    }
  }
  if (platform.hasStandardBrowserEnv) {
    withXSRFToken && utils$1.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
    if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin(newConfig.url)) {
      const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName);
      if (xsrfValue) {
        headers.set(xsrfHeaderName, xsrfValue);
      }
    }
  }
  return newConfig;
};
const isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
const xhrAdapter = isXHRAdapterSupported && function(config2) {
  return new Promise(function dispatchXhrRequest(resolve2, reject2) {
    const _config = resolveConfig(config2);
    let requestData = _config.data;
    const requestHeaders = AxiosHeaders.from(_config.headers).normalize();
    let { responseType, onUploadProgress, onDownloadProgress } = _config;
    let onCanceled;
    let uploadThrottled, downloadThrottled;
    let flushUpload, flushDownload;
    function done() {
      flushUpload && flushUpload();
      flushDownload && flushDownload();
      _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
      _config.signal && _config.signal.removeEventListener("abort", onCanceled);
    }
    let request = new XMLHttpRequest();
    request.open(_config.method.toUpperCase(), _config.url, true);
    request.timeout = _config.timeout;
    function onloadend() {
      if (!request) {
        return;
      }
      const responseHeaders = AxiosHeaders.from(
        "getAllResponseHeaders" in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config2,
        request
      };
      settle(function _resolve(value) {
        resolve2(value);
        done();
      }, function _reject(err) {
        reject2(err);
        done();
      }, response);
      request = null;
    }
    if ("onloadend" in request) {
      request.onloadend = onloadend;
    } else {
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }
      reject2(new AxiosError("Request aborted", AxiosError.ECONNABORTED, config2, request));
      request = null;
    };
    request.onerror = function handleError() {
      reject2(new AxiosError("Network Error", AxiosError.ERR_NETWORK, config2, request));
      request = null;
    };
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
      const transitional2 = _config.transitional || transitionalDefaults;
      if (_config.timeoutErrorMessage) {
        timeoutErrorMessage = _config.timeoutErrorMessage;
      }
      reject2(new AxiosError(
        timeoutErrorMessage,
        transitional2.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
        config2,
        request
      ));
      request = null;
    };
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request) {
      utils$1.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }
    if (!utils$1.isUndefined(_config.withCredentials)) {
      request.withCredentials = !!_config.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request.responseType = _config.responseType;
    }
    if (onDownloadProgress) {
      [downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
      request.addEventListener("progress", downloadThrottled);
    }
    if (onUploadProgress && request.upload) {
      [uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
      request.upload.addEventListener("progress", uploadThrottled);
      request.upload.addEventListener("loadend", flushUpload);
    }
    if (_config.cancelToken || _config.signal) {
      onCanceled = (cancel) => {
        if (!request) {
          return;
        }
        reject2(!cancel || cancel.type ? new CanceledError(null, config2, request) : cancel);
        request.abort();
        request = null;
      };
      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
      if (_config.signal) {
        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol = parseProtocol(_config.url);
    if (protocol && platform.protocols.indexOf(protocol) === -1) {
      reject2(new AxiosError("Unsupported protocol " + protocol + ":", AxiosError.ERR_BAD_REQUEST, config2));
      return;
    }
    request.send(requestData || null);
  });
};
const composeSignals = (signals, timeout) => {
  const { length: length2 } = signals = signals ? signals.filter(Boolean) : [];
  if (timeout || length2) {
    let controller = new AbortController();
    let aborted;
    const onabort = function(reason) {
      if (!aborted) {
        aborted = true;
        unsubscribe2();
        const err = reason instanceof Error ? reason : this.reason;
        controller.abort(err instanceof AxiosError ? err : new CanceledError(err instanceof Error ? err.message : err));
      }
    };
    let timer = timeout && setTimeout(() => {
      timer = null;
      onabort(new AxiosError(`timeout ${timeout} of ms exceeded`, AxiosError.ETIMEDOUT));
    }, timeout);
    const unsubscribe2 = () => {
      if (signals) {
        timer && clearTimeout(timer);
        timer = null;
        signals.forEach((signal2) => {
          signal2.unsubscribe ? signal2.unsubscribe(onabort) : signal2.removeEventListener("abort", onabort);
        });
        signals = null;
      }
    };
    signals.forEach((signal2) => signal2.addEventListener("abort", onabort));
    const { signal } = controller;
    signal.unsubscribe = () => utils$1.asap(unsubscribe2);
    return signal;
  }
};
const streamChunk = function* (chunk, chunkSize) {
  let len = chunk.byteLength;
  if (len < chunkSize) {
    yield chunk;
    return;
  }
  let pos = 0;
  let end;
  while (pos < len) {
    end = pos + chunkSize;
    yield chunk.slice(pos, end);
    pos = end;
  }
};
const readBytes = async function* (iterable, chunkSize) {
  for await (const chunk of readStream(iterable)) {
    yield* streamChunk(chunk, chunkSize);
  }
};
const readStream = async function* (stream) {
  if (stream[Symbol.asyncIterator]) {
    yield* stream;
    return;
  }
  const reader = stream.getReader();
  try {
    for (; ; ) {
      const { done, value } = await reader.read();
      if (done) {
        break;
      }
      yield value;
    }
  } finally {
    await reader.cancel();
  }
};
const trackStream = (stream, chunkSize, onProgress, onFinish) => {
  const iterator = readBytes(stream, chunkSize);
  let bytes = 0;
  let done;
  let _onFinish = (e2) => {
    if (!done) {
      done = true;
      onFinish && onFinish(e2);
    }
  };
  return new ReadableStream({
    async pull(controller) {
      try {
        const { done: done2, value } = await iterator.next();
        if (done2) {
          _onFinish();
          controller.close();
          return;
        }
        let len = value.byteLength;
        if (onProgress) {
          let loadedBytes = bytes += len;
          onProgress(loadedBytes);
        }
        controller.enqueue(new Uint8Array(value));
      } catch (err) {
        _onFinish(err);
        throw err;
      }
    },
    cancel(reason) {
      _onFinish(reason);
      return iterator.return();
    }
  }, {
    highWaterMark: 2
  });
};
const isFetchSupported = typeof fetch === "function" && typeof Request === "function" && typeof Response === "function";
const isReadableStreamSupported = isFetchSupported && typeof ReadableStream === "function";
const encodeText = isFetchSupported && (typeof TextEncoder === "function" ? /* @__PURE__ */ ((encoder) => (str) => encoder.encode(str))(new TextEncoder()) : async (str) => new Uint8Array(await new Response(str).arrayBuffer()));
const test = (fn, ...args) => {
  try {
    return !!fn(...args);
  } catch (e2) {
    return false;
  }
};
const supportsRequestStream = isReadableStreamSupported && test(() => {
  let duplexAccessed = false;
  const hasContentType = new Request(platform.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      duplexAccessed = true;
      return "half";
    }
  }).headers.has("Content-Type");
  return duplexAccessed && !hasContentType;
});
const DEFAULT_CHUNK_SIZE = 64 * 1024;
const supportsResponseStream = isReadableStreamSupported && test(() => utils$1.isReadableStream(new Response("").body));
const resolvers = {
  stream: supportsResponseStream && ((res) => res.body)
};
isFetchSupported && ((res) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type) => {
    !resolvers[type] && (resolvers[type] = utils$1.isFunction(res[type]) ? (res2) => res2[type]() : (_, config2) => {
      throw new AxiosError(`Response type '${type}' is not supported`, AxiosError.ERR_NOT_SUPPORT, config2);
    });
  });
})(new Response());
const getBodyLength = async (body) => {
  if (body == null) {
    return 0;
  }
  if (utils$1.isBlob(body)) {
    return body.size;
  }
  if (utils$1.isSpecCompliantForm(body)) {
    const _request = new Request(platform.origin, {
      method: "POST",
      body
    });
    return (await _request.arrayBuffer()).byteLength;
  }
  if (utils$1.isArrayBufferView(body) || utils$1.isArrayBuffer(body)) {
    return body.byteLength;
  }
  if (utils$1.isURLSearchParams(body)) {
    body = body + "";
  }
  if (utils$1.isString(body)) {
    return (await encodeText(body)).byteLength;
  }
};
const resolveBodyLength = async (headers, body) => {
  const length2 = utils$1.toFiniteNumber(headers.getContentLength());
  return length2 == null ? getBodyLength(body) : length2;
};
const fetchAdapter = isFetchSupported && (async (config2) => {
  let {
    url,
    method,
    data: data2,
    signal,
    cancelToken,
    timeout,
    onDownloadProgress,
    onUploadProgress,
    responseType,
    headers,
    withCredentials = "same-origin",
    fetchOptions
  } = resolveConfig(config2);
  responseType = responseType ? (responseType + "").toLowerCase() : "text";
  let composedSignal = composeSignals([signal, cancelToken && cancelToken.toAbortSignal()], timeout);
  let request;
  const unsubscribe2 = composedSignal && composedSignal.unsubscribe && (() => {
    composedSignal.unsubscribe();
  });
  let requestContentLength;
  try {
    if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength(headers, data2)) !== 0) {
      let _request = new Request(url, {
        method: "POST",
        body: data2,
        duplex: "half"
      });
      let contentTypeHeader;
      if (utils$1.isFormData(data2) && (contentTypeHeader = _request.headers.get("content-type"))) {
        headers.setContentType(contentTypeHeader);
      }
      if (_request.body) {
        const [onProgress, flush] = progressEventDecorator(
          requestContentLength,
          progressEventReducer(asyncDecorator(onUploadProgress))
        );
        data2 = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
      }
    }
    if (!utils$1.isString(withCredentials)) {
      withCredentials = withCredentials ? "include" : "omit";
    }
    const isCredentialsSupported = "credentials" in Request.prototype;
    request = new Request(url, {
      ...fetchOptions,
      signal: composedSignal,
      method: method.toUpperCase(),
      headers: headers.normalize().toJSON(),
      body: data2,
      duplex: "half",
      credentials: isCredentialsSupported ? withCredentials : void 0
    });
    let response = await fetch(request);
    const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
    if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe2)) {
      const options = {};
      ["status", "statusText", "headers"].forEach((prop) => {
        options[prop] = response[prop];
      });
      const responseContentLength = utils$1.toFiniteNumber(response.headers.get("content-length"));
      const [onProgress, flush] = onDownloadProgress && progressEventDecorator(
        responseContentLength,
        progressEventReducer(asyncDecorator(onDownloadProgress), true)
      ) || [];
      response = new Response(
        trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
          flush && flush();
          unsubscribe2 && unsubscribe2();
        }),
        options
      );
    }
    responseType = responseType || "text";
    let responseData = await resolvers[utils$1.findKey(resolvers, responseType) || "text"](response, config2);
    !isStreamResponse && unsubscribe2 && unsubscribe2();
    return await new Promise((resolve2, reject2) => {
      settle(resolve2, reject2, {
        data: responseData,
        headers: AxiosHeaders.from(response.headers),
        status: response.status,
        statusText: response.statusText,
        config: config2,
        request
      });
    });
  } catch (err) {
    unsubscribe2 && unsubscribe2();
    if (err && err.name === "TypeError" && /fetch/i.test(err.message)) {
      throw Object.assign(
        new AxiosError("Network Error", AxiosError.ERR_NETWORK, config2, request),
        {
          cause: err.cause || err
        }
      );
    }
    throw AxiosError.from(err, err && err.code, config2, request);
  }
});
const knownAdapters = {
  http: httpAdapter,
  xhr: xhrAdapter,
  fetch: fetchAdapter
};
utils$1.forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, "name", { value });
    } catch (e2) {
    }
    Object.defineProperty(fn, "adapterName", { value });
  }
});
const renderReason = (reason) => `- ${reason}`;
const isResolvedHandle = (adapter) => utils$1.isFunction(adapter) || adapter === null || adapter === false;
const adapters = {
  getAdapter: (adapters2) => {
    adapters2 = utils$1.isArray(adapters2) ? adapters2 : [adapters2];
    const { length: length2 } = adapters2;
    let nameOrAdapter;
    let adapter;
    const rejectedReasons = {};
    for (let i = 0; i < length2; i++) {
      nameOrAdapter = adapters2[i];
      let id2;
      adapter = nameOrAdapter;
      if (!isResolvedHandle(nameOrAdapter)) {
        adapter = knownAdapters[(id2 = String(nameOrAdapter)).toLowerCase()];
        if (adapter === void 0) {
          throw new AxiosError(`Unknown adapter '${id2}'`);
        }
      }
      if (adapter) {
        break;
      }
      rejectedReasons[id2 || "#" + i] = adapter;
    }
    if (!adapter) {
      const reasons = Object.entries(rejectedReasons).map(
        ([id2, state]) => `adapter ${id2} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
      );
      let s = length2 ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
      throw new AxiosError(
        `There is no suitable adapter to dispatch the request ` + s,
        "ERR_NOT_SUPPORT"
      );
    }
    return adapter;
  },
  adapters: knownAdapters
};
function throwIfCancellationRequested(config2) {
  if (config2.cancelToken) {
    config2.cancelToken.throwIfRequested();
  }
  if (config2.signal && config2.signal.aborted) {
    throw new CanceledError(null, config2);
  }
}
function dispatchRequest(config2) {
  throwIfCancellationRequested(config2);
  config2.headers = AxiosHeaders.from(config2.headers);
  config2.data = transformData.call(
    config2,
    config2.transformRequest
  );
  if (["post", "put", "patch"].indexOf(config2.method) !== -1) {
    config2.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter = adapters.getAdapter(config2.adapter || defaults.adapter);
  return adapter(config2).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config2);
    response.data = transformData.call(
      config2,
      config2.transformResponse,
      response
    );
    response.headers = AxiosHeaders.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config2);
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config2,
          config2.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}
const VERSION = "1.7.9";
const validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i) => {
  validators$1[type] = function validator2(thing) {
    return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
  };
});
const deprecatedWarnings = {};
validators$1.transitional = function transitional(validator2, version2, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return (value, opt, opts) => {
    if (validator2 === false) {
      throw new AxiosError(
        formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")),
        AxiosError.ERR_DEPRECATED
      );
    }
    if (version2 && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version2 + " and will be removed in the near future"
        )
      );
    }
    return validator2 ? validator2(value, opt, opts) : true;
  };
};
validators$1.spelling = function spelling(correctSpelling) {
  return (value, opt) => {
    console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
    return true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
  }
  const keys6 = Object.keys(options);
  let i = keys6.length;
  while (i-- > 0) {
    const opt = keys6[i];
    const validator2 = schema[opt];
    if (validator2) {
      const value = options[opt];
      const result = value === void 0 || validator2(value, opt, options);
      if (result !== true) {
        throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
    }
  }
}
const validator = {
  assertOptions,
  validators: validators$1
};
const validators = validator.validators;
class Axios {
  constructor(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager(),
      response: new InterceptorManager()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(configOrUrl, config2) {
    try {
      return await this._request(configOrUrl, config2);
    } catch (err) {
      if (err instanceof Error) {
        let dummy = {};
        Error.captureStackTrace ? Error.captureStackTrace(dummy) : dummy = new Error();
        const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
        try {
          if (!err.stack) {
            err.stack = stack;
          } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
            err.stack += "\n" + stack;
          }
        } catch (e2) {
        }
      }
      throw err;
    }
  }
  _request(configOrUrl, config2) {
    if (typeof configOrUrl === "string") {
      config2 = config2 || {};
      config2.url = configOrUrl;
    } else {
      config2 = configOrUrl || {};
    }
    config2 = mergeConfig(this.defaults, config2);
    const { transitional: transitional2, paramsSerializer, headers } = config2;
    if (transitional2 !== void 0) {
      validator.assertOptions(transitional2, {
        silentJSONParsing: validators.transitional(validators.boolean),
        forcedJSONParsing: validators.transitional(validators.boolean),
        clarifyTimeoutError: validators.transitional(validators.boolean)
      }, false);
    }
    if (paramsSerializer != null) {
      if (utils$1.isFunction(paramsSerializer)) {
        config2.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator.assertOptions(paramsSerializer, {
          encode: validators.function,
          serialize: validators.function
        }, true);
      }
    }
    validator.assertOptions(config2, {
      baseUrl: validators.spelling("baseURL"),
      withXsrfToken: validators.spelling("withXSRFToken")
    }, true);
    config2.method = (config2.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders = headers && utils$1.merge(
      headers.common,
      headers[config2.method]
    );
    headers && utils$1.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (method) => {
        delete headers[method];
      }
    );
    config2.headers = AxiosHeaders.concat(contextHeaders, headers);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config2) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise2;
    let i = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), void 0];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;
      promise2 = Promise.resolve(config2);
      while (i < len) {
        promise2 = promise2.then(chain[i++], chain[i++]);
      }
      return promise2;
    }
    len = requestInterceptorChain.length;
    let newConfig = config2;
    i = 0;
    while (i < len) {
      const onFulfilled = requestInterceptorChain[i++];
      const onRejected = requestInterceptorChain[i++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error2) {
        onRejected.call(this, error2);
        break;
      }
    }
    try {
      promise2 = dispatchRequest.call(this, newConfig);
    } catch (error2) {
      return Promise.reject(error2);
    }
    i = 0;
    len = responseInterceptorChain.length;
    while (i < len) {
      promise2 = promise2.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
    }
    return promise2;
  }
  getUri(config2) {
    config2 = mergeConfig(this.defaults, config2);
    const fullPath = buildFullPath(config2.baseURL, config2.url);
    return buildURL(fullPath, config2.params, config2.paramsSerializer);
  }
}
utils$1.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
  Axios.prototype[method] = function(url, config2) {
    return this.request(mergeConfig(config2 || {}, {
      method,
      url,
      data: (config2 || {}).data
    }));
  };
});
utils$1.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data2, config2) {
      return this.request(mergeConfig(config2 || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url,
        data: data2
      }));
    };
  }
  Axios.prototype[method] = generateHTTPMethod();
  Axios.prototype[method + "Form"] = generateHTTPMethod(true);
});
class CancelToken {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve2) {
      resolvePromise = resolve2;
    });
    const token2 = this;
    this.promise.then((cancel) => {
      if (!token2._listeners) return;
      let i = token2._listeners.length;
      while (i-- > 0) {
        token2._listeners[i](cancel);
      }
      token2._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise2 = new Promise((resolve2) => {
        token2.subscribe(resolve2);
        _resolve = resolve2;
      }).then(onfulfilled);
      promise2.cancel = function reject2() {
        token2.unsubscribe(_resolve);
      };
      return promise2;
    };
    executor(function cancel(message, config2, request) {
      if (token2.reason) {
        return;
      }
      token2.reason = new CanceledError(message, config2, request);
      resolvePromise(token2.reason);
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  }
  toAbortSignal() {
    const controller = new AbortController();
    const abort = (err) => {
      controller.abort(err);
    };
    this.subscribe(abort);
    controller.signal.unsubscribe = () => this.unsubscribe(abort);
    return controller.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token2 = new CancelToken(function executor(c2) {
      cancel = c2;
    });
    return {
      token: token2,
      cancel
    };
  }
}
function spread(callback2) {
  return function wrap2(arr) {
    return callback2.apply(null, arr);
  };
}
function isAxiosError(payload) {
  return utils$1.isObject(payload) && payload.isAxiosError === true;
}
const HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});
function createInstance(defaultConfig) {
  const context = new Axios(defaultConfig);
  const instance = bind2(Axios.prototype.request, context);
  utils$1.extend(instance, Axios.prototype, context, { allOwnKeys: true });
  utils$1.extend(instance, context, null, { allOwnKeys: true });
  instance.create = function create4(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };
  return instance;
}
const axios = createInstance(defaults);
axios.Axios = Axios;
axios.CanceledError = CanceledError;
axios.CancelToken = CancelToken;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData;
axios.AxiosError = AxiosError;
axios.Cancel = axios.CanceledError;
axios.all = function all2(promises) {
  return Promise.all(promises);
};
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.mergeConfig = mergeConfig;
axios.AxiosHeaders = AxiosHeaders;
axios.formToJSON = (thing) => formDataToJSON(utils$1.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.getAdapter = adapters.getAdapter;
axios.HttpStatusCode = HttpStatusCode;
axios.default = axios;
var define_process_env_default = {};
var __assign = function() {
  __assign = Object.assign || function __assign2(t2) {
    for (var s, i = 1, n2 = arguments.length; i < n2; i++) {
      s = arguments[i];
      for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2)) t2[p2] = s[p2];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
function __rest(s, e2) {
  var t2 = {};
  for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
    t2[p2] = s[p2];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
        t2[p2[i]] = s[p2[i]];
    }
  return t2;
}
typeof SuppressedError === "function" ? SuppressedError : function(error2, suppressed, message) {
  var e2 = new Error(message);
  return e2.name = "SuppressedError", e2.error = error2, e2.suppressed = suppressed, e2;
};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
var propTypes = { exports: {} };
var ReactPropTypesSecret_1;
var hasRequiredReactPropTypesSecret;
function requireReactPropTypesSecret() {
  if (hasRequiredReactPropTypesSecret) return ReactPropTypesSecret_1;
  hasRequiredReactPropTypesSecret = 1;
  var ReactPropTypesSecret2 = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  ReactPropTypesSecret_1 = ReactPropTypesSecret2;
  return ReactPropTypesSecret_1;
}
var factoryWithThrowingShims;
var hasRequiredFactoryWithThrowingShims;
function requireFactoryWithThrowingShims() {
  if (hasRequiredFactoryWithThrowingShims) return factoryWithThrowingShims;
  hasRequiredFactoryWithThrowingShims = 1;
  var ReactPropTypesSecret2 = requireReactPropTypesSecret();
  function emptyFunction2() {
  }
  function emptyFunctionWithReset2() {
  }
  emptyFunctionWithReset2.resetWarningCache = emptyFunction2;
  factoryWithThrowingShims = function() {
    function shim(props, propName, componentName, location, propFullName, secret) {
      if (secret === ReactPropTypesSecret2) {
        return;
      }
      var err = new Error(
        "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
      );
      err.name = "Invariant Violation";
      throw err;
    }
    shim.isRequired = shim;
    function getShim() {
      return shim;
    }
    var ReactPropTypes = {
      array: shim,
      bigint: shim,
      bool: shim,
      func: shim,
      number: shim,
      object: shim,
      string: shim,
      symbol: shim,
      any: shim,
      arrayOf: getShim,
      element: shim,
      elementType: shim,
      instanceOf: getShim,
      node: shim,
      objectOf: getShim,
      oneOf: getShim,
      oneOfType: getShim,
      shape: getShim,
      exact: getShim,
      checkPropTypes: emptyFunctionWithReset2,
      resetWarningCache: emptyFunction2
    };
    ReactPropTypes.PropTypes = ReactPropTypes;
    return ReactPropTypes;
  };
  return factoryWithThrowingShims;
}
{
  propTypes.exports = requireFactoryWithThrowingShims()();
}
var propTypesExports = propTypes.exports;
var PropTypes = /* @__PURE__ */ getDefaultExportFromCjs(propTypesExports);
var classnames = { exports: {} };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
(function(module) {
  (function() {
    var hasOwn3 = {}.hasOwnProperty;
    function classNames2() {
      var classes = "";
      for (var i = 0; i < arguments.length; i++) {
        var arg2 = arguments[i];
        if (arg2) {
          classes = appendClass(classes, parseValue(arg2));
        }
      }
      return classes;
    }
    function parseValue(arg2) {
      if (typeof arg2 === "string" || typeof arg2 === "number") {
        return arg2;
      }
      if (typeof arg2 !== "object") {
        return "";
      }
      if (Array.isArray(arg2)) {
        return classNames2.apply(null, arg2);
      }
      if (arg2.toString !== Object.prototype.toString && !arg2.toString.toString().includes("[native code]")) {
        return arg2.toString();
      }
      var classes = "";
      for (var key in arg2) {
        if (hasOwn3.call(arg2, key) && arg2[key]) {
          classes = appendClass(classes, key);
        }
      }
      return classes;
    }
    function appendClass(value, newClass) {
      if (!newClass) {
        return value;
      }
      if (value) {
        return value + " " + newClass;
      }
      return value + newClass;
    }
    if (module.exports) {
      classNames2.default = classNames2;
      module.exports = classNames2;
    } else {
      window.classNames = classNames2;
    }
  })();
})(classnames);
var classnamesExports = classnames.exports;
var classNames = /* @__PURE__ */ getDefaultExportFromCjs(classnamesExports);
var toCamelCase = function(str) {
  return str.replace(/([-_][a-z0-9])/gi, function($1) {
    return $1.toUpperCase();
  }).replace(/-/gi, "");
};
var CIcon = reactExports.forwardRef(function(_a, ref) {
  var _b;
  var className = _a.className, content = _a.content, customClassName = _a.customClassName, height2 = _a.height, icon = _a.icon, name = _a.name, size3 = _a.size, title = _a.title, use3 = _a.use, width2 = _a.width, rest = __rest(_a, ["className", "content", "customClassName", "height", "icon", "name", "size", "title", "use", "width"]);
  var _c = reactExports.useState(0), change = _c[0], setChange = _c[1];
  var _icon = icon || content || name;
  if (content) {
    process && define_process_env_default && false;
  }
  if (name) {
    process && define_process_env_default && false;
  }
  reactExports.useMemo(function() {
    return setChange(change + 1);
  }, [_icon, JSON.stringify(_icon)]);
  var titleCode = title ? "<title>".concat(title, "</title>") : "";
  var code = reactExports.useMemo(function() {
    var iconName = _icon && typeof _icon === "string" && _icon.includes("-") ? toCamelCase(_icon) : _icon;
    if (Array.isArray(_icon)) {
      return _icon;
    }
    if (typeof _icon === "string" && React$1["icons"]) {
      return React$1[iconName];
    }
  }, [change]);
  var iconCode = reactExports.useMemo(function() {
    return Array.isArray(code) ? code[1] || code[0] : code;
  }, [change]);
  var scale3 = function() {
    return Array.isArray(code) && code.length > 1 ? code[0] : "64 64";
  }();
  var viewBox = function() {
    return rest["viewBox"] || "0 0 ".concat(scale3);
  }();
  var _className = customClassName ? classNames(customClassName) : classNames("icon", (_b = {}, _b["icon-".concat(size3)] = size3, _b["icon-custom-size"] = height2 || width2, _b), className);
  return React$1.createElement(
    React$1.Fragment,
    null,
    use3 ? React$1.createElement(
      "svg",
      __assign({ xmlns: "http://www.w3.org/2000/svg", className: _className }, height2 && { height: height2 }, width2 && { width: width2 }, { role: "img", "aria-hidden": "true" }, rest, { ref }),
      React$1.createElement("use", { href: use3 })
    ) : React$1.createElement("svg", __assign({ xmlns: "http://www.w3.org/2000/svg", viewBox, className: _className }, height2 && { height: height2 }, width2 && { width: width2 }, { role: "img", "aria-hidden": "true", dangerouslySetInnerHTML: { __html: titleCode + iconCode } }, rest, { ref })),
    title && React$1.createElement("span", { className: "visually-hidden" }, title)
  );
});
CIcon.propTypes = {
  className: PropTypes.string,
  content: PropTypes.oneOfType([PropTypes.array, PropTypes.string]),
  customClassName: PropTypes.string,
  height: PropTypes.number,
  icon: PropTypes.oneOfType([PropTypes.array, PropTypes.string]),
  name: PropTypes.string,
  size: PropTypes.oneOf([
    "custom",
    "custom-size",
    "sm",
    "lg",
    "xl",
    "xxl",
    "3xl",
    "4xl",
    "5xl",
    "6xl",
    "7xl",
    "8xl",
    "9xl"
  ]),
  title: PropTypes.string,
  use: PropTypes.string,
  viewBox: PropTypes.string,
  width: PropTypes.number
};
CIcon.displayName = "CIcon";
var CIconSvg = reactExports.forwardRef(function(_a, ref) {
  var _b;
  var children = _a.children, className = _a.className, customClassName = _a.customClassName, height2 = _a.height, size3 = _a.size, title = _a.title, width2 = _a.width, rest = __rest(_a, ["children", "className", "customClassName", "height", "size", "title", "width"]);
  var _className = customClassName ? classNames(customClassName) : classNames("icon", (_b = {}, _b["icon-".concat(size3)] = size3, _b["icon-custom-size"] = height2 || width2, _b), className);
  return React$1.createElement(
    React$1.Fragment,
    null,
    reactExports.Children.map(children, function(child) {
      if (React$1.isValidElement(child)) {
        return React$1.cloneElement(child, __assign({ "aria-hidden": true, className: _className, focusable: "false", ref, role: "img" }, rest));
      }
      return;
    }),
    title && React$1.createElement("span", { className: "visually-hidden" }, title)
  );
});
CIconSvg.propTypes = {
  className: PropTypes.string,
  customClassName: PropTypes.string,
  height: PropTypes.number,
  size: PropTypes.oneOf([
    "custom",
    "custom-size",
    "sm",
    "lg",
    "xl",
    "xxl",
    "3xl",
    "4xl",
    "5xl",
    "6xl",
    "7xl",
    "8xl",
    "9xl"
  ]),
  title: PropTypes.string,
  width: PropTypes.number
};
CIconSvg.displayName = "CIconSvg";
var cilLockLocked = ["512 512", "<path fill='var(--ci-primary-color, currentColor)' d='M384,200V144a128,128,0,0,0-256,0v56H88V328c0,92.635,75.364,168,168,168s168-75.365,168-168V200ZM160,144a96,96,0,0,1,192,0v56H160ZM392,328c0,74.99-61.01,136-136,136s-136-61.01-136-136V232H392Z' class='ci-primary'/>"];
var cilUser = ["512 512", "<path fill='var(--ci-primary-color, currentColor)' d='M411.6,343.656l-72.823-47.334,27.455-50.334A80.23,80.23,0,0,0,376,207.681V128a112,112,0,0,0-224,0v79.681a80.236,80.236,0,0,0,9.768,38.308l27.455,50.333L116.4,343.656A79.725,79.725,0,0,0,80,410.732V496H448V410.732A79.727,79.727,0,0,0,411.6,343.656ZM416,464H112V410.732a47.836,47.836,0,0,1,21.841-40.246l97.66-63.479-41.64-76.341A48.146,48.146,0,0,1,184,207.681V128a80,80,0,0,1,160,0v79.681a48.146,48.146,0,0,1-5.861,22.985L296.5,307.007l97.662,63.479h0A47.836,47.836,0,0,1,416,410.732Z' class='ci-primary'/>"];
var cilX = ["512 512", "<polygon fill='var(--ci-primary-color, currentColor)' points='427.314 107.313 404.686 84.687 256 233.373 107.314 84.687 84.686 107.313 233.373 256 84.686 404.687 107.314 427.313 256 278.627 404.686 427.313 427.314 404.687 278.627 256 427.314 107.313' class='ci-primary'/>"];
const boxClasses = generateUtilityClasses("MuiBox", ["root"]);
const defaultTheme = createTheme();
const Box = createBox({
  themeId: THEME_ID,
  defaultTheme,
  defaultClassName: boxClasses.root,
  generateClassName: ClassNameGenerator.generate
});
function hasCorrectMainProperty(obj) {
  return typeof obj.main === "string";
}
function checkSimplePaletteColorValues(obj, additionalPropertiesToCheck = []) {
  if (!hasCorrectMainProperty(obj)) {
    return false;
  }
  for (const value of additionalPropertiesToCheck) {
    if (!obj.hasOwnProperty(value) || typeof obj[value] !== "string") {
      return false;
    }
  }
  return true;
}
function createSimplePaletteValueFilter(additionalPropertiesToCheck = []) {
  return ([, value]) => value && checkSimplePaletteColorValues(value, additionalPropertiesToCheck);
}
function getTypographyUtilityClass(slot) {
  return generateUtilityClass("MuiTypography", slot);
}
const typographyClasses = generateUtilityClasses("MuiTypography", ["root", "h1", "h2", "h3", "h4", "h5", "h6", "subtitle1", "subtitle2", "body1", "body2", "inherit", "button", "caption", "overline", "alignLeft", "alignRight", "alignCenter", "alignJustify", "noWrap", "gutterBottom", "paragraph"]);
const v6Colors = {
  primary: true,
  secondary: true,
  error: true,
  info: true,
  success: true,
  warning: true,
  textPrimary: true,
  textSecondary: true,
  textDisabled: true
};
const extendSxProp = internal_createExtendSxProp();
const useUtilityClasses$4 = (ownerState) => {
  const {
    align,
    gutterBottom,
    noWrap,
    paragraph,
    variant,
    classes
  } = ownerState;
  const slots = {
    root: ["root", variant, ownerState.align !== "inherit" && `align${capitalize(align)}`, gutterBottom && "gutterBottom", noWrap && "noWrap", paragraph && "paragraph"]
  };
  return composeClasses(slots, getTypographyUtilityClass, classes);
};
const TypographyRoot = styled("span", {
  name: "MuiTypography",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.variant && styles2[ownerState.variant], ownerState.align !== "inherit" && styles2[`align${capitalize(ownerState.align)}`], ownerState.noWrap && styles2.noWrap, ownerState.gutterBottom && styles2.gutterBottom, ownerState.paragraph && styles2.paragraph];
  }
})(memoTheme(({
  theme
}) => {
  var _a;
  return {
    margin: 0,
    variants: [{
      props: {
        variant: "inherit"
      },
      style: {
        // Some elements, like <button> on Chrome have default font that doesn't inherit, reset this.
        font: "inherit",
        lineHeight: "inherit",
        letterSpacing: "inherit"
      }
    }, ...Object.entries(theme.typography).filter(([variant, value]) => variant !== "inherit" && value && typeof value === "object").map(([variant, value]) => ({
      props: {
        variant
      },
      style: value
    })), ...Object.entries(theme.palette).filter(createSimplePaletteValueFilter()).map(([color2]) => ({
      props: {
        color: color2
      },
      style: {
        color: (theme.vars || theme).palette[color2].main
      }
    })), ...Object.entries(((_a = theme.palette) == null ? void 0 : _a.text) || {}).filter(([, value]) => typeof value === "string").map(([color2]) => ({
      props: {
        color: `text${capitalize(color2)}`
      },
      style: {
        color: (theme.vars || theme).palette.text[color2]
      }
    })), {
      props: ({
        ownerState
      }) => ownerState.align !== "inherit",
      style: {
        textAlign: "var(--Typography-textAlign)"
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.noWrap,
      style: {
        overflow: "hidden",
        textOverflow: "ellipsis",
        whiteSpace: "nowrap"
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.gutterBottom,
      style: {
        marginBottom: "0.35em"
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.paragraph,
      style: {
        marginBottom: 16
      }
    }]
  };
}));
const defaultVariantMapping = {
  h1: "h1",
  h2: "h2",
  h3: "h3",
  h4: "h4",
  h5: "h5",
  h6: "h6",
  subtitle1: "h6",
  subtitle2: "h6",
  body1: "p",
  body2: "p",
  inherit: "p"
};
const Typography = /* @__PURE__ */ reactExports.forwardRef(function Typography2(inProps, ref) {
  const {
    color: color2,
    ...themeProps
  } = useDefaultProps({
    props: inProps,
    name: "MuiTypography"
  });
  const isSxColor = !v6Colors[color2];
  const props = extendSxProp({
    ...themeProps,
    ...isSxColor && {
      color: color2
    }
  });
  const {
    align = "inherit",
    className,
    component,
    gutterBottom = false,
    noWrap = false,
    paragraph = false,
    variant = "body1",
    variantMapping = defaultVariantMapping,
    ...other
  } = props;
  const ownerState = {
    ...props,
    align,
    color: color2,
    className,
    component,
    gutterBottom,
    noWrap,
    paragraph,
    variant,
    variantMapping
  };
  const Component = component || (paragraph ? "p" : variantMapping[variant] || defaultVariantMapping[variant]) || "span";
  const classes = useUtilityClasses$4(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TypographyRoot, {
    as: Component,
    ref,
    className: clsx(classes.root, className),
    ...other,
    ownerState,
    style: {
      ...align !== "inherit" && {
        "--Typography-textAlign": align
      },
      ...other.style
    }
  });
});
class LazyRipple {
  constructor() {
    __publicField(this, "mountEffect", () => {
      if (this.shouldMount && !this.didMount) {
        if (this.ref.current !== null) {
          this.didMount = true;
          this.mounted.resolve();
        }
      }
    });
    this.ref = {
      current: null
    };
    this.mounted = null;
    this.didMount = false;
    this.shouldMount = false;
    this.setShouldMount = null;
  }
  /** React ref to the ripple instance */
  /** If the ripple component should be mounted */
  /** Promise that resolves when the ripple component is mounted */
  /** If the ripple component has been mounted */
  /** React state hook setter */
  static create() {
    return new LazyRipple();
  }
  static use() {
    const ripple = useLazyRef(LazyRipple.create).current;
    const [shouldMount, setShouldMount] = reactExports.useState(false);
    ripple.shouldMount = shouldMount;
    ripple.setShouldMount = setShouldMount;
    reactExports.useEffect(ripple.mountEffect, [shouldMount]);
    return ripple;
  }
  mount() {
    if (!this.mounted) {
      this.mounted = createControlledPromise();
      this.shouldMount = true;
      this.setShouldMount(this.shouldMount);
    }
    return this.mounted;
  }
  /* Ripple API */
  start(...args) {
    this.mount().then(() => {
      var _a;
      return (_a = this.ref.current) == null ? void 0 : _a.start(...args);
    });
  }
  stop(...args) {
    this.mount().then(() => {
      var _a;
      return (_a = this.ref.current) == null ? void 0 : _a.stop(...args);
    });
  }
  pulsate(...args) {
    this.mount().then(() => {
      var _a;
      return (_a = this.ref.current) == null ? void 0 : _a.pulsate(...args);
    });
  }
}
function useLazyRipple() {
  return LazyRipple.use();
}
function createControlledPromise() {
  let resolve2;
  let reject2;
  const p2 = new Promise((resolveFn, rejectFn) => {
    resolve2 = resolveFn;
    reject2 = rejectFn;
  });
  p2.resolve = resolve2;
  p2.reject = reject2;
  return p2;
}
function Ripple(props) {
  const {
    className,
    classes,
    pulsate = false,
    rippleX,
    rippleY,
    rippleSize,
    in: inProp,
    onExited,
    timeout
  } = props;
  const [leaving, setLeaving] = reactExports.useState(false);
  const rippleClassName = clsx(className, classes.ripple, classes.rippleVisible, pulsate && classes.ripplePulsate);
  const rippleStyles = {
    width: rippleSize,
    height: rippleSize,
    top: -(rippleSize / 2) + rippleY,
    left: -(rippleSize / 2) + rippleX
  };
  const childClassName = clsx(classes.child, leaving && classes.childLeaving, pulsate && classes.childPulsate);
  if (!inProp && !leaving) {
    setLeaving(true);
  }
  reactExports.useEffect(() => {
    if (!inProp && onExited != null) {
      const timeoutId = setTimeout(onExited, timeout);
      return () => {
        clearTimeout(timeoutId);
      };
    }
    return void 0;
  }, [onExited, inProp, timeout]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
    className: rippleClassName,
    style: rippleStyles,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
      className: childClassName
    })
  });
}
const touchRippleClasses = generateUtilityClasses("MuiTouchRipple", ["root", "ripple", "rippleVisible", "ripplePulsate", "child", "childLeaving", "childPulsate"]);
const DURATION = 550;
const DELAY_RIPPLE = 80;
const enterKeyframe = keyframes`
  0% {
    transform: scale(0);
    opacity: 0.1;
  }

  100% {
    transform: scale(1);
    opacity: 0.3;
  }
`;
const exitKeyframe = keyframes`
  0% {
    opacity: 1;
  }

  100% {
    opacity: 0;
  }
`;
const pulsateKeyframe = keyframes`
  0% {
    transform: scale(1);
  }

  50% {
    transform: scale(0.92);
  }

  100% {
    transform: scale(1);
  }
`;
const TouchRippleRoot = styled("span", {
  name: "MuiTouchRipple",
  slot: "Root"
})({
  overflow: "hidden",
  pointerEvents: "none",
  position: "absolute",
  zIndex: 0,
  top: 0,
  right: 0,
  bottom: 0,
  left: 0,
  borderRadius: "inherit"
});
const TouchRippleRipple = styled(Ripple, {
  name: "MuiTouchRipple",
  slot: "Ripple"
})`
  opacity: 0;
  position: absolute;

  &.${touchRippleClasses.rippleVisible} {
    opacity: 0.3;
    transform: scale(1);
    animation-name: ${enterKeyframe};
    animation-duration: ${DURATION}ms;
    animation-timing-function: ${({
  theme
}) => theme.transitions.easing.easeInOut};
  }

  &.${touchRippleClasses.ripplePulsate} {
    animation-duration: ${({
  theme
}) => theme.transitions.duration.shorter}ms;
  }

  & .${touchRippleClasses.child} {
    opacity: 1;
    display: block;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: currentColor;
  }

  & .${touchRippleClasses.childLeaving} {
    opacity: 0;
    animation-name: ${exitKeyframe};
    animation-duration: ${DURATION}ms;
    animation-timing-function: ${({
  theme
}) => theme.transitions.easing.easeInOut};
  }

  & .${touchRippleClasses.childPulsate} {
    position: absolute;
    /* @noflip */
    left: 0px;
    top: 0;
    animation-name: ${pulsateKeyframe};
    animation-duration: 2500ms;
    animation-timing-function: ${({
  theme
}) => theme.transitions.easing.easeInOut};
    animation-iteration-count: infinite;
    animation-delay: 200ms;
  }
`;
const TouchRipple = /* @__PURE__ */ reactExports.forwardRef(function TouchRipple2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiTouchRipple"
  });
  const {
    center: centerProp = false,
    classes = {},
    className,
    ...other
  } = props;
  const [ripples, setRipples] = reactExports.useState([]);
  const nextKey = reactExports.useRef(0);
  const rippleCallback = reactExports.useRef(null);
  reactExports.useEffect(() => {
    if (rippleCallback.current) {
      rippleCallback.current();
      rippleCallback.current = null;
    }
  }, [ripples]);
  const ignoringMouseDown = reactExports.useRef(false);
  const startTimer = useTimeout();
  const startTimerCommit = reactExports.useRef(null);
  const container = reactExports.useRef(null);
  const startCommit = reactExports.useCallback((params2) => {
    const {
      pulsate: pulsate2,
      rippleX,
      rippleY,
      rippleSize,
      cb: cb2
    } = params2;
    setRipples((oldRipples) => [...oldRipples, /* @__PURE__ */ jsxRuntimeExports.jsx(TouchRippleRipple, {
      classes: {
        ripple: clsx(classes.ripple, touchRippleClasses.ripple),
        rippleVisible: clsx(classes.rippleVisible, touchRippleClasses.rippleVisible),
        ripplePulsate: clsx(classes.ripplePulsate, touchRippleClasses.ripplePulsate),
        child: clsx(classes.child, touchRippleClasses.child),
        childLeaving: clsx(classes.childLeaving, touchRippleClasses.childLeaving),
        childPulsate: clsx(classes.childPulsate, touchRippleClasses.childPulsate)
      },
      timeout: DURATION,
      pulsate: pulsate2,
      rippleX,
      rippleY,
      rippleSize
    }, nextKey.current)]);
    nextKey.current += 1;
    rippleCallback.current = cb2;
  }, [classes]);
  const start = reactExports.useCallback((event = {}, options = {}, cb2 = () => {
  }) => {
    const {
      pulsate: pulsate2 = false,
      center = centerProp || options.pulsate,
      fakeElement = false
      // For test purposes
    } = options;
    if ((event == null ? void 0 : event.type) === "mousedown" && ignoringMouseDown.current) {
      ignoringMouseDown.current = false;
      return;
    }
    if ((event == null ? void 0 : event.type) === "touchstart") {
      ignoringMouseDown.current = true;
    }
    const element = fakeElement ? null : container.current;
    const rect = element ? element.getBoundingClientRect() : {
      width: 0,
      height: 0,
      left: 0,
      top: 0
    };
    let rippleX;
    let rippleY;
    let rippleSize;
    if (center || event === void 0 || event.clientX === 0 && event.clientY === 0 || !event.clientX && !event.touches) {
      rippleX = Math.round(rect.width / 2);
      rippleY = Math.round(rect.height / 2);
    } else {
      const {
        clientX,
        clientY
      } = event.touches && event.touches.length > 0 ? event.touches[0] : event;
      rippleX = Math.round(clientX - rect.left);
      rippleY = Math.round(clientY - rect.top);
    }
    if (center) {
      rippleSize = Math.sqrt((2 * rect.width ** 2 + rect.height ** 2) / 3);
      if (rippleSize % 2 === 0) {
        rippleSize += 1;
      }
    } else {
      const sizeX = Math.max(Math.abs((element ? element.clientWidth : 0) - rippleX), rippleX) * 2 + 2;
      const sizeY = Math.max(Math.abs((element ? element.clientHeight : 0) - rippleY), rippleY) * 2 + 2;
      rippleSize = Math.sqrt(sizeX ** 2 + sizeY ** 2);
    }
    if (event == null ? void 0 : event.touches) {
      if (startTimerCommit.current === null) {
        startTimerCommit.current = () => {
          startCommit({
            pulsate: pulsate2,
            rippleX,
            rippleY,
            rippleSize,
            cb: cb2
          });
        };
        startTimer.start(DELAY_RIPPLE, () => {
          if (startTimerCommit.current) {
            startTimerCommit.current();
            startTimerCommit.current = null;
          }
        });
      }
    } else {
      startCommit({
        pulsate: pulsate2,
        rippleX,
        rippleY,
        rippleSize,
        cb: cb2
      });
    }
  }, [centerProp, startCommit, startTimer]);
  const pulsate = reactExports.useCallback(() => {
    start({}, {
      pulsate: true
    });
  }, [start]);
  const stop = reactExports.useCallback((event, cb2) => {
    startTimer.clear();
    if ((event == null ? void 0 : event.type) === "touchend" && startTimerCommit.current) {
      startTimerCommit.current();
      startTimerCommit.current = null;
      startTimer.start(0, () => {
        stop(event, cb2);
      });
      return;
    }
    startTimerCommit.current = null;
    setRipples((oldRipples) => {
      if (oldRipples.length > 0) {
        return oldRipples.slice(1);
      }
      return oldRipples;
    });
    rippleCallback.current = cb2;
  }, [startTimer]);
  reactExports.useImperativeHandle(ref, () => ({
    pulsate,
    start,
    stop
  }), [pulsate, start, stop]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TouchRippleRoot, {
    className: clsx(touchRippleClasses.root, classes.root, className),
    ref: container,
    ...other,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionGroup, {
      component: null,
      exit: true,
      children: ripples
    })
  });
});
function getButtonBaseUtilityClass(slot) {
  return generateUtilityClass("MuiButtonBase", slot);
}
const buttonBaseClasses = generateUtilityClasses("MuiButtonBase", ["root", "disabled", "focusVisible"]);
const useUtilityClasses$3 = (ownerState) => {
  const {
    disabled,
    focusVisible,
    focusVisibleClassName,
    classes
  } = ownerState;
  const slots = {
    root: ["root", disabled && "disabled", focusVisible && "focusVisible"]
  };
  const composedClasses = composeClasses(slots, getButtonBaseUtilityClass, classes);
  if (focusVisible && focusVisibleClassName) {
    composedClasses.root += ` ${focusVisibleClassName}`;
  }
  return composedClasses;
};
const ButtonBaseRoot = styled("button", {
  name: "MuiButtonBase",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})({
  display: "inline-flex",
  alignItems: "center",
  justifyContent: "center",
  position: "relative",
  boxSizing: "border-box",
  WebkitTapHighlightColor: "transparent",
  backgroundColor: "transparent",
  // Reset default value
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0,
  border: 0,
  margin: 0,
  // Remove the margin in Safari
  borderRadius: 0,
  padding: 0,
  // Remove the padding in Firefox
  cursor: "pointer",
  userSelect: "none",
  verticalAlign: "middle",
  MozAppearance: "none",
  // Reset
  WebkitAppearance: "none",
  // Reset
  textDecoration: "none",
  // So we take precedent over the style of a native <a /> element.
  color: "inherit",
  "&::-moz-focus-inner": {
    borderStyle: "none"
    // Remove Firefox dotted outline.
  },
  [`&.${buttonBaseClasses.disabled}`]: {
    pointerEvents: "none",
    // Disable link interactions
    cursor: "default"
  },
  "@media print": {
    colorAdjust: "exact"
  }
});
const ButtonBase = /* @__PURE__ */ reactExports.forwardRef(function ButtonBase2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiButtonBase"
  });
  const {
    action,
    centerRipple = false,
    children,
    className,
    component = "button",
    disabled = false,
    disableRipple = false,
    disableTouchRipple = false,
    focusRipple = false,
    focusVisibleClassName,
    LinkComponent = "a",
    onBlur,
    onClick,
    onContextMenu,
    onDragLeave,
    onFocus,
    onFocusVisible,
    onKeyDown,
    onKeyUp,
    onMouseDown,
    onMouseLeave,
    onMouseUp,
    onTouchEnd,
    onTouchMove,
    onTouchStart,
    tabIndex = 0,
    TouchRippleProps,
    touchRippleRef,
    type,
    ...other
  } = props;
  const buttonRef = reactExports.useRef(null);
  const ripple = useLazyRipple();
  const handleRippleRef = useForkRef(ripple.ref, touchRippleRef);
  const [focusVisible, setFocusVisible] = reactExports.useState(false);
  if (disabled && focusVisible) {
    setFocusVisible(false);
  }
  reactExports.useImperativeHandle(action, () => ({
    focusVisible: () => {
      setFocusVisible(true);
      buttonRef.current.focus();
    }
  }), []);
  const enableTouchRipple = ripple.shouldMount && !disableRipple && !disabled;
  reactExports.useEffect(() => {
    if (focusVisible && focusRipple && !disableRipple) {
      ripple.pulsate();
    }
  }, [disableRipple, focusRipple, focusVisible, ripple]);
  const handleMouseDown = useRippleHandler(ripple, "start", onMouseDown, disableTouchRipple);
  const handleContextMenu = useRippleHandler(ripple, "stop", onContextMenu, disableTouchRipple);
  const handleDragLeave = useRippleHandler(ripple, "stop", onDragLeave, disableTouchRipple);
  const handleMouseUp = useRippleHandler(ripple, "stop", onMouseUp, disableTouchRipple);
  const handleMouseLeave = useRippleHandler(ripple, "stop", (event) => {
    if (focusVisible) {
      event.preventDefault();
    }
    if (onMouseLeave) {
      onMouseLeave(event);
    }
  }, disableTouchRipple);
  const handleTouchStart = useRippleHandler(ripple, "start", onTouchStart, disableTouchRipple);
  const handleTouchEnd = useRippleHandler(ripple, "stop", onTouchEnd, disableTouchRipple);
  const handleTouchMove = useRippleHandler(ripple, "stop", onTouchMove, disableTouchRipple);
  const handleBlur = useRippleHandler(ripple, "stop", (event) => {
    if (!isFocusVisible(event.target)) {
      setFocusVisible(false);
    }
    if (onBlur) {
      onBlur(event);
    }
  }, false);
  const handleFocus = useEventCallback((event) => {
    if (!buttonRef.current) {
      buttonRef.current = event.currentTarget;
    }
    if (isFocusVisible(event.target)) {
      setFocusVisible(true);
      if (onFocusVisible) {
        onFocusVisible(event);
      }
    }
    if (onFocus) {
      onFocus(event);
    }
  });
  const isNonNativeButton = () => {
    const button = buttonRef.current;
    return component && component !== "button" && !(button.tagName === "A" && button.href);
  };
  const handleKeyDown = useEventCallback((event) => {
    if (focusRipple && !event.repeat && focusVisible && event.key === " ") {
      ripple.stop(event, () => {
        ripple.start(event);
      });
    }
    if (event.target === event.currentTarget && isNonNativeButton() && event.key === " ") {
      event.preventDefault();
    }
    if (onKeyDown) {
      onKeyDown(event);
    }
    if (event.target === event.currentTarget && isNonNativeButton() && event.key === "Enter" && !disabled) {
      event.preventDefault();
      if (onClick) {
        onClick(event);
      }
    }
  });
  const handleKeyUp = useEventCallback((event) => {
    if (focusRipple && event.key === " " && focusVisible && !event.defaultPrevented) {
      ripple.stop(event, () => {
        ripple.pulsate(event);
      });
    }
    if (onKeyUp) {
      onKeyUp(event);
    }
    if (onClick && event.target === event.currentTarget && isNonNativeButton() && event.key === " " && !event.defaultPrevented) {
      onClick(event);
    }
  });
  let ComponentProp = component;
  if (ComponentProp === "button" && (other.href || other.to)) {
    ComponentProp = LinkComponent;
  }
  const buttonProps = {};
  if (ComponentProp === "button") {
    buttonProps.type = type === void 0 ? "button" : type;
    buttonProps.disabled = disabled;
  } else {
    if (!other.href && !other.to) {
      buttonProps.role = "button";
    }
    if (disabled) {
      buttonProps["aria-disabled"] = disabled;
    }
  }
  const handleRef = useForkRef(ref, buttonRef);
  const ownerState = {
    ...props,
    centerRipple,
    component,
    disabled,
    disableRipple,
    disableTouchRipple,
    focusRipple,
    tabIndex,
    focusVisible
  };
  const classes = useUtilityClasses$3(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(ButtonBaseRoot, {
    as: ComponentProp,
    className: clsx(classes.root, className),
    ownerState,
    onBlur: handleBlur,
    onClick,
    onContextMenu: handleContextMenu,
    onFocus: handleFocus,
    onKeyDown: handleKeyDown,
    onKeyUp: handleKeyUp,
    onMouseDown: handleMouseDown,
    onMouseLeave: handleMouseLeave,
    onMouseUp: handleMouseUp,
    onDragLeave: handleDragLeave,
    onTouchEnd: handleTouchEnd,
    onTouchMove: handleTouchMove,
    onTouchStart: handleTouchStart,
    ref: handleRef,
    tabIndex: disabled ? -1 : tabIndex,
    type,
    ...buttonProps,
    ...other,
    children: [children, enableTouchRipple ? /* @__PURE__ */ jsxRuntimeExports.jsx(TouchRipple, {
      ref: handleRippleRef,
      center: centerRipple,
      ...TouchRippleProps
    }) : null]
  });
});
function useRippleHandler(ripple, rippleAction, eventCallback, skipRippleAction = false) {
  return useEventCallback((event) => {
    if (eventCallback) {
      eventCallback(event);
    }
    if (!skipRippleAction) {
      ripple[rippleAction](event);
    }
    return true;
  });
}
function getCircularProgressUtilityClass(slot) {
  return generateUtilityClass("MuiCircularProgress", slot);
}
generateUtilityClasses("MuiCircularProgress", ["root", "determinate", "indeterminate", "colorPrimary", "colorSecondary", "svg", "circle", "circleDeterminate", "circleIndeterminate", "circleDisableShrink"]);
const SIZE = 44;
const circularRotateKeyframe = keyframes`
  0% {
    transform: rotate(0deg);
  }

  100% {
    transform: rotate(360deg);
  }
`;
const circularDashKeyframe = keyframes`
  0% {
    stroke-dasharray: 1px, 200px;
    stroke-dashoffset: 0;
  }

  50% {
    stroke-dasharray: 100px, 200px;
    stroke-dashoffset: -15px;
  }

  100% {
    stroke-dasharray: 1px, 200px;
    stroke-dashoffset: -126px;
  }
`;
const rotateAnimation = typeof circularRotateKeyframe !== "string" ? css`
        animation: ${circularRotateKeyframe} 1.4s linear infinite;
      ` : null;
const dashAnimation = typeof circularDashKeyframe !== "string" ? css`
        animation: ${circularDashKeyframe} 1.4s ease-in-out infinite;
      ` : null;
const useUtilityClasses$2 = (ownerState) => {
  const {
    classes,
    variant,
    color: color2,
    disableShrink
  } = ownerState;
  const slots = {
    root: ["root", variant, `color${capitalize(color2)}`],
    svg: ["svg"],
    circle: ["circle", `circle${capitalize(variant)}`, disableShrink && "circleDisableShrink"]
  };
  return composeClasses(slots, getCircularProgressUtilityClass, classes);
};
const CircularProgressRoot = styled("span", {
  name: "MuiCircularProgress",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.variant], styles2[`color${capitalize(ownerState.color)}`]];
  }
})(memoTheme(({
  theme
}) => ({
  display: "inline-block",
  variants: [{
    props: {
      variant: "determinate"
    },
    style: {
      transition: theme.transitions.create("transform")
    }
  }, {
    props: {
      variant: "indeterminate"
    },
    style: rotateAnimation || {
      animation: `${circularRotateKeyframe} 1.4s linear infinite`
    }
  }, ...Object.entries(theme.palette).filter(createSimplePaletteValueFilter()).map(([color2]) => ({
    props: {
      color: color2
    },
    style: {
      color: (theme.vars || theme).palette[color2].main
    }
  }))]
})));
const CircularProgressSVG = styled("svg", {
  name: "MuiCircularProgress",
  slot: "Svg",
  overridesResolver: (props, styles2) => styles2.svg
})({
  display: "block"
  // Keeps the progress centered
});
const CircularProgressCircle = styled("circle", {
  name: "MuiCircularProgress",
  slot: "Circle",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.circle, styles2[`circle${capitalize(ownerState.variant)}`], ownerState.disableShrink && styles2.circleDisableShrink];
  }
})(memoTheme(({
  theme
}) => ({
  stroke: "currentColor",
  variants: [{
    props: {
      variant: "determinate"
    },
    style: {
      transition: theme.transitions.create("stroke-dashoffset")
    }
  }, {
    props: {
      variant: "indeterminate"
    },
    style: {
      // Some default value that looks fine waiting for the animation to kicks in.
      strokeDasharray: "80px, 200px",
      strokeDashoffset: 0
      // Add the unit to fix a Edge 16 and below bug.
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.variant === "indeterminate" && !ownerState.disableShrink,
    style: dashAnimation || {
      // At runtime for Pigment CSS, `bufferAnimation` will be null and the generated keyframe will be used.
      animation: `${circularDashKeyframe} 1.4s ease-in-out infinite`
    }
  }]
})));
const CircularProgress = /* @__PURE__ */ reactExports.forwardRef(function CircularProgress2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiCircularProgress"
  });
  const {
    className,
    color: color2 = "primary",
    disableShrink = false,
    size: size3 = 40,
    style: style2,
    thickness = 3.6,
    value = 0,
    variant = "indeterminate",
    ...other
  } = props;
  const ownerState = {
    ...props,
    color: color2,
    disableShrink,
    size: size3,
    thickness,
    value,
    variant
  };
  const classes = useUtilityClasses$2(ownerState);
  const circleStyle = {};
  const rootStyle = {};
  const rootProps = {};
  if (variant === "determinate") {
    const circumference = 2 * Math.PI * ((SIZE - thickness) / 2);
    circleStyle.strokeDasharray = circumference.toFixed(3);
    rootProps["aria-valuenow"] = Math.round(value);
    circleStyle.strokeDashoffset = `${((100 - value) / 100 * circumference).toFixed(3)}px`;
    rootStyle.transform = "rotate(-90deg)";
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgressRoot, {
    className: clsx(classes.root, className),
    style: {
      width: size3,
      height: size3,
      ...rootStyle,
      ...style2
    },
    ownerState,
    ref,
    role: "progressbar",
    ...rootProps,
    ...other,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgressSVG, {
      className: classes.svg,
      ownerState,
      viewBox: `${SIZE / 2} ${SIZE / 2} ${SIZE} ${SIZE}`,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgressCircle, {
        className: classes.circle,
        style: circleStyle,
        ownerState,
        cx: SIZE,
        cy: SIZE,
        r: (SIZE - thickness) / 2,
        fill: "none",
        strokeWidth: thickness
      })
    })
  });
});
function getIconButtonUtilityClass(slot) {
  return generateUtilityClass("MuiIconButton", slot);
}
const iconButtonClasses = generateUtilityClasses("MuiIconButton", ["root", "disabled", "colorInherit", "colorPrimary", "colorSecondary", "colorError", "colorInfo", "colorSuccess", "colorWarning", "edgeStart", "edgeEnd", "sizeSmall", "sizeMedium", "sizeLarge", "loading", "loadingIndicator", "loadingWrapper"]);
const useUtilityClasses$1 = (ownerState) => {
  const {
    classes,
    disabled,
    color: color2,
    edge,
    size: size3,
    loading
  } = ownerState;
  const slots = {
    root: ["root", loading && "loading", disabled && "disabled", color2 !== "default" && `color${capitalize(color2)}`, edge && `edge${capitalize(edge)}`, `size${capitalize(size3)}`],
    loadingIndicator: ["loadingIndicator"],
    loadingWrapper: ["loadingWrapper"]
  };
  return composeClasses(slots, getIconButtonUtilityClass, classes);
};
const IconButtonRoot = styled(ButtonBase, {
  name: "MuiIconButton",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.loading && styles2.loading, ownerState.color !== "default" && styles2[`color${capitalize(ownerState.color)}`], ownerState.edge && styles2[`edge${capitalize(ownerState.edge)}`], styles2[`size${capitalize(ownerState.size)}`]];
  }
})(memoTheme(({
  theme
}) => ({
  textAlign: "center",
  flex: "0 0 auto",
  fontSize: theme.typography.pxToRem(24),
  padding: 8,
  borderRadius: "50%",
  color: (theme.vars || theme).palette.action.active,
  transition: theme.transitions.create("background-color", {
    duration: theme.transitions.duration.shortest
  }),
  variants: [{
    props: (props) => !props.disableRipple,
    style: {
      "--IconButton-hoverBg": theme.vars ? `rgba(${theme.vars.palette.action.activeChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette.action.active, theme.palette.action.hoverOpacity),
      "&:hover": {
        backgroundColor: "var(--IconButton-hoverBg)",
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          backgroundColor: "transparent"
        }
      }
    }
  }, {
    props: {
      edge: "start"
    },
    style: {
      marginLeft: -12
    }
  }, {
    props: {
      edge: "start",
      size: "small"
    },
    style: {
      marginLeft: -3
    }
  }, {
    props: {
      edge: "end"
    },
    style: {
      marginRight: -12
    }
  }, {
    props: {
      edge: "end",
      size: "small"
    },
    style: {
      marginRight: -3
    }
  }]
})), memoTheme(({
  theme
}) => ({
  variants: [{
    props: {
      color: "inherit"
    },
    style: {
      color: "inherit"
    }
  }, ...Object.entries(theme.palette).filter(createSimplePaletteValueFilter()).map(([color2]) => ({
    props: {
      color: color2
    },
    style: {
      color: (theme.vars || theme).palette[color2].main
    }
  })), ...Object.entries(theme.palette).filter(createSimplePaletteValueFilter()).map(([color2]) => ({
    props: {
      color: color2
    },
    style: {
      "--IconButton-hoverBg": theme.vars ? `rgba(${(theme.vars || theme).palette[color2].mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha((theme.vars || theme).palette[color2].main, theme.palette.action.hoverOpacity)
    }
  })), {
    props: {
      size: "small"
    },
    style: {
      padding: 5,
      fontSize: theme.typography.pxToRem(18)
    }
  }, {
    props: {
      size: "large"
    },
    style: {
      padding: 12,
      fontSize: theme.typography.pxToRem(28)
    }
  }],
  [`&.${iconButtonClasses.disabled}`]: {
    backgroundColor: "transparent",
    color: (theme.vars || theme).palette.action.disabled
  },
  [`&.${iconButtonClasses.loading}`]: {
    color: "transparent"
  }
})));
const IconButtonLoadingIndicator = styled("span", {
  name: "MuiIconButton",
  slot: "LoadingIndicator",
  overridesResolver: (props, styles2) => styles2.loadingIndicator
})(({
  theme
}) => ({
  display: "none",
  position: "absolute",
  visibility: "visible",
  top: "50%",
  left: "50%",
  transform: "translate(-50%, -50%)",
  color: (theme.vars || theme).palette.action.disabled,
  variants: [{
    props: {
      loading: true
    },
    style: {
      display: "flex"
    }
  }]
}));
const IconButton = /* @__PURE__ */ reactExports.forwardRef(function IconButton2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiIconButton"
  });
  const {
    edge = false,
    children,
    className,
    color: color2 = "default",
    disabled = false,
    disableFocusRipple = false,
    size: size3 = "medium",
    id: idProp,
    loading = null,
    loadingIndicator: loadingIndicatorProp,
    ...other
  } = props;
  const loadingId = useId(idProp);
  const loadingIndicator = loadingIndicatorProp ?? /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress, {
    "aria-labelledby": loadingId,
    color: "inherit",
    size: 16
  });
  const ownerState = {
    ...props,
    edge,
    color: color2,
    disabled,
    disableFocusRipple,
    loading,
    loadingIndicator,
    size: size3
  };
  const classes = useUtilityClasses$1(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(IconButtonRoot, {
    id: loading ? loadingId : idProp,
    className: clsx(classes.root, className),
    centerRipple: true,
    focusRipple: !disableFocusRipple,
    disabled: disabled || loading,
    ref,
    ...other,
    ownerState,
    children: [typeof loading === "boolean" && // use plain HTML span to minimize the runtime overhead
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
      className: classes.loadingWrapper,
      style: {
        display: "contents"
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconButtonLoadingIndicator, {
        className: classes.loadingIndicator,
        ownerState,
        children: loading && loadingIndicator
      })
    }), children]
  });
});
const BalanceContext = reactExports.createContext();
let setNotEnoughBalanceGlobal;
let setGlobalNotVerified;
const useBalance = () => {
  return reactExports.useContext(BalanceContext);
};
const BalanceProvider = ({ children }) => {
  const [notEnough, setNotEnough] = reactExports.useState(false);
  const [notVerified, setNotVerified] = reactExports.useState(false);
  setNotEnoughBalanceGlobal = setNotEnough;
  setGlobalNotVerified = setNotVerified;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(BalanceContext.Provider, { value: { notEnough, setNotEnough, notVerified, setNotVerified }, children });
};
const backend = "https://bezkaa-back.onrender.com";
const apiPost = async (url, params2, isForm) => {
  var _a;
  const token2 = (_a = JSON.parse(localStorage.getItem("authData"))) == null ? void 0 : _a.token;
  try {
    if (!token2 && !showGlobalLoginVar) {
      if (showGlobalLogin) showGlobalLogin(true);
    } else {
      let headers = {
        Authorization: token2
      };
      if (isForm) ;
      else {
        headers["Content-Type"] = "application/json";
        params2 = JSON.stringify(params2);
      }
      const res = await axios.post(backend + url, params2, { headers });
      const Data = res.data.status === 200 ? { success: true, data: res.data } : { success: false, data: res.data };
      return Data;
    }
  } catch (error2) {
    console.error("error", error2);
    if (error2.status === 402) {
      setNotEnoughBalanceGlobal(true);
    }
    if (error2.status === 403) {
      setGlobalNotVerified(true);
    }
    return { success: false, data: null, error: error2 };
  }
};
const img = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%2048%2048'%20width='48px'%20height='48px'%3e%3cpath%20fill='%23FFC107'%20d='M43.611,20.083H42V20H24v8h11.303c-1.649,4.657-6.08,8-11.303,8c-6.627,0-12-5.373-12-12c0-6.627,5.373-12,12-12c3.059,0,5.842,1.154,7.961,3.039l5.657-5.657C34.046,6.053,29.268,4,24,4C12.955,4,4,12.955,4,24c0,11.045,8.955,20,20,20c11.045,0,20-8.955,20-20C44,22.659,43.862,21.35,43.611,20.083z'/%3e%3cpath%20fill='%23FF3D00'%20d='M6.306,14.691l6.571,4.819C14.655,15.108,18.961,12,24,12c3.059,0,5.842,1.154,7.961,3.039l5.657-5.657C34.046,6.053,29.268,4,24,4C16.318,4,9.656,8.337,6.306,14.691z'/%3e%3cpath%20fill='%234CAF50'%20d='M24,44c5.166,0,9.86-1.977,13.409-5.192l-6.19-5.238C29.211,35.091,26.715,36,24,36c-5.202,0-9.619-3.317-11.283-7.946l-6.522,5.025C9.505,39.556,16.227,44,24,44z'/%3e%3cpath%20fill='%231976D2'%20d='M43.611,20.083H42V20H24v8h11.303c-0.792,2.237-2.231,4.166-4.087,5.571c0.001-0.001,0.002-0.001,0.003-0.002l6.19,5.238C36.971,39.205,44,34,44,24C44,22.659,43.862,21.35,43.611,20.083z'/%3e%3c/svg%3e";
function Login() {
  const handleLogin = () => {
    window.location.href = "http://localhost:3001/auth/google";
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "100%", alignItems: "center", display: "flex", justifyContent: "center" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    "img",
    {
      style: {
        display: "flex",
        // To align the icon and text horizontally
        justifyContent: "center",
        // Center the content
        alignItems: "center",
        // Align items vertically in the center
        width: "20%",
        // Make the button full-width
        padding: "10px",
        // Add some padding for better spacing
        border: "none",
        // Remove the default button border
        color: "white",
        // White text color
        borderRadius: "4px",
        // Optional: rounded corners
        cursor: "pointer",
        // Pointer cursor to indicate clickability
        fontSize: "16px"
        // Optional: adjust font size
      },
      src: img,
      onClick: handleLogin,
      alt: "Google Icon"
    }
  ) });
}
const AuthModal = ({ handleClose, open }) => {
  const [isLogin, setIsLogin] = reactExports.useState(true);
  const [formData, setFormData] = reactExports.useState({
    username: "",
    email: "",
    password: "",
    confirmPassword: ""
  });
  const [error2, setError] = reactExports.useState("");
  const [success, setSuccess] = reactExports.useState("");
  const { setAuthData, login } = useAuth();
  const toggleForm = () => {
    setIsLogin(!isLogin);
    setError("");
    setSuccess("");
  };
  const handleChange = (e2) => {
    const { name, value } = e2.target;
    setFormData((prev2) => ({
      ...prev2,
      [name]: value
    }));
  };
  const handleLogin = async (e2) => {
    var _a, _b;
    e2.preventDefault();
    console.log("jj");
    setError("");
    setSuccess("");
    try {
      const response = await apiPost("/auth/login", {
        email: formData.username,
        password: formData.password
      });
      console.log(response);
      if (((_a = response == null ? void 0 : response.data) == null ? void 0 : _a.status) === 200) {
        setSuccess("تم تسجيل الدخول بنجاح!");
        login((_b = response == null ? void 0 : response.data) == null ? void 0 : _b.body);
      } else setError("فشل تسجيل الدخول. الرجاء التحقق من البيانات المدخلة.");
      console.log("Login Response:", response.data);
    } catch (err) {
      setError("فشل تسجيل الدخول. الرجاء التحقق من البيانات المدخلة.");
    }
  };
  const handleRegister = async (e2) => {
    console.log("first");
    setError("");
    setSuccess("");
    if (formData.password !== formData.confirmPassword) {
      setError("كلمتا المرور غير متطابقتين.");
      return;
    }
    try {
      const response = await axios.post("/api/register", {
        username: formData.username,
        email: formData.email,
        password: formData.password
      });
      setSuccess("تم إنشاء الحساب بنجاح! يمكنك الآن تسجيل الدخول.");
      console.log("Register Response:", response.data);
      toggleForm();
    } catch (err) {
      setError("فشل إنشاء الحساب. الرجاء التحقق من البيانات المدخلة.");
    }
  };
  const modalStyle = {
    position: "absolute",
    top: "50%",
    left: "50%",
    transform: "translate(-50%, -50%)",
    width: "400px",
    bgcolor: "background.paper",
    boxShadow: 24,
    borderRadius: "8px",
    p: 4,
    outline: "none",
    direction: "rtl"
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Modal,
    {
      open,
      onClose: handleClose,
      "aria-labelledby": "auth-modal-title",
      "aria-describedby": "auth-modal-description",
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: modalStyle, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { display: "flex", justifyContent: "space-between", alignItems: "center", mb: 2, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { id: "auth-modal-title", variant: "h5", children: isLogin ? "تسجيل الدخول" : "إنشاء حساب جديد" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { onClick: handleClose, children: /* @__PURE__ */ jsxRuntimeExports.jsx(CIcon, { icon: cilX }) })
        ] }),
        error2 && /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { color: "error", mb: 2, children: error2 }),
        success && /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { color: "success", mb: 2, children: success }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Fade, { in: isLogin, timeout: 500, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: isLogin ? "block" : "none" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(CForm, { onSubmit: handleLogin, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", align: "center", mb: 2, children: "تسجيل الدخول إلى حسابك" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(CInputGroup, { className: "mb-3", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(CInputGroupText, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(CIcon, { icon: cilUser }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                CFormInput,
                {
                  placeholder: "اسم المستخدم",
                  name: "username",
                  value: formData.username,
                  onChange: handleChange,
                  autoComplete: "username",
                  required: true
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(CInputGroup, { className: "mb-4", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(CInputGroupText, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(CIcon, { icon: cilLockLocked }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                CFormInput,
                {
                  type: "password",
                  placeholder: "كلمة المرور",
                  name: "password",
                  value: formData.password,
                  onChange: handleChange,
                  autoComplete: "current-password",
                  required: true
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "d-grid", children: /* @__PURE__ */ jsxRuntimeExports.jsx(CButton, { color: "primary", type: "submit", children: "تسجيل الدخول" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Typography,
              {
                variant: "body2",
                align: "center",
                mt: 2,
                style: { cursor: "pointer", color: "#007bff" },
                onClick: toggleForm,
                children: "ليس لديك حساب؟ أنشئ حساب جديد"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Login, {})
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Fade, { in: !isLogin, timeout: 500, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: isLogin ? "none" : "block" }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(CForm, { onSubmit: handleRegister, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", align: "center", mb: 2, children: "قم بإنشاء حسابك الجديد" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(CInputGroup, { className: "mb-3", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(CInputGroupText, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(CIcon, { icon: cilUser }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              CFormInput,
              {
                placeholder: "اسم المستخدم",
                name: "username",
                value: formData.username,
                onChange: handleChange,
                autoComplete: "username",
                required: true
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(CInputGroup, { className: "mb-3", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(CInputGroupText, { children: "@" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              CFormInput,
              {
                placeholder: "البريد الإلكتروني",
                name: "email",
                value: formData.email,
                onChange: handleChange,
                autoComplete: "email",
                required: true
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(CInputGroup, { className: "mb-3", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(CInputGroupText, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(CIcon, { icon: cilLockLocked }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              CFormInput,
              {
                type: "password",
                placeholder: "كلمة المرور",
                name: "password",
                value: formData.password,
                onChange: handleChange,
                autoComplete: "new-password",
                required: true
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(CInputGroup, { className: "mb-4", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(CInputGroupText, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(CIcon, { icon: cilLockLocked }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              CFormInput,
              {
                type: "password",
                placeholder: "أعد كتابة كلمة المرور",
                name: "confirmPassword",
                value: formData.confirmPassword,
                onChange: handleChange,
                autoComplete: "new-password",
                required: true
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "d-grid", children: /* @__PURE__ */ jsxRuntimeExports.jsx(CButton, { color: "success", type: "submit", children: "إنشاء الحساب" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Typography,
            {
              variant: "body2",
              align: "center",
              mt: 2,
              style: { cursor: "pointer", color: "#007bff" },
              onClick: toggleForm,
              children: "لديك حساب؟ تسجيل الدخول"
            }
          )
        ] }) }) })
      ] })
    }
  );
};
function getButtonUtilityClass(slot) {
  return generateUtilityClass("MuiButton", slot);
}
const buttonClasses = generateUtilityClasses("MuiButton", ["root", "text", "textInherit", "textPrimary", "textSecondary", "textSuccess", "textError", "textInfo", "textWarning", "outlined", "outlinedInherit", "outlinedPrimary", "outlinedSecondary", "outlinedSuccess", "outlinedError", "outlinedInfo", "outlinedWarning", "contained", "containedInherit", "containedPrimary", "containedSecondary", "containedSuccess", "containedError", "containedInfo", "containedWarning", "disableElevation", "focusVisible", "disabled", "colorInherit", "colorPrimary", "colorSecondary", "colorSuccess", "colorError", "colorInfo", "colorWarning", "textSizeSmall", "textSizeMedium", "textSizeLarge", "outlinedSizeSmall", "outlinedSizeMedium", "outlinedSizeLarge", "containedSizeSmall", "containedSizeMedium", "containedSizeLarge", "sizeMedium", "sizeSmall", "sizeLarge", "fullWidth", "startIcon", "endIcon", "icon", "iconSizeSmall", "iconSizeMedium", "iconSizeLarge", "loading", "loadingWrapper", "loadingIconPlaceholder", "loadingIndicator", "loadingPositionCenter", "loadingPositionStart", "loadingPositionEnd"]);
const ButtonGroupContext = /* @__PURE__ */ reactExports.createContext({});
const ButtonGroupButtonContext = /* @__PURE__ */ reactExports.createContext(void 0);
const useUtilityClasses = (ownerState) => {
  const {
    color: color2,
    disableElevation,
    fullWidth,
    size: size3,
    variant,
    loading,
    loadingPosition,
    classes
  } = ownerState;
  const slots = {
    root: ["root", loading && "loading", variant, `${variant}${capitalize(color2)}`, `size${capitalize(size3)}`, `${variant}Size${capitalize(size3)}`, `color${capitalize(color2)}`, disableElevation && "disableElevation", fullWidth && "fullWidth", loading && `loadingPosition${capitalize(loadingPosition)}`],
    startIcon: ["icon", "startIcon", `iconSize${capitalize(size3)}`],
    endIcon: ["icon", "endIcon", `iconSize${capitalize(size3)}`],
    loadingIndicator: ["loadingIndicator"],
    loadingWrapper: ["loadingWrapper"]
  };
  const composedClasses = composeClasses(slots, getButtonUtilityClass, classes);
  return {
    ...classes,
    // forward the focused, disabled, etc. classes to the ButtonBase
    ...composedClasses
  };
};
const commonIconStyles = [{
  props: {
    size: "small"
  },
  style: {
    "& > *:nth-of-type(1)": {
      fontSize: 18
    }
  }
}, {
  props: {
    size: "medium"
  },
  style: {
    "& > *:nth-of-type(1)": {
      fontSize: 20
    }
  }
}, {
  props: {
    size: "large"
  },
  style: {
    "& > *:nth-of-type(1)": {
      fontSize: 22
    }
  }
}];
const ButtonRoot = styled(ButtonBase, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiButton",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.variant], styles2[`${ownerState.variant}${capitalize(ownerState.color)}`], styles2[`size${capitalize(ownerState.size)}`], styles2[`${ownerState.variant}Size${capitalize(ownerState.size)}`], ownerState.color === "inherit" && styles2.colorInherit, ownerState.disableElevation && styles2.disableElevation, ownerState.fullWidth && styles2.fullWidth, ownerState.loading && styles2.loading];
  }
})(memoTheme(({
  theme
}) => {
  const inheritContainedBackgroundColor = theme.palette.mode === "light" ? theme.palette.grey[300] : theme.palette.grey[800];
  const inheritContainedHoverBackgroundColor = theme.palette.mode === "light" ? theme.palette.grey.A100 : theme.palette.grey[700];
  return {
    ...theme.typography.button,
    minWidth: 64,
    padding: "6px 16px",
    border: 0,
    borderRadius: (theme.vars || theme).shape.borderRadius,
    transition: theme.transitions.create(["background-color", "box-shadow", "border-color", "color"], {
      duration: theme.transitions.duration.short
    }),
    "&:hover": {
      textDecoration: "none"
    },
    [`&.${buttonClasses.disabled}`]: {
      color: (theme.vars || theme).palette.action.disabled
    },
    variants: [{
      props: {
        variant: "contained"
      },
      style: {
        color: `var(--variant-containedColor)`,
        backgroundColor: `var(--variant-containedBg)`,
        boxShadow: (theme.vars || theme).shadows[2],
        "&:hover": {
          boxShadow: (theme.vars || theme).shadows[4],
          // Reset on touch devices, it doesn't add specificity
          "@media (hover: none)": {
            boxShadow: (theme.vars || theme).shadows[2]
          }
        },
        "&:active": {
          boxShadow: (theme.vars || theme).shadows[8]
        },
        [`&.${buttonClasses.focusVisible}`]: {
          boxShadow: (theme.vars || theme).shadows[6]
        },
        [`&.${buttonClasses.disabled}`]: {
          color: (theme.vars || theme).palette.action.disabled,
          boxShadow: (theme.vars || theme).shadows[0],
          backgroundColor: (theme.vars || theme).palette.action.disabledBackground
        }
      }
    }, {
      props: {
        variant: "outlined"
      },
      style: {
        padding: "5px 15px",
        border: "1px solid currentColor",
        borderColor: `var(--variant-outlinedBorder, currentColor)`,
        backgroundColor: `var(--variant-outlinedBg)`,
        color: `var(--variant-outlinedColor)`,
        [`&.${buttonClasses.disabled}`]: {
          border: `1px solid ${(theme.vars || theme).palette.action.disabledBackground}`
        }
      }
    }, {
      props: {
        variant: "text"
      },
      style: {
        padding: "6px 8px",
        color: `var(--variant-textColor)`,
        backgroundColor: `var(--variant-textBg)`
      }
    }, ...Object.entries(theme.palette).filter(createSimplePaletteValueFilter()).map(([color2]) => ({
      props: {
        color: color2
      },
      style: {
        "--variant-textColor": (theme.vars || theme).palette[color2].main,
        "--variant-outlinedColor": (theme.vars || theme).palette[color2].main,
        "--variant-outlinedBorder": theme.vars ? `rgba(${theme.vars.palette[color2].mainChannel} / 0.5)` : alpha(theme.palette[color2].main, 0.5),
        "--variant-containedColor": (theme.vars || theme).palette[color2].contrastText,
        "--variant-containedBg": (theme.vars || theme).palette[color2].main,
        "@media (hover: hover)": {
          "&:hover": {
            "--variant-containedBg": (theme.vars || theme).palette[color2].dark,
            "--variant-textBg": theme.vars ? `rgba(${theme.vars.palette[color2].mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette[color2].main, theme.palette.action.hoverOpacity),
            "--variant-outlinedBorder": (theme.vars || theme).palette[color2].main,
            "--variant-outlinedBg": theme.vars ? `rgba(${theme.vars.palette[color2].mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette[color2].main, theme.palette.action.hoverOpacity)
          }
        }
      }
    })), {
      props: {
        color: "inherit"
      },
      style: {
        color: "inherit",
        borderColor: "currentColor",
        "--variant-containedBg": theme.vars ? theme.vars.palette.Button.inheritContainedBg : inheritContainedBackgroundColor,
        "@media (hover: hover)": {
          "&:hover": {
            "--variant-containedBg": theme.vars ? theme.vars.palette.Button.inheritContainedHoverBg : inheritContainedHoverBackgroundColor,
            "--variant-textBg": theme.vars ? `rgba(${theme.vars.palette.text.primaryChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette.text.primary, theme.palette.action.hoverOpacity),
            "--variant-outlinedBg": theme.vars ? `rgba(${theme.vars.palette.text.primaryChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette.text.primary, theme.palette.action.hoverOpacity)
          }
        }
      }
    }, {
      props: {
        size: "small",
        variant: "text"
      },
      style: {
        padding: "4px 5px",
        fontSize: theme.typography.pxToRem(13)
      }
    }, {
      props: {
        size: "large",
        variant: "text"
      },
      style: {
        padding: "8px 11px",
        fontSize: theme.typography.pxToRem(15)
      }
    }, {
      props: {
        size: "small",
        variant: "outlined"
      },
      style: {
        padding: "3px 9px",
        fontSize: theme.typography.pxToRem(13)
      }
    }, {
      props: {
        size: "large",
        variant: "outlined"
      },
      style: {
        padding: "7px 21px",
        fontSize: theme.typography.pxToRem(15)
      }
    }, {
      props: {
        size: "small",
        variant: "contained"
      },
      style: {
        padding: "4px 10px",
        fontSize: theme.typography.pxToRem(13)
      }
    }, {
      props: {
        size: "large",
        variant: "contained"
      },
      style: {
        padding: "8px 22px",
        fontSize: theme.typography.pxToRem(15)
      }
    }, {
      props: {
        disableElevation: true
      },
      style: {
        boxShadow: "none",
        "&:hover": {
          boxShadow: "none"
        },
        [`&.${buttonClasses.focusVisible}`]: {
          boxShadow: "none"
        },
        "&:active": {
          boxShadow: "none"
        },
        [`&.${buttonClasses.disabled}`]: {
          boxShadow: "none"
        }
      }
    }, {
      props: {
        fullWidth: true
      },
      style: {
        width: "100%"
      }
    }, {
      props: {
        loadingPosition: "center"
      },
      style: {
        transition: theme.transitions.create(["background-color", "box-shadow", "border-color"], {
          duration: theme.transitions.duration.short
        }),
        [`&.${buttonClasses.loading}`]: {
          color: "transparent"
        }
      }
    }]
  };
}));
const ButtonStartIcon = styled("span", {
  name: "MuiButton",
  slot: "StartIcon",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.startIcon, ownerState.loading && styles2.startIconLoadingStart, styles2[`iconSize${capitalize(ownerState.size)}`]];
  }
})(({
  theme
}) => ({
  display: "inherit",
  marginRight: 8,
  marginLeft: -4,
  variants: [{
    props: {
      size: "small"
    },
    style: {
      marginLeft: -2
    }
  }, {
    props: {
      loadingPosition: "start",
      loading: true
    },
    style: {
      transition: theme.transitions.create(["opacity"], {
        duration: theme.transitions.duration.short
      }),
      opacity: 0
    }
  }, {
    props: {
      loadingPosition: "start",
      loading: true,
      fullWidth: true
    },
    style: {
      marginRight: -8
    }
  }, ...commonIconStyles]
}));
const ButtonEndIcon = styled("span", {
  name: "MuiButton",
  slot: "EndIcon",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.endIcon, ownerState.loading && styles2.endIconLoadingEnd, styles2[`iconSize${capitalize(ownerState.size)}`]];
  }
})(({
  theme
}) => ({
  display: "inherit",
  marginRight: -4,
  marginLeft: 8,
  variants: [{
    props: {
      size: "small"
    },
    style: {
      marginRight: -2
    }
  }, {
    props: {
      loadingPosition: "end",
      loading: true
    },
    style: {
      transition: theme.transitions.create(["opacity"], {
        duration: theme.transitions.duration.short
      }),
      opacity: 0
    }
  }, {
    props: {
      loadingPosition: "end",
      loading: true,
      fullWidth: true
    },
    style: {
      marginLeft: -8
    }
  }, ...commonIconStyles]
}));
const ButtonLoadingIndicator = styled("span", {
  name: "MuiButton",
  slot: "LoadingIndicator",
  overridesResolver: (props, styles2) => styles2.loadingIndicator
})(({
  theme
}) => ({
  display: "none",
  position: "absolute",
  visibility: "visible",
  variants: [{
    props: {
      loading: true
    },
    style: {
      display: "flex"
    }
  }, {
    props: {
      loadingPosition: "start"
    },
    style: {
      left: 14
    }
  }, {
    props: {
      loadingPosition: "start",
      size: "small"
    },
    style: {
      left: 10
    }
  }, {
    props: {
      variant: "text",
      loadingPosition: "start"
    },
    style: {
      left: 6
    }
  }, {
    props: {
      loadingPosition: "center"
    },
    style: {
      left: "50%",
      transform: "translate(-50%)",
      color: (theme.vars || theme).palette.action.disabled
    }
  }, {
    props: {
      loadingPosition: "end"
    },
    style: {
      right: 14
    }
  }, {
    props: {
      loadingPosition: "end",
      size: "small"
    },
    style: {
      right: 10
    }
  }, {
    props: {
      variant: "text",
      loadingPosition: "end"
    },
    style: {
      right: 6
    }
  }, {
    props: {
      loadingPosition: "start",
      fullWidth: true
    },
    style: {
      position: "relative",
      left: -10
    }
  }, {
    props: {
      loadingPosition: "end",
      fullWidth: true
    },
    style: {
      position: "relative",
      right: -10
    }
  }]
}));
const ButtonLoadingIconPlaceholder = styled("span", {
  name: "MuiButton",
  slot: "LoadingIconPlaceholder",
  overridesResolver: (props, styles2) => styles2.loadingIconPlaceholder
})({
  display: "inline-block",
  width: "1em",
  height: "1em"
});
const Button = /* @__PURE__ */ reactExports.forwardRef(function Button2(inProps, ref) {
  const contextProps = reactExports.useContext(ButtonGroupContext);
  const buttonGroupButtonContextPositionClassName = reactExports.useContext(ButtonGroupButtonContext);
  const resolvedProps = resolveProps(contextProps, inProps);
  const props = useDefaultProps({
    props: resolvedProps,
    name: "MuiButton"
  });
  const {
    children,
    color: color2 = "primary",
    component = "button",
    className,
    disabled = false,
    disableElevation = false,
    disableFocusRipple = false,
    endIcon: endIconProp,
    focusVisibleClassName,
    fullWidth = false,
    id: idProp,
    loading = null,
    loadingIndicator: loadingIndicatorProp,
    loadingPosition = "center",
    size: size3 = "medium",
    startIcon: startIconProp,
    type,
    variant = "text",
    ...other
  } = props;
  const loadingId = useId(idProp);
  const loadingIndicator = loadingIndicatorProp ?? /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress, {
    "aria-labelledby": loadingId,
    color: "inherit",
    size: 16
  });
  const ownerState = {
    ...props,
    color: color2,
    component,
    disabled,
    disableElevation,
    disableFocusRipple,
    fullWidth,
    loading,
    loadingIndicator,
    loadingPosition,
    size: size3,
    type,
    variant
  };
  const classes = useUtilityClasses(ownerState);
  const startIcon = (startIconProp || loading && loadingPosition === "start") && /* @__PURE__ */ jsxRuntimeExports.jsx(ButtonStartIcon, {
    className: classes.startIcon,
    ownerState,
    children: startIconProp || /* @__PURE__ */ jsxRuntimeExports.jsx(ButtonLoadingIconPlaceholder, {
      className: classes.loadingIconPlaceholder,
      ownerState
    })
  });
  const endIcon = (endIconProp || loading && loadingPosition === "end") && /* @__PURE__ */ jsxRuntimeExports.jsx(ButtonEndIcon, {
    className: classes.endIcon,
    ownerState,
    children: endIconProp || /* @__PURE__ */ jsxRuntimeExports.jsx(ButtonLoadingIconPlaceholder, {
      className: classes.loadingIconPlaceholder,
      ownerState
    })
  });
  const positionClassName = buttonGroupButtonContextPositionClassName || "";
  const loader = typeof loading === "boolean" ? (
    // use plain HTML span to minimize the runtime overhead
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
      className: classes.loadingWrapper,
      style: {
        display: "contents"
      },
      children: loading && /* @__PURE__ */ jsxRuntimeExports.jsx(ButtonLoadingIndicator, {
        className: classes.loadingIndicator,
        ownerState,
        children: loadingIndicator
      })
    })
  ) : null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(ButtonRoot, {
    ownerState,
    className: clsx(contextProps.className, classes.root, className, positionClassName),
    component,
    disabled: disabled || loading,
    focusRipple: !disableFocusRipple,
    focusVisibleClassName: clsx(classes.focusVisible, focusVisibleClassName),
    ref,
    type,
    id: loading ? loadingId : idProp,
    ...other,
    classes,
    children: [startIcon, loadingPosition !== "end" && loader, children, loadingPosition === "end" && loader, endIcon]
  });
});
const Stack = createStack({
  createStyledComponent: styled("div", {
    name: "MuiStack",
    slot: "Root",
    overridesResolver: (props, styles2) => styles2.root
  }),
  useThemeProps: (inProps) => useDefaultProps({
    props: inProps,
    name: "MuiStack"
  })
});
const BalanceModal = ({ open, onClose }) => {
  const navigate = useNavigate();
  const handlePaymentRedirect = () => {
    onClose();
    navigate("/payment");
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Modal,
    {
      open,
      onClose,
      "aria-labelledby": "balance-modal-title",
      "aria-describedby": "balance-modal-description",
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Box,
        {
          sx: {
            position: "absolute",
            top: "50%",
            left: "50%",
            transform: "translate(-50%, -50%)",
            width: 400,
            bgcolor: "background.paper",
            boxShadow: 24,
            p: 4,
            borderRadius: 2,
            textAlign: "center",
            direction: "rtl"
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { id: "balance-modal-title", variant: "h6", component: "h2", sx: { mb: 2 }, children: "رصيدك غير كافٍ" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { id: "balance-modal-description", sx: { mb: 3, color: "text.secondary" }, children: "عذرًا، رصيدك الحالي غير كافٍ لإتمام هذه العملية. يمكنك إعادة شحن رصيدك الآن." }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", spacing: 2, justifyContent: "center", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  variant: "contained",
                  color: "primary",
                  onClick: handlePaymentRedirect,
                  style: { margin: "5px" },
                  children: "اشترك الان"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "contained", color: "secondary", onClick: onClose, style: { margin: "5px" }, children: "إغلاق" })
            ] })
          ]
        }
      )
    }
  );
};
const EmailVerificationModal = ({ visible, onClose }) => {
  const navigate = useNavigate();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(CModal, { visible, onClose, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(CModalHeader, { children: "التحقق من البريد الإلكتروني" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(CModalBody, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "يُرجى التحقق من بريدك الإلكتروني لمتابعة الاستخدام." }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(CModalFooter, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        CButton,
        {
          color: "primary",
          onClick: () => {
            navigate("/verify");
            onClose();
          },
          children: "تحقق"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(CButton, { color: "secondary", onClick: onClose, children: "إغلاق" })
    ] })
  ] }) });
};
const DefaultLayout = React$1.lazy(() => __vitePreload(() => import("./DefaultLayout-D9cihayI.js").then((n2) => n2.D), true ? __vite__mapDeps([0,1,2]) : void 0, import.meta.url));
const Register = React$1.lazy(() => __vitePreload(() => import("./Register-Dpam4VvG.js"), true ? __vite__mapDeps([3,1,4,5]) : void 0, import.meta.url));
const Page404 = React$1.lazy(() => __vitePreload(() => import("./Page404-Bjcm-ULf.js"), true ? __vite__mapDeps([6,1,4,7]) : void 0, import.meta.url));
const Page500 = React$1.lazy(() => __vitePreload(() => import("./Page500-bTRzm0I-.js"), true ? __vite__mapDeps([8,1,4,7]) : void 0, import.meta.url));
const App = () => {
  const { isColorModeSet, setColorMode } = useColorModes("coreui-free-react-admin-template-theme");
  const storedTheme = useSelector((state) => state.theme);
  const { showAuthModal, login } = useAuth();
  const { notEnough, notVerified } = useBalance();
  reactExports.useEffect(() => {
    const urlParams = new URLSearchParams(window.location.search);
    const token2 = urlParams.get("token");
    const userData = urlParams.get("user");
    if (token2 && userData) {
      login({ token: token2, ...userData });
    }
  }, []);
  reactExports.useEffect(() => {
    const urlParams = new URLSearchParams(window.location.href.split("?")[1]);
    const theme = urlParams.get("theme") && urlParams.get("theme").match(/^[A-Za-z0-9\s]+/)[0];
    if (theme) {
      setColorMode(theme);
    }
    if (isColorModeSet()) {
      return;
    }
    setColorMode(storedTheme);
  }, []);
  const handleLoginClose = () => {
    showGlobalLogin(false);
  };
  const handleBalanceClose = () => {
    setNotEnoughBalanceGlobal(false);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(HashRouter, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      reactExports.Suspense,
      {
        fallback: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "pt-3 text-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(CSpinner, { color: "primary", variant: "grow" }) }),
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Routes, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { exact: true, path: "/register", name: "Register Page", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Register, {}) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { exact: true, path: "/404", name: "Page 404", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Page404, {}) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { exact: true, path: "/500", name: "Page 500", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Page500, {}) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "*", name: "Home", element: /* @__PURE__ */ jsxRuntimeExports.jsx(DefaultLayout, {}) })
        ] })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(AuthModal, { open: showAuthModal, handleClose: handleLoginClose }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(BalanceModal, { open: notEnough, onClose: handleBalanceClose }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(EmailVerificationModal, { visible: notVerified, onClose: () => setGlobalNotVerified(false) })
  ] });
};
function formatProdErrorMessage(code) {
  return `Minified Redux error #${code}; visit https://redux.js.org/Errors?code=${code} for the full message or use the non-minified dev environment for full errors. `;
}
var $$observable = /* @__PURE__ */ (() => typeof Symbol === "function" && Symbol.observable || "@@observable")();
var symbol_observable_default = $$observable;
var randomString = () => Math.random().toString(36).substring(7).split("").join(".");
var ActionTypes = {
  INIT: `@@redux/INIT${/* @__PURE__ */ randomString()}`,
  REPLACE: `@@redux/REPLACE${/* @__PURE__ */ randomString()}`,
  PROBE_UNKNOWN_ACTION: () => `@@redux/PROBE_UNKNOWN_ACTION${randomString()}`
};
var actionTypes_default = ActionTypes;
function isPlainObject(obj) {
  if (typeof obj !== "object" || obj === null)
    return false;
  let proto = obj;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(obj) === proto || Object.getPrototypeOf(obj) === null;
}
function createStore(reducer, preloadedState, enhancer) {
  if (typeof reducer !== "function") {
    throw new Error(formatProdErrorMessage(2));
  }
  let currentReducer = reducer;
  let currentState = preloadedState;
  let currentListeners = /* @__PURE__ */ new Map();
  let nextListeners = currentListeners;
  let listenerIdCounter = 0;
  let isDispatching = false;
  function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = /* @__PURE__ */ new Map();
      currentListeners.forEach((listener, key) => {
        nextListeners.set(key, listener);
      });
    }
  }
  function getState() {
    if (isDispatching) {
      throw new Error(formatProdErrorMessage(3));
    }
    return currentState;
  }
  function subscribe2(listener) {
    if (typeof listener !== "function") {
      throw new Error(formatProdErrorMessage(4));
    }
    if (isDispatching) {
      throw new Error(formatProdErrorMessage(5));
    }
    let isSubscribed = true;
    ensureCanMutateNextListeners();
    const listenerId = listenerIdCounter++;
    nextListeners.set(listenerId, listener);
    return function unsubscribe2() {
      if (!isSubscribed) {
        return;
      }
      if (isDispatching) {
        throw new Error(formatProdErrorMessage(6));
      }
      isSubscribed = false;
      ensureCanMutateNextListeners();
      nextListeners.delete(listenerId);
      currentListeners = null;
    };
  }
  function dispatch(action) {
    if (!isPlainObject(action)) {
      throw new Error(formatProdErrorMessage(7));
    }
    if (typeof action.type === "undefined") {
      throw new Error(formatProdErrorMessage(8));
    }
    if (typeof action.type !== "string") {
      throw new Error(formatProdErrorMessage(17));
    }
    if (isDispatching) {
      throw new Error(formatProdErrorMessage(9));
    }
    try {
      isDispatching = true;
      currentState = currentReducer(currentState, action);
    } finally {
      isDispatching = false;
    }
    const listeners = currentListeners = nextListeners;
    listeners.forEach((listener) => {
      listener();
    });
    return action;
  }
  function replaceReducer(nextReducer) {
    if (typeof nextReducer !== "function") {
      throw new Error(formatProdErrorMessage(10));
    }
    currentReducer = nextReducer;
    dispatch({
      type: actionTypes_default.REPLACE
    });
  }
  function observable() {
    const outerSubscribe = subscribe2;
    return {
      /**
       * The minimal observable subscription method.
       * @param observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       */
      subscribe(observer) {
        if (typeof observer !== "object" || observer === null) {
          throw new Error(formatProdErrorMessage(11));
        }
        function observeState() {
          const observerAsObserver = observer;
          if (observerAsObserver.next) {
            observerAsObserver.next(getState());
          }
        }
        observeState();
        const unsubscribe2 = outerSubscribe(observeState);
        return {
          unsubscribe: unsubscribe2
        };
      },
      [symbol_observable_default]() {
        return this;
      }
    };
  }
  dispatch({
    type: actionTypes_default.INIT
  });
  const store2 = {
    dispatch,
    subscribe: subscribe2,
    getState,
    replaceReducer,
    [symbol_observable_default]: observable
  };
  return store2;
}
function legacy_createStore(reducer, preloadedState, enhancer) {
  return createStore(reducer, preloadedState);
}
const initialState = {
  sidebarShow: true,
  theme: "light"
};
const changeState = (state = initialState, { type, ...rest }) => {
  switch (type) {
    case "set":
      return { ...state, ...rest };
    default:
      return state;
  }
};
const store = legacy_createStore(changeState);
createRoot(document.getElementById("root")).render(
  /* @__PURE__ */ jsxRuntimeExports.jsxs(BalanceProvider, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(AuthProvider, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Provider_default, { store, children: /* @__PURE__ */ jsxRuntimeExports.jsx(App, {}) }),
      ","
    ] }),
    ","
  ] })
);
export {
  composeClasses as $,
  CInputGroupText as A,
  cilUser as B,
  CLink as C,
  CFormInput as D,
  cilLockLocked as E,
  CButton as F,
  resolveComponentProps as G,
  mergeSlotProps as H,
  useForkRef as I,
  appendOwnerState as J,
  useThemeProps as K,
  defaultTheme$1 as L,
  THEME_ID as M,
  Navigate as N,
  clsx as O,
  PropTypes$1 as P,
  useId as Q,
  React$1 as R,
  useEventCallback as S,
  Transition as T,
  setRef as U,
  generateUtilityClasses as V,
  generateUtilityClass as W,
  ownerDocument as X,
  Portal as Y,
  useEnhancedEffect as Z,
  __rest$1 as _,
  __assign$1 as a,
  styled as a0,
  useDefaultProps as a1,
  capitalize as a2,
  memoTheme as a3,
  alpha as a4,
  createSimplePaletteValueFilter as a5,
  ButtonBase as a6,
  ownerWindow as a7,
  globalCss as a8,
  formatMuiErrorMessage as a9,
  FocusTrap as aA,
  CircularProgress as aB,
  Button as aC,
  Box as aD,
  axios as aE,
  CFormLabel as aF,
  apiPost as aG,
  getAugmentedNamespace as aH,
  CFormControlWrapper as aI,
  extractEventHandlers as aJ,
  emphasize as aK,
  getOverlayAlpha as aL,
  Transition$1 as aM,
  reflow as aN,
  getTransitionProps as aO,
  IconButton as aa,
  useSlot as ab,
  rootShouldForwardProp as ac,
  deepmerge as ad,
  Typography as ae,
  keyframes as af,
  css as ag,
  lighten as ah,
  darken as ai,
  typographyClasses as aj,
  getScrollbarSize as ak,
  Modal as al,
  slotShouldForwardProp as am,
  getReactElementRef as an,
  useTheme as ao,
  useTimeout as ap,
  Timeout as aq,
  isFocusVisible as ar,
  useLazyRef as as,
  useOnMount as at,
  _extends as au,
  _objectWithoutPropertiesLoose$1 as av,
  resolveProps as aw,
  styled$1 as ax,
  decomposeColor as ay,
  recomposeColor as az,
  colorPropType as b,
  classNames$1 as c,
  reactDomExports as d,
  CBackdrop as e,
  __vitePreload as f,
  useLocation as g,
  CSpinner as h,
  Routes as i,
  jsxRuntimeExports as j,
  Route as k,
  useColorModes as l,
  useAuth as m,
  useDispatch as n,
  useSelector as o,
  CIcon as p,
  commonjsGlobal as q,
  reactExports as r,
  shapePropType as s,
  textColorsPropType as t,
  useForkedRef as u,
  getDefaultExportFromCjs$2 as v,
  NavLink as w,
  CCloseButton as x,
  CForm as y,
  CInputGroup as z
};
